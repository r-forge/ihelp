<html lang="en">
<head>
<title>R FAQ in Korean (한국어 번역, ver.0.93.2013.07.18)</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="R FAQ in Korean (한국어 번역, ver.0.93.2013.07.18)">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body {margin-left: 5%; margin-right: 5%;}

H1{             background: white;
                color: rgb(25%, 25%, 25%);
                font-family: monospace;
                font-size: xx-large;
                text-align: center }

H2{             background: white;
                color: rgb(40%, 40%, 40%);
                font-family: monospace;
                font-size: x-large;
                text-align: center }

H3{             background: white;
                color: rgb(40%, 40%, 40%);
                font-family: monospace;
                font-size: large }

H4{             background: white;
                color: rgb(40%, 40%, 40%);
                font-family: monospace }

span.samp{font-family: monospace}
span.command{font-family: monospace}
span.option{font-family: monospace}
span.file{font-family: monospace}
span.env{font-family: monospace}

ul.menu{list-style-type: decimal}
--></style>
</head>
<body>
<h1 class="settitle">R FAQ in Korean (한국어 번역, ver.0.93.2013.07.18)</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">R FAQ</h2>

<!-- <h2>Frequently Asked Questions on R</h2> -->
<p><h2> R 에 관하여 자주 물어보는 질문들 </h2>
<h2>Version 2.15.2013-02-08</h2>
<h2>ISBN 3-900051-08-9</h2>
<address>Kurt Hornik</address>
<p><p><hr><p>

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>
<li><a accesskey="2" href="#R-Basics">R Basics</a>
<li><a accesskey="3" href="#R-and-S">R and S</a>
<li><a accesskey="4" href="#R-Web-Interfaces">R Web Interfaces</a>
<li><a accesskey="5" href="#R-Add_002dOn-Packages">R Add-On Packages</a>
<li><a accesskey="6" href="#R-and-Emacs">R and Emacs</a>
<li><a accesskey="7" href="#R-Miscellanea">R Miscellanea</a>
<li><a accesskey="8" href="#R-Programming">R Programming</a>
<li><a accesskey="9" href="#R-Bugs">R Bugs</a>
<li><a href="#Acknowledgments">Acknowledgments</a>
</ul>

<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#R-Basics">R Basics</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter Introduction -->
<h2 class="chapter">1 소개</h2>

<!-- This document contains answers to some of the most frequently asked -->
<!-- questions about R. -->
<p>이 문서는 R에 관하여 가장 많이 자주 물어보는 질문들에 대해서 정리한 문서입니다.

<ul class="menu">
<li><a accesskey="1" href="#Legalese">Legalese</a>
<li><a accesskey="2" href="#Obtaining-this-document">Obtaining this document</a>
<li><a accesskey="3" href="#Citing-this-document">Citing this document</a>
<li><a accesskey="4" href="#Notation">Notation</a>
<li><a accesskey="5" href="#Feedback">Feedback</a>
</ul>

<div class="node">
<a name="Legalese"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Obtaining-this-document">Obtaining this document</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<!-- @section Legalese -->
<h3 class="section">1.1 Legalese</h3>

<!-- This document is copyright @copyright{} 1998-@value{FAQ_YEAR} by Kurt -->
<!-- Hornik. -->
<p>이 문서의 영문본에 대한 저작권은 &copy; 1998&ndash;2013 Kurt Hornik에게 있으며, 한국어 번역본은 Chel Hee Lee &copy; 2009&ndash;2013에 있습니다.

<!-- This document is free software; you can redistribute it and/or modify it -->
<!-- under the terms of the @acronym{GNU} General Public License as published -->
<!-- by the Free Software Foundation; either version 2, or (at your option) -->
<!-- any later version. -->
   <p>본 문서는 자유소프트웨어(free software)이므로, 자유소프트웨어 재단 (Free Software Foundation)에 의해서 배포되는 <acronym>GNU</acronym> 일반공중라이센스 (General Public License) 버전 2 또는 그 이후의 버전들을 통하여 수정 및 재배포를 할 수 있습니다.

<!-- This document is distributed in the hope that it will be useful, but -->
<!-- WITHOUT ANY WARRANTY; without even the implied warranty of -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the -->
<!-- @acronym{GNU} General Public License for more details. -->
   <p>이 문서가 사용자에게 유용하길 바라는 희망에서 배포되고 있습니다. 
그러나, 어떤 상업적 형태(MERCHANTABILITY)로서의 보증 및 특수한 목적에 적합(FITNESS FOR A PARTICULAR PURPOSES)등 어떠한 형태의 보증을 하지 않습니다. 
보다 자세한 사항들은 <acronym>GNU</acronym> 일반공증라이센스를 참조하시길 부탁드립니다.

<!-- Copies of the @acronym{GNU} General Public License versions are -->
<!-- available at -->
   <p><acronym>GNU</acronym> 일반공증라이센스의 사본들을 아래의 주소로부터 찾으실 수 있습니다.

<pre class="display">     <a href="http://www.R-project.org/Licenses/">http://www.R-project.org/Licenses/</a>
</pre>
   <div class="node">
<a name="Obtaining-this-document"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Citing-this-document">Citing this document</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Legalese">Legalese</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<!-- @section Obtaining this document -->
<h3 class="section">1.2 이 문서를 얻는 방법</h3>

<!-- The latest version of this document is always available from -->
<p>가장 최신 버전의 문서는 항상 아래의 주소에서 확인이 가능합니다.
<pre class="display">     <a href="http://CRAN.R-project.org/doc/FAQ/">http://CRAN.R-project.org/doc/FAQ/</a>
</pre>
   <!-- From there, you can obtain versions converted to -->
   <p>위의 주소로부터
<a href="http://CRAN.R-project.org/doc/FAQ/R-FAQ.txt">plain <acronym>ASCII</acronym> text</a>,
<a href="http://CRAN.R-project.org/doc/FAQ/R-FAQ.dvi.gz">DVI</a>,
<a href="http://CRAN.R-project.org/doc/FAQ/R-FAQ.info.gz"><acronym>GNU</acronym> info</a>, <a href="http://CRAN.R-project.org/doc/FAQ/R-FAQ.html"><acronym>HTML</acronym></a>,
<a href="http://CRAN.R-project.org/doc/FAQ/R-FAQ.pdf">PDF</a>,
<a href="http://CRAN.R-project.org/doc/FAQ/R-FAQ.ps.gz">PostScript</a>
으로 변환되어진 문서형식을 가진 버전들을 얻을 수 있습니다. 
<!-- as well as the -->
또한, 이렇게 다양한 형식의 문서들을 생성하기 위해 사용된
<a href="http://CRAN.R-project.org/doc/FAQ/R-FAQ.texi">Texinfo source</a>
<!-- used for creating all these formats using the -->
를 얻을 수 있습니다. 
<!-- @url{http://texinfo.org/, @acronym{GNU} Texinfo system}. -->

<!-- You can also obtain the R @acronym{FAQ} from the @file{doc/FAQ} -->
<!-- subdirectory of a @CRAN{} site (@pxref{What is CRAN?}). -->
   <p>그외에도 R <acronym>FAQ</acronym> 문서를 <acronym>CRAN</acronym> 사이트 (see <a href="#What-is-CRAN_003f">What is CRAN?</a> 참조)의 하위디렉토리 <samp><span class="file">doc/FAQ</span></samp>에서 찾을 수 있습니다.

<div class="node">
<a name="Citing-this-document"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Notation">Notation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Obtaining-this-document">Obtaining this document</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<!-- @section Citing this document -->
<h3 class="section">1.3 이 문서를 인용하는 방법</h3>

<!-- In publications, please refer to this @acronym{FAQ} as Hornik -->
<!-- (@value{FAQ_YEAR}), ``The R @acronym{FAQ}'', and give the above, -->
<!-- @emph{official} @acronym{URL} and the ISBN @value{FAQ_ISBN}: -->
<p>퍼블리케이션 (publication)에서 본 <acronym>FAQ</acronym> 문서를 인용하고자 할 때에는 Hornik (2013), &ldquo;The R <acronym>FAQ</acronym>&rdquo; 이라고 해주시고, 위에서 언급한 <em>공식적인</em> <acronym>URL</acronym>과 ISBN 3-900051-08-9을 기재해 주세요.

<pre class="example">     @Misc{,
       author        = {Kurt Hornik},
       title         = {The {R} {FAQ}},
       year          = {2013},
       note          = {{ISBN} 3-900051-08-9},
       url           = {http://CRAN.R-project.org/doc/FAQ/R-FAQ.html}
     }
</pre>
   <div class="node">
<a name="Notation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Feedback">Feedback</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Citing-this-document">Citing this document</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<!-- @section Notation -->
<h3 class="section">1.4 표기법</h3>

<!-- Everything should be pretty standard.  @samp{R>} is used for the R -->
<!-- prompt, and a @samp{$} for the shell prompt (where applicable). -->
<p>이 문서에서는 거의 대부분이 표준에 가까운 표기법을 사용합니다. 
예를들면, &lsquo;<samp><span class="samp">R&gt;</span></samp>&rsquo;은 R 프롬프트(prompt)를 나타내고, &lsquo;<samp><span class="samp">$</span></samp>&rsquo;는 쉘프롬프트(shell prompt)를 의미합니다.

<div class="node">
<a name="Feedback"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Notation">Notation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<!-- @section Feedback -->
<h3 class="section">1.5 피드백 보내기</h3>

<!-- Feedback via email to @email{Kurt.Hornik@@R-project.org} is of course -->
<!-- most welcome. -->
<!-- 피드백은 @email{Kurt.Hornik@@R-project.org}로 보내주시면 감사드리겠습니다. -->
<p>본 문서에 대한 피드백은 <a href="mailto:gnustats@korea.gnu.org">gnustats@korea.gnu.org</a> 또는 <a href="mailto:ihelp-translators@lists.r-forge.r-project.org">ihelp-translators@lists.r-forge.r-project.org</a>로 보내주시길 부탁드립니다.

<!-- In particular, note that I do not have access to Windows or Macintosh -->
<!-- systems.  Features specific to the Windows and Mac OS X ports of R are -->
<!-- described in the -->
<!-- @url{http://CRAN.R-project.org/bin/windows/base/rw-FAQ.html, ``R for -->
<!-- Windows @acronym{FAQ}''} and the -->
<!-- @url{http://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html, ``R for Mac -->
<!-- OS X @acronym{FAQ}''}.  If you have information on Macintosh or Windows -->
<!-- systems that you think should be added to this document, please let me -->
<!-- know. -->
   <p>특히, 다음의 내용에 대해서 알아주셨으면 합니다. 
이 문서의 작성자 (및 번역자 Chel Hee Lee)는 Windows 또는 Macintosh 시스템들을 가지고 있지 않습니다. 
따라서, Windows와 Mac OS X와 관련된 특별한 내용들에 대해서는
<a href="http://CRAN.R-project.org/bin/windows/base/rw-FAQ.html">&ldquo;R for Windows <acronym>FAQ</acronym>&rdquo;</a> 와
<a href="http://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html">&ldquo;R for Mac OS X <acronym>FAQ</acronym>&rdquo;</a>을 참고 해주세요. 
만약 Macintosh와 Windows 시스템들에 관련된 정보라고 할지라도, 이 문서내에 곡 포함되어야 한다고 생각되시면 꼭 알려주시기를 부탁드립니다.

<!-- <FIXME> -->
<!-- Should we maybe have direct links inside the R tree to the various -->
<!-- rw-FAQ versions? -->
<!-- </FIXME> -->
<div class="node">
<a name="R-Basics"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#R-and-S">R and S</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter R Basics -->
<h2 class="chapter">2 R의 기본적인 사항들</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-R_003f">What is R?</a>
<li><a accesskey="2" href="#What-machines-does-R-run-on_003f">What machines does R run on?</a>
<li><a accesskey="3" href="#What-is-the-current-version-of-R_003f">What is the current version of R?</a>
<li><a accesskey="4" href="#How-can-R-be-obtained_003f">How can R be obtained?</a>
<li><a accesskey="5" href="#How-can-R-be-installed_003f">How can R be installed?</a>
<li><a accesskey="6" href="#Are-there-Unix_002dlike-binaries-for-R_003f">Are there Unix-like binaries for R?</a>
<li><a accesskey="7" href="#What-documentation-exists-for-R_003f">What documentation exists for R?</a>
<li><a accesskey="8" href="#Citing-R">Citing R</a>
<li><a accesskey="9" href="#What-mailing-lists-exist-for-R_003f">What mailing lists exist for R?</a>
<li><a href="#What-is-CRAN_003f">What is CRAN?</a>
<li><a href="#Can-I-use-R-for-commercial-purposes_003f">Can I use R for commercial purposes?</a>
<li><a href="#Why-is-R-named-R_003f">Why is R named R?</a>
<li><a href="#What-is-the-R-Foundation_003f">What is the R Foundation?</a>
<li><a href="#What-is-R_002dForge_003f">What is R-Forge?</a>
</ul>

<div class="node">
<a name="What-is-R%3f"></a>
<a name="What-is-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-machines-does-R-run-on_003f">What machines does R run on?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Basics">R Basics</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section What is R? -->
<h3 class="section">2.1 R이란 무엇인가?</h3>

<!-- R is a system for statistical computation and graphics.  It consists of -->
<!-- a language plus a run-time environment with graphics, a debugger, access -->
<!-- to certain system functions, and the ability to run programs stored in -->
<!-- script files. -->
<p>R은 통계 계산 (statistical computation)과 그래픽 (graphics)를 위한 시스템입니다. 
이것은 언어(language), 그래픽을 사용하는 실행환경 (run-time environment), 디버거(debugger), 특정시스템 함수들에 대한 접근, 그리고 스크립트 파일들에 저장되어 있는 프로그램들을 실행시키는 요소들로 구성되어 있습니다.

<!-- The design of R has been heavily influenced by two existing languages: -->
<!-- Becker, Chambers & Wilks' S (@pxref{What is S?}) and Sussman's -->
<!-- @url{http://www.cs.indiana.edu/scheme-repository/home.html, Scheme}. -->
<!-- Whereas the resulting language is very similar in appearance to S, the -->
<!-- underlying implementation and semantics are derived from Scheme. -->
<!-- @xref{What are the differences between R and S?}, for further details. -->
   <p>R의 디자인은 Becker, Chambers &amp; Wilks의 S (see <a href="#What-is-S_003f">What is S?</a>)와 Sussman의 <a href="http://www.cs.indiana.edu/scheme-repository/home.html">Scheme</a>으로부터 크게 영향을 받았습니다. 
결과적으로 보이는 언어는 S의 외형과 매우 흡사하지만, 근본적인 구현방법과 시맨틱스(sematics)는 Scheme으로부터 유래되었습니다. 
더 많은 내용을 알고 싶으시다면 <a href="#What-are-the-differences-between-R-and-S_003f">What are the differences between R and S?</a>를 참고하시길 바랍니다.

<!-- The core of R is an interpreted computer language which allows branching -->
<!-- and looping as well as modular programming using functions.  Most of the -->
<!-- user-visible functions in R are written in R.  It is possible for the -->
<!-- user to interface to procedures written in the C, C++, or FORTRAN -->
<!-- languages for efficiency.  The R distribution contains functionality for -->
<!-- a large number of statistical procedures.  Among these are: linear and -->
<!-- generalized linear models, nonlinear regression models, time series -->
<!-- analysis, classical parametric and nonparametric tests, clustering and -->
<!-- smoothing.  There is also a large set of functions which provide a -->
<!-- flexible graphical environment for creating various kinds of data -->
<!-- presentations.  Additional modules (``add-on packages'') are available -->
<!-- for a variety of specific purposes (@pxref{R Add-On Packages}). -->
   <p>R의 핵심은 인터프리트된 컴퓨터 언어 (interpreted computer language)입니다. 
이것은 분기(branching), 루핑(Looping) 그리고 함수(functions)를 이용한 모듈(modular) 프로그래밍을 가능하게 합니다. 
R에서 사용자가 사용하는 함수들의 대부분은 R로 작성되었습니다. 
또한, 사용자가 효율성(efficiency)를 위한 목적으로 C, C++, 또는 FORTRAN과 같은 언어로 작성된 프로시져들에 인터페이싱(interface)하는 것이 가능합니다. 
R 배포판 (distribution)은 방대한 양의 통계적 프로시져(statistical procedure)들을 위한 기능(functionalities)들을 포함하고 있습니다. 
이들중에는 선형 및 일반화 선형 모델 (linear and generalized linear models), 비선형모델 (nonlinear regression model), 시계열분석 (time series analysis), 전통적인 모수 및 비모수 테스트 (classical parametric and nonparametric tests), 클러스터링 (clustering)과 평활화 (smoothing)이 있습니다. 
또한 매우 다양한 종류의 데이터 시각적 표현들을 생성할 수 있는 매우 유연한 그래픽 환경을 제공해주는 방대한 양의 함수들의 집합이 있습니다. 
특수한 목적을 달성하기 위해서 개발된 애드온 패키지(&ldquo;add-on packages&rdquo;)로 알려져 있는 부가적인 모듈들 역시 이용이 가능합니다. 
(이들에 대해서 더 알고 싶으시면 <a href="#R-Add_002dOn-Packages">R Add-On Packages</a>를 참고해주세요).

<!-- R was initially written by @email{Ross.Ihaka@@R-project.org, Ross Ihaka} -->
<!-- and @email{Robert.Gentleman@@R-project.org, Robert Gentleman} at the -->
<!-- Department of Statistics of the University of Auckland in Auckland, New -->
<!-- Zealand.  In addition, a large group of individuals has contributed to R -->
<!-- by sending code and bug reports. -->
   <p>최초의 R은 <a href="mailto:Ross.Ihaka@R-project.org">Ross Ihaka</a>와 <a href="mailto:Robert.Gentleman@R-project.org">Robert Gentleman</a>가 New Zealand의 Auckland 에 있는 University of Auckland의 통계학과에 재직중일 당시 작성되었습니다. 
그 이후, 많은 사용자들이 코드를 제공하고 버그를 리포팅 함으로서 R에 기여 해왔습니다.

<!-- Since mid-1997 there has been a core group (the ``R Core Team'') who can -->
<!-- modify the R source code archive.  The group currently consists of Doug -->
<!-- Bates, John Chambers, Peter Dalgaard, Seth Falcon, Robert Gentleman, -->
<!-- Kurt Hornik, Stefano Iacus, Ross Ihaka, Friedrich Leisch, Uwe Ligges, -->
<!-- Thomas Lumley, Martin Maechler, Duncan Murdoch, Paul Murrell, Martyn -->
<!-- Plummer, Brian Ripley, Deepayan Sarkar, Duncan Temple Lang, Luke -->
<!-- Tierney, and Simon Urbanek. -->
   <p>1997년 중반 이래로 &ldquo;R Core Team&rdquo;이라는 이름의 그룹에 의해서 R의 소스 코드 아카이브를 수정 및 관리되어지고 있습니다. 
이 그룹은 Doug Bates, John Chambers, Peter Dalgaard, Seth Falcon, Robert Gentleman, Kurt Hornik, Stefano Iacus, Ross Ihaka, Friedrich Leisch, Uwe Ligges, Thomas Lumley, Martin Maechler, Duncan Murdoch, Paul Murrell, Martyn Plummer, Brian Ripley, Deepayan Sarkar, Duncan Temple Lang, Luke Tierney, Simon Urbanek 으로 구성되어 있습니다.

<!-- R has a home page at @url{http://www.R-project.org/}.  It is -->
<!-- @url{http://www.gnu.org/philosophy/free-sw.html, free software} -->
<!-- distributed under a @acronym{GNU}-style -->
<!-- @url{http://www.gnu.org/copyleft/copyleft.html, copyleft}, and an -->
<!-- official part of the @url{http://www.gnu.org/, @acronym{GNU}} project -->
<!-- (``@acronym{GNU} S''). -->
   <p>R은 홈페이지 <a href="http://www.R-project.org/">http://www.R-project.org/</a>를 가지고 있습니다. 
<acronym>GNU</acronym> <a href="http://www.gnu.org/copyleft/copyleft.html">copyleft</a>를 기반으로 배포되는 <a href="http://www.gnu.org/philosophy/free-sw.html">free software</a>입니다. 
이는 &ldquo;<acronym>GNU</acronym> S&rdquo;라고 불리는 <a href="http://www.gnu.org/"><acronym>GNU</acronym></a> 공식 프로젝트의 일부입니다.

<div class="node">
<a name="What-machines-does-R-run-on%3f"></a>
<a name="What-machines-does-R-run-on_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-the-current-version-of-R_003f">What is the current version of R?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-R_003f">What is R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section What machines does R run on? -->
<h3 class="section">2.2 R이 실행이 가능한 기계들</h3>

<!-- R is being developed for the Unix-like, Windows and Mac families of -->
<!-- operating systems.  Support for Mac OS Classic ended with R 1.7.1. -->
<p>R은 Unix, Windows와 Mac 계열의 환경에서 개발되어져 왔습니다. 
R 1.7.1 이후로는 Mac OS Classic 에 대한 지원이 종료되었습니다.

<!-- The current version of R will configure and build under a number of -->
<!-- common Unix-like (e.g., @uref{http://en.wikipedia.org/wiki/Unix-like}) -->
<!-- platforms including @var{cpu}-linux-gnu for the i386, amd64, alpha, -->
<!-- arm/armel, hppa, ia64, m68k, mips/mipsel, powerpc, s390 and sparc -->
<!-- @acronym{CPU}s (e.g., @url{http://buildd.debian.org/build.php?&pkg=r-base}), -->
<!-- i386-hurd-gnu, @var{cpu}-kfreebsd-gnu for i386 and amd64, -->
<!-- powerpc-apple-darwin, mips-sgi-irix, -->
   <p>현 버전의 R은 보편적인 유닉스와 같은 (<a href="http://en.wikipedia.org/wiki/Unix-like">http://en.wikipedia.org/wiki/Unix-like</a>) 플랫폼을 기반으로 개발되고 설정됩니다. 
<var>cpu</var>-linux-gnu for the i386, amd64, alpha, arm/armel, hppa, ia64, m68k, mips/mipsel, powerpc, s390 and sparc <acronym>CPU</acronym>s (e.g., <a href="http://buildd.debian.org/build.php?&amp;pkg=r-base">http://buildd.debian.org/build.php?&amp;pkg=r-base</a>), i386-hurd-gnu, <var>cpu</var>-kfreebsd-gnu for i386 and amd64, powerpc-apple-darwin, mips-sgi-irix, rs6000-ibm-aix, 그리고 sparc-sun-solaris이 이에 해당합니다.

<!-- <FIXME> -->
<!-- Not sure anymore ... -->
<!-- alpha-dec-osf4, -->
<!-- <COMMENT> -->
<!-- i386-freebsd reported by B. Gian James" <gian.james@gmail.com> on -->
<!-- 2009-01-11 -->
<!-- (Architecture: i386, OS: FreeBSD 7.1-PRERELEASE, Vendor: PC-BSD) -->
<!-- i386-freebsd, -->
<!-- </COMMENT> -->
<!-- i386-sun-solaris, -->
<!-- hppa-hp-hpux, -->
<!-- </FIXME> -->
<!-- rs6000-ibm-aix, and sparc-sun-solaris. -->
<!-- and according to @email{jlindsey@@luc.ac.be, Jim Lindsey} also on -->
<!-- Mac, Amiga and Atari under m68k-linux. -->
   <p><a href="mailto:jlindsey@luc.ac.be">Jim Lindsey</a>에 따르면 m68k-linux에 속하는 Mac, Amiga 그리고 Atari 에서도 가능합니다.

<!-- If you know about other platforms, please drop us a note. -->
   <p>만약, 다른 플랫폼에 대해서 알고 계신다면 저희에게 알려주시길 부탁드립니다.

<div class="node">
<a name="What-is-the-current-version-of-R%3f"></a>
<a name="What-is-the-current-version-of-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-R-be-obtained_003f">How can R be obtained?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-machines-does-R-run-on_003f">What machines does R run on?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section What is the current version of R? -->
<h3 class="section">2.3 R의 현재 발표된 버전은 무엇인가요?</h3>

<!-- The current released version is @value{REL_VERSION}.  Based on this -->
<!-- `major.minor.patchlevel' numbering scheme, there are two development -->
<!-- versions of R, a patched version of the current release (`r-patched') -->
<!-- and one working towards the next minor or eventually major (`r-devel') -->
<!-- releases of R, respectively.  Version r-patched is for bug fixes mostly. -->
<!-- New features are typically introduced in r-devel. -->
<p>현재 발표된 (released) 버전은 2.15.3입니다. 
`major.minor.patchlevel'의 형식을 가지는 번호체계(numbering scheme)에 기초하여, R은 두 개발버전 (development version)들과 현재 발표된 버전의 일부를 수정한 'r-patched'라는 이름의 패치된 버전이 있으며, 다음 단계의 마이너(minor) 버전 또는 결과적으로는 주버전(major)이 될 `r-devel'라는 이름으로 발표된 R이 있습니다. 
패치 버전 (r-patched)은 대개 버그 수정을 한 것입니다. 
새로운 기능 및 형상들은 일반적으로 r-devel 에서 소개됩니다.

<div class="node">
<a name="How-can-R-be-obtained%3f"></a>
<a name="How-can-R-be-obtained_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-R-be-installed_003f">How can R be installed?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-the-current-version-of-R_003f">What is the current version of R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section How can R be obtained? -->
<h3 class="section">2.4 어떻게 R을 얻을 수 있나요?</h3>

<!-- Sources, binaries and documentation for R can be obtained via @CRAN{}, -->
<!-- the ``Comprehensive R Archive Network'' (see @ref{What is CRAN?}). -->
<p>R 원시코드 (sources), 바이너리 (binaries), 그리고 문서들(documentation)은 <acronym>CRAN</acronym>(&ldquo;Comprehensive R Archive Network&rdquo;)을 통하여 얻을 수 있습니다. 
(<a href="#What-is-CRAN_003f">What is CRAN?</a>을 살펴보세요).

<!-- Sources are also available via @url{https://svn.R-project.org/R/}, the -->
<!-- R Subversion repository, but currently not via anonymous rsync (nor -->
<!-- CVS). -->
   <p>원시코드 (sources)는 또한 R 서브버전 저장소 (subversion repository)인 <a href="https://svn.R-project.org/R/">https://svn.R-project.org/R/</a>를 통하여 얻을 수 있습니다. 
그러나, 익명 rsync (그리고 CVS)를 사용할 수 없습니다.

<!-- Tarballs with daily snapshots of the r-devel and r-patched development -->
<!-- versions of R can be found at -->
<!-- @url{ftp://ftp.stat.math.ethz.ch/Software/R}. -->
   <p>R의 r-devel와 r-patched 버전들에 대한 일일 스냅샷(daily snapshot)을 <a href="ftp://ftp.stat.math.ethz.ch/Software/R">ftp://ftp.stat.math.ethz.ch/Software/R</a>에서 타르볼(tarball)의 형태로 찾을 수 있습니다.

<!-- Sources are also available via anonymous rsync.  Use -->
<!-- @example -->
<!-- rsync -rptC -delete rsync.R-project.org::@var{module} R -->
<!-- @end example -->
<!-- @noindent -->
<!-- to create a copy of the source tree specified by @var{module} in the -->
<!-- subdirectory @file{R} of the current directory, where @var{module} -->
<!-- specifies one of the three existing flavors of the R sources, and can be -->
<!-- one of @samp{r-release} (current released version), @samp{r-patched} -->
<!-- (patched released version), and @samp{r-devel} (development version). -->
<!-- The rsync trees are created directly from the master CVS archive and are -->
<!-- updated hourly.  The @option{-C} and in the @command{rsync} command -->
<!-- is to cause it to skip the CVS directories.  Further information on -->
<!-- @command{rsync} is available at @url{http://rsync.samba.org/rsync/}. -->
<!-- @c <NOTE> -->
<!-- @c Keep in sync with R-admin. -->
<!-- Note that the sources available via rsync do not include the recommended -->
<!-- packages, whereas these are included in the tarballs of released -->
<!-- versions.  To install the appropriate sources for the recommended -->
<!-- packages, run @command{./tools/rsync-recommended} from the top-level of -->
<!-- the R sources that you pulled by rsync. -->
<!-- @c </NOTE> -->
<!-- The sources of the development version are also available via anonymous -->
<!-- CVS.  See @url{http://anoncvs.R-project.org} for more information. -->
<div class="node">
<a name="How-can-R-be-installed%3f"></a>
<a name="How-can-R-be-installed_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Are-there-Unix_002dlike-binaries-for-R_003f">Are there Unix-like binaries for R?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-R-be-obtained_003f">How can R be obtained?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section How can R be installed? -->
<h3 class="section">2.5 어떻게 R을 설치할 수 있나요?</h3>

<ul class="menu">
<li><a accesskey="1" href="#How-can-R-be-installed-_0028Unix_002dlike_0029">How can R be installed (Unix-like)</a>
<li><a accesskey="2" href="#How-can-R-be-installed-_0028Windows_0029">How can R be installed (Windows)</a>
<li><a accesskey="3" href="#How-can-R-be-installed-_0028Macintosh_0029">How can R be installed (Macintosh)</a>
</ul>

<div class="node">
<a name="How-can-R-be-installed-(Unix-like)"></a>
<a name="How-can-R-be-installed-_0028Unix_002dlike_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-R-be-installed-_0028Windows_0029">How can R be installed (Windows)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-R-be-installed_003f">How can R be installed?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-can-R-be-installed_003f">How can R be installed?</a>

</div>

<!-- @subsection How can R be installed (Unix-like) -->
<h4 class="subsection">2.5.1 Unix와 같은 환경에서 R을 어떻게 설치할 수 있나요?</h4>

<!-- If R is already installed, it can be started by typing @kbd{R} at the -->
<!-- shell prompt (of course, provided that the executable is in your path). -->
<p>만약 R이 이미 설치되어 있다면, 쉘 프롬프트(shell prompt)에서 <kbd>R</kbd>이라고 입력을 함으로서 실행할 수 있습니다 (물론, 실행가능한 파일이 경로에 올바르게 위치해 있다는 가정하에서 입니다).

<!-- If binaries are available for your platform (see @ref{Are there -->
<!-- Unix-like binaries for R?}), you can use these, following the -->
<!-- instructions that come with them. -->
   <p>만약 사용자의 플랫폼에 바이너리(binaries)가 사용가능하다면 (<a href="#Are-there-Unix_002dlike-binaries-for-R_003f">Are there Unix-like binaries for R?</a> 섹션을 살펴보세요), 이와 함께 제공되는 지시사항들을 따른다면 이들을 사용할 수 있습니다.

<!-- Otherwise, you can compile and install R yourself, which can be done -->
<!-- very easily under a number of common Unix-like platforms (see @ref{What -->
<!-- machines does R run on?}).  The file @file{INSTALL} that comes with the -->
<!-- R distribution contains a brief introduction, and the ``R Installation -->
<!-- and Administration'' guide (@pxref{What documentation exists for R?}) -->
<!-- has full details. -->
   <p>그렇지 않다면, R을 직접 컴파일하여 설치하여야 합니다. 
일반적인 Unix와 같은 플랫폼(<a href="#What-machines-does-R-run-on_003f">What machines does R run on?</a>를 참고해주세요)에서 이 과정을 수행하는 것은 매우 쉽쉽니다. 
R의 배포판과 함께 제공되는 <samp><span class="file">INSTALL</span></samp> 파일은 간단한 설치지침을 포함하고 있으면 &ldquo;R Installation and Administration&rdquo;라는 가이드는 설치와 관련한 자세한 내용들이 잘 문서화 되어 있습니다 (<a href="#What-documentation-exists-for-R_003f">What documentation exists for R?</a>을 참고하세요).

<!-- Note that you need a @FORTRAN{} compiler or perhaps @command{f2c} in -->
<!-- addition to a C compiler to build R. -->
   <p>참고로 R을 빌드(build)하기 위해서는 C 컴파일러(compiler) 외에도 FORTRAN 컴파일러 혹은 아마도 <samp><span class="command">f2c</span></samp>라는 것이 필요할 수도 있습니다.

<!-- In the simplest case, untar the R source code, change to the directory -->
<!-- thus created, and issue the following commands (at the shell prompt): -->
   <p>가장 간단한 방법은 R 원시코드(source code)의 압축을 풀고, 압축이 풀어 생성된 디렉토리로 이동한 후, (쉘 프롬프트상에서) 다음과 같은 명령어를 입력하는 것입니다.

<pre class="example">     $ ./configure
     $ make
</pre>
   <!-- If these commands execute successfully, the R binary and a shell script -->
<!-- front-end called @file{R} are created and copied to the @file{bin} -->
<!-- directory.  You can copy the script to a place where users can invoke -->
<!-- it, for example to @file{/usr/local/bin}.  In addition, plain text help -->
<!-- pages as well as @HTML{} and @LaTeX{} versions of the documentation are -->
<!-- built. -->
   <p>만약 명령어들이 성공적으로 수행된다면, R 바이너리와 쉘 스크립트로 작성된 사용자가 이용이 가능한 <samp><span class="file">R</span></samp>이라는 이름을 가진 파일이 생성되고, 이는 <samp><span class="file">bin</span></samp> 디렉토리에 복사되어 질 것입니다. 
사용자는 이 스크립트를 실행시키고자 하는 위치로 스크립트를 복사해 넣기만 하면 됩니다. 
예를들면, <samp><span class="file">/usr/local/bin</span></samp> 디렉토리입니다. 
또한, 텍스트로만 구성된 도움말 페이지 뿐만아니라 <acronym>HTML</acronym>, LaTeX 버전의 문서들도 함께 설치됩니다.

<!-- Use @kbd{make dvi} to create DVI versions of the R manuals, such as -->
<!-- @file{refman.dvi} (an R object reference index) and @file{R-exts.dvi}, -->
<!-- the ``R Extension Writers Guide'', in the @file{doc/manual} -->
<!-- subdirectory.  These files can be previewed and printed using standard -->
<!-- programs such as @command{xdvi} and @command{dvips}.  You can also use -->
<!-- @kbd{make pdf} to build PDF (Portable Document Format) version of the -->
<!-- manuals, and view these using e.g.@: Acrobat.  Manuals written in the -->
<!-- @acronym{GNU} Texinfo system can also be converted to info files -->
<!-- suitable for reading online with Emacs or stand-alone @acronym{GNU} -->
<!-- Info; use @kbd{make info} to create these versions (note that this -->
<!-- requires Makeinfo version 4.5). -->
   <p><samp><span class="file">doc/manual</span></samp>에 놓여있는 <samp><span class="file">refman.dvi</span></samp> (R object reference index) 혹은 <samp><span class="file">R-exts.dvi</span></samp> (&ldquo;R Extension Writers Guide&rdquo;)와 같은 R 매뉴얼들의 DVI 버전을 생성하기 위해서는 <kbd>make dvi</kbd>를 이용해보세요. 
이러한 파일들은 <samp><span class="command">xdvi</span></samp> 또는 <samp><span class="command">dvips</span></samp>와 같은 표준 프로그램들을 이용하여 미리 보거나 프린트를 할 수 있습니다. 
또한, <kbd>make pdf</kbd>의 사용은 매뉴얼들을 PDF (Portable Document Format)의 형식으로 생성하게 해줍니다. 
이들은 Arobat을 이용하여 볼 수 있습니다. 
<acronym>GNU</acronym> Texinfo 시스템에 의하여 작성된 매뉴얼들 (본 한국어 매뉴얼 역시 <acronym>GNU</acronym> Texinfo 시스템을 이용하여 작성되었습니다) 은 또한 Emacs 또는 독립적인 <acronym>GNU</acronym> Info 와 함께 온라인으로 읽을 수 읽을 수 있도록 info 파일들로 변환할 수 있습니다. 
이들을 생성하기 위해서는 <kbd>make info</kbd>를 이용하시길 바랍니다. 
(단, 이경우에는 Makeinfo 의 버전이 4.5 이상이 요구됩니다).

<!-- Finally, use @kbd{make check} to find out whether your R system works -->
<!-- correctly. -->
   <p>마지막으로 R 시스템이 정상적으로 작동하는지 확인하기 위해서 <kbd>make check</kbd>를 이용해 보세요.

<!-- You can also perform a ``system-wide'' installation using @kbd{make -->
<!-- install}.  By default, this will install to the following directories: -->
   <p><kbd>make install</kbd>을 이용하여 &ldquo;system-wide&rdquo;(시스템 전체에서 사용이 가능한) 설치를 수행할 수도 있습니다. 
기본적으로 이것은 다음의 디렉토리에 설치됩니다.

     <dl>
<dt><samp><span class="file">${prefix}/bin</span></samp><dd><!-- the front-end shell script -->
사용자가 직접 이용하는 쉘 스크립트 (front-end shell script)
<br><dt><samp><span class="file">${prefix}/man/man1</span></samp><dd><!-- the man page -->
도움말 페이지
<br><dt><samp><span class="file">${prefix}/lib/R</span></samp><dd><!-- all the rest (libraries, on-line help system, @dots{}).  This is the ``R -->
<!-- Home Directory'' (@env{R_HOME}) of the installed system. -->
위의 내용을 제외한 나머지 모두 (라이브러리, 온라인 도움말, <small class="dots">...</small>)이 이곳에 설치됩니다. 
이것을 설치된 시스템의 &ldquo;R Home Directory&rdquo;(R 홈디렉토리, <samp><span class="env">R_HOME</span></samp>)이라고 합니다. 
</dl>

<p class="noindent"><!-- In the above, @code{prefix} is determined during configuration -->
<!-- (typically @file{/usr/local}) and can be set by running -->
<!-- @command{configure} with the option -->
위에서 <code>prefix</code>는 환경설정을 하는 동안에 결정되어 지며 (일반적으로 <samp><span class="file">/usr/local/</span></samp>입니다), 아래에 보이는 것과 같이 <samp><span class="command">configure</span></samp>에 옵션을 이용하여 설치시에 정할 수도 있습니다.

<pre class="example">     $ ./configure --prefix=/where/you/want/R/to/go
</pre>
   <p class="noindent"><!-- (E.g., the R executable will then be installed into -->
<!-- @file{/where/you/want/R/to/go/bin}.) -->
(즉, R의 실행파일들은 <samp><span class="file">/where/you/want/R/to/go/bin</span></samp>에 설치될 것입니다).

<!-- To install DVI, info and PDF versions of the manuals, use @kbd{make -->
<!-- install-dvi}, @kbd{make install-info} and @kbd{make install-pdf}, -->
<!-- respectively. -->
   <p>DVI, info, PDF 버전의 매뉴얼들을 설치하기 위해서는 <kbd>make install-dvi</kbd>, <kbd>make install-info</kbd>, <kbd>make install-pdf</kbd>을 각각 실행시키세요.

<div class="node">
<a name="How-can-R-be-installed-(Windows)"></a>
<a name="How-can-R-be-installed-_0028Windows_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-R-be-installed-_0028Macintosh_0029">How can R be installed (Macintosh)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-R-be-installed-_0028Unix_002dlike_0029">How can R be installed (Unix-like)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-can-R-be-installed_003f">How can R be installed?</a>

</div>

<!-- @subsection How can R be installed (Windows) -->
<h4 class="subsection">2.5.2 Windows 에서는 R을 어떻게 설치해야 하나요?</h4>

<!-- The @file{bin/windows} directory of a @CRAN{} site contains binaries for -->
<!-- a base distribution and a large number of add-on packages from @CRAN{} -->
<!-- to run on Windows 2000 and later (including 64-bit versions of Windows) -->
<!-- on ix86 and x86_64 chips. The Windows version of R was created by Robert -->
<!-- Gentleman and Guido Masarotto, and is now being developed and maintained -->
<!-- by @email{murdoch@@stats.uwo.ca, Duncan Murdoch} and -->
<!-- @email{Brian.Ripley@@R-project.org, Brian D. Ripley}. -->
<p><acronym>CRAN</acronym> 사이트의 <samp><span class="file">bin/windows</span></samp> 디렉토리는 ix86 과 x86_64 칩상에서 돌아가는 Windows 2000 과 그 이후
의 버전들 (64비트 포함)에서 돌아갈 수 있는 R base 배포판과 방대한 양의 애드온(add-on) 패키지들에 대한 바이너리들을 포함하고 있습니다. 
Windows 버전의 R은 Robert Gentleman과 Guido Masarotto에 의해서 만들어졌으며, 현재는 <a href="mailto:murdoch@stats.uwo.ca">Duncan Murdoch</a>와 <a href="mailto:Brian.Ripley@R-project.org">Brian D. Ripley</a>에 의해서 개발
및 유지보수가 되고 있습니다.

<!-- Note that when uncompressing the zip files, the pkunzip program needs to -->
<!-- be invoked with the @samp{-D} flag to create subdirectories.  Also, be -->
<!-- aware that some decompression programs do not preserve long file names -->
<!-- properly. -->
<!-- For most installations the Windows installer program will be the easiest -->
<!-- tool to use. -->
   <p>대부분의 경우, Windows 설치 프로그램 (installer)은 이용하기에 가장 쉬운 도구일 것입니다.

<!-- See the @url{http://CRAN.R-project.org/bin/windows/base/@/rw-FAQ.html, -->
<!-- ``R for Windows @acronym{FAQ}''} for more details. -->
   <p>보다 더 자세한 사항에 대해서는 <a href="http://CRAN.R-project.org/bin/windows/base/rw-FAQ.html">&ldquo;R for Windows <acronym>FAQ</acronym>&rdquo;</a>를 참고하세요.

<div class="node">
<a name="How-can-R-be-installed-(Macintosh)"></a>
<a name="How-can-R-be-installed-_0028Macintosh_0029"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-R-be-installed-_0028Windows_0029">How can R be installed (Windows)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-can-R-be-installed_003f">How can R be installed?</a>

</div>

<!-- @subsection How can R be installed (Macintosh) -->
<h4 class="subsection">2.5.3 Macintosh에서는 어떻게 R을 설치하나요?</h4>

<!-- The @file{bin/macosx} directory of a @CRAN{} site contains a standard -->
<!-- Apple installer package inside a disk image named @file{R.dmg}.  Once -->
<!-- downloaded and executed, the installer will install the current -->
<!-- non-developer release of R.  RAqua is a native Mac OS X Darwin version -->
<!-- of R with a R.app Mac OS X @acronym{GUI}.  Inside -->
<!-- @file{bin/macosx/powerpc/contrib/@var{x}.@var{y}} there are prebuilt -->
<!-- binary packages (for powerpc version of Mac OS X) to be used with RAqua -->
<!-- corresponding to the ``@var{x}.@var{y}'' release of R. The installation -->
<!-- of these packages is available through the ``Package'' menu of the R.app -->
<!-- @acronym{GUI}.  This port of R for Mac OS X is maintained by -->
<!-- @email{Stefano.Iacus@@R-project.org, Stefano Iacus}.  The -->
<!-- @url{http://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html, ``R for Mac -->
<!-- OS X @acronym{FAQ}} has more details. -->
<p><acronym>CRAN</acronym> 사이트내의 <samp><span class="file">bin/macosx</span></samp> 디렉토리는 <samp><span class="file">R.dmg</span></samp>라는 이름의 디스크 이미지가 표준 Apple 인스톨러 패키지를 포함하고 있습니다. 
이것을 다운로드 받아 실행시키면, 설치프로그램은 비개발자 배포판non-developer release)을 설치하게 될 것입니다. 
RAqua 는 네이브(naive) Mac OS X Darwin 버전의 R과 R.app Mac OS X <acronym>GUI</acronym>를 지칭합니다. 
<samp><span class="file">bin/macosx/powerpc/contrib/</span><var>x</var><span class="file">.</span><var>y</var></samp> 디렉토리 내에는, R의 &ldquo;<var>x</var>.<var>y</var>&rdquo; 릴리즈에 대응되는 RAqua 와 함께 사용될 (Mac OS X 의 powerpc 버전을 위하여) 미리 빌드된 바이너리 패키지들이 있을 것입니다. 
이러한 패키지들의 설치는 R.app <acronym>GUI</acronym>에 있는 &ldquo;Package&rdquo; 메뉴를 통하여 가능합니다. 
Mac OS X 에 대한 이러한 R 포트 (port) 는 <a href="mailto:Stefano.Iacus@R-project.org">Stefano Iacus</a>에 의하여 유지 보수 됩니다. 
더 자세한 사항에 대해서는 <a href="http://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html">&ldquo;R for Mac OS X <acronym>FAQ</acronym></a> 를 참고하길 바랍니다.

<!-- The @file{bin/macos} directory of a @CRAN{} site contains bin-hexed -->
<!-- (@file{hqx}) and stuffit (@file{sit}) archives for a base distribution -->
<!-- and a large number of add-on packages of R 1.7.1 to run under Mac OS 8.6 -->
<!-- to Mac OS 9.2.2.  This port of R for Macintosh is no longer supported. -->
<div class="node">
<a name="Are-there-Unix-like-binaries-for-R%3f"></a>
<a name="Are-there-Unix_002dlike-binaries-for-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-documentation-exists-for-R_003f">What documentation exists for R?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-R-be-installed_003f">How can R be installed?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section Are there Unix-like binaries for R? -->
<h3 class="section">2.6 Unix와 같은 바이너리들이 있나요?</h3>

<!-- Linux binaries as of 2011-07-05: -->
<!-- debian -->
<!-- etch-cran -->
<!-- i386   2.11.0  Johannes Ranke -->
<!-- amd64  2.11.0  Johannes Ranke -->
<!-- lenny-cran -->
<!-- i386   2.13.0  Johannes Ranke -->
<!-- amd64  2.13.0  Johannes Ranke -->
<!-- squeeze-cran -->
<!-- i386   2.13.0  Johannes Ranke -->
<!-- amd64  2.13.0  Johannes Ranke -->
<!-- redhat -->
<!-- el4      i386   2.10.0  Bob Kinney <rhel_cran@hmdc.harvard.edu> -->
<!-- x86_64 2.10.0  Bob Kinney <rhel_cran@hmdc.harvard.edu> -->
<!-- el5      i386   2.10.0  Bob Kinney <rhel_cran@hmdc.harvard.edu> -->
<!-- x86_64 2.10.0  Bob Kinney <rhel_cran@hmdc.harvard.edu> -->
<!-- fedora10 i386   2.10.0  Martyn Plummer <Martyn.Plummer@R-project.org> -->
<!-- x86_64 2.10.0  Martyn Plummer <Martyn.Plummer@R-project.org> -->
<!-- fedora11 i386   2.10.0  Martyn Plummer <Martyn.Plummer@R-project.org> -->
<!-- x86_64 2.10.0  Martyn Plummer <Martyn.Plummer@R-project.org> -->
<!-- ubuntu -->
<!-- intrepid [Intrepid Ibex, 8.10] -->
<!-- i386   2.8.1  Vincent Goulet -->
<!-- amd64  2.8.1  Michael Rutter -->
<!-- hardy [Hardy Heron, 8.04] -->
<!-- i386   2.8.1  Vincent Goulet -->
<!-- amd64  2.8.1  Michael Rutter -->
<!-- gutsy [Gutsy Gibbon, 7.10] -->
<!-- i386   2.8.1  Vincent Goulet -->
<!-- amd64  2.8.1  Michael Rutter -->
<!-- dapper [Dapper Drake, 6.06] -->
<!-- i386   2.8.1  Vincent Goulet -->
<!-- amd64  2.8.1  Michael Rutter -->
<!-- The @file{bin/linux} directory of a @CRAN{} site contains the following -->
<!-- packages. -->
<p><acronym>CRAN</acronym> 사이트의 <samp><span class="file">bin/linux</span></samp> 디렉토리는 다음과 같은 패키지들을 포함하고 있습니다.

   <blockquote>
   <p><table summary=""><tr align="left"><th valign="top"></th><th valign="top">CPU </th><th valign="top">Versions </th><th valign="top">Provider
<br></th></tr><tr align="left"><td valign="top">Debian   </td><td valign="top">i386/amd64 </td><td valign="top">etch/lenny/squeeze </td><td valign="top">Johannes Ranke
<br></td></tr><tr align="left"><td valign="top">Red Hat  </td><td valign="top">i386/x86_64 </td><td valign="top">fedora10/fedora11 </td><td valign="top">Martyn Plummer
<br></td></tr><tr align="left"><td valign="top">Ubuntu   </td><td valign="top">i386/amd64 </td><td valign="top">hardy/lucid/natty/oneiric/precise </td><td valign="top">Michael Rutter
   <br></td></tr></table>
</blockquote>

<!-- Debian packages, maintained by Dirk Eddelbuettel, have long been part of -->
<!-- the Debian distribution, and can be accessed through APT, the Debian -->
<!-- package maintenance tool.  Use e.g.@: @code{apt-get install r-base -->
<!-- r-recommended} to install the R environment and recommended packages. -->
<!-- If you also want to build R packages from source, also run @code{apt-get -->
<!-- install r-base-dev} to obtain the additional tools required for this. -->
<!-- So-called ``backports'' of the current R packages for at least the -->
<!-- @dfn{stable} distribution of Debian are provided by Johannes Ranke, and -->
<!-- available from @CRAN{}.  See -->
<!-- @url{http://CRAN.R-project.org/bin/linux/debian/README} for details on R -->
<!-- Debian packages and installing the backports, which should also be -->
<!-- suitable for other Debian derivatives.  Native backports for Ubuntu are -->
<!-- provided by Michael Rutter. -->
   <p>Dirk Eddelbuettel에 의해 유지보수되는 데비안(Debian) 패지들은 오랜 시간에 걸쳐 데비안 배포판의 일부분이 되어가고 있으며, 데비안 패키지 관리도구인 APT 를 통하여 쉽게 엑세스 될 수 있습니다. 
R 기본 환경 및 추천 패키지들을 설치하기 위해서는 <code>apt-get install r-base r-recommended</code>을 입력하면 됩니다. 
만약, 원시코드(source)로부터 R 패키지를 빌드하고자 한다면, 이에 필요한 도구들을 설치하기 위해서 <code>apt-get
install r-base-dev</code>이라고 입력하면 됩니다. 
최소한 <dfn>stable</dfn>(안정적인 버전의) 데비안에 적용이 될 수 있는 &ldquo;backport&rdquo;라고 불리우는 R 패키지들은 Johannes Ranke에 의하여 제공되며, <acronym>CRAN</acronym>으로부터 받을 수 있습니다. 
R 데비안 패키지들에 대한 사항들과 백포트(backport)를 설치하는 하는 방법에 대해서는 <a href="http://CRAN.R-project.org/bin/linux/debian/README">http://CRAN.R-project.org/bin/linux/debian/README</a>를 살펴보시길 바랍니다. 
이는 데비안으로부터 파생된 다른 배포판에서도 안정적으로 작동될 것입니다. 
우분투를 위한 네이티브 백포트 (native backports)는 Michael Rutter에 의해서 제공됩니다.

<!-- R binaries for Fedora, maintained by Tom ``Spot'' Callaway, are provided -->
<!-- as part of the Fedora distribution and can be accessed through -->
<!-- @command{yum}, the RPM installer/updater.  The Fedora R RPM is a -->
<!-- ``meta-package'' which installs all the user and developer components of -->
<!-- R (available separately as @code{R-core} and @code{R-devel}), as well as -->
<!-- the standalone R math library (@code{libRmath} and -->
<!-- @code{libRmath-devel}).  RPMs for a selection of R packages are also -->
<!-- provided by Fedora.  The Extra Packages for Enterprise Linux (EPEL) -->
<!-- project (@url{http://fedoraproject.org/wiki/EPEL}) provides ports of the -->
<!-- Fedora RPMs for RedHat Enterprise Linux and compatible distributions. -->
<!-- When a new version of R is released, there may be a delay of up to 2 -->
<!-- weeks until the Fedora RPM becomes publicly available, as it must pass -->
<!-- through the statutory Fedora review process. -->
   <p>Fedora(페도라)를 위한 R 바이너리들은 Tom &ldquo;Spot&rdquo; Callaway에 의해서 유지보수되며, 페도라 배포판의 일부로서 제공되며 RPM 설치 및 업데이트 관리프로그램인 <samp><span class="command">yum</span></samp>을 통하여 엑세스 할 수 있습니다. 
페도라 R RPM 은 사용자와 개발자에게 필요한 모든 구성요소들을 다 함께 설치해주는 메타패키지(&ldquo;meta-package&rdquo;)인데, 이는 <code>R-core</code>와 <code>R-devel</code>으로 구분되어집니다. 
또한, 독립적인 (standalone) R math library (<code>libRmath</code>와 <code>libRmath-devel</code>)를 설치할 수 있으며, R 패키지들을 선택하여 설치하는 기능 역시 포함하고 있습니다. 
Enterprise Linux (EPEL) 프로젝트 (<a href="http://fedoraproject.org/wiki/EPEL">http://fedoraproject.org/wiki/EPEL</a>)를 위한 추가적인 패키지들은 RedHat Enterprise Linux와 이와 호환되는 배포판들을 위한 Fedora RPM의 포트를 제공합니다. 
새로운 버전의 R이 배포될때, 페도라 RPM 에서 새버전을 사용하기 위해서는 최대 2주까지 지연될 가능성이 있습니다. 
이는 반드시 페도라내에 지정된 검증프로세스 (statuory Fedora review process)를 반드시 거쳐야 하기 때문입니다.

<!-- See @url{http://CRAN.R-project.org/bin/linux/suse/README.html} for -->
<!-- information about RPMs for openSUSE. -->
   <p>openSUSE 에서 이용되는 RPM에 관한 정보는 <a href="http://CRAN.R-project.org/bin/linux/suse/README.html">http://CRAN.R-project.org/bin/linux/suse/README.html</a>를 살펴보시길 바랍니다.

<!-- The @file{bin/osf} directory of a @CRAN{} site contains RPMs -->
<!-- by Albrecht Gebhardt for alpha systems running Alpha Unix -->
<!-- (OSF/Tru64). -->
<!-- There are also `tar' distributions for NEXTSTEP on the i386 and m68k -->
<!-- platforms in @file{bin/nextstep/i386} and @file{bin/nextstep/m68k}, -->
<!-- created by Stephen Shiboski <steve@biostat.ucsf.edu>. -->
<!-- The @file{bin/solaris} directory of a @CRAN{} site contains binary -->
<!-- packages for Solaris on the SPARC and x64 platforms, provided by Mithun -->
<!-- Sridharan. -->
<!-- No other binary distributions are currently publically available via -->
<!-- @CRAN{}. -->
   <p>현재 다른 종류들에 대하여 공개적으로 <acronym>CRAN</acronym>을 통해 이용가능한 바이너들은 없습니다.

<!-- A ``live'' Linux distribution with a particular focus on R is -->
<!-- @dfn{Quantian}, which provides a directly bootable and self-configuring -->
<!-- ``Live DVD'' containing numerous applications of interests to scientists -->
<!-- and researchers, including several hundred @CRAN{} and Bioconductor -->
<!-- packages, the ``ESS'' extensions for Emacs, the ``JGR'' Java -->
<!-- @acronym{GUI} for R, the Ggobi visualization tool as well as several -->
<!-- other R interfaces. The @dfn{Quantian} website at -->
<!-- @url{http://dirk.eddelbuettel.com/quantian/} contains more details as -->
<!-- well download information. -->
<div class="node">
<a name="What-documentation-exists-for-R%3f"></a>
<a name="What-documentation-exists-for-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Citing-R">Citing R</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Are-there-Unix_002dlike-binaries-for-R_003f">Are there Unix-like binaries for R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section What documentation exists for R? -->
<h3 class="section">2.7 R에 대해서 어떤 문서들이 존재하나요?</h3>

<!-- Online documentation for most of the functions and variables in R -->
<!-- exists, and can be printed on-screen by typing @kbd{help(@var{name})} -->
<!-- (or @kbd{?@var{name}}) at the R prompt, where @var{name} is the name of -->
<!-- the topic help is sought for.  (In the case of unary and binary -->
<!-- operators and control-flow special forms, the name may need to be be -->
<!-- quoted.) -->
<p>R에서 사용할 수 있는 대부분의 함수들과 변수들에 대해서는 온라인 문서가 있으며, 이들은 R 프롬프트에서 <kbd>help(</kbd><var>name</var><kbd>)</kbd> (또는 <kbd>?</kbd><var>name</var>)이라고 입력함으로서 스크린을 통하여 확인할 수 있습니다. 
여기에서 <var>name</var>은 도움을 받고자 하는 주제를 의미합니다. 
(단항과 이항 연산자 (unary and binary operators), 그리고 분기문(control-flow)과 같은 특수한 형태의 경우에는 검색어를 입력할때 따옴표를 함께 넣어주어야 할 수도 있습니다).

<!-- This documentation can also be made available as one reference manual -->
<!-- for on-line reading in @HTML{} and PDF formats, and as hardcopy via -->
<!-- @LaTeX{}, see @ref{How can R be installed?}.  An up-to-date @HTML{} -->
<!-- version is always available for web browsing at -->
<!-- @url{http://stat.ethz.ch/R-manual/}. -->
   <p>본 문서 또한 <acronym>HTML</acronym>과 PDF 형식으로 온라인으로 읽을 수 있는 하나의 참고메뉴얼(reference manual)이며, LaTeX를 통하여 출력할 수도 있습니다. 
<a href="#How-can-R-be-installed_003f">How can R be installed?</a>를 참고하시길 바랍니다. 
가장 최신버전의 <acronym>HTML</acronym> 버전은 항상 <a href="http://stat.ethz.ch/R-manual/">http://stat.ethz.ch/R-manual/</a>에서 확인해 보실수 있습니다.

<!-- Printed copies of the R reference manual for some version(s) are -->
<!-- available from Network Theory Ltd, at -->
<!-- @url{http://www.network-theory.co.uk/R/base/}.  For each set of manuals -->
<!-- sold, the publisher donates USD 10 to the R Foundation (@pxref{What is -->
<!-- the R Foundation?}). -->
   <p>일부 버전들에 대한 참고매뉴얼 (R reference manual)들은 Network Theory Ltd <a href="http://www.network-theory.co.uk/R/base/">http://www.network-theory.co.uk/R/base/</a>에서 구매할 수 있습니다. 
매뉴얼 한 부가 판매될 때마다, 출판사는 R Foundation (see <a href="#What-is-the-R-Foundation_003f">What is the R Foundation?</a>)에 USD 10 (미국돈으로 10달러)를 기부합니다.

<!-- The R distribution also comes with the following manuals. -->
   <p>R은 다음과 같은 매뉴얼들과 함께 배포되고 있습니다.

<!-- start from this point next time -->
<!-- start from this point next time -->
<!-- start from this point next time -->
<!-- start from this point next time -->
<!-- start from this point next time -->
<!-- start from this point next time -->
     <ul>
<li>&ldquo;An Introduction to R&rdquo; (<samp><span class="file">R-intro</span></samp>)
<!-- includes information on data types, programming elements, statistical -->
<!-- modeling and graphics.  This document is based on the ``Notes on -->
<!-- @SPLUS{}'' by Bill Venables and David Smith. -->
는 데이터의 유형, 프로그래밍 구성요소들, 통계 모델링과 그래픽스에 대한 정보를 포함하고 있습니다. 
이 문서는 Bill Venables과 David Smith가 작성한 &ldquo;Notes on S-Plus&rdquo;라는 문서를 토대로 하고 있습니다.

     <li>&ldquo;Writing R Extensions&rdquo; (<samp><span class="file">R-exts</span></samp>)
<!-- currently describes the process of creating R add-on packages, writing R -->
<!-- documentation, R's system and foreign language interfaces, and the R -->
<!-- @acronym{API}. -->
는 R 애드온(add-on) 패키지의 작성절차, R 문서 작성요령, R과 다른 언어들과의 인터페이스, 그리고 <acronym>API</acronym>에 대해서 기술하고 있습니다.

     <li>&ldquo;R Data Import/Export&rdquo; (<samp><span class="file">R-data</span></samp>)
<!-- is a guide to importing and exporting data to and from R. -->
는 데이터 입출력에 대한 가이드입니다.

     <li>&ldquo;The R Language Definition&rdquo; (<samp><span class="file">R-lang</span></samp>),
<!-- a first version of the ``Kernighan & Ritchie of R'', explains -->
<!-- evaluation, parsing, object oriented programming, computing on the -->
<!-- language, and so forth. -->
는 &ldquo;Kernighan &amp; Ritchie of R&rdquo;이라는 문서의 최초 버전이기도 하며, 이밸류에이션(evaluation, 평가, 파싱(parsing, 구문해석), 객체지향 프로그래밍 (object oriented programming), 연산(computing) 등의 내용을 다루고 있습니다.

     <li>&ldquo;R Installation and Administration&rdquo; (<samp><span class="file">R-admin</span></samp>). 
<li>&ldquo;R Internals&rdquo; (<samp><span class="file">R-ints</span></samp>)
<!-- is a guide to R's internal structures. -->
<!-- (Added in R 2.4.0.) -->
R의 내부구조(internal structure)에 대한 가이드입니다 (R-2.4.0에서 추가되었습니다). 
</ul>

<!-- An annotated bibliography (Bib@TeX{} format) of R-related publications -->
<!-- can be found at -->
   <p>R과 관련된 문헌(publications)들에 대한 정보는 BibTeX 형식으로 아래의 주소에서 찾아 볼 수있습니다.

<pre class="display">     <a href="http://www.R-project.org/doc/bib/R.bib">http://www.R-project.org/doc/bib/R.bib</a>
</pre>
   <!-- Books on R by R Core Team members include -->
   <p>R 코어팀 멤버들에 의해서 씌여진 책들은 아래와 같습니다.

   <blockquote>
John M. Chambers (2008), &ldquo;Software for Data Analysis: Programming with
R&rdquo;.  Springer, New York, ISBN 978-0-387-75935-7,
<a href="http://stat.stanford.edu/~jmc4/Rbook/">http://stat.stanford.edu/~jmc4/Rbook/</a>.

   <p>Peter Dalgaard (2008), &ldquo;Introductory Statistics with R&rdquo;, 2nd edition. 
Springer, ISBN 978-0-387-79053-4,
<a href="http://www.biostat.ku.dk/~pd/ISwR.html">http://www.biostat.ku.dk/~pd/ISwR.html</a>.

   <p>Robert Gentleman (2008), &ldquo;R Programming for Bioinformatics&rdquo;.  Chapman
&amp; Hall/CRC, Boca Raton, FL, ISBN 978-1-420-06367-7,
<a href="http://www.bioconductor.org/pub/RBioinf/">http://www.bioconductor.org/pub/RBioinf/</a>.

   <p>Stefano M. Iacus (2008), &ldquo;Simulation and Inference for Stochastic
Differential Equations: With R Examples&rdquo;. Springer, New York, ISBN
978-0-387-75838-1.

   <p>Deepayan Sarkar (2007), &ldquo;Lattice: Multivariate Data Visualization with
R&rdquo;. Springer, New York, ISBN 978-0-387-75968-5.

   <p>W. John Braun and Duncan J. Murdoch (2007), &ldquo;A First Course in
Statistical Programming with R&rdquo;.  Cambridge University Press,
Cambridge, ISBN 978-0521872652.

   <p>P. Murrell (2005), &ldquo;R Graphics&rdquo;, Chapman &amp; Hall/CRC, ISBN:
1-584-88486-X,
<a href="http://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html">http://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html</a>.

   <p>William N. Venables and Brian D. Ripley (2002), &ldquo;Modern Applied
Statistics with S&rdquo; (4th edition).  Springer, ISBN 0-387-95457-0,
<a href="http://www.stats.ox.ac.uk/pub/MASS4/">http://www.stats.ox.ac.uk/pub/MASS4/</a>.

   <p>Jose C. Pinheiro and Douglas M. Bates (2000), &ldquo;Mixed-Effects Models in
S and S-Plus&rdquo;. Springer, ISBN 0-387-98957-0. 
</blockquote>

<!-- Last, but not least, Ross' and Robert's experience in designing and -->
<!-- implementing R is described in -->
   <p>마지막으로, 최근의 것은 아니지만, Ross와 Robert가 R을 디자인하고 구현하면서 겪은 경험이 다음의 문서에 기록되어 있습니다. 
Ihaka &amp; Gentleman (1996), &ldquo;R: A Language
for Data Analysis and Graphics&rdquo;,
<a href="http://www.amstat.org/publications/jcgs/"><em>Journal of Computational and Graphical Statistics</em></a>, <strong>5</strong>, 299&ndash;314.

<div class="node">
<a name="Citing-R"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-mailing-lists-exist-for-R_003f">What mailing lists exist for R?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-documentation-exists-for-R_003f">What documentation exists for R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section Citing R -->
<h3 class="section">2.8 R을 인용하는 방법</h3>

<!-- To cite R in publications, use -->
<p>R을 참고자료로서 인용하고자 한다면, 아래의 BibTeX를 이용하시면 됩니다.
<pre class="example">     @Manual{,
       title        = {R: A Language and Environment for Statistical
                       Computing},
       author       = {{R Core Team}},
       organization = {R Foundation for Statistical Computing},
       address      = {Vienna, Austria},
       year         = 2013,
       note         = {{ISBN} 3-900051-07-0},
       url          = {http://www.R-project.org}
     }
</pre>
   <!-- Citation strings (or Bib@TeX{} entries) for R and R packages can also be -->
<!-- obtained by @code{citation()}. -->
   <p>R과 R 패키지들에 대한 BibTeX 항목들또는 인용정보들은 <code>citation()</code>을 통하여 얻을 수 있습니다.

<div class="node">
<a name="What-mailing-lists-exist-for-R%3f"></a>
<a name="What-mailing-lists-exist-for-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-CRAN_003f">What is CRAN?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Citing-R">Citing R</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section What mailing lists exist for R? -->
<h3 class="section">2.9 어떤 메일링 리스트가 있나요?</h3>

<!-- Thanks to @email{Martin.Maechler@@R-project.org, Martin Maechler}, there -->
<!-- are four mailing lists devoted to R. -->
<p>이러한 서비스를 제공해 준 <a href="mailto:Martin.Maechler@R-project.org">Martin Maechler</a>에게 감사를 드립니다. 
네가지 종류의 메일링 리스트가 있습니다.

     <dl>
<dt><code>R-announce</code><dd><!-- A moderated list for major announcements about the development of R and -->
<!-- the availability of new code. -->
는 R의 개발과 새로운 코드의 유용성에 관한 주요 공지사항들을 위한 (moderated) 리스트입니다.

     <br><dt><code>R-packages</code><dd><!-- A moderated list for announcements on the availability of new or -->
<!-- enhanced contributed packages. -->
는 새롭게 개발되거나 주요기능들이 강화된 패키지들의 유용성에 대한 공지사항들을 위한 (moderated) 리스트입니다.

     <br><dt><code>R-help</code><dd><!-- The `main' R mailing list, for discussion about problems and solutions -->
<!-- using R, announcements (not covered by `R-announce' and `R-packages') -->
<!-- about the development of R and the availability of new code. -->
<!-- enhancements and patches to the source code and documentation of R, -->
<!-- comparison and compatibility with S and @SPLUS{}, and for the posting of -->
<!-- nice examples and benchmarks. -->
은 R을 사용하면서 겪는 문제들과 이들에 대한 해법들을 논의하는 목적으로 사용되는 주된 메일링 리스트입니다. 
R의 개발과 새로운 코드들의 유용성에 관하여 `R-announce'와 `R-packages'에서 다루지 않은 공지사항들을 포함하기도 하며, R의 원시코드와 문서에 대한 강화된 기능 및 패치들에 대한 내용을 다루기도 합니다. 
S와 <span class="sc">S-Plus</span>와의 호환성과 비교에 대한 내용도 있으며, 좋은 예제들과 벤치마크들을 포스팅할 목적으로도 사용합니다.

     <br><dt><code>R-devel</code><dd><!-- This list is for questions and discussion about code development in R. -->
<!-- discussions about the future of R, proposals of new functionality, and -->
<!-- pre-testing of new versions.  It is meant for those who maintain an -->
<!-- active position in the development of R. -->
는 R의 코드개발 (code development)에 관한 질문들과 논의를 위한 리스트입니다. 
R의 미래에 대한 논의, 새로운 기능에 대한 제안, 그리고 새로운 버전에 대한 테스트를 목적으로 이용될 수 있습니다. 
이 리스트는 R의 개발에 적극적인 자세 (active position)을 유지하는 사람을 위한 것입니다. 
</dl>

<p class="noindent"><!-- Please read the @url{http://www.R-project.org/posting-guide.html, -->
<!-- posting guide} @emph{before} sending anything to any mailing list. -->
위에서 나열한 어떠한 종류의 메일링 리스트에 어떤 내용을 보내기 <em>전에 반드시</em> <a href="http://www.R-project.org/posting-guide.html">posting guide(포스팅 가이드)</a>를 읽어보시길 바랍니다.

<!-- Note in particular that R-help is intended to be comprehensible to -->
<!-- people who want to use R to solve problems but who are not necessarily -->
<!-- interested in or knowledgeable about programming.  Questions likely to -->
<!-- prompt discussion unintelligible to non-programmers (e.g., questions -->
<!-- involving C or C++) should go to R-devel. -->
   <p>R-help 는 본래 R을 이용하여 본인의 문제를 해결하고자 하지만 프로그래밍에 대한 지식이 부족한 분들을 위해서 개설되었다는 것을 아셨으면 합니다. 
따라서, 프로그래머가 아닌 사람들이 이해하기 어려운 질문들 (즉, C 혹은 C++ 과 연관된 내용)은 R-devel을 이용하시길 부탁드립니다.

<!-- Convenient access to information on these lists, subscription, and -->
<!-- archives is provided by the web interface at -->
<!-- @url{http://stat.ethz.ch/mailman/listinfo/}.  One can also subscribe -->
<!-- (or unsubscribe) via email, e.g.@: to R-help by sending @samp{subscribe} -->
<!-- (or @samp{unsubscribe}) in the @emph{body} of the message (not in the -->
<!-- subject!) to @email{R-help-request@@lists.R-project.org}. -->
   <p>이러한 메일링 리스트들에 대한 구독 및 보관된 자료들에 대한 열람은 <a href="http://stat.ethz.ch/mailman/listinfo/">http://stat.ethz.ch/mailman/listinfo/</a>을 통하여 손쉽게 하실 수 있습니다. 
이는 <a href="mailto:R-help-request@lists.R-project.org">R-help-request@lists.R-project.org</a>에 이메일을 보낼 때 subject(제목)이 아닌 <em>body(본문)</em>에 &lsquo;<samp><span class="samp">subscribe(구독)</span></samp>&rsquo; (또는 &lsquo;<samp><span class="samp">unsubscribe(구독해지)</span></samp>&rsquo;라고 이메일을 보냄으로서 이용하실 수 있습니다.

<!-- Send email to @email{R-help@@lists.R-project.org} to send a message to -->
<!-- everyone on the R-help mailing list.  Subscription and posting to the -->
<!-- other lists is done analogously, with @samp{R-help} replaced by -->
<!-- @samp{R-announce}, @samp{R-packages}, and @samp{R-devel}, respectively. -->
<!-- Note that the R-announce and R-packages lists are gatewayed into R-help. -->
<!-- Hence, you should subscribe to either of them only in case you are not -->
<!-- subscribed to R-help. -->
   <p>R-help 메일링 리스트를 구독하는 모든 이들에게 메시지를 보내기 위해서는 <a href="mailto:R-help@lists.R-project.org">R-help@lists.R-project.org</a>로 이메일을 보내주세요. 
다른 메일링 리스트들의 구독 및 포스팅 요령은 r-help와 동일합니다. 
&lsquo;<samp><span class="samp">R-help</span></samp>&rsquo; 대신에 &lsquo;<samp><span class="samp">R-announce</span></samp>&rsquo;, &lsquo;<samp><span class="samp">R-packages</span></samp>&rsquo;, &lsquo;<samp><span class="samp">R-devel</span></samp>&rsquo; 이라고만 변경해주시면 됩니다. 
R-announce과 R-packages는 R-help에 이르는 과정이라는 점을 아시길 바랍니다. 
만약 R-help를 구독하고 있지 않다면 둘 중 어느 하나는 구독을 해야합니다.

<!-- It is recommended that you send mail to R-help rather than only to the R -->
<!-- Core developers (who are also subscribed to the list, of course).  This -->
<!-- may save them precious time they can use for constantly improving R, and -->
<!-- will typically also result in much quicker feedback for yourself. -->
   <p><strong>사용자가 R 코어 개발자들에게 개별적으로 이메일을 보내기 보다는 R-help에 메일을 보내주시길 부탁드립니다 (코어 멤버들 역시 메일링을 사용하고 있습니다)</strong>. 
이러한 부탁을 하는 이유는 코어 개발자들이 지속적으로 R을 향상시키는데 있어서 많은 시간을 줄여주기도 할 뿐더러, 질문자가 가장 빠른 시간내에 답변을 받을 수 있기 때문입니다.

<!-- Of course, in the case of bug reports it would be very helpful to have -->
<!-- code which reliably reproduces the problem.  Also, make sure that you -->
<!-- include information on the system and version of R being used.  See -->
<!-- @ref{R Bugs} for more details. -->
   <p>버그리포트를 할 때에는 버그를 정확하게 재구현할 수 있도록 코드를 함께 올려주시면 매우 도움이 됩니다. 
또한, 이러한 버그를 보고할 때 사용자가 어떤 시스템과 어떤 버전의 R 을 사용하는지 알려주시길 부탁드립니다. 
더 자세한 사항들에 대해서는 <a href="#R-Bugs">R Bugs</a>를 살펴보세요.

<!-- See @url{http://www.R-project.org/mail.html} for more information on -->
<!-- the R mailing lists. -->
   <p>R 메일링 리스트들에 대한 좀 더 많은 정보를 알고 싶으시다면 <a href="http://www.R-project.org/mail.html">http://www.R-project.org/mail.html</a>을 살펴보시길 바랍니다.

<!-- The R Core Team can be reached at @email{R-core@@lists.R-project.org} -->
<!-- for comments and reports. -->
   <p>코멘트와 리포트들을 <a href="mailto:R-core@lists.R-project.org">R-core@lists.R-project.org</a>을 통하여 R 코어팀에 보내주실 수 있습니다.

<!-- Many of the R project's mailing lists are also available via -->
<!-- @url{http://gmane.org, Gmane}, from which they can be read with a web -->
<!-- browser, using an NNTP news reader, or via RSS feeds.  See -->
<!-- @uref{http://dir.gmane.org/@/index.php?prefix=gmane.comp.lang.r.}@: for -->
<!-- the available mailing lists, and @uref{http://www.gmane.org/rss.php} for -->
<!-- details on RSS feeds. -->
   <p>R project의 메일링 리스트들의 대부분은 또한 NNTP 뉴스리더를 이용하는 웹브라우저를 이용하여 읽을 수 있는 <a href="http://gmane.org">Gmane</a> 또는 RSS 피드를 통해서 이용할 수 있습니다. 
사용가능한 메일링 리스트들에 대해서는 <a href="http://dir.gmane.org/index.php?prefix=gmane.comp.lang.r.">http://dir.gmane.org/index.php?prefix=gmane.comp.lang.r.</a>에서 확인하시길 바라며, RSS 피드에 대한 더 자세한 사항들은 <a href="http://www.gmane.org/rss.php">http://www.gmane.org/rss.php</a>에서 확인부탁드립니다.

<div class="node">
<a name="What-is-CRAN%3f"></a>
<a name="What-is-CRAN_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Can-I-use-R-for-commercial-purposes_003f">Can I use R for commercial purposes?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-mailing-lists-exist-for-R_003f">What mailing lists exist for R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section What is @acronym{CRAN}? -->
<h3 class="section">2.10 <acronym>CRAN</acronym>이란 무엇인가요?</h3>

<!-- The ``Comprehensive R Archive Network'' (@CRAN{}) is a collection of -->
<!-- sites which carry identical material, consisting of the R -->
<!-- distribution(s), the contributed extensions, documentation for R, and -->
<!-- binaries. -->
<p>&ldquo;Comprehensive R Archive Network&rdquo; (<acronym>CRAN</acronym>)은 R 배포판, 기여된 확장 프로그램들 (즉, 패키지들), R과 관련된 문서들, 그리고 바이너리들로 구성되어 있는 동일한 자료들을 전달하는 사이트들의 모음을 의미합니다.

<!-- The @CRAN{} master site at Wirtschaftsuniversit@"at Wien, Austria, can -->
<!-- be found at the @acronym{URL} -->
   <p>다음의 <acronym>URL</acronym>로부터 오스트리아(Austria) 빈(Wien) Wirtschaftsuniversit&uml;에서 <acronym>CRAN</acronym> 마스터 사이트를 찾을 수 있습니다.

   <blockquote>
<!-- @multitable @columnfractions .45 .30 -->
<!-- @item -->
<a href="http://CRAN.R-project.org/">http://CRAN.R-project.org/</a>
<!-- @tab (Austria) -->
<!-- @end multitable -->
</blockquote>

<p class="noindent"><!-- (which is the same as @url{http://cran.at.R-project.org/}) -->
<!-- Daily mirrors are available at @acronym{URL}s including -->
데일리 미러(daily mirrors)들은 <acronym>URL</acronym>에서 찾을 수 있습니다.

   <blockquote>
   <p><table summary=""><tr align="left"><td valign="top" width="45%"><a href="http://cran.at.R-project.org/">http://cran.at.R-project.org/</a>
</td><td valign="top" width="40%">(WU Wien, Austria)
<br></td></tr><tr align="left"><td valign="top" width="45%"><a href="http://cran.au.R-project.org/">http://cran.au.R-project.org/</a>
</td><td valign="top" width="40%">(PlanetMirror, Australia)
<br></td></tr><tr align="left"><td valign="top" width="45%"><a href="http://cran.br.R-project.org/">http://cran.br.R-project.org/</a>
</td><td valign="top" width="40%">(Universidade Federal do Paran&aacute;, Brazil)
<br></td></tr><tr align="left"><td valign="top" width="45%"><a href="http://cran.ch.R-project.org/">http://cran.ch.R-project.org/</a>
</td><td valign="top" width="40%">(ETH Z&uuml;rich, Switzerland)
<br></td></tr><tr align="left"><td valign="top" width="45%"><a href="http://cran.dk.R-project.org/">http://cran.dk.R-project.org/</a>
</td><td valign="top" width="40%">(SunSITE, Denmark)
<br></td></tr><tr align="left"><td valign="top" width="45%"><a href="http://cran.es.R-project.org/">http://cran.es.R-project.org/</a>
</td><td valign="top" width="40%">(Spanish National Research Network, Madrid, Spain)
<br></td></tr><tr align="left"><td valign="top" width="45%"><a href="http://cran.fr.R-project.org/">http://cran.fr.R-project.org/</a>
</td><td valign="top" width="40%">(INRA, Toulouse, France)
<!-- @item @url{http://cran.hu.R-project.org/} -->
<!-- @tab (Semmelweis U, Hungary) -->
<br></td></tr><tr align="left"><td valign="top" width="45%"><a href="http://cran.pt.R-project.org/">http://cran.pt.R-project.org/</a>
</td><td valign="top" width="40%">(Universidade do Porto, Portugal)
<br></td></tr><tr align="left"><td valign="top" width="45%"><a href="http://cran.uk.R-project.org/">http://cran.uk.R-project.org/</a>
</td><td valign="top" width="40%">(U of Bristol, United Kingdom)
<!-- @item @url{http://cran.us.R-project.org/} -->
<!-- @tab (pair Networks, USA) -->
<br></td></tr><tr align="left"><td valign="top" width="45%"><a href="http://cran.za.R-project.org/">http://cran.za.R-project.org/</a>
</td><td valign="top" width="40%">(Rhodes U, South Africa)
   <br></td></tr></table>
</blockquote>

<p class="noindent"><!-- See @url{http://CRAN.R-project.org/mirrors.html} for a complete list of -->
<!-- mirrors.  Please use the @CRAN{} site closest to you to reduce network -->
<!-- load. -->
미러들의 모든 목록에 대해서는 <a href="http://CRAN.R-project.org/mirrors.html">http://CRAN.R-project.org/mirrors.html</a> 를 참고해주세요. 
네트워크 부담을 줄이기 위해서 현재 접속하고 계신 위치에서 가장 가까운 위치에 있는 <acronym>CRAN</acronym> 사이트를 이용해주세요.

<!-- From @CRAN{}, you can obtain the latest official release of R, daily -->
<!-- snapshots of R (copies of the current source trees), as gzipped and -->
<!-- bzipped tar files, a wealth of additional contributed code, as well as -->
<!-- prebuilt binaries for various operating systems (Linux, Mac OS Classic, -->
<!-- Mac OS X, and MS Windows).  @CRAN{} also provides access to -->
<!-- documentation on R, existing mailing lists and the R Bug Tracking -->
<!-- system. -->
   <p><acronym>CRAN</acronym>으로부터 R의 가장 최신 공식 릴리즈, R의 데일리 스냅샷 (현재 소스트리의 복사본), gzip과 bzip으로 압축된 tar 파일들, 추가적으로 기여된 코드들, Linux, Mac OS Classic, Mac OS X, 그리고 MS Windows와 같은 다양한 운영체제를 위하여 미리 빌드된 바이너리들을 얻을 수 있습니다. 
<acronym>CRAN</acronym>은 또한 R 문서들, 메일링 리스트들, 그리고 버그트랙킹 시스템에 접근할 수 있도록 해줍니다.

<!-- To ``submit'' to @CRAN{}, check that your submission meets the -->
<!-- @url{http://CRAN.R-project.org/web/packages/policies.html, CRAN -->
<!-- Repository Policy}, upload to @url{ftp://CRAN.R-project.org/incoming/} -->
<!-- and send an email to @email{CRAN@@R-project.org}.  Note that @CRAN{} -->
<!-- generally does not accept submissions of precompiled binaries due to -->
<!-- security reasons.  In particular, binary packages for Windows and Mac OS -->
<!-- X are provided by the respective binary package maintainers. -->
   <p><acronym>CRAN</acronym>에 &ldquo;submit&rdquo;(제출)하기 위해서는 사용자의 제출(submission)이 <a href="http://CRAN.R-project.org/web/packages/policies.html">CRAN Repository Policy</a>에 부합하는지 먼저 확인을 해야 합니다. 
그리고, <a href="ftp://CRAN.R-project.org/incoming/">ftp://CRAN.R-project.org/incoming/</a>에 내용을 올려 놓은 후 <a href="mailto:CRAN@R-project.org">CRAN@R-project.org</a>로 이메일을 보내주셔야 합니다. 
<acronym>CRAN</acronym>은 일반적으로 보안적인 문제로 인하여 미리 컴파일된 바이너리를 수용하지 않습니다. 
특히, Windows와 Mac OS X를 위한 바이너리 패키지들은 바이너리 패키지 메인테이너들에 의해서 제공됩니다.

   <blockquote>
<b>Note:</b> <!-- It is very important that you indicate the copyright (license) -->
<!-- information (@acronym{GPL-2}, @acronym{GPL-3}, @acronym{BSD}, Artistic, -->
<!-- @dots{}) in your submission. -->
카피라이트 (라이센스) 정보 (<acronym>GPL-2</acronym>, <acronym>GPL-3</acronym>, <acronym>BSD</acronym>, Artistic, <small class="dots">...</small>)를 함께 제공하는 것은 매우 중요합니다. 
</blockquote>

<!-- Please always use the @acronym{URL} of the master site when referring to -->
<!-- @CRAN{}. -->
   <p><acronym>CRAN</acronym>을 가리킬 때에는 꼭 마스터 사이트의 <acronym>URL</acronym>을 사용하시길 바랍니다.

<div class="node">
<a name="Can-I-use-R-for-commercial-purposes%3f"></a>
<a name="Can-I-use-R-for-commercial-purposes_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-is-R-named-R_003f">Why is R named R?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-CRAN_003f">What is CRAN?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section Can I use R for commercial purposes? -->
<h3 class="section">2.11 R을 상업적 용도로 사용할 수 있나요?</h3>

<!-- R is released under the -->
<!-- @url{http://www.gnu.org/licenses/old-licenses/gpl-2.0.html,, -->
<!-- @acronym{GNU} General Public License (@acronym{GPL}), version 2}.  If -->
<!-- you have any questions regarding the legality of using R in any -->
<!-- particular situation you should bring it up with your legal counsel.  We -->
<!-- are in no position to offer legal advice. -->
<p>R은 <a href="http://www.gnu.org/licenses/old-licenses/gpl-2.0.html"><acronym>GNU</acronym> General Public License (<acronym>GPL</acronym>)</a> version 2하에 배포됩니다. 
만약, 어떤 특정한 상황에서 R을 사용하는 것이 합법적인가에 대한 의구심이 생길 경우, 반드시 전문 법률상담가와 상의하시길 바랍니다. 
우리는 법적 조언을 줄 수 있는 그 어떠한 위치에 있지 않습니다.

<!-- It is the opinion of the R Core Team that one can use R for commercial -->
<!-- purposes (e.g., in business or in consulting).  The @acronym{GPL}, like -->
<!-- all Open Source licenses, permits all and any use of the package.  It -->
<!-- only restricts distribution of R or of other programs containing code -->
<!-- from R.  This is made clear in clause 6 (``No Discrimination Against -->
<!-- Fields of Endeavor'') of the -->
<!-- @url{http://www.opensource.org/docs/definition.html, Open Source -->
<!-- Definition}: -->
   <p>R Core Team은 R 을 상업적 목적 (즉, 비지니스 혹은 컨설팅)으로도 사용할 수 있다고 생각합니다. 
모든 오픈소스의 라이센스들과 같이 <acronym>GPL</acronym>은 패키지들의 모든 그리고 어떠한 (all and any) 용도로 사용되는 것을 허용합니다. 
이것은 오로지 R 혹은 R 코드의 일부분을 포함하는 프로그램의 배포를 제한하는 것입니다. 
<a href="http://www.opensource.org/docs/definition.html">Open Source Definition</a>의 제 6항 (clause 6) &ldquo;No Discrimination Against Fields of Endeavor&rdquo;에서 명확하게 나타납니다.

   <blockquote>
The license must not restrict anyone from making use of the program in a
specific field of endeavor.  For example, it may not restrict the
program from being used in a business, or from being used for genetic
research. 
</blockquote>

<p class="noindent"><!-- It is also explicitly stated in clause 0 of the GPL, which says in part -->
이는 또한 GPL 제 0항 (clause 0)에서도 아래와 같이 (일부분만) 언급되어 있습니다.

   <blockquote>
Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of running
the Program is not restricted, and the output from the Program is
covered only if its contents constitute a work based on the Program. 
</blockquote>

<!-- Most add-on packages, including all recommended ones, also explicitly -->
<!-- allow commercial use in this way.  A few packages are restricted to -->
<!-- ``non-commercial use''; you should contact the author to clarify whether -->
<!-- these may be used or seek the advice of your legal counsel. -->
   <p>모든 추천(recommended) 패키지들을 포함하여 대부분의 애드온(add-on) 패키지들은 이러한 방법으로서 상업적으로도 이용이 될 수 있음을 명시하고 있습니다. 
몇개의 패키지들은 &ldquo;non-commercial use&rdquo;(비상업용적 용도)로서 제한됩니다. 
이 경우 사용자는 반드시 저작권자에게 상업적 용도로의 활용여부를 문의하거나 법률상담가로부터의 조언을 찾아야 합니다.

<!-- None of the discussion in this section constitutes legal advice.  The R -->
<!-- Core Team does not provide legal advice under any circumstances. -->
   <p>이 섹션에 언급된 모든 논의는 법적조언이 아닙니다. 
R Core Team은 어떠한 경우에도 법적조언을 제공하지 않습니다.

<div class="node">
<a name="Why-is-R-named-R%3f"></a>
<a name="Why-is-R-named-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-the-R-Foundation_003f">What is the R Foundation?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Can-I-use-R-for-commercial-purposes_003f">Can I use R for commercial purposes?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section Why is R named R? -->
<h3 class="section">2.12 왜 R 이라고 이름을 붙였나요?</h3>

<!-- The name is partly based on the (first) names of the first two R authors -->
<!-- (Robert Gentleman and Ross Ihaka), and partly a play on the name of the -->
<!-- Bell Labs language `S' (@pxref{What is S?}). -->
<p>R이라는 이름은 R을 최초로 개발한 두 개발자인 Robert Gentleman과 Ross Ihaka의 이름에서 기인하기도 하며, 동시에 Bell 연구소의 'S' 라는 언어에서 영감을 받기도 하였습니다 (see <a href="#What-is-S_003f">What is S?</a> 섹션을 참고하세요).

<!-- At the time the name was coined no one expected that the software would -->
<!-- get used outside of Auckland, so it seemed ok to make a joke of it. -->
<div class="node">
<a name="What-is-the-R-Foundation%3f"></a>
<a name="What-is-the-R-Foundation_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-R_002dForge_003f">What is R-Forge?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-is-R-named-R_003f">Why is R named R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<!-- @section What is the R Foundation? -->
<h3 class="section">2.13 R Foundation은 무엇인가요?</h3>

<!-- The R Foundation is a not for profit organization working in the public -->
<!-- interest.  It was founded by the members of the R Core Team in order to -->
<!-- provide support for the R project and other innovations in statistical -->
<!-- computing, provide a reference point for individuals, institutions or -->
<!-- commercial enterprises that want to support or interact with the R -->
<!-- development community, and to hold and administer the copyright of R -->
<!-- software and documentation.  See -->
<!-- @url{http://www.R-project.org/foundation/} for more information. -->
<p>The R Foundation은 공익(public interest)을 위한 비영리단체(not for profit organization)입니다. 
이 단체는 R project와 통계계산 (statistical computing)에 연관된 기술들을 지원하고, R 개발 커뮤니티(development community)를 지원하거나 함께 일하고 싶어하는 개인, 기관 및 영리추구의 사업체(commercial enterprises)들에게 기준(reference point)을 제공하며, R 소프트웨어와 문서에 대한 저작권을 관리 및 유지하기 위하여 R Core Team 멤버들에 의하여 설립되었습니다. 
<a href="http://www.R-project.org/foundation/">http://www.R-project.org/foundation/</a>에서 더 많은 정보를 찾을 수 있습니다.

<div class="node">
<a name="What-is-R-Forge%3f"></a>
<a name="What-is-R_002dForge_003f"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-the-R-Foundation_003f">What is the R Foundation?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Basics">R Basics</a>

</div>

<h3 class="section">2.14 What is R-Forge?</h3>

<!-- R-Forge (@url{http://R-Forge.R-project.org/}) offers a central platform -->
<!-- for the development of R packages, R-related software and further -->
<!-- projects.  It is based on @url{http://www.gforge.org/, GForge} offering -->
<!-- easy access to the best in SVN, daily built and checked packages, -->
<!-- mailing lists, bug tracking, message boards/forums, site hosting, -->
<!-- permanent file archival, full backups, and total web-based -->
<!-- administration.  For more information, see the R-Forge web page and -->
<!-- Stefan Theu@ss{}l and Achim Zeileis (2009), ``Collaborative software -->
<!-- development using R-Forge'', @url{http://journal.R-project.org/, , -->
<!-- @emph{The R Journal}}, @strong{1}(1):9-14. -->
<p>R-Forge (<a href="http://R-Forge.R-project.org/">http://R-Forge.R-project.org/</a>)는 R 패키지, R 관련 소프트웨어, 그리고 다양한 프로젝트들의 개발을 위한 중요한 기반(central platform)을 제공합니다. 
SVN에 최적화된 손쉬운 접근, 매일 빌드되고 체크되는 패키지들, 메일링 리스트, 버그 트래킹, 메시지 보드/포럼공간, 사이트 호스팅, 영구파일 저장공간, 안정적인 백업, 그리고 웹기반의 관리 기능등을 제공하는 <a href="http://www.gforge.org/">GForge</a>를 기초로 운영됩니다. 
R-Forge 웹페이지와 Stefan Theu&szlig;l and Achim Zeileis (2009), &ldquo;Collaborative software development using R-Forge&rdquo;, <a href="http://journal.R-project.org/"><em>The R Journal</em></a>, <strong>1</strong>(1):9&ndash;14 로부터 더 많은 내용을 얻을 수 있습니다.

<div class="node">
<a name="R-and-S"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#R-Web-Interfaces">R Web Interfaces</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Basics">R Basics</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter R and S -->
<h2 class="chapter">3 R과 S</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-S_003f">What is S?</a>
<li><a accesskey="2" href="#What-is-S_002dPLUS_003f">What is S-PLUS?</a>
<li><a accesskey="3" href="#What-are-the-differences-between-R-and-S_003f">What are the differences between R and S?</a>
<li><a accesskey="4" href="#Is-there-anything-R-can-do-that-S_002dPLUS-cannot_003f">Is there anything R can do that S-PLUS cannot?</a>
<li><a accesskey="5" href="#What-is-R_002dplus_003f">What is R-plus?</a>
</ul>

<div class="node">
<a name="What-is-S%3f"></a>
<a name="What-is-S_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-S_002dPLUS_003f">What is S-PLUS?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-and-S">R and S</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-and-S">R and S</a>

</div>

<!-- @section What is S? -->
<h3 class="section">3.1 S란 무엇인가요?</h3>

<!-- S is a very high level language and an environment for data analysis and -->
<!-- graphics.  In 1998, the Association for Computing Machinery -->
<!-- (@acronym{ACM}) presented its Software System Award to John M. Chambers, -->
<!-- the principal designer of S, for -->
<p>S는 데이터 분석과 그래픽스를 위한 하이레벨 언어 (high level language)이며 환경입니다. 
1998년에 Association for Computing Machinery (<acronym>ACM</acronym>)는 1998년에 S언어의 주요설계자인 John M. Chambers에게 아래와 같이 치하하며 Software System Award를 수여하였습니다.

   <blockquote>
the S system, which has forever altered the way people analyze,
visualize, and manipulate data <small class="dots">...</small>

   <p>S is an elegant, widely accepted, and enduring software system, with
conceptual integrity, thanks to the insight, taste, and effort of John
Chambers. 
</blockquote>

<!-- The evolution of the S language is characterized by four books by John -->
<!-- Chambers and coauthors, which are also the primary references for S. -->
   <p>S 언어의 발전은 John Chambers와 공동저자들에 의하여 쓰여진 네권의 책들에 잘 설명되어 있습니다. 
이들은 또한 S에 대한 주요 참고문헌이기도 합니다.

     <ul>
<li>Richard A. Becker and John M. Chambers (1984), &ldquo;S.  An Interactive
Environment for Data Analysis and Graphics,&rdquo; Monterey: Wadsworth and
Brooks/Cole.

     <!-- This is also referred to as the ``@emph{Brown Book}'', and of historical -->
     <!-- interest only. -->
     <p>이 책은 &ldquo;<em>Brown Book</em>&rdquo;(브라운 북)이라고도 알려져 있으며, 역사적 관심으로서입니다.

     <li>Richard A. Becker, John M. Chambers and Allan R. Wilks (1988), &ldquo;The New
S Language,&rdquo; London: Chapman &amp; Hall.

     <!-- This book is often called the ``@emph{Blue Book}'', and introduced what -->
     <!-- is now known as S version 2. -->
     <p>이 책은 &ldquo;<em>Blue Book</em>&rdquo;(블루 북)이라고도 하며, S 버전 2로 알려진 것이 무엇인지를 소개합니다.

     <li>John M. Chambers and Trevor J. Hastie (1992), &ldquo;Statistical Models in
S,&rdquo;  London: Chapman &amp; Hall.

     <!-- This is also called the ``@emph{White Book}'', and introduced S version -->
     <!-- 3, which added structures to facilitate statistical modeling in S. -->
     <p>이 책은 <em>White Book</em>라고도 하며, S에서 통계모델링(statistical modeling)의 기능을 수행하기 위한 구조들이 추가되어진 S 버전 3로 알려진 것을 소개합니다.

     <li>John M. Chambers (1998), &ldquo;Programming with Data,&rdquo; New York: Springer,
ISBN 0-387-98503-4
(<a href="http://cm.bell-labs.com/cm/ms/departments/sia/Sbook/">http://cm.bell-labs.com/cm/ms/departments/sia/Sbook/</a>).

     <!-- This ``@emph{Green Book}'' describes version 4 of S, a major revision of -->
     <!-- S designed by John Chambers to improve its usefulness at every stage of -->
     <!-- the programming process. -->
     <p>&ldquo;<em>Green Book</em>&rdquo;(그린 북)은 프로그래밍 프로세스의 매 단계마다 유용성을 향상시킬 수 있도록 John Chambers에 의하여 설계된 S의 주요수정사항들이 있는 S 버전 4를 설명합니다. 
</ul>

<!-- See @url{http://cm.bell-labs.com/cm/ms/departments/sia/S/history.html} -->
<!-- for further information on ``Stages in the Evolution of S''. -->
   <p>더 자세한 내용은 <a href="http://cm.bell-labs.com/cm/ms/departments/sia/S/history.html">http://cm.bell-labs.com/cm/ms/departments/sia/S/history.html</a>에서 &ldquo;Stages in the Evolution of S&rdquo;를 살펴보시길 바랍니다.

<!-- There is a huge amount of user-contributed code for S, available at the -->
<!-- @url{http://lib.stat.cmu.edu/S/, S Repository} at @acronym{CMU}. -->
   <p><acronym>CMU</acronym>에 있는 <a href="http://lib.stat.cmu.edu/S/">S Repository</a>에 가시면 사용자들이 제공한 매우 방대한 양의 S코드들을 있습니다.

<!-- The @url{http://lib.stat.cmu.edu/S/faq, ``Frequently Asked Questions -->
<!-- about S''} contains further information about S, but is not -->
<!-- up-to-date. -->
   <p><a href="http://lib.stat.cmu.edu/S/faq">&ldquo;Frequently Asked Questions about S&rdquo;</a>페이지는 S에 대한 더 많은 정보를 담고 있으나, 이는 최신의 정보가 아닙니다.

<div class="node">
<a name="What-is-S-PLUS%3f"></a>
<a name="What-is-S_002dPLUS_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-are-the-differences-between-R-and-S_003f">What are the differences between R and S?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-S_003f">What is S?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-and-S">R and S</a>

</div>

<!-- @section What is @sc{S-Plus}? -->
<h3 class="section">3.2 <span class="sc">S-Plus</span>란 무엇인가요?</h3>

<!-- @SPLUS{} is a value-added version of S sold by -->
<!-- @url{http://www.insightful.com, Insightful Corporation}, which in 2008 -->
<!-- was acquired by @url{http://www.tibco.com/, TIBCO Software Inc}.  See -->
<!-- the @url{http://www.insightful.com/products/splus/, Insightful @SPLUS{} -->
<!-- page} and the -->
<!-- @url{http://spotfire.tibco.com/Products/S-Plus-Overview.aspx, , TIBCO -->
<!-- Spotfire S+ Products page} for further information. -->
<p><span class="sc">S-Plus</span>는 <a href="http://www.tibco.com/">TIBCO Software Inc</a>에서 2008년에 인수한 <a href="http://www.insightful.com">Insightful Corporation</a>에서 판매하는 S의 부가가치된(value-added) 버전입니다 (즉, 상업용입니다). 
더 많은 정보를 원하시면 <a href="http://www.insightful.com/products/splus/">Insightful <span class="sc">S-Plus</span> page</a>페이지와 <a href="http://spotfire.tibco.com/Products/S-Plus-Overview.aspx">TIBCO Spotfire S+ Products page</a>제품 페이지를 참조하세요.

<div class="node">
<a name="What-are-the-differences-between-R-and-S%3f"></a>
<a name="What-are-the-differences-between-R-and-S_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Is-there-anything-R-can-do-that-S_002dPLUS-cannot_003f">Is there anything R can do that S-PLUS cannot?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-S_002dPLUS_003f">What is S-PLUS?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-and-S">R and S</a>

</div>

<!-- @section What are the differences between R and S? -->
<h3 class="section">3.3 R과 S의 다른 점은 무엇입니까?</h3>

<!-- We can regard S as a language with three current implementations or -->
<!-- ``engines'', the ``old S engine'' (S version 3; @SPLUS{} 3.x and 4.x), -->
<!-- the ``new S engine'' (S version 4; @SPLUS{} 5.x and above), and R. -->
<!-- Given this understanding, asking for ``the differences between R and S'' -->
<!-- really amounts to asking for the specifics of the R implementation of -->
<!-- the S language, i.e., the difference between the R and S @emph{engines}. -->
<p>S는 현재 세가지 종류의 구현체 또는 &ldquo;engines&rdquo;(엔진)을 가진 언어로서 여길 수 있습니다. 
이는 &ldquo;old S engine&rdquo; (S version 3; S-Plus 3.x 그리고 4.x), &ldquo;new S engine&rdquo; (S version 4; S-Plus 5.x 혹은 그 이후의 버전), 그리고 R입니다. 
이러한 내용을 바탕으로 보면, &ldquo;R과 S 사이의 다른점&rdquo;에 대한 질문은 S언어를 이용하여 구현된 R의 세부사항들을 묻는것과 같습니다. 
즉, R의 엔진과 S의 엔진 사이에 다른 점의 다른 점입니다.

<!-- For the remainder of this section, ``S'' refers to the S engines and not -->
<!-- the S language. -->
   <p>이 섹션의 나머지 부분에서 &ldquo;S&rdquo;는 S 엔진(engine)을 지칭하며 S 언어(language)를 의미하는 것이 아님을 기억하시길 바랍니다.

<ul class="menu">
<li><a accesskey="1" href="#Lexical-scoping">Lexical scoping</a>
<li><a accesskey="2" href="#Models">Models</a>
<li><a accesskey="3" href="#Others">Others</a>
</ul>

<div class="node">
<a name="Lexical-scoping"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Models">Models</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-are-the-differences-between-R-and-S_003f">What are the differences between R and S?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#What-are-the-differences-between-R-and-S_003f">What are the differences between R and S?</a>

</div>

<h4 class="subsection">3.3.1 Lexical scoping</h4>

<!-- Contrary to other implementations of the S language, R has adopted an -->
<!-- evaluation model in which nested function definitions are lexically -->
<!-- scoped.  This is analogous to the evaluation model in Scheme. -->
<p>S언어를 이용한 다른 구현체들과는 다르게 R은 내포된 함수 정의들(nested function definitions)이 렉시컬 스코프(lexically scoped)된 평가모델(evaluation model)을 사용합니다. 
이것은 Scheme의 평가모델과 유사합니다.

<!-- This difference becomes manifest when @emph{free} variables occur in a -->
<!-- function.  Free variables are those which are neither formal parameters -->
<!-- (occurring in the argument list of the function) nor local variables -->
<!-- (created by assigning to them in the body of the function).  In S, the -->
<!-- values of free variables are determined by a set of global variables -->
<!-- (similar to C, there is only local and global scope).  In R, they are -->
<!-- determined by the environment in which the function was created. -->
   <p>이 차이점은 함수(function)내에서 <em>free</em>(자유)변수들이 발생할때 분명해집니다. 
자유변수들은 함수의 인자목록에서 사용된 형식인자(formal argument)도 아니고, 함수의 본체에서 이들에 할당함으로서 생성된 지역변수(local variables)도 아닙니다. 
S에서는 자유변수들은 C와 유사하게 전역변수(global variable)들의 묶음에 의해서 결정되어 집니다. 
(C에서는 지역적 범위와 전역적 범위만이 있습니다). 
R에서 이들은 함수가 생성되어진 환경(environment)에 의해서 결정되어집니다.

<!-- Consider the following function: -->
   <p>다음의 함수를 보십시오:

<pre class="example">     cube &lt;- function(n) {
       sq &lt;- function() n * n
       n * sq()
     }
</pre>
   <!-- Under S, @code{sq()} does not ``know'' about the variable @code{n} -->
<!-- unless it is defined globally: -->
   <p>S에서, <code>sq()</code>는 변수 <code>n</code>이 전역적으로 정의되지 않는 이상은 이에 대해서 알지 못합니다:

<pre class="example">     S&gt; cube(2)
     Error in sq():  Object "n" not found
     Dumped
     S&gt; n &lt;- 3
     S&gt; cube(2)
     [1] 18
</pre>
   <!-- In R, the ``environment'' created when @code{cube()} was invoked is -->
<!-- also looked in: -->
   <p>R에서는 <code>cube()</code>가 실행되었을때 생성된 &ldquo;environment&rdquo;(환경)이 살펴지게 됩니다:

<pre class="example">     R&gt; cube(2)
     [1] 8
</pre>
   <!-- The following more `realistic' example illustrating the differences in -->
<!-- scoping is due to @email{tlumley@@u.washington.edu, Thomas Lumley}. -->
<!-- The function -->
<!-- @example -->
<!-- jackknife.lm <- function(lmobj) @{ -->
<!-- n <- length(resid(lmobj)) -->
<!-- jval <- sapply(1:n, function(i) coef(update(lmobj, subset = -i))) -->
<!-- (n - 1) * (n - 1) * var(jval) / n -->
<!-- @} -->
<!-- @end example -->
<!-- @noindent -->
<!-- does something useful in R, but does not work in S.  In order to make it -->
<!-- work in S you need to explicitly pass the linear model object into the -->
<!-- function nested in @code{apply()}.  If you don't and you are lucky you -->
<!-- will get @samp{Error: Object "lmobj" not found}.  If you are unlucky -->
<!-- enough to have a linear model called @code{lmobj} in your global -->
<!-- environment you will get the wrong answer with no warning. -->
<!-- The following version works in S. -->
<!-- @example -->
<!-- jackknife.S.lm <- function(lmobj) @{ -->
<!-- n <- length(resid(lmobj)) -->
<!-- jval <- sapply(1:n, -->
<!-- function(i, lmobj) coef(update(lmobj, subset = -i)), -->
<!-- lmobj = lmobj) -->
<!-- (n - 1) * (n - 1) * var(jval) / n -->
<!-- @} -->
<!-- @end example -->
<!-- (The S version was written independently by Thomas and at least three of -->
<!-- his fellow students over the past couple of years, causing literally -->
<!-- hours of confusion on each occasion.) -->
<!-- As a more ``interesting'' real-world problem, suppose you want to write -->
<!-- a function which returns the density function of the @math{r}-th order -->
<!-- statistic from a sample of size @math{n} from a (continuous) -->
<!-- distribution.  For simplicity, we shall use both the cdf and pdf of the -->
<!-- distribution as explicit arguments.  (Example compiled from various -->
<!-- postings by Luke Tierney.) -->
   <p>실제로 다루어 볼 수 있는 흥미로운 문제로서, (연속)분포에서 샘플의 크기 n으로부터 r 번째의 order statistic (순서통계량)의 밀도함수를 구하는 함수를 작성해본다고 가정해 봅니다. 
단순한 방법으로 우리는 분포의 cdf와 pdf 모두를 explicit arguments(명시적 인자들)로 사용해야 합니다. 
(이는 Luke Tierney에 의하여 작성된 다양한 포스팅으로부터 뽑아낸 예제입니다).

<!-- The @SPLUS{} documentation for @code{call()} basically suggests the -->
<!-- following: -->
   <p><code>call()</code>에 대한 <span class="sc">S-Plus</span> 문서는 기본적으로 다음과 같이 하도록 안내합니다.

<pre class="example">     dorder &lt;- function(n, r, pfun, dfun) {
       f &lt;- function(x) NULL
       con &lt;- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
       PF &lt;- call(substitute(pfun), as.name("x"))
       DF &lt;- call(substitute(dfun), as.name("x"))
       f[[length(f)]] &lt;-
         call("*", con,
              call("*", call("^", PF, r - 1),
                   call("*", call("^", call("-", 1, PF), n - r),
                        DF)))
       f
     }
</pre>
   <!-- @noindent Rather tricky, isn't it?  The code uses the fact that in S, -->
<!-- functions are just lists of special mode with the function body as the -->
<!-- last argument, and hence does not work in R (one could make the idea -->
<!-- work, though). -->
   <p>다소 혼란스럽지 않나요? 
이 코드는 S에서는 함수들이 마지막 인자와 같이 함수의 본체의 특정한 방식(mode)의 목록들이라는 사실을 이용하고 있습니다. 
이러한 방식은 R에서 작동하지 않습니다 (누군가는 여기에서 사용된 아이디어를 성공적으로 구현할 수도 있을것입니다).

<!-- A version which makes heavy use of @code{substitute()} and seems to work -->
<!-- under both S and R is -->
   <p><code>substitute()</code>의 사용빈도가 매우 높으며 S와 R 모두 작동하는 것처럼 보이는 버전은 다음과 같습니다.

<pre class="example">     dorder &lt;- function(n, r, pfun, dfun) {
       con &lt;- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
       eval(substitute(function(x) K * PF(x)^a * (1 - PF(x))^b * DF(x),
                       list(PF = substitute(pfun), DF = substitute(dfun),
                            a = r - 1, b = n - r, K = con)))
     }
</pre>
   <!-- @noindent -->
<!-- (the @code{eval()} is not needed in S). -->
   <p>(S에서는 <code>eval()</code>이 필요하지 않습니다).

<!-- However, in R there is a much easier solution: -->
   <p>그러나, R에서는 다음과 같은 더욱 쉬운 해결책이 있습니다:

<pre class="example">     dorder &lt;- function(n, r, pfun, dfun) {
       con &lt;- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
       function(x) {
         con * pfun(x)^(r - 1) * (1 - pfun(x))^(n - r) * dfun(x)
       }
     }
</pre>
   <p class="noindent"><!-- This seems to be the ``natural'' implementation, and it works because -->
<!-- the free variables in the returned function can be looked up in the -->
<!-- defining environment (this is lexical scope). -->
이것은 &ldquo;natural(자연스러운)&rdquo; 구현 같이 보이며, 귀환된 함수(returned function)내에 있는 자유변수(free variable)들이 환경을 규정한 내부에서 찾아질 수 있기 때문에 잘 실행됩니다 (이것을 렉시컬 스코프(lexical scope)라고 합니다).

<!-- Note that what you really need is the function @emph{closure}, i.e., the -->
<!-- body along with all variable bindings needed for evaluating it.  Since -->
<!-- in the above version, the free variables in the value function are not -->
<!-- modified, you can actually use it in S as well if you abstract out the -->
<!-- closure operation into a function @code{MC()} (for ``make closure''): -->
   <p>꼭 알아야 할 것은 함수 <em>closure</em>라는 것입니다. 
즉, 함수를 평가하기 위하여 필요한 모든 variable binding(변수 바인딩)들 있는 본체를 의미합니다. 
위의 버전의 경우, 값을 지닌 함수내의 자유변수들은 변경되지 않았기 때문에 S에서 이를 사용할 수 있을 뿐아니라, 만약 클로저 작동 (closure operation)을 함수 <code>MC()</code>로 이끌어 내고자 한다면 (클로져를 만들기 위해서) 다음과 같이 할 수 있습니다.

<pre class="example">     dorder &lt;- function(n, r, pfun, dfun) {
       con &lt;- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
       MC(function(x) {
            con * pfun(x)^(r - 1) * (1 - pfun(x))^(n - r) * dfun(x)
          },
          list(con = con, pfun = pfun, dfun = dfun, r = r, n = n))
     }
</pre>
   <!-- Given the appropriate definitions of the closure operator, this works in -->
<!-- both R and S, and is much ``cleaner'' than a substitute/eval solution -->
<!-- (or one which overrules the default scoping rules by using explicit -->
<!-- access to evaluation frames, as is of course possible in both R and S). -->
   <p>적절한 클로져 연산자(closure operator)의 정의가 주어진다면 이것은 R과 S에서 모두 작동하며 substitute/eval을 활용한 것 (혹은 기본 스코핑 규칙(default scoping rule)을 평가 프레임(evaluation frame)에 대한 명시적 접근(explicit access)을 이용하여 무효화 하는 해결책, 물론 R과 S 모두 가능한) 보다 말끔한 해결책이라고 할 수 있습니다.

<!-- For R, @code{MC()} simply is -->
   <p>R에서는 <code>MC()</code>는 단순히 아래와 같습니다.

<pre class="example">     MC &lt;- function(f, env) f
</pre>
   <!-- @noindent (lexical scope!), a version for S is -->
<p class="noindent">(렉시컬 스코프입니다!), S를 위한 버전은 다음과 같습니다.

<pre class="example">     MC &lt;- function(f, env = NULL) {
       env &lt;- as.list(env)
       if (mode(f) != "function")
         stop(paste("not a function:", f))
       if (length(env) &gt; 0 &amp;&amp; any(names(env) == ""))
         stop(paste("not all arguments are named:", env))
       fargs &lt;- if(length(f) &gt; 1) f[1:(length(f) - 1)] else NULL
       fargs &lt;- c(fargs, env)
       if (any(duplicated(names(fargs))))
         stop(paste("duplicated arguments:", paste(names(fargs)),
              collapse = ", "))
       fbody &lt;- f[length(f)]
       cf &lt;- c(fargs, fbody)
       mode(cf) &lt;- "function"
       return(cf)
     }
</pre>
   <!-- Similarly, most optimization (or zero-finding) routines need some -->
<!-- arguments to be optimized over and have other parameters that depend on -->
<!-- the data but are fixed with respect to optimization.  With R scoping -->
<!-- rules, this is a trivial problem; simply make up the function with the -->
<!-- required definitions in the same environment and scoping takes care of -->
<!-- it.  With S, one solution is to add an extra parameter to the function -->
<!-- and to the optimizer to pass in these extras, which however can only -->
<!-- work if the optimizer supports this. -->
   <p>유사하게 대부분의 최적화 (optimization 또는 zero-finding) 루틴(rountine)들은 최적화 되어야 할 일부 인자들이 필요하며, 데이터에 의존하지만 최적화와 관련해서는 영향을 미치지 않는 다른 인자들을 가집니다. 
이것은 R 스코핑 규칙(scoping rules)을 이용하면 단순하게 같은 환경내에서 필요한 정의들만을 가지고 함수를 만들게 되면 나머지는 스코핑이 알아서 처리하게 되므로 매우 간단한 문제입니다. 
S를 이용한 한가지 방법은 별도의 인자(extra parameter)를 함수와 이러한 별도의 인자들이 넘겨지게 될 옵티마이저(optimizer)에 추가하는 것이지만, 이는 오로지 옵티마이저가 지원될 경우에만 가능합니다.

<!-- Nested lexically scoped functions allow using function closures and -->
<!-- maintaining local state.  A simple example (taken from Abelson and -->
<!-- Sussman) is obtained by typing @kbd{demo("scoping")} at the R prompt. -->
<!-- Further information is provided in the standard R reference ``R: A -->
<!-- Language for Data Analysis and Graphics'' (@pxref{What documentation -->
<!-- exists for R?}) and in Robert Gentleman and Ross Ihaka (2000), ``Lexical -->
<!-- Scope and Statistical Computing'', -->
<!-- @url{http://www.amstat.org/publications/jcgs/, , @emph{Journal of -->
<!-- Computational and Graphical Statistics}}, @strong{9}, 491-508. -->
   <p>중첩된 구조의 렉시컬 스코프를 따르는 함수들(nested lexically scoped functions)은 함수 클로져 (function closure)의 사용과 지역적 상태(local state)를 유지하는 것을 허용합니다. 
(Abelson과 Sussman으로부터 가져온) 간단한 예는 R 프롬프트에서 <kbd>demo("scoping")</kbd>이라고 입력함으로서 확인해 볼 수 있습니다. 
이에 대한 더 많은 정보는 표준 R 참고자료인 &ldquo;R: A Language for Data Analysis and Graphics&rdquo; (see <a href="#What-documentation-exists-for-R_003f">What documentation exists for R?</a>)과 Robert Gentleman and Ross Ihaka (2000), &ldquo;Lexical Scope and Statistical Computing&rdquo;, <a href="http://www.amstat.org/publications/jcgs/"><em>Journal of Computational and Graphical Statistics</em></a>, <strong>9</strong>, 491&ndash;508. 으로부터 찾아 볼 수 있습니다.

<!-- Nested lexically scoped functions also imply a further major difference. -->
<!-- Whereas S stores all objects as separate files in a directory somewhere -->
<!-- (usually @file{.Data} under the current directory), R does not.  All -->
<!-- objects in R are stored internally.  When R is started up it grabs a -->
<!-- piece of memory and uses it to store the objects.  R performs its own -->
<!-- memory management of this piece of memory, growing and shrinking its -->
<!-- size as needed.  Having everything in memory is necessary because it is -->
<!-- not really possible to externally maintain all relevant ``environments'' -->
<!-- of symbol/value pairs.  This difference also seems to make R -->
<!-- @emph{faster} than S. -->
   <p>중첩된 구조의 렉시컬 스코프를 따르는 함수들 (nested lexically scoped functions)은 더 중요한 다른 점을 의미합니다. 
S는 모든 객체들을 디렉토리의 어딘가에 (보통은 현재 디렉토리내에  <samp><span class="file">.Data</span></samp>의 형식으로) 각각 다른 파일들로 저장하는 반면, R은 그러하지 않습니다. 
R의 모든 객체들은 내부적으로 저장됩니다. 
R이 실행되었을때, R은 메모리(memory)의 한 조각을 붙잡고 이를 객체를 저장하는데 사용합니다. 
R은 이러한 메모리 사용을 위한 메모리 관리기능(memory management)을 수행하고, 필요한 만큼의 크기를 늘이고 줄이게 됩니다. 
심볼과 값들간의 바인딩(symbol/value pairs)에 관련된 모든 &ldquo;환경(environments)&rdquo;를 외부에서 유지하는 것은 거의 가능하지 않기 때문에 모든 것을 메모리내에서 관리할 필요가 있습니다. 
이러한 차이 또한 R이 S보다 빠른 것 처럼 보이게 합니다.

<!-- The down side is that if R crashes you will lose all the work for the -->
<!-- current session.  Saving and restoring the memory ``images'' (the -->
<!-- functions and data stored in R's internal memory at any time) can be a -->
<!-- bit slow, especially if they are big.  In S this does not happen, -->
<!-- because everything is saved in disk files and if you crash nothing is -->
<!-- likely to happen to them.  (In fact, one might conjecture that the S -->
<!-- developers felt that the price of changing their approach to persistent -->
<!-- storage just to accommodate lexical scope was far too expensive.) -->
<!-- Hence, when doing important work, you might consider saving often (see -->
<!-- @ref{How can I save my workspace?}) to safeguard against possible -->
<!-- crashes.  Other possibilities are logging your sessions, or have your R -->
<!-- commands stored in text files which can be read in using -->
<!-- @code{source()}. -->
   <p>다소 불편한 점이 있다면 R이 크래쉬(crash)되면 현재 세션에서 작업하는 모든 것을 잃게 됩니다. 
메모리를 저장하고 복원하는 &ldquo;images&rdquo;(이미지라는 것은 R의 내부 메모리에 항시 저장되는 함수들과 데이터를 의미합니다)의 크기가 크다면 다소 느릴 수 있습니다. 
S에서는 이와 같은 일이 발생하지 않습니다. 
그 이유는 모든것이 디스크 파일의 형식으로 저장되기 때문입니다
(누군가는 S 개발자들이 렉시컬 스코프을 위한 공간을 제공하는 것이 지속적인 저장방식을 사용하는 것보다 더 많은 비용이 들것이라고 느꼈을 것이라고 추측할 수도 있습니다). 
그래서, 중요한 작업을 할때에는 가능한 크래쉬(crash)들로부터 보호하기 위해서 자주 저장하는 것을 생각해 볼 수 있습니다 (<a href="#How-can-I-save-my-workspace_003f">How can I save my workspace?</a>를 살펴보세요). 
또 다른 방법으로는 세션(session)을 기록(logging)하거나, <code>source()</code>를 이용하여 읽어들일 수 있는 텍스트 파일에 저장된 R 명령어들을 가지는 것입니다.

   <blockquote>
<b>Note:</b> <!-- If you run R from within Emacs (see @ref{R and Emacs}), you can save the -->
<!-- contents of the interaction buffer to a file and conveniently manipulate -->
<!-- it using @code{ess-transcript-mode}, as well as save source copies of -->
<!-- all functions and data used. -->
만약 R을 Emacs내에서 실행한다면 (<a href="#R-and-Emacs">R and Emacs</a>을 살펴보세요), 인터랙션버퍼(interaction buffer)안의 내용들(contents)를 파일에 저장하고 이들을 <code>ess-transcript-mode</code>를 이용하여 쉽게 조작할 수 있으며, 사용된 모든 함수와 데이터들의 원시복제(source copy)를 저장할 수 있습니다. 
</blockquote>

<div class="node">
<a name="Models"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Others">Others</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Lexical-scoping">Lexical scoping</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#What-are-the-differences-between-R-and-S_003f">What are the differences between R and S?</a>

</div>

<!-- @subsection Models -->
<h4 class="subsection">3.3.2 모델(Models)</h4>

<!-- There are some differences in the modeling code, such as -->
<p>모델링 코드(modeling code)에는 아래와 같이 몇가지 다른 점들을 볼 수 있습니다.

     <ul>
<li><!-- Whereas in S, you would use @code{lm(y ~ x^3)} to regress @code{y} on -->
<!-- @code{x^3}, in R, you have to insulate powers of numeric vectors (using -->
<!-- @code{I()}), i.e., you have to use @code{lm(y ~ I(x^3))}. -->
S에서는 <code>y</code>를 <code>x^3</code>을 이용하여 회귀(regress)하기 위해서는 <code>lm(y ~ x^3)</code>를 사용하는 반면, R에서는 수치벡터의 자승부분을 <code>I()</code>를 이용하여 따로 보호처리를 해야합니다. 
즉, <code>lm(y ~ I(x^3))</code>이라고 사용해야 합니다.

     <li><!-- The glm family objects are implemented differently in R and S.  The same -->
<!-- functionality is available but the components have different names. -->
일반선형화모델 페밀리 객체들(glm family objects)는 R과 S에서 다르게 구현되어 있습니다. 
같은 기능을 이용할 수 있으나, 구성요소들은 서로 다른 이름들을 가지고 있습니다.

     <li><!-- Option @code{na.action} is set to @code{"na.omit"} by default in R, -->
<!-- but not set in S. -->
<code>na.action</code>이라는 옵션은 <code>"na.omit"</code>이라는 값으로 R에서는 기본적으로 설정되어 있으나, S에서는 그렇지 않습니다.

     <li><!-- Terms objects are stored differently.  In S a terms object is an -->
<!-- expression with attributes, in R it is a formula with attributes.  The -->
<!-- attributes have the same names but are mostly stored differently. -->
항 객체(terms objects)들은 다른 방식으로 저장됩니다. 
S에서는 항 객체(terms objects)은 속성(attributes)와 함께 이용된 표현식(expression)이지만, R에서는 속성과 함께 이용된 formula (공식 또는 포뮬러)입니다. 
속성들은 같은 이름들을 가지고 있으나 대부분 다르게 저장됩니다.

     <li><!-- Finally, in R @code{y ~ x + 0} is an alternative to @code{y ~ x - 1} for -->
<!-- specifying a model with no intercept.  Models with no parameters at all -->
<!-- can be specified by @code{y ~ 0}. -->
마지막으로 절편(intercept)가 없는 모델을 정의하기 위해서 R에서는 <code>y ~ x + 0</code>이라는 표현은 <code>y ~ x - 1</code>의 또 다른 표현입니다. 
아무런 파라미터들(parameters)를 없는 모델을 <code>y ~ 0</code>로 표현할 수 있습니다. 
</ul>

<div class="node">
<a name="Others"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Models">Models</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#What-are-the-differences-between-R-and-S_003f">What are the differences between R and S?</a>

</div>

<!-- @subsection  Others -->
<h4 class="subsection">3.3.3 그외의 다른 내용들</h4>

<!-- Apart from lexical scoping and its implications, R follows the S -->
<!-- language definition in the Blue and White Books as much as possible, and -->
<!-- hence really is an ``implementation'' of S.  There are some intentional -->
<!-- differences where the behavior of S is considered ``not clean''.  In -->
<!-- general, the rationale is that R should help you detect programming -->
<!-- errors, while at the same time being as compatible as possible with S. -->
<p>렉시컬 스코핑(lexical scoping)과 이것의 의미를 떠나서, R은 Blue와 White 책에 있는 S 랭귀지 정의(language definition)을 가능하면 많이 본땄기 때문에 결과적으로는 S를 이용한 &ldquo;implementation&rdquo;(구현물)입니다. 
S의 작동방식(behaviour)가 &ldquo;not clean&rdquo;(깔끔하지 못하다고) 고려되는 부분들에 있어서는 의도적인 다른 점들을 가지고 있습니다. 
일반적 방침은 R은 S와 가능하면 호환될 수 있게 함과 동시에 사용자가 프로그래밍 에러를 찾을수 있게 도와주도록 하는 것입니다.

<!-- Some known differences are the following. -->
   <p>몇 가지 알려진 다른 점들을 아래에 설명하였습니다.

     <ul>
<li><!-- In R, if @code{x} is a list, then @code{x[i] <- NULL} and @code{x[[i]] -->
<!-- <- NULL} remove the specified elements from @code{x}.  The first of -->
<!-- these is incompatible with S, where it is a no-op.  (Note that you can -->
<!-- set elements to @code{NULL} using @code{x[i] <- list(NULL)}.) -->
R에서는 만약 <code>x</code>가 리스트(list)라면 <code>x[i] &lt;- NULL</code>과 <code>x[[i]] &lt;- NULL</code>이라고 하는 것은 <code>x</code>로부터 지정된 구성요소들을 삭제합니다. 
이들중 첫번째 표현은 no-op인 곳에서는 S에서 사용할 수 없습니다. 
(<code>x[i] &lt;- list(NULL)</code>을 이용하여 <code>NULL</code>이라는 구성요소를 지정할 수 있습니다).

     <!-- @item -->
     <!-- In R @code{x[-4]} fails if @code{x} is not @code{NULL} but has fewer -->
     <!-- than 4 elements.  In S it has no effect. -->
     <li><!-- In S, the functions named @code{.First} and @code{.Last} in the -->
<!-- @file{.Data} directory can be used for customizing, as they are executed -->
<!-- at the very beginning and end of a session, respectively. -->
S에서, <samp><span class="file">.Data</span></samp> 디렉토리 내에서 <code>.First</code>와 <code>.Last</code>라는 이름을 가진 함수들은 세션의 가장 처음과 마지막에서 실행되기 때문에 커스터마이징(customizing)을 위한 목적으로 사용될 수 있습니다.

     <!-- In R, the startup mechanism is as follows.  Unless @option{-no-environ} -->
     <!-- was given on the command line, R searches for site and user files to -->
     <!-- process for setting environment variables.  Then, R searches for a -->
     <!-- site-wide startup profile unless the command line option -->
     <!-- @option{-no-site-file} was given.  This code is loaded in package -->
     <!-- @pkg{base}.  Then, unless @option{-no-init-file} was given, R -->
     <!-- searches for a user profile file, and sources it into the user -->
     <!-- workspace.  It then loads a saved image of the user workspace from -->
     <!-- @file{.RData} in case there is one (unless @option{-no-restore-data} or -->
     <!-- @option{-no-restore} were specified).  Next, a function @code{.First()} -->
     <!-- is run if found on the search path.  Finally, function @code{.First.sys} -->
     <!-- in the @pkg{base} package is run.  When terminating an R session, by -->
     <!-- default a function @code{.Last} is run if found on the search path, -->
     <!-- followed by @code{.Last.sys}.  If needed, the functions @code{.First()} -->
     <!-- and @code{.Last()} should be defined in the appropriate startup -->
     <!-- profiles.  See the help pages for @code{.First} and @code{.Last} for -->
     <!-- more details. -->
     <p>R에서 스타트업(startup) 메카니즘은 다음과 같습니다. 
만약 명령어 라인에 <samp><span class="option">--no-environ</span></samp>이 주어지지 않았다면, R은 환경변수들(environment variables)들을 설정하기 위한 사이트와 사용자 파일들(site and user files)으르 찾습니다. 
그리고 나서, 명령어 라인에 <samp><span class="option">--no-site-file</span></samp>이 주어지지 않았다면, 사이트-와이드 스타트업 프로파일 (site-wide startup profile)을 탐색합니다. 
이 코드는 패키지 <strong>base</strong>에 로드되어 있습니다. 
그리고 나서, <samp><span class="option">--no-init-file</span></samp>이 주어지지 않았다면 R은 사용자 프로파일 파일(user profile file)을 탐색하고 이를 사용자의 작업공간(user workspace)로 읽어(source)들입니다. 
그런 후에, 만약 <samp><span class="option">--no-restore-data</span></samp> 또는 <samp><span class="option">--no-restore</span></samp>가 지정되지 않는 이상 <samp><span class="file">.RData</span></samp>에 사용자 작업공간의 저장된 이미지가 있다면 이를 불러옵니다. 
그런 다음, 함수 <code>.First()</code>가 검색경로(serach path)위에 있다면 실행됩니다. 
마지막으로 패키지 <strong>base</strong> 내에 있는 함수 <code>.First.sys</code>가 실해됩니다. 
R 세션을 종료할 때, 만약 <code>.Last</code>가 검색경로에서 찾아진다면 이를 실행한 뒤에 <samp><span class="option">.Last.sys</span></samp>가 실행됩니다. 
만약 필요하다면 함수들 <code>.First()</code>와 <code>.Last()</code>들은 적절한 스타트업 프로파일에 정의되어야 합니다. 
더 구체적인 내용은 <code>.First</code>와 <code>.Last</code>에 대한 도움말을 참고하세요.

     <li><!-- In R, @code{T} and @code{F} are just variables being set to @code{TRUE} -->
<!-- and @code{FALSE}, respectively, but are not reserved words as in S and -->
<!-- hence can be overwritten by the user.  (This helps e.g.@: when you have -->
<!-- factors with levels @code{"T"} or @code{"F"}.)  Hence, when writing code -->
<!-- you should always use @code{TRUE} and @code{FALSE}. -->
R에서는 <code>T</code>와 <code>F</code>는 단순히 <code>TRUE</code>와 <code>FALSE</code>로 정해지는 변수들이지만, S에서는 예약어(reserved words)가 아니기 때문에 사용자에 의해서 덮어씌여질 수 있습니다. 
(이는 <code>"T"</code>와 <code>"F"</code>라는 요인의 수준들을 이용할 때 유용합니다). 
그러므로, 코드를 작성할 때 <code>TRUE</code>와 <code>FALSE</code>를 항상 이용해야만 합니다.

     <li><!-- In R, @code{dyn.load()} can only load @emph{shared objects}, as created -->
<!-- for example by @kbd{R CMD SHLIB}. -->
R에서, <code>dyn.load()</code>는 오로지 공유된 객체들(shared objects)만을 불러옵니다. 
예를들면, <kbd>R CMD SHLIB</kbd>에 의해 생성된 것들입니다.

     <li><!-- In R, @code{attach()} currently only works for lists and data frames, -->
<!-- but not for directories.  (In fact, @code{attach()} also works for R -->
<!-- data files created with @code{save()}, which is analogous to attaching -->
<!-- directories in S.)  Also, you cannot attach at position 1. -->
R에서 <code>attach()</code>는 현재의 리스트들과 데이터프레임들만을 결합하는데 이용되지만 디렉토리에는 적용되지 않습니다. 
(실제로는 <code>attach()</code>는 <code>save()</code>에 의하여 생성된 R 데이터 파일들을 결합하는데, 이는 S에서 디렉토리를 결합하는 것과 유사합니다). 
또한 위치 1(position 1)에서는 결합할 수 없습니다.

     <li><!-- Categories do not exist in R, and never will as they are deprecated now -->
<!-- in S.  Use factors instead. -->
R에서는 카테고리 (categories)라는 개념은 존재하지 않으며, S에서 더 이상 사용을 하지 않기 때문에 앞으로도 존재하지 않을 것입니다. 
대신에 요인 (factors)를 이용하시길 바랍니다.

     <li><!-- In R, @code{For()} loops are not necessary and hence not supported. -->
R에서는 <code>For()</code> 루프는 필요하지 않으므로 지원되지 않습니다.

     <li><!-- In R, @code{assign()} uses the argument @option{envir=} rather than -->
<!-- @option{where=} as in S. -->
R에서는 <code>assign()</code>은 S에서 인자 <samp><span class="option">where=</span></samp>를 사용하는 것과는 달리 인자 <samp><span class="option">envir=</span></samp>를 이용합니다.

     <li><!-- The random number generators are different, and the seeds have different -->
<!-- length. -->
난수발생기(random number generators)가 다르며, 시드(seeds)의 길이가 다릅니다.

     <li><!-- R passes integer objects to C as @code{int *} rather than @code{long *} -->
<!-- as in S. -->
R은 정수형 객체를 C로 패스할 때 S가 <code>long *</code>를 사용하는 것과 달리 <code>int *</code>를 이용합니다.

     <li><!-- R has no single precision storage mode.  However, as of version 0.65.1, -->
<!-- there is a single precision interface to C/@FORTRAN{} subroutines. -->
R은 단정도 (single precision) 저장모드 (storage mode). 
그러나, 0.65.1부터는 C/FORTRAN 서브루틴에 접속하는(interface) 단정도가 있습니다.

     <li><!-- By default, @code{ls()} returns the names of the objects in the current -->
<!-- (under R) and global (under S) environment, respectively.  For example, -->
<!-- given -->
기본적으로 <code>ls()</code>는 R에서 현재의 환경(current environment)에 있는 객체들의 이름을 반환하지만, S는 전역환경(global environment)에 있는 객체들의 이름을 반환합니다. 
예를들면,

     <pre class="example">          x &lt;- 1; fun &lt;- function() {y &lt;- 1; ls()}
</pre>
     <p class="noindent"><!-- then @code{fun()} returns @code{"y"} in R and @code{"x"} (together with -->
<!-- the rest of the global environment) in S. -->
<code>fun()</code>은 R에서는 <code>"y"</code>를 반환하고 S에서는 <code>"x"</code> 그리고 전역환경(global environment)에 있는 다른 객체들을 함께 반환합니다.

     <li><!-- R allows for zero-extent matrices (and arrays, i.e., some elements of -->
<!-- the @code{dim} attribute vector can be 0).  This has been determined a -->
<!-- useful feature as it helps reducing the need for special-case tests for -->
<!-- empty subsets.  For example, if @code{x} is a matrix, @code{x[, FALSE]} -->
<!-- is not @code{NULL} but a ``matrix'' with 0 columns.  Hence, such objects -->
<!-- need to be tested for by checking whether their @code{length()} is zero -->
<!-- (which works in both R and S), and not using @code{is.null()}. -->

     <p>R은 0의 크기를 가진 행렬 (zero-extent matrices)와 배열 (즉, <code>dim</code> 속성벡터(attribute vector)의 일부 구성요소가 0이 될 수 있습니다)를 허용합니다. 
이것은 비어있는 부분집합 (empty subset)에 대한 특별한 테스트들의 필요성을 도움을 주기 때문에 유용한 기능이라고 여겨져 왔습니다. 
만약, <code>x</code>가 행렬이며, <code>x[,FALSE]</code>는 <code>NULL</code>이 아니라, 아무런 행을 가지지 않는 &ldquo;행렬&rdquo;입니다. 
그러므로, 이러한 객체들은 <code>is.null()</code>을 이용하는 것이 아니라 <code>length()</code>가 0인지를 확인해야 합니다 (R과 S 둘 다 작동합니다).

     <li><!-- Named vectors are considered vectors in R but not in S (e.g., -->
<!-- @code{is.vector(c(a = 1:3))} returns @code{FALSE} in S and @code{TRUE} -->
<!-- in R). -->
벡터의 구성요소에 이름이 있는 벡터(named vector)들은 R에서는 벡터로 여겨지지만, S에서는 그렇지 않습니다 (즉, <code>is.vector(c(a=1:3))</code>은 S에서 <code>FALSE</code>이지만, R에서는 <code>TRUE</code>입니다).

     <li><!-- Data frames are not considered as matrices in R (i.e., if @code{DF} is a -->
<!-- data frame, then @code{is.matrix(DF)} returns @code{FALSE} in R and -->
<!-- @code{TRUE} in S). -->
R에서는 데이터프레임은 행렬로 여겨지지 않습니다 (즉, 만약에 <code>DF</code>가 데이터 프레임이라면, <code>is.matrix(DF)</code>의 결과는 R에서는 <code>FALSE</code>이지만 S에서는 <code>TRUE</code>입니다).

     <li><!-- R by default uses treatment contrasts in the unordered case, whereas S -->
<!-- uses the Helmert ones.  This is a deliberate difference reflecting the -->
<!-- opinion that treatment contrasts are more natural. -->
R에서는 기본적으로 순서가 없는 경우(unordered case)에는 treatment contrast를 사용하는 반면 S는 Helmert 대조를 사용합니다. 
이것은 treatment contrast가 더 자연스럽다는 의견이 반영된 다른 점입니다.

     <li><!-- In R, the argument of a replacement function which corresponds to the -->
<!-- right hand side must be named @samp{value}.  E.g., @code{f(a) <- b} is -->
<!-- evaluated as @code{a <- "f<-"(a, value = b)}.  S always takes the last -->
<!-- argument, irrespective of its name. -->
R에서는 우변(right hand side)에 해당하는 치환함수의 인자는 &lsquo;<samp><span class="samp">value</span></samp>&rsquo;라고 반드시 이름지어져야 합니다. 
즉, <code>f(a) &lt;- b</code>는 <code>a &lt;- "f&lt;-"(a, value = b)</code>처럼 평가됩니다. 
S는 명칭에 관계없이 항상 마지막 인자를 취합니다.

     <li><!-- In S, @code{substitute()} searches for names for substitution in the -->
<!-- given expression in three places: the actual and the default arguments -->
<!-- of the matching call, and the local frame (in that order).  R looks in -->
<!-- the local frame only, with the special rule to use a ``promise'' if a -->
<!-- variable is not evaluated.  Since the local frame is initialized with -->
<!-- the actual arguments or the default expressions, this is usually -->
<!-- equivalent to S, until assignment takes place. -->
S에서는 <code>substitute()</code>는 주어진 표현(expression)으로부터 대체에 이용될 이름들을 검색합니다:
매칭호출(matching call)의 실제적(actual) 인자와 기본(default) 인자, 그리고 이의 순서에 따른 지역적 프레임(local frame). 
R은 변수가 평가되지 않았다면, &ldquo;promise&rdquo;를 사용하기 위한 특별한 규칙과 함께 지역적 프레임 내를 살펴보게 됩니다. 
지역적 프레임은 할당(assignment)이 일어나기 전에 실제적 인자 (actual argument) 또는 디폴트 표현(default expression)으로 초기화 되기 때문에 이는 보통 S와 일치하게 됩니다.

     <li><!-- In S, the index variable in a @code{for()} loop is local to the inside -->
<!-- of the loop.  In R it is local to the environment where the @code{for()} -->
<!-- statement is executed. -->
S에서는 <code>for()</code> 루프내의 인덱스 변수(index variable)은 루프내에서 지역적으로 이용됩니다. 
R에서는 <code>for()</code>문이 실행되어진 곳의 환경(environment)에 지역적입니다.

     <li><!-- In S, @code{tapply(simplify=TRUE)} returns a vector where R returns a -->
<!-- one-dimensional array (which can have named dimnames). -->
S에서는 <code>tapply(simplify=TRUE)</code>는 R이 1-차원 배열(dimnames이라고 이름을 가질 수도 있는)을 반환하는 벡터를 반환하게 됩니다.

     <li><!-- In S(-@sc{Plus}) the C locale is used, whereas in R the current -->
<!-- operating system locale is used for determining which characters are -->
<!-- alphanumeric and how they are sorted.  This affects the set of valid -->
<!-- names for R objects (for example accented chars may be allowed in R) and -->
<!-- ordering in sorts and comparisons (such as whether @code{"aA" < "Bb"} is -->
<!-- true or false).  From version 1.2.0 the locale can be (re-)set in R by -->
<!-- the @code{Sys.setlocale()} function. -->
S(-<span class="sc">Plus</span>)에서는 C 로케일이 사용되는 반면 R은 현재 운영체제의 로케일이 문자들이 알파벳인지 어떻게 분류되는지를 결정하기 위해서 사용됩니다. 
이것은 R 객체에 유효한 이름들(예를들면, 엑센트가 있는 문자들도 R에서는 허용될 수도 있습니다), 정렬의 순서와 비교 (<code>"aA" &lt; "Bb"</code>가 참 또는 거짓인지를 결정)에 영향을 줍니다. 
1.2.0 버전부터는 로케일은 <code>Sys.setlocale()</code>함수를 이용하여 R내부에서 재설정될 수 있습니다.

     <li><!-- In S, @code{missing(@var{arg})} remains @code{TRUE} if @var{arg} is -->
<!-- subsequently modified; in R it doesn't. -->
S에서는 <code>missing(</code><var>arg</var><code>)</code>는 만약 <var>arg</var>가 실제적으로 수정이 되면 <code>TRUE</code>로 남아있게 되나, R에서는 그렇지 않습니다.

     <li><!-- From R version 1.3.0, @code{data.frame} strips @code{I()} when creating -->
<!-- (column) names. -->
버전 1.3.0 부터는 <code>data.frame</code>은 (행의) 이름을 생성할때 <code>I()</code>를 분해합니다.

     <li><!-- In R, the string @code{"NA"} is not treated as a missing value in a -->
<!-- character variable.  Use @code{as.character(NA)} to create a missing -->
<!-- character value. -->
R에서는 문자열 <code>"NA"</code>는 문자형 변수에서 결측값(missing value)로 처리되지 않습니다. 
결측을 의미하는 문자값(missing character value)를 생성하기 위해서는 <code>as.character(NA)</code>를 활용하세요.

     <li><!-- R disallows repeated formal arguments in function calls. -->
R은 함수호출에서 중복되는 형식인자(formal argument)를 허용하지 않습니다.

     <li><!-- In S, @code{dump()}, @code{dput()} and @code{deparse()} are essentially -->
<!-- different interfaces to the same code.  In R from version 2.0.0, this is -->
<!-- only true if the same @code{control} argument is used, but by default it -->
<!-- is not.  By default @code{dump()} tries to write code that will evaluate -->
<!-- to reproduce the object, whereas @code{dput()} and @code{deparse()} -->
<!-- default to options for producing deparsed code that is readable. -->
S에서는 <code>dump()</code>, <code>dput()</code>, 그리고 <code>deparse()</code>는 같은 코드에 근본적으로 다른 인터페이스입니다. 
R에서는 버전 2.0.0부터 같은 <code>control</code> 인자가 이용될 때에만 참(true)이지만, 기본적으로 그렇지는 않습니다. 
기본적으로는 <code>dump()</code>는 색체를 재생산하기 위한 평가를 하는 코드를 작성하는 반면, <code>dput()</code>과  <code>deparse()</code>는 기본적으로 읽기가 가능한 구문분석이 되지 않은 코드(deparsed code)를 생성하기 위한 옵션들입니다.

     <li><!-- In R, indexing a vector, matrix, array or data frame with @code{[} using -->
<!-- a character vector index looks only for exact matches (whereas @code{[[} -->
<!-- and @code{$} allow partial matches).  In S, @code{[} allows partial -->
<!-- matches. -->
R에서는 문자벡터 인덱스(character vector index)를 이용하여 <code>[</code>와 함께 벡터, 행렬, 배열, 또는 데이터프레임을 인덱싱하는 것은 오로지 정확한 매치(exact matches)들만을 찾습니다 (그러나, <code>[[</code>와 <code>$</code>는 부분매치를 허용합니다).

     <li><!-- S has a two-argument version of @code{atan} and no @code{atan2}.  A call -->
<!-- in S such as @code{atan(x1, x2)} is equivalent to R's @code{atan2(x1, -->
<!-- x2)}.  However, beware of named arguments since S's @code{atan(x = a, y -->
<!-- = b)} is equivalent to R's @code{atan2(y = a, x = b)} with the meanings -->
<!-- of @code{x} and @code{y} interchanged.  (R used to have undocumented -->
<!-- support for a two-argument @code{atan} with positional arguments, but -->
<!-- this has been withdrawn to avoid further confusion.) -->
S는 두개의 인자를 가지는 <code>atan</code>이 있으나, <code>atan2</code>는 없습니다. 
S에서 <code>atan(x1, x2)</code>라고 호출을 하는 것은 R에서  <code>atan2(x1, x2)</code>라고 하는 것과 같습니다. 
그러나, S의 코드 <code>atan(x=a, y=b)</code>는 R에서 <code>atan2(y=a, x=b)</code>이기 때문에 <code>x</code>와 <code>y</code>가 서로 바뀌어 있음을 아셔야 합니다. 
(R은 위치인수(positional arguments)와 함께 사용되는 2개의 인자를 가지는 <code>atan</code>에 대하여 문서가 없이 지원을 했었으나, 이는 더이상의 혼란을 피하기 위하여 제거되었습니다).

     <li><!-- Numeric constants with no fractional and exponent (i.e., only integer) -->
<!-- part are taken as integer in @SPLUS{} 6.x or later, but as double in R. -->
분수와 지수부분이 없는 숫자형 상수들은 in<span class="sc">S-Plus</span> 6.x 또는 그 이후버전에서는 정수로 처리하지만, R에서는 이를 더블(double)로 처리합니다. 
</ul>

<!-- There are also differences which are not intentional, and result from -->
<!-- missing or incorrect code in R.  The developers would appreciate hearing -->
<!-- about any deficiencies you may find (in a written report fully -->
<!-- documenting the difference as you see it).  Of course, it would be -->
<!-- useful if you were to implement the change yourself and make sure it -->
<!-- works. -->
   <p>의도하지 않았지만, R에서 잘못된 코드 또는 누락된 부분으로 인한 다른 점 또한 있을 수 있습니다. 
개발자들은 사용자가 찾게 되는 어떠한 결점들에 대하여 (사용자가 찾은 다른 점들에 대해서 충분하게 문서화된 보고서의 형태로서) 듣는것을 매우 감사히 여깁니다. 
물론, 스스로가 변경을 해 본뒤에 이 변경이 확실하게 작동하는가를 확인해준다면 더욱 유용합니다.

<div class="node">
<a name="Is-there-anything-R-can-do-that-S-PLUS-cannot%3f"></a>
<a name="Is-there-anything-R-can-do-that-S_002dPLUS-cannot_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-R_002dplus_003f">What is R-plus?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-are-the-differences-between-R-and-S_003f">What are the differences between R and S?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-and-S">R and S</a>

</div>

<!-- @section Is there anything R can do that @sc{S-Plus} cannot? -->
<h3 class="section">3.4 <span class="sc">S-Plus</span>는 할 수 없지만 R이 할 수 있는것이 있나요?</h3>

<!-- Since almost anything you can do in R has source code that you could -->
<!-- port to @SPLUS{} with little effort there will never be much you can do -->
<!-- in R that you couldn't do in @SPLUS{} if you wanted to.  (Note that -->
<!-- using lexical scoping may simplify matters considerably, though.) -->
<p>R에서 할 수 있는 거의 모든 것들은 약간의 노력만으로 <span class="sc">S-Plus</span>로 포트할 수 있는 소스 코드들이 있기때문에 <span class="sc">S-Plus</span>에서 하지 못하는 것을 R에서 할 수 있지는 않을 것입니다 (그러나, 렉시컬 스코핑을 이용하는 것은 상당히 문제를 단순화 시킬 수도 있습니다).

<!-- R offers several graphics features that @SPLUS{} does not, such as finer -->
<!-- handling of line types, more convenient color handling (via palettes), -->
<!-- gamma correction for color, and, most importantly, mathematical -->
<!-- annotation in plot texts, via input expressions reminiscent of @TeX{} -->
<!-- constructs.  See the help page for @code{plotmath}, which features an -->
<!-- impressive on-line example.  More details can be found in Paul Murrell -->
<!-- and Ross Ihaka (2000), ``An Approach to Providing Mathematical -->
<!-- Annotation in Plots'', @url{http://www.amstat.org/publications/jcgs/, , -->
<!-- @emph{Journal of Computational and Graphical Statistics}}, @strong{9}, -->
<!-- 582-599. -->
   <p>R은 <span class="sc">S-Plus</span>에서는 없는 몇가지 그래픽 기능들을 제공합니다. 
라인(line)의 종류를 다루는데 더 나은 처리, (팔레트를 통한) 더 편리한 색상 관리, 색의 감마 보정, 그리고 가장 중요한 것은 TeX와 같은 입력을 이용하여 플랏 텍스트에 수학적 주석을 나타내는 것등입니다. 
이러한 기능들을 볼 수 있는 좋은 예제들을 <code>plotmath</code> 도움말을 살펴보시길 바랍니다. 
더 자세한 내용들은 Paul Murrell and Ross Ihaka (2000), &ldquo;An Approach to Providing Mathematical Annotation in Plots&rdquo;, <a href="http://www.amstat.org/publications/jcgs/"><em>Journal of Computational and Graphical Statistics</em></a>, <strong>9</strong>, 582&ndash;599 에서 찾아 볼 수 있습니다.

<div class="node">
<a name="What-is-R-plus%3f"></a>
<a name="What-is-R_002dplus_003f"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Is-there-anything-R-can-do-that-S_002dPLUS-cannot_003f">Is there anything R can do that S-PLUS cannot?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-and-S">R and S</a>

</div>

<!-- @section What is R-plus? -->
<h3 class="section">3.5 R-plus는 무엇인가요?</h3>

<!-- For a very long time, there was no such thing. -->
<p>매우 오랜 기간동안 다음과 같은 것들은 존재하지 않았습니다.

<!-- @url{http://www.xlsolutions-corp.com/, XLSolutions Corporation} is -->
<!-- currently beta testing a commercially supported version of R named R+ -->
<!-- (read R plus). -->
   <p><a href="http://www.xlsolutions-corp.com/">XLSolutions Corporation</a>은 R 플러스라고 읽는 R+라는 상업용 버전을 현재 베타 테스팅 하고 있습니다.

<!-- @url{http://www.revolution-computing.com/, REvolution Computing} has -->
<!-- released -->
<!-- @url{http://www.revolution-computing.com/products/revolution-r.php, -->
<!-- REvolution R}, an enterprise-class statistical analysis system based on -->
<!-- R, suitable for deployment in professional, commercial and regulated -->
<!-- environments. -->
   <p><a href="http://www.revolution-computing.com/">REvolution Computing</a>은 R에 기초를 둔 기업용 통계시스템(enterprise-class statistical analysis system), 전문가용, 상업용, 그리고 규제된 환경 배치에 적합한 <a href="http://www.revolution-computing.com/products/revolution-r.php">REvolution R</a>을 선보였습니다.

<!-- @url{http://www.random-technologies-llc.com/, Random Technologies} -->
<!-- offers @url{http://random-technologies-llc.com/products/RStat/rstat, -->
<!-- RStat}, an enterprise-strength statistical computing environment which -->
<!-- combines R with enterprise-level validation, documentation, software -->
<!-- support, and consulting services, as well as related R-based products. -->
   <p><a href="http://www.random-technologies-llc.com/">Random Technologies</a>는 R을 기업수준의 밸리데이션, 문서화 및 소프트웨어 지원과 상담 서비스들, 그리고 R 기반의 제품들을 결합한 기업의 통계컴퓨팅 환경인 <a href="http://random-technologies-llc.com/products/RStat/rstat">RStat</a>을 제공합니다.

<!-- See also -->
<!-- @url{http://en.wikipedia.org/wiki/R_programming_language#Commercialized_versions_of_R} -->
<!-- for pointers to commercialized versions of R. -->
   <p>커머셜 버전의 R에 대해서는 <a href="http://en.wikipedia.org/wiki/R_programming_language#Commercialized_versions_of_R">http://en.wikipedia.org/wiki/R_programming_language#Commercialized_versions_of_R</a> 를 참고하십시오.

<div class="node">
<a name="R-Web-Interfaces"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#R-Add_002dOn-Packages">R Add-On Packages</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-and-S">R and S</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter R Web Interfaces -->
<h2 class="chapter">4 R 웹 인터페이스</h2>

<!-- @strong{Rweb} is developed and maintained by -->
<!-- @email{jeff@@math.montana.edu, Jeff Banfield}.  The -->
<!-- @url{http://www.math.montana.edu/Rweb/, Rweb Home Page} provides access -->
<!-- to all three versions of Rweb-a simple text entry form that returns -->
<!-- output and graphs, a more sophisticated JavaScript version that provides -->
<!-- a multiple window environment, and a set of point and click modules that -->
<!-- are useful for introductory statistics courses and require no knowledge -->
<!-- of the R language.  All of the Rweb versions can analyze Web accessible -->
<!-- datasets if a @acronym{URL} is provided. -->
<p><strong>Rweb</strong>은 <a href="mailto:jeff@math.montana.edu">Jeff Banfield</a>에 의해 개발되고 유지되고 있습니다. 
<a href="http://www.math.montana.edu/Rweb/">Rweb Home Page</a>는 다음과 같은 세가지 버전의 Rweb을 제공합니다 &mdash; 결과물과 그래프를 반환해주는 간단한 텍스트 입력 방식, 여러 개의 창을 제공하며 좀 더 보기에 좋은 JavaScript 버전, 그리고 R 언어에 대한 지식이 요구되지 않고 기초 통계 과목들에 유요한 포인트와 클릭만으로 이루어진 버전들입니다. 
만약 <acronym>URL</acronym>이 제공되어 있다면, 모든 Rweb 버전들은 웹에서 접근이 가능한 데이터들을 분석할 수 있습니다.

<!-- The paper ``Rweb: Web-based Statistical Analysis'', providing a detailed -->
<!-- explanation of the different versions of Rweb and an overview of how -->
<!-- Rweb works, was published in the Journal of Statistical Software -->
<!-- (@url{http://www.jstatsoft.org/v04/i01/}). -->
   <p>다른 버전들의 Rweb에 대한 자세한 설명과 Rweb이 어떻게 작동하는지에 대한 개요는 Journal of Statistical Software (<a href="http://www.jstatsoft.org/v04/i01/">http://www.jstatsoft.org/v04/i01/</a>)에서 출간된 &ldquo;Rweb: Web-based Statistical Analysis&rdquo;에 설명되어 있습니다.

<!-- @email{ulfi@@cs.tu-berlin.de, Ulf Bartel} has developed -->
<!-- @strong{R-Online}, a simple on-line programming environment for R which -->
<!-- intends to make the first steps in statistical programming with R -->
<!-- (especially with time series) as easy as possible.  There is no need for -->
<!-- a local installation since the only requirement for the user is a -->
<!-- JavaScript capable browser.  See @url{http://osvisions.com/r-online/} -->
<!-- for more information. -->
   <p><a href="mailto:ulfi@cs.tu-berlin.de">Ulf Bartel</a>은 R을 이용한 통계 프로그래밍의 기초 단계들(특히 시계열에 이용이 가능한)을 가능한 쉽게 만들수 있도록 간단한 R 온라인 프로그래밍 환경인 <strong>R-Online</strong>을 개발하였습니다. 
이를 사용하기 위해서는 사용자는 JavaScript가 가능한 브라우저만이 요구되기 때문에 추가적인 로컬 설치는 요구되지 않습니다. 
더 많은 정보를 <a href="http://osvisions.com/r-online/">http://osvisions.com/r-online/</a>에서 찾을 수 있습니다.

<!-- @strong{Rcgi} is a CGI WWW interface to R by @email{mjr@@dsl.pipex.com, -->
<!-- MJ Ray}.  It had the ability to use ``embedded code'': you could mix -->
<!-- user input and code, allowing the @HTML{} author to do anything from -->
<!-- load in data sets to enter most of the commands for users without -->
<!-- writing CGI scripts.  Graphical output was possible in PostScript or GIF -->
<!-- formats and the executed code was presented to the user for revision. -->
<!-- However, it is not clear if the project is still active. -->
<!-- @c URL no longer seems to work ... -->
<!-- @c See @url{http://stats.mth.uea.ac.uk/Rcgi/} for more information. -->
<!-- Currently, a modified version of @strong{Rcgi} by -->
<!-- @email{mai@@ms.uky.edu, Mai Zhou} (actually, two versions: one with -->
<!-- (bitmap) graphics and one without) as well as the original code are -->
<!-- available from @url{http://www.ms.uky.edu/~statweb/}. -->
   <p><strong>Rcgi</strong>는 <a href="mailto:mjr@dsl.pipex.com">MJ Ray</a>에서 만들어진 CGI WWW 인터페이스입니다. 
이는 <acronym>HTML</acronym> 작성자가 CGI 스크립들을 쓰지 않고도 데이터 셋을 로드하는 것부터 사용자가 대부분의 명령어들을 입력하며, 사용자의 입력과 코드를 섞어 사용할 수 있는 &ldquo;embedded code&rdquo;을 사용할 수 있었습니다. 
PostScript 또는 GIF 형식들의 그래픽적 결과물이 가능했으며, 실행된 코드는 사용자가 수정할 수 있도록 보여졌습니다. 
그러나, 이 프로젝트가 아직도 진행중인지는 확실하지 않습니다. 
현재 <a href="mailto:mai@ms.uky.edu">Mai Zhou</a>에 의한 수정된 버전의 <strong>Rcgi</strong> (실제로는 (bitmap) 그래픽스가 있는 것과 없는 것 두가지가 존재합니다)가 있으며, 본래의 코드는 <a href="http://www.ms.uky.edu/~statweb/">http://www.ms.uky.edu/~statweb/</a>에서 찾아 볼 수 있습니다.

<!-- CGI-based web access to R is also provided at -->
<!-- @url{http://hermes.sdu.dk/cgi-bin/go/}.  There are many additional -->
<!-- examples of web interfaces to R which basically allow to submit R code -->
<!-- to a remote server, see for example the collection of links available from -->
<!-- @url{http://biostat.mc.vanderbilt.edu/twiki/bin/view/Main/StatCompCourse}. -->
   <p>CGI에 기초한 웹 액세스 또한 <a href="http://hermes.sdu.dk/cgi-bin/go/">http://hermes.sdu.dk/cgi-bin/go/</a>에서 제공됩니다. 
기본적으로 원격서버로 R코드를 보낼 수 있도록 해주는 웹 인터페이스 구현예들이 많이 있습니다. 
예를들면, <a href="http://biostat.mc.vanderbilt.edu/twiki/bin/view/Main/StatCompCourse">http://biostat.mc.vanderbilt.edu/twiki/bin/view/Main/StatCompCourse</a>으로부터 링크들의 모음을 찾을 수 있습니다.

<!-- @url{http://www.warwick.ac.uk/go/dfirth, David Firth} has written -->
<!-- @CRANpkg{CGIwithR}, an R add-on package available from @CRAN{}.  It -->
<!-- provides some simple extensions to R to facilitate running R scripts -->
<!-- through the CGI interface to a web server, and allows submission of data -->
<!-- using both GET and POST methods.  It is easily installed using Apache -->
<!-- under Linux and in principle should run on any platform that supports R -->
<!-- and a web server provided that the installer has the necessary security -->
<!-- permissions.  David's paper ``CGIwithR: Facilities for Processing Web -->
<!-- Forms Using R'' was published in the Journal of Statistical Software -->
<!-- (@url{http://www.jstatsoft.org/v08/i10/}).  The package is now -->
<!-- maintained by @email{duncan@@wald.ucdavis.edu, Duncan Temple Lang} and -->
<!-- has a web page at @url{http://www.omegahat.org/CGIwithR/}. -->
   <p><a href="http://www.warwick.ac.uk/go/dfirth">David Firth</a>는 <acronym>CRAN</acronym>으로부터 얻을 수 있는 R 애드온 패키지인 <a href="http://CRAN.R-project.org/package=CGIwithR"><strong>CGIwithR</strong></a>을 작성하였습니다. 
이것은 웹서버에 대한 CGI 인터페이스를 통하여 R script들을 실행할 수 있도록 하는 다소 간단한 R 익스텐션(extension)을 제공하며, GET과 POST 메소드들을 이용한 데이터의 서브미션 또한 가능합니다. 
기본적으로 Linux의 Apache를 사용하여 쉽게 설치되고 R을 지원하는 모든 플랫폼과 인스톨러가 필요한 보안 권한(necessary security permissions)들을 모두 가지고 있는 있는 웹서버에서 작동을 해야 합니다. 
이는 the Journal of Statistical Software (<a href="http://www.jstatsoft.org/v08/i10/">http://www.jstatsoft.org/v08/i10/</a>)에 출판된 David의 논문 &ldquo;CGIwithR: Facilities for Processing Web Forms Using R&rdquo;에 있습니다. 
현재 이 패키지는 <a href="mailto:duncan@wald.ucdavis.edu">Duncan Temple Lang</a>에 의하여 관리되고 있으며, 웹페이지는 <a href="http://www.omegahat.org/CGIwithR/">http://www.omegahat.org/CGIwithR/</a>입니다.

<!-- @url{http://www.rpad.org/Rpad, Rpad}, developed and actively maintained -->
<!-- by Tom Short, provides a sophisticated environment which combines some -->
<!-- of the features of the previous approaches with quite a bit of -->
<!-- JavaScript, allowing for a @acronym{GUI}-like behavior (with sortable -->
<!-- tables, clickable graphics, editable output), etc. -->
   <p>Tom Short에 의해 개발되고 활동적으로 관리되고 있는 <a href="http://www.rpad.org/Rpad">Rpad</a>는 꽤 많은 양의 JaveScript와 <acronym>GUI</acronym>와 같이 작동하는 것들 (정렬이 가능한 테이블들, 클릭할 수 있는 그래픽들, 편집이 가능한 결과물) 등 이전 접근법들에 몇가지 기능들을 추가한 정교한 환경을 제공합니다.

<!-- Jeff Horner is working on the R/Apache Integration Project which embeds -->
<!-- the R interpreter inside Apache 2 (and beyond).  A tutorial and -->
<!-- presentation are available from the project web page at -->
<!-- @url{http://biostat.mc.vanderbilt.edu/@/twiki/@/bin/@/view/@/Main/@/RApacheProject}. -->
   <p>Jeff Horner은 Apache 2(그리고 이후버전)내의 R 인터프리터(interpreter)를 보관하는 R/Apache 융합 프로젝트(Integration project)를 진행하고 있습니다. 
튜토리얼과 프레젠테이션은 프로젝트 웹페이지 <a href="http://biostat.mc.vanderbilt.edu/twiki/bin/view/Main/RApacheProject">http://biostat.mc.vanderbilt.edu/twiki/bin/view/Main/RApacheProject</a>에서 이용가능합니다.

<!-- @url{http://stats.math.uni-augsburg.de/Rserve/, Rserve} is a project -->
<!-- actively developed by Simon Urbanek.  It implements a TCP/IP server which -->
<!-- allows other programs to use facilities of R.  Clients are available from -->
<!-- the web site for Java and C++ (and could be written for other languages -->
<!-- that support TCP/IP sockets). -->
   <p><a href="http://stats.math.uni-augsburg.de/Rserve/">Rserve</a>는 Simon Urbanek에 의해 활발히 개발되는 프로젝트입니다. 
이는 다른 프로그램들이 R의 기능들을 사용할 수 있도록 허용하는 TCP/IP 서버를 구현하는 것입니다. 
Java와 C++ (TCP/IP socket들을 지원하는 다른 언어로도 쓰여질 수 있습니다) 클라이언트들은 웹사이트로부터 얻을 수 있습니다.

<!-- @url{http://openstatserver.org/index.html, OpenStatServer} is being -->
<!-- developed by a team lead by Greg Warnes; it aims ``to provide clean access -->
<!-- to computational modules defined in a variety of computational -->
<!-- environments (R, SAS, Matlab, etc) via a single well-defined client -->
<!-- interface'' and to turn computational services into web services. -->
   <p><a href="http://openstatserver.org/index.html">OpenStatServer</a>는 Greg Warnes이 지휘하는 팀에의해 개발되고 있습니다;
이는 &ldquo;R, SAS, Matlab 등과 같은 다양한 컴퓨팅 환경으로부터 정의되어 있는 컴퓨팅 모듈들에 대하여 하나의 잘 정의된 클라이언트 인터페이스를 통하여 깔끔한 엑세스를 제공하는 것&rdquo;과 이러한 컴퓨테이션 서비스를 웹서비스로 전환하는 것을 목표로 하고 있습니다.

<!-- Two projects use PHP to provide a web interface to R. -->
<!-- @url{http://steve-chen.net/R_PHP/, R_PHP_Online} by Steve Chen (though -->
<!-- it is unclear if this project is still active) is somewhat similar to -->
<!-- the above Rcgi and Rweb.  @url{http://dssm.unipa.it/R-php/?cmd=home, -->
<!-- R-php} is actively developed by Alfredo Pontillo and Angelo Mineo and -->
<!-- provides both a web interface to R and a set of pre-specified analyses -->
<!-- that need no R code input. -->
   <p>R 웹인터페이스를 제공하는데 PHP를 사용한 두 개의 프로젝트가 있습니다. 
Steve Chen에 의해서 개발되는 <a href="http://steve-chen.net/R_PHP/">R_PHP_Online</a>(이 프로젝트가 아직 진행중인지는 불분명합니다)는 위의 Rcgi와 Rweb과 다소 비슷합니다. 
<a href="http://dssm.unipa.it/R-php/?cmd=home">R-php</a>는  Alfredo Pontillo와 Angelo Mineo에 의해 활발히 개발중이며, R 코드 입력이 필요하지 않은 미리 정의된 특수한 분석도구들이 제공됩니다.

<!-- @url{http://www.bioconductor.org/, webbioc} is ``an integrated web -->
<!-- interface for doing microarray analysis using several of the -->
<!-- Bioconductor packages'' and is designed to be installed at local sites -->
<!-- as a shared computing resource. -->
   <p><a href="http://www.bioconductor.org/">webbioc</a>은 &ldquo;여러가지 Bioconductor 패키지들을 이용하여 마이크로어레이 분석 (microarray analysis)을 수행하는 통합적인 웹 인터페이스&rdquo;이며, 마치 공유되어 있은 컴퓨팅 자원(computing resources)와 같이 로컬사이트(local site)에서 설치될 수있도록 설계되었습니다.

<!-- @url{http://sysbio.mrc-bsu.cam.ac.uk/Rwui, Rwui} is a web application to -->
<!-- create user-friendly web interfaces for R scripts.  All code for the web -->
<!-- interface is created automatically.  There is no need for the user to do -->
<!-- any extra scripting or learn any new scripting techniques. -->
   <p><a href="http://sysbio.mrc-bsu.cam.ac.uk/Rwui">Rwui</a>는 R 스크립트를 사용할 수 있도록 사용자 기반의 웹인터페이스를 생성해주는 웹 어플리케이션입니다. 
웹 인터페이스에 대한 모든 코드가 자동으로 생성됩니다. 
사용자가 추가적인 스크립트 작업을 하거나 새로운 스크립팅 기술들을 배울 필요가 없습니다.

<!-- The @CRANpkg{R.rsp} package by Henrik Bengtsson introduces ``R Server -->
<!-- Pages''.  Analogous to Java Server Pages, an R server page is typically -->
<!-- @HTML{} with embedded R code that gets evaluated when the page is -->
<!-- requested.  The package includes an internal cross-platform HTTP server -->
<!-- implemented in Tcl, so provides a good framework for including web-based -->
<!-- user interfaces in packages.  The approach is similar to the use of the -->
<!-- @CRANpkg{brew} package with @url{http://rapache.net/, Rapache} with the -->
<!-- advantage of cross-platform support and easy installation. -->
   <p>Henrik Bengtsson에 의해서 개발된 <a href="http://CRAN.R-project.org/package=R.rsp"><strong>R.rsp</strong></a>패키지는 &ldquo;R server Pages&rdquo;를 소개합니다. 
Java Server 페이지들과 유사하게, Rserver Pasge는 페이지가 요구되었을 때 평가된 R코드가 포함된 <acronym>HTML</acronym> 페이지입니다. 
이 패키지는 Tcl로 구현된 내부 클로스 플랫폼 HTTP 서버(internal cross-platform HTTP server)를 포함하고 있어, 웹 기반의 사용자 인터페이스를 포함하게 해주는 좋은 프레임워크를 제공합니다. 
크로스 플랫폼(cross-platform)에 대한 지원과 쉬운 설치 이점이 있는 <a href="http://rapache.net/">Rapache</a>와 함께 사용하는 <a href="http://CRAN.R-project.org/package=brew"><strong>brew</strong></a>의 사용과 유사합니다.

<!-- The @CRANpkg{Rook} package by Jeffrey Horner provides a web server -->
<!-- interface borrowing heavily from Ruby's Rack project. -->
   <p>Jeffrey Horner의 <a href="http://CRAN.R-project.org/package=Rook"><strong>Rook</strong></a> 패키지는 Ruby의 Rack project의 많은 부분을 가져와 사용하는 웹서버 인터페이스를 제공합니다.

<!-- Finally, @uref{http://code.google.com/p/concerto-platform/, Concerto} is -->
<!-- a user friendly open-source Web Interface to R developed at the -->
<!-- Psychometrics Centre of Cambridge University.  It was designed as an -->
<!-- online platform to design and run Computerized Adaptive Tests, but can -->
<!-- be also used as a general-purpose R Web Interface.  It allows R users -->
<!-- with no programming or web designing background to quickly develop -->
<!-- flexible and powerful online applications, websites, and psychometrics -->
<!-- tests.  To maximize its reliability, security, and performance, Concerto -->
<!-- relies on the popular and reliable open-source elements such as MySQL -->
<!-- server (exchange and storage of the data), @uref{http://rstudio.org/, -->
<!-- Rstudio} (R code designing and testing, file management), CKEditor -->
<!-- (@HTML{} Layer design), and PHP. -->
   <p>마지막으로 <a href="http://code.google.com/p/concerto-platform/">Concerto</a>는 the Psychometrics Centre of Cambridge University에서 개발된 사용이 쉬운 오픈소스 웹 인터페이스 입니다. 
이는 Computerized Adaptive Test를 디자인하고 작동하는 온라인 플랫폼과 같이 디자인 되었으나, 일반적인 목적의 R 웹 인터페이스로도 사용할 수 있습니다. 
이는 프로그래밍이나 웹디자인의 기초 지식이 없는 R 사용자들이 융통성 있고 강력한 온라인 어플리케이션과 웹사이트, 그리고 심리측정 테스트(psychometrics tests)들을 빠르게 개발해 줄 수 있도록 해줍니다. 
신뢰성(reliability), 보안성(security), 그리고 성능(performance)를 최대화 하기 위하여 Concerto는 MySQL 서버 (데이터의 교환과 저장), <a href="http://rstudio.org/">Rstudio</a> (R코드의 디자인, 테스트, 그리고 파일관리), CKEditor (<acronym>HTML</acronym> Layer 디자인), 그리고 PHP와 같은 인기있고 신뢰할 수 있는 오픈소스들로 구성되어 있습니다.

<!-- See @url{http://rwiki.sciviews.org/doku.php?id=faq-r#web_interfaces} for -->
<!-- additional information. -->
   <p>더 많은 정보를 <a href="http://rwiki.sciviews.org/doku.php?id=faq-r#web_interfaces">http://rwiki.sciviews.org/doku.php?id=faq-r#web_interfaces</a>에서 찾을 수 있습니다.

<div class="node">
<a name="R-Add-On-Packages"></a>
<a name="R-Add_002dOn-Packages"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#R-and-Emacs">R and Emacs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Web-Interfaces">R Web Interfaces</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter R Add-On Packages -->
<h2 class="chapter">5 R 애드온 패키지들</h2>

<ul class="menu">
<li><a accesskey="1" href="#Which-add_002don-packages-exist-for-R_003f">Which add-on packages exist for R?</a>
<li><a accesskey="2" href="#How-can-add_002don-packages-be-installed_003f">How can add-on packages be installed?</a>
<li><a accesskey="3" href="#How-can-add_002don-packages-be-used_003f">How can add-on packages be used?</a>
<li><a accesskey="4" href="#How-can-add_002don-packages-be-removed_003f">How can add-on packages be removed?</a>
<li><a accesskey="5" href="#How-can-I-create-an-R-package_003f">How can I create an R package?</a>
<li><a accesskey="6" href="#How-can-I-contribute-to-R_003f">How can I contribute to R?</a>
</ul>

<div class="node">
<a name="Which-add-on-packages-exist-for-R%3f"></a>
<a name="Which-add_002don-packages-exist-for-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-add_002don-packages-be-installed_003f">How can add-on packages be installed?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Add_002dOn-Packages">R Add-On Packages</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Add_002dOn-Packages">R Add-On Packages</a>

</div>

<!-- @section Which add-on packages exist for R? -->
<h3 class="section">5.1 어떤 애드온 패키지들이 있나요?</h3>

<ul class="menu">
<li><a accesskey="1" href="#Add_002don-packages-in-R">Add-on packages in R</a>
<li><a accesskey="2" href="#Add_002don-packages-from-CRAN">Add-on packages from CRAN</a>
<li><a accesskey="3" href="#Add_002don-packages-from-Omegahat">Add-on packages from Omegahat</a>
<li><a accesskey="4" href="#Add_002don-packages-from-Bioconductor">Add-on packages from Bioconductor</a>
<li><a accesskey="5" href="#Other-add_002don-packages">Other add-on packages</a>
</ul>

<div class="node">
<a name="Add-on-packages-in-R"></a>
<a name="Add_002don-packages-in-R"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Add_002don-packages-from-CRAN">Add-on packages from CRAN</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Which-add_002don-packages-exist-for-R_003f">Which add-on packages exist for R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Which-add_002don-packages-exist-for-R_003f">Which add-on packages exist for R?</a>

</div>

<!-- @subsection Add-on packages in R -->
<h4 class="subsection">5.1.1 애드온 패키지들</h4>

<!-- The R distribution comes with the following packages: -->
<p>R은 다음과 같은 패키지들과 함께 배포됩니다.

     <dl>
<!-- <FIXME> -->
<!-- 3.0.0 -->
<dt><strong>base</strong><dd><!-- Base R functions (and datasets before R 2.0.0). -->
Base R 함수들 (그리고 R 2.0.0 전의 데이터셋들).

     <br><dt><strong>compiler</strong><dd><!-- R byte code compiler (added in R 2.13.0). -->
(R 2.13.0에서 더해진) R 바이트 코드 컴파일러(byte code compiler).

     <br><dt><strong>datasets</strong><dd><!-- Base R datasets (added in R 2.0.0). -->
(R 2.0.0에서 더해진) Base R 데이터셋들.

     <br><dt><strong>grDevices</strong><dd><!-- Graphics devices for base and grid graphics (added in R 2.0.0). -->
(R 2.0.0에 더해진) base와 grid 그래픽스를 위한 그래픽 장치들.

     <!-- </FIXME> -->
     <br><dt><strong>graphics</strong><dd><!-- R functions for base graphics. -->
base 그래픽스를 위한 R 함수들.

     <br><dt><strong>grid</strong><dd><!-- A rewrite of the graphics layout capabilities, plus some support for -->
<!-- interaction. -->
그래픽스 레이아웃 성능을 재작성하고 인터랙션을 위한 일부 지원이 추가됨.

     <br><dt><strong>methods</strong><dd><!-- Formally defined methods and classes for R objects, plus other -->
<!-- programming tools, as described in the Green Book. -->
그린북에 설명되어 있는 것과 같이 R 객체들에 대하여 형식적으로 정의된 메소드들과 클래스들, 그리고 다른 프로그래밍 툴들.

     <br><dt><strong>parallel</strong><dd><!-- Support for parallel computation, including by forking and by sockets, -->
<!-- and random-number generation (added in R 2.14.0). -->
포킹(forking), 소켓(sockets), 그리고 (R 2.14.0에 더해진) 난수생성(random-number generation) 기능을 포함한 병렬 연산(parallel computation)을 지원.

     <br><dt><strong>splines</strong><dd><!-- Regression spline functions and classes. -->
리그레션 스플라인(regression spline)함수들과 클래스들.

     <br><dt><strong>stats</strong><dd><!-- R statistical functions. -->
R 통계관련 함수들.

     <br><dt><strong>stats4</strong><dd><!-- Statistical functions using S4 classes. -->
S4 클래스들을 이용한 통계 함수들.

     <br><dt><strong>tcltk</strong><dd><!-- Interface and language bindings to Tcl/Tk @acronym{GUI} elements. -->
Tcl/Tk <acronym>GUI</acronym> 구성요소들에 인터페이스와 랭귀지 바인딩 (interface and language bindings).

     <br><dt><strong>tools</strong><dd><!-- Tools for package development and administration. -->
패키지 개발과 관리를 위한 도구들.

     <br><dt><strong>utils</strong><dd><!-- R utility functions. -->
R 유틸리티 함수들. 
</dl>

<!-- These ``base packages'' were substantially reorganized in R 1.9.0.  The -->
<!-- former @pkg{base} was split into the four packages @pkg{base}, -->
<!-- @pkg{graphics}, @pkg{stats}, and @pkg{utils}.  Packages @pkg{ctest}, -->
<!-- @pkg{eda}, @pkg{modreg}, @pkg{mva}, @pkg{nls}, @pkg{stepfun} and -->
<!-- @pkg{ts} were merged into @pkg{stats}, package @pkg{lqs} returned to the -->
<!-- recommended package @CRANpkg{MASS}, and package @pkg{mle} moved to -->
<!-- @pkg{stats4}. -->
   <p>&ldquo;base packages&rdquo;(베이스 패키지)은 R 1.9.0에서 크게 재구성되었습니다. 
이전의 <strong>base</strong>는 <strong>base</strong>, <strong>graphics</strong>, <strong>stats</strong>, <strong>utils</strong>의 네가지로 나뉘어졌습니다. 
<strong>ctest</strong>, <strong>eda</strong>, <strong>modreg</strong>, <strong>mva</strong>, <strong>nls</strong>, <strong>stepfun</strong>, <strong>ts</strong>는 <strong>stats</strong>로 병합되었으며, <strong>lqs</strong>는 추천패키지인 <a href="http://CRAN.R-project.org/package=MASS"><strong>MASS</strong></a>로 다시 옮겨지고, 패키지 <strong>mle</strong>는 <strong>stats4</strong>로 이동되었습니다.

<div class="node">
<a name="Add-on-packages-from-CRAN"></a>
<a name="Add_002don-packages-from-CRAN"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Add_002don-packages-from-Omegahat">Add-on packages from Omegahat</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Add_002don-packages-in-R">Add-on packages in R</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Which-add_002don-packages-exist-for-R_003f">Which add-on packages exist for R?</a>

</div>

<!-- @subsection Add-on packages from @acronym{CRAN} -->
<h4 class="subsection">5.1.2 <acronym>CRAN</acronym>으로부터 이용가능한 애드온 패키지들</h4>

<!-- The @CRAN{} @file{src/contrib} area contains a wealth of add-on -->
<!-- packages, including the following @emph{recommended} packages which are -->
<!-- to be included in all binary distributions of R. -->
<p><acronym>CRAN</acronym>의 <samp><span class="file">src/contrib</span></samp> 디렉토리는 R의 모든 바이너리 배포에 포함되어질 <em>recommended</em>(추천) 패키지들을 포함하여 방대한 양의 애드온 패키지들을 포함하고 있습니다.

<!-- <FIXME> -->
<!-- 3.0.0 -->
     <dl>
<dt><strong>KernSmooth</strong><dd><!-- Functions for kernel smoothing (and density estimation) corresponding to -->
<!-- the book ``Kernel Smoothing'' by M. P. Wand and M. C. Jones, 1995. -->
1995년에 M. P. Wand와 M. C. Jones에 의해 쓰여진 책 &ldquo;Kernel Smoothing&rdquo;을 바탕으로 한 Kernel smoothing(커널스무딩 또는 커널평활법)을 위한 함수들(그리고 밀도추정)을 포함합니다.

     <br><dt><strong>MASS</strong><dd><!-- Functions and datasets from the main package of Venables and Ripley, -->
<!-- ``Modern Applied Statistics with S''. -->
<!-- (Contained in the @file{VR} bundle for R versions prior to 2.10.0.) -->
Venables 와 Ripley의 핵심 패키지 &ldquo;Modern Applied Statistics with S&rdquo;으로부터의 함수와 데이터셋들을 포함합니다 (2.10.0 이전의 R 버전들을 위한 <samp><span class="file">VR</span></samp>번들에 포함되어 있습니다).

     <br><dt><strong>Matrix</strong><dd><!-- A Matrix package. -->
<!-- (Recommended for R 2.9.0 or later.) -->
(R 2.9.0 또는 이후 버전에 권장되는) 행렬 패키지입니다.

     <br><dt><strong>boot</strong><dd><!-- Functions and datasets for bootstrapping from the book ``Bootstrap -->
<!-- Methods and Their Applications'' by A. C. Davison and D. V. Hinkley, -->
<!-- 1997, Cambridge University Press. -->
1997년에 Cambridge University Press로부터 출판된 A. C. Davison과 D. V. Hinkley에 의해 쓰여진 &ldquo;Bootstrap Methods and Their Applications&rdquo;이라는 책으로부터 부츠트랩핑(bootstrapping)에 이용된 함수들과 데이터셋들을 포함하고 있습니다.

     <br><dt><strong>class</strong><dd><!-- Functions for classification (@math{k}-nearest neighbor and LVQ). -->
<!-- (Contained in the @file{VR} bundle for R versions prior to 2.10.0.) -->
(k-nearest neighbor와 LVQ 같은) 클래시피케이션에 사용되는 함수들을 포함하고 있습니다 (2.10.0 이전의 R 버전들에는 <samp><span class="file">VR</span></samp> 번들내에 포함되어 있었습니다).

     <br><dt><strong>cluster</strong><dd><!-- Functions for cluster analysis. -->
클러스터 분석(cluster analysis)를 위한 함수들이 포함되어 있습니다.

     <br><dt><strong>codetools</strong><dd><!-- Code analysis tools. -->
<!-- (Recommended for R 2.5.0 or later.) -->
(R 2.5.0 또는 그 이후의 버전들에 추천되는) 코드 분석 도구들이 포함되어 있습니다.

     <br><dt><strong>foreign</strong><dd><!-- Functions for reading and writing data stored by statistical software -->
<!-- like Minitab, S, SAS, SPSS, Stata, Systat, etc. -->
Minitab, S, SAS, SPSS, Stata, Systat등과 같은 통계 소프트웨어에 의해 저장된 데이터르르 읽고 쓰는데 필요한 함수들이 포함되어 있습니다.

     <br><dt><strong>lattice</strong><dd><!-- Lattice graphics, an implementation of Trellis Graphics functions. -->
트렐리스(Trellis) 그래픽 함수들의 구현체인 라띠스(lattice) 그래픽스가 포함되어 있습니다.

     <br><dt><strong>mgcv</strong><dd><!-- Routines for GAMs and other generalized ridge regression problems with -->
<!-- multiple smoothing parameter selection by GCV or UBRE. -->
GCV 또는 UBRE을 이용한 multiple soomthing parameter selection을 포함한 GAM 그리고 다른 generalized ridge regression 문제들을 위한 루틴들이 포함되어 있습니다.

     <br><dt><strong>nlme</strong><dd><!-- Fit and compare Gaussian linear and nonlinear mixed-effects models. -->
가우시안(Gaussian) 선형과 비선형의 혼합 모델들(linear and nonlinear mixed-effects models)을 적합하고 비교하는 함수들이 포함되어 있습니다.

     <br><dt><strong>nnet</strong><dd><!-- Software for single hidden layer perceptrons (``feed-forward neural -->
<!-- networks''), and for multinomial log-linear models. -->
<!-- (Contained in the @file{VR} bundle for R versions prior to 2.10.0.) -->
Single hideen perceptrons (&ldquo;feed-forward neural networks&rdquo;)와 다항로그선형모델(multinomial log-linear models)을 위한 소프트웨어입니다 (2.10.0 이전의 R 버전들에서는 <samp><span class="file">VR</span></samp> 번들내에 포함되어 있었습니다).

     <br><dt><strong>rpart</strong><dd><!-- Recursive PARTitioning and regression trees. -->
재귀적 파티셔닝(recursive partioning)과 회귀나무(regression trees)를 수행하는 함수들이 포함되어 있습니다.

     <br><dt><strong>spatial</strong><dd><!-- Functions for kriging and point pattern analysis from ``Modern Applied -->
<!-- Statistics with S'' by W. Venables and B. Ripley. -->
<!-- (Contained in the @file{VR} bundle for R versions prior to 2.10.0.) -->
W. Venables와 B. Ripley에 의하여 씌여진 &ldquo;Modern Applied Statistics with S&rdquo;으로부터 크리깅과 포인트 패턴분석 (kriging and point pattern analysis)를 위한 함수들이 포함되어 있습니다 (2.10.0 이전의 R 버전들에서는 <samp><span class="file">VR</span></samp> 번들내에 포함되어 있었습니다).

     <br><dt><strong>survival</strong><dd><!-- Functions for survival analysis, including penalized likelihood. -->
벌점가능성 함수(penalized likelihood)함수를 포함한 생존분석(survival analysis)에 필요한 함수들을 포함하고 있습니다. 
</dl>
   <!-- </FIXME> -->

<!-- See the @url{http://CRAN.R-project.org/web/packages/, , @CRAN{} -->
<!-- contributed packages page} for more information. -->
   <p>더 많은 정보를 정보를 <a href="http://CRAN.R-project.org/web/packages/"><acronym>CRAN</acronym> contributed packages page</a>에서 찾을 수 있습니다.

<!-- Many of these packages are categorized into -->
<!-- @url{http://CRAN.R-project.org/web/views/, @CRAN{} Task Views}, allowing -->
<!-- to browse packages by topic and providing tools to automatically install -->
<!-- all packages for special areas of interest. -->
   <p>많은 패키지들이 주제별로 검색이 가능하고 특정 주제에 대한 모든 패키지들을 자동적으로 설치할 수 있는 도구를 제공해주는 <a href="http://CRAN.R-project.org/web/views/"><acronym>CRAN</acronym> Task Views</a>내에 정리되어 있습니다.

<!-- Some @CRAN{} packages that do not build out of the box on Windows, -->
<!-- require additional software, or are shipping third party libraries for -->
<!-- Windows cannot be made available on @CRAN{} in form of a Windows binary -->
<!-- packages.  Nevertheless, some of these packages are available at the -->
<!-- ``@CRAN{} extras'' repository at -->
<!-- @url{http://www.stats.ox.ac.uk/pub/RWin/} kindly provided by Brian -->
<!-- D. Ripley.  Note that this repository is a default repository for recent -->
<!-- versions of R for Windows. -->
   <p>Windows에서 특수하게 빌드되어지지 않거나, 추가적인 소프트웨어를 필요로 하거나, 또는 Windows에 제삼의 라이브러리를 구입해야하는 일부 <acronym>CRAN</acronym>패키지들은 Windows 바이너리 패키지의 형태로 이용할 수 없습니다. 
그럼에도 불구하고, 이러한 패키지들의 일부는 Brian D. Ripley에 의하여 친절하게 제공되어지는 &ldquo;<acronym>CRAN</acronym> extras&rdquo; 저장소 <a href="http://www.stats.ox.ac.uk/pub/RWin/">http://www.stats.ox.ac.uk/pub/RWin/</a>로부터 얻을 수 있습니다. 
이 저장소는 Windows를 위한 최근의 R 버전들을 위한 기본저장소입니다.

<div class="node">
<a name="Add-on-packages-from-Omegahat"></a>
<a name="Add_002don-packages-from-Omegahat"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Add_002don-packages-from-Bioconductor">Add-on packages from Bioconductor</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Add_002don-packages-from-CRAN">Add-on packages from CRAN</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Which-add_002don-packages-exist-for-R_003f">Which add-on packages exist for R?</a>

</div>

<!-- @subsection Add-on packages from Omegahat -->
<h4 class="subsection">5.1.3 Omegahat으로부터의 애드온 패키지들</h4>

<!-- The @url{http://www.omegahat.org/, Omega Project for Statistical -->
<!-- Computing} provides a variety of open-source software for statistical -->
<!-- applications, with special emphasis on web-based software, Java, the -->
<!-- Java virtual machine, and distributed computing.  A @acronym{CRAN} style -->
<!-- R package repository is available via @url{http://www.omegahat.org/R/}. -->
<!-- See @url{http://www.omegahat.org/} for information on most R packages -->
<!-- available from the Omega project. -->
<p><a href="http://www.omegahat.org/">Omega Project for Statistical Computing</a>은 웹기반의 소프트웨어에 특별한 주안점을 두고 있는 통계 어플리케이션, Java, Java 버츄얼 머신, 그리고 분산 컴퓨팅(distributed computing)을 위한 다양한 오픈소스 소프트웨어를 제공하고 있습니다. 
<acronym>CRAN</acronym> 스타일의 R 패키지 저장소는 <a href="http://www.omegahat.org/R/">http://www.omegahat.org/R/</a>를 통하여 이용할 수 있습니다. 
Omega project로부터 가능한 대부분의 R 패키지들에 대한 정보는 <a href="http://www.omegahat.org/">http://www.omegahat.org/</a>에서 찾을 수 있습니다.

<div class="node">
<a name="Add-on-packages-from-Bioconductor"></a>
<a name="Add_002don-packages-from-Bioconductor"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Other-add_002don-packages">Other add-on packages</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Add_002don-packages-from-Omegahat">Add-on packages from Omegahat</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Which-add_002don-packages-exist-for-R_003f">Which add-on packages exist for R?</a>

</div>

<!-- @subsection Add-on packages from Bioconductor -->
<h4 class="subsection">5.1.4 Bioconductor로부터의 애드온 패키지들</h4>

<!-- @url{http://www.bioconductor.org/, Bioconductor} is an open source and -->
<!-- open development software project for the analysis and comprehension of -->
<!-- genomic data.  Most Bioconductor components are distributed as R add-on -->
<!-- packages.  Initially most of the -->
<!-- @url{http://www.bioconductor.org/packages/bioc/, Bioconductor software -->
<!-- packages} focused primarily on DNA microarray data analysis.  As the -->
<!-- project has matured, the functional scope of the software packages -->
<!-- broadened to include the analysis of all types of genomic data, such as -->
<!-- SAGE, sequence, or SNP data.  In addition, there are metadata -->
<!-- (annotation, CDF and probe) and experiment data packages.  See -->
<!-- @url{http://www.bioconductor.org/download/} for available packages and a -->
<!-- complete taxonomy via BioC Views. -->
<p><a href="http://www.bioconductor.org/">Bioconductor</a>는 오픈소스이며 게놈 데이터의 분석과 이해를 위한 오픈 개발 소프트웨어 프로젝트입니다. 
대부분의 Bioconductor 구성요소들은 R 애드온 패키지들과 같이 배포됩니다. 
대부분의 <a href="http://www.bioconductor.org/packages/bioc/">Bioconductor software packages</a>들은 주로 DNA 마이크로어레이(microarray) 데이터 분석에 주력하였습니다. 
프로젝트가 점점 발전하게 되면서, SAGE, sqeuence, 또는 SNP 데이터와 같은 모든 종류의 게놈 데이터 분석을 포함한 소프트웨어 패키지들의 기능적 범위가 넓어지게 되었습니다. 
게다가 메타데이터(annotation, CDF, 그리고 probe)들과 실험데이터(experiment data) 패키지들도 존재합니다. 
이용 가능한 패키지들과 BioC View를 통한 완전한 분류체계를 위해서는 <a href="http://www.bioconductor.org/download/">http://www.bioconductor.org/download/</a>를 살펴보세요.

<div class="node">
<a name="Other-add-on-packages"></a>
<a name="Other-add_002don-packages"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Add_002don-packages-from-Bioconductor">Add-on packages from Bioconductor</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Which-add_002don-packages-exist-for-R_003f">Which add-on packages exist for R?</a>

</div>

<!-- @subsection Other add-on packages -->
<h4 class="subsection">5.1.5 다른 애드온 패키지들</h4>

<!-- Many more packages are available from places other than the three -->
<!-- default repositories discussed above (@CRAN{}, Bioconductor and -->
<!-- Omegahat).  In particular, R-Forge provides a @CRAN{} style repository -->
<!-- at @url{http://R-Forge.R-project.org/}. -->
<p>더 많은 패키지들을 위에서 언급된 세가지 기본 저장소 (<acronym>CRAN</acronym>, Bioconductor 그리고 Omegahat) 외에서도 찾을 수 있습니다. 
특히, R-Forge는 <acronym>CRAN</acronym> 스타일의 저장소 <a href="http://R-Forge.R-project.org/">http://R-Forge.R-project.org/</a>를 제공합니다.

<!-- More code has been posted to the R-help mailing list, and can be -->
<!-- obtained from the mailing list archive. -->
   <p>더 많은 코드들이 R-help 메일링 리스트에 올라오고 있으며, 메일링 리스트 보관소로부터 이들을 확인할 수 있습니다.

<div class="node">
<a name="How-can-add-on-packages-be-installed%3f"></a>
<a name="How-can-add_002don-packages-be-installed_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-add_002don-packages-be-used_003f">How can add-on packages be used?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Which-add_002don-packages-exist-for-R_003f">Which add-on packages exist for R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Add_002dOn-Packages">R Add-On Packages</a>

</div>

<!-- @section How can add-on packages be installed? -->
<h3 class="section">5.2 어떻게 애드온 패키지들을 설치할 수 있나요?</h3>

<!-- (Unix-like only.)  The add-on packages on @CRAN{} come as gzipped tar -->
<!-- files named @code{@var{pkg}_@var{version}.tar.gz}, which may in fact be -->
<!-- ``bundles'' containing more than one package.  Let @var{path} be the -->
<!-- path to such a package file.  Provided that @command{tar} and -->
<!-- @command{gzip} are available on your system, type -->
<p>(Unix와 같은 환경에서만 사용할 수 있습니다) <acronym>CRAN</acronym>의 애드온 패키지들은 실제로 한개 이상의 패키지들은 포함하는 &ldquo;bundles&rdquo;(번들)과 같이 <var>pkg</var><code>_</code><var>version</var><code>.tar.gz</code>의 이름을 가진 gzip으로 압축된 tar 파일로 제공되어집니다. 
<var>path</var>를 그러한 패키지 파일에 대한 경로라고 가정합니다. 
만약 <samp><span class="command">tar</span></samp>와 <samp><span class="command">gzip</span></samp>을 사용가능하다면, 라이브러리 검색경로 (library search path)내 첫번째 디렉토리에서 갈려져 나오는 라이브러리 트리(library tree)에 설치하고자 한다면 쉘프롬프트에서 아래와 같이 입력해 보세요. 
(검색경로가 어떻게 결정되는지에 대한 자세한 사항은 <code>.libPahts()</code>에 대한 도움말 페이지를 살펴보시길 바랍니다).

<pre class="example">     $ R CMD INSTALL <var>path</var>/<var>pkg</var>_<var>version</var>.tar.gz
</pre>
   <p class="noindent"><!-- at the shell prompt to install to the library tree rooted at the first -->
<!-- directory in your library search path (see the help page for -->
<!-- @code{.libPaths()} for details on how the search path is determined). -->

<!-- To install to another tree (e.g., your private one), use -->
   <p>다른 트리에 설치를 하려면 (즉, 사용자의 개인적인 곳), 다음의 명령어를 이용하길 바랍니다.

<pre class="example">     $ R CMD INSTALL -l <var>lib</var> <var>path</var>/<var>pkg</var>_<var>version</var>.tar.gz
</pre>
   <p class="noindent"><!-- where @var{lib} gives the path to the library tree to install to. -->
여기에서 <var>lib</var>는 설치를 하고자 하는 라이브러리 트리(library tree)에 대한 경로를 의미합니다.

<!-- Even more conveniently, you can install and automatically update -->
<!-- packages from within R if you have access to repositories such as -->
<!-- @CRAN{}.  See the help page for @code{available.packages()} for more -->
<!-- information. -->
   <p>만약 <acronym>CRAN</acronym>과 같은 저장소들에 접근할 수 있다면, 더욱 더 편리하게 사용자는 R 내에서 패키지들을 설치하고 이들을 자동으로 업데이트 할 수 있습니다. 
이에 대한 더 많은 정보들을 <code>available.packages()</code>의 도움말 페이지로부터 찾을 수 있습니다.

<!-- <COMMENT> -->
<!-- This is really no longer quite accurate (R_LIBS_USER is preferred to -->
<!-- R_LIBS), and described in ?libPaths anyways ... hence comment out. -->
<!-- You can use several library trees of add-on packages.  The easiest way -->
<!-- to tell R to use these is via the environment variable @env{R_LIBS} -->
<!-- which should be a colon-separated list of directories at which R library -->
<!-- trees are rooted.  You do not have to specify the default tree in -->
<!-- @env{R_LIBS}.  E.g., to use a private tree in @file{$HOME/lib/R} and a -->
<!-- public site-wide tree in @file{/usr/local/lib/R-contrib}, put -->
<!-- @example -->
<!-- R_LIBS="$HOME/lib/R:/usr/local/lib/R-contrib"; export R_LIBS -->
<!-- @end example -->
<!-- @noindent -->
<!-- into your (Bourne) shell profile or even preferably, add the line -->
<!-- @example -->
<!-- R_LIBS="~/lib/R:/usr/local/lib/R-contrib" -->
<!-- @end example -->
<!-- @noindent -->
<!-- your environment (e.g., @file{~/.Renviron}) file.  (Note that no -->
<!-- @code{export} statement is needed or allowed in this file; see the -->
<!-- on-line help for @code{Startup} for more information.) -->
<div class="node">
<a name="How-can-add-on-packages-be-used%3f"></a>
<a name="How-can-add_002don-packages-be-used_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-add_002don-packages-be-removed_003f">How can add-on packages be removed?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-add_002don-packages-be-installed_003f">How can add-on packages be installed?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Add_002dOn-Packages">R Add-On Packages</a>

</div>

<!-- @section How can add-on packages be used? -->
<h3 class="section">5.3 어떻게 애드온 패키지들을 이용할 수 있나요?</h3>

<!-- To find out which additional packages are available on your system, type -->
<p>사용자의 시스템에 이용이 가능한 추가적인 패키지들을 확인하기 위해서는 R 프롬프트에 아래와 같이 입력해보세요.

<pre class="example">     library()
</pre>
   <p class="noindent"><!-- at the R prompt. -->

<!-- This produces something like -->
   <p>다음과 같은 결과를 생성해 줄 것입니다.

   <blockquote>
<p><table class="cartouche" summary="cartouche" border="1"><tr><td>
<pre class="smallexample">     Packages in `/home/me/lib/R':
     
     mystuff       My own R functions, nicely packaged but not documented
     
     Packages in `/usr/local/lib/R/library':
     
     KernSmooth    Functions for kernel smoothing for Wand &amp; Jones (1995)
     MASS          Main Package of Venables and Ripley's MASS
     Matrix        Sparse and Dense Matrix Classes and Methods
     base          The R Base package
     boot          Bootstrap R (S-Plus) Functions (Canty)
     class         Functions for Classification
     cluster       Functions for clustering (by Rousseeuw et al.)
     codetools     Code Analysis Tools for R
     datasets      The R Datasets Package
     foreign       Read Data Stored by Minitab, S, SAS, SPSS, Stata, Systat,
                   dBase, ...
     grDevices     The R Graphics Devices and Support for Colours and Fonts
     graphics      The R Graphics Package
     grid          The Grid Graphics Package
     lattice       Lattice Graphics
     methods       Formal Methods and Classes
     mgcv          GAMs with GCV/AIC/REML smoothness estimation and GAMMs
                   by PQL
     nlme          Linear and Nonlinear Mixed Effects Models
     nnet          Feed-forward Neural Networks and Multinomial Log-Linear
                   Models
     rpart         Recursive Partitioning
     spatial       Functions for Kriging and Point Pattern Analysis
     splines       Regression Spline Functions and Classes
     stats         The R Stats Package
     stats4        Statistical functions using S4 Classes
     survival      Survival analysis, including penalised likelihood
     tcltk         Tcl/Tk Interface
     tools         Tools for Package Development
     utils         The R Utils Package
</pre>
   </td></tr></table>
</blockquote>

<!-- You can ``load'' the installed package @var{pkg} by -->
   <p>설치된 패키지 <var>pkg</var>를 다음과 같은 방법으로 로드할 수 있습니다.

<pre class="example">     library(<var>pkg</var>)
</pre>
   <!-- You can then find out which functions it provides by typing one of -->
   <p>어떤 함수들이 해당 패키지들로부터 제공되는지 아래에 나열된 명령어들 중 하나를 입력해봄으로서 확인할 수 있습니다.
<pre class="example">     library(help = <var>pkg</var>)
     help(package = <var>pkg</var>)
</pre>
   <!-- You can unload the loaded package @var{pkg} by -->
   <p>사용자는 다음과 같은 방법으로 패키지 <var>pkg</var>를 로드하거나 언로드 할 수 있습니다.
<pre class="example">     detach("package:<var>pkg</var>", unload = TRUE)
</pre>
   <p class="noindent"><!-- (where @code{unload = TRUE} is needed only for packages with a -->
<!-- namespace, see @code{?unload}). -->
(여기에서 <code>unload=TRUE</code>는 네임스페이스가 있는 패키지들에만 필요합니다. <code>?unload</code>를 살펴보세요).

<div class="node">
<a name="How-can-add-on-packages-be-removed%3f"></a>
<a name="How-can-add_002don-packages-be-removed_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-create-an-R-package_003f">How can I create an R package?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-add_002don-packages-be-used_003f">How can add-on packages be used?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Add_002dOn-Packages">R Add-On Packages</a>

</div>

<!-- @section How can add-on packages be removed? -->
<h3 class="section">5.4 어떻게 애드온 패키지들을 제거할 수 있나요?</h3>

<!-- Use -->
<p>아래와 같이 입력해보세요.

<pre class="example">     $ R CMD REMOVE <var>pkg_1</var> ... <var>pkg_n</var>
</pre>
   <p class="noindent"><!-- to remove the packages @var{pkg_1}, @dots{}, @var{pkg_n} from the -->
<!-- library tree rooted at the first directory given in @env{R_LIBS} if this -->
<!-- is set and non-null, and from the default library otherwise.  (Versions -->
<!-- of R prior to 1.3.0 removed from the default library by default.) -->

   <p>만약, <samp><span class="env">R_LIBS</span></samp>가 설정되어 null이 아니면, <samp><span class="env">R_LIBS</span></samp>내에 주어진 첫번째 디렉토리부터 갈려나오는 라이브러리 트리로부터 <var>pkg_1</var>, <small class="dots">...</small>, <var>pkg_n</var>을 제거합니다. 
그렇지 않다면 디폴트 라이브러리로부터 제거됩니다. 
(1.3.0 이전의 R 버전들은 기본적으로 디폴트 라이브러리로부터 제거되었습니다).

<!-- To remove from library @var{lib}, do -->
   <p>라이브러리 <var>lib</var>으로부터 제거하기 위해서는 아래와 같이 입력하세요.

<pre class="example">     $ R CMD REMOVE -l <var>lib</var> <var>pkg_1</var> ... <var>pkg_n</var>
</pre>
   <div class="node">
<a name="How-can-I-create-an-R-package%3f"></a>
<a name="How-can-I-create-an-R-package_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-contribute-to-R_003f">How can I contribute to R?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-add_002don-packages-be-removed_003f">How can add-on packages be removed?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Add_002dOn-Packages">R Add-On Packages</a>

</div>

<!-- @section How can I create an R package? -->
<h3 class="section">5.5 어떻게 R 패키지를 만들 수 있나요?</h3>

<!-- A package consists of a subdirectory containing a file -->
<!-- @file{DESCRIPTION} and the subdirectories @file{R}, @file{data}, -->
<!-- @file{demo}, @file{exec}, @file{inst}, @file{man}, @file{po}, -->
<!-- @file{src}, and @file{tests} (some of which can be missing).  The -->
<!-- package subdirectory may also contain files @file{INDEX}, -->
<!-- @file{NAMESPACE}, @file{configure}, @file{cleanup}, @file{LICENSE}, -->
<!-- @file{LICENCE}, @file{COPYING} and @file{NEWS}. -->
<p>패키지는 <samp><span class="file">DESCRIPTION</span></samp>을 포함하는 서브디렉토리와 <samp><span class="file">R</span></samp>, <samp><span class="file">data</span></samp>, <samp><span class="file">demo</span></samp>, <samp><span class="file">exec</span></samp>, <samp><span class="file">inst</span></samp>, <samp><span class="file">inst</span></samp>, <samp><span class="file">man</span></samp>, <samp><span class="file">po</span></samp>, <samp><span class="file">src</span></samp>, 그리고 <samp><span class="file">tests</span></samp>라는 서브디렉토리들로 구성되어 있습니다 (이들 중 몇가지는 빠질 수도 있습니다). 
패키지 서브디렉토리느느 또한 <samp><span class="file">INDEX</span></samp>, <samp><span class="file">NAMESPACE</span></samp>, <samp><span class="file">configure</span></samp>, <samp><span class="file">cleanup</span></samp>, <samp><span class="file">LICENSE</span></samp>, <samp><span class="file">LICENCE</span></samp>, <samp><span class="file">COPYING</span></samp>, 그리고 <samp><span class="file">NEWS</span></samp> 파일들을 포함할 수도 있습니다.

<!-- See section ``Creating R packages'' in @cite{Writing R Extensions}, for -->
<!-- details.  This manual is included in the R distribution, @pxref{What -->
<!-- documentation exists for R?}, and gives information on package -->
<!-- structure, the configure and cleanup mechanisms, and on automated -->
<!-- package checking and building. -->
   <p>더 자세한 사항은 <cite>Writing R Extensions</cite> 문서의 &ldquo;Creating R packages&rdquo; 섹션을 살펴보세요. 
이 매뉴얼은 R 배포에 포함되어 있으며 see <a href="#What-documentation-exists-for-R_003f">What documentation exists for R?</a>, 패키지의 구조, 설정(configure)과 클린업(cleanup) 메카니즘, 그리고 패키지의 확인(checking)과 구축(building)에 대한 정보를 제공합니다.

<!-- R version 1.3.0 has added the function @code{package.skeleton()} which -->
<!-- will set up directories, save data and code, and create skeleton help -->
<!-- files for a set of R functions and datasets. -->
   <p>디렉토리들을 지정하고, 데이터와 코드를 저장하며, R함수들과 데이터세들에 대한 도움말 파일들의 구조를 생성하는데 사용되는 함수 <code>package.skeleton()</code>가 R 버전 1.3.0에서 추가되었습니다.

<!-- @xref{What is CRAN?}, for information on uploading a package to @CRAN{}. -->
   <p><acronym>CRAN</acronym>에 패키지들 업로드하는 방법에 대해서는 <a href="#What-is-CRAN_003f">What is CRAN?</a>를 살펴보시길 바랍니다.

<div class="node">
<a name="How-can-I-contribute-to-R%3f"></a>
<a name="How-can-I-contribute-to-R_003f"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-create-an-R-package_003f">How can I create an R package?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Add_002dOn-Packages">R Add-On Packages</a>

</div>

<!-- @section How can I contribute to R? -->
<h3 class="section">5.6 어떻게 R에 기여할 수 있나요?</h3>

<!-- R is in active development and there is always a risk of bugs creeping -->
<!-- in.  Also, the developers do not have access to all possible machines -->
<!-- capable of running R.  So, simply using it and communicating problems is -->
<!-- certainly of great value. -->
<p>R은 활발히 개발중이므로, 버그가 생길 수 있는 위험이 항상 존재합니다. 
또한 개발자들은 R을 실행할 수 있는 모든 가능한 기계들에 대하여 접근하지 못합니다. 
따라서, 이들을 이요하면서 문제들에 대해서 알려주는 것은 대단히 큰 가치를 가지고 있습니다.

<!-- The @url{http://developer.R-project.org/, R Developer Page} acts as an -->
<!-- intermediate repository for more or less finalized ideas and plans for -->
<!-- the R statistical system.  It contains (pointers to) TODO lists, RFCs, -->
<!-- various other writeups, ideas lists, and SVN miscellanea. -->
   <p><a href="http://developer.R-project.org/">R Developer Page</a>는 더도 아니고 덜도 아니게 R 통게시스템을 위한 아이디어들과 플랜들을 위한 중간 저장소와 같이 이용됩니다. 
여기에는 TODO 목록, RFC, 다양한 기록들, 아이디어 목록, 그리고 SVN miscelanea등이 포함되어 있습니다.

<div class="node">
<a name="R-and-Emacs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#R-Miscellanea">R Miscellanea</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Add_002dOn-Packages">R Add-On Packages</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter R and Emacs -->
<h2 class="chapter">6 R과 이맥스</h2>

<ul class="menu">
<li><a accesskey="1" href="#Is-there-Emacs-support-for-R_003f">Is there Emacs support for R?</a>
<li><a accesskey="2" href="#Should-I-run-R-from-within-Emacs_003f">Should I run R from within Emacs?</a>
<li><a accesskey="3" href="#Debugging-R-from-within-Emacs">Debugging R from within Emacs</a>
</ul>

<div class="node">
<a name="Is-there-Emacs-support-for-R%3f"></a>
<a name="Is-there-Emacs-support-for-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Should-I-run-R-from-within-Emacs_003f">Should I run R from within Emacs?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-and-Emacs">R and Emacs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-and-Emacs">R and Emacs</a>

</div>

<!-- @section Is there Emacs support for R? -->
<h3 class="section">6.1 Emacs가 R을 지원하나요?</h3>

<!-- There is an Emacs package called @acronym{ESS} (``Emacs Speaks -->
<!-- Statistics'') which provides a standard interface between statistical -->
<!-- programs and statistical processes.  It is intended to provide -->
<!-- assistance for interactive statistical programming and data analysis. -->
<!-- Languages supported include: S dialects (R, S 3/4, and @SPLUS{} -->
<!-- 3.x/4.x/5.x/6.x/7.x), LispStat dialects (XLispStat, ViSta), SAS, Stata, -->
<!-- and BUGS. -->
<p>통계 프로그램들과 통계 프로세스들 간의 기본 인터페이스를 제공하는 <acronym>ESS</acronym> (&ldquo;Emacs Speaks Statistics&rdquo;) 라고 불리는 패키지가 있습니다. 
이는 통계 프로그래밍과 데이터 분석간의 쌍방향 소통을 위한 지원을 제공하는 것이 목적입니다. 
지원되는 언어는 R, S 3/4, 그리고 S-Plus 3.x/4.x/5.x/6.x/7.x 와 같은 S 계열의 언어들(dialects), XLispStat, ViSta와 같은 LispStat계열의 언어들, SAS, Stata, 그리고 BUGS가 있습니다.

<!-- @acronym{ESS} grew out of the need for bug fixes and extensions to -->
<!-- S-mode 4.8 (which was a @acronym{GNU} Emacs interface to S/@SPLUS{} -->
<!-- version 3 only).  The current set of developers desired support for -->
<!-- XEmacs, R, S4, and MS Windows.  In addition, with new modes being -->
<!-- developed for R, Stata, and SAS, it was felt that a unifying interface -->
<!-- and framework for the user interface would benefit both the user and the -->
<!-- developer, by helping both groups conform to standard Emacs usage.  The -->
<!-- end result is an increase in efficiency for statistical programming and -->
<!-- data analysis, over the usual tools. -->
   <p><acronym>ESS</acronym>는 버그 수정과  S/<span class="sc">S-Plus</span> 버전 3만을 지원하는 <acronym>GNU</acronym> Emacs 확장에 대하나 필요성에 의해서 발달하였습니다. 
현재의 개발자들은 XEmacs, R, S4, 그리고 MS Windows에 대한 지원을 갈망했습니다. 
게다가, R, Stata, 그리고 SAS를 위한 개발되어질 새로운 방식과 사용자 인터페이스에 대해서 표준 이맥스 사용법을 따르는 두개의 그룹모두를 도움으로서 인터페이스와 프레임워크를 하나로 통합하는 것이 사용자와 개발자 모두에게 도움이 된다고 느꼈습니다. 
그 결과로 일반적인 도구를 이용하는 것보다 통계 프로그래밍과 데이터 분석에 대한 능률이 증가되게 되었습니다.

<!-- R support contains code for editing R source code (syntactic indentation -->
<!-- and highlighting of source code, partial evaluations of code, loading -->
<!-- and error-checking of code, and source code revision maintenance) and -->
<!-- documentation (syntactic indentation and highlighting of source code, -->
<!-- sending examples to running @acronym{ESS} process, and previewing), -->
<!-- interacting with an inferior R process from within Emacs (command-line -->
<!-- editing, searchable command history, command-line completion of R object -->
<!-- and file names, quick access to object and search lists, transcript -->
<!-- recording, and an interface to the help system), and transcript -->
<!-- manipulation (recording and saving transcript files, manipulating and -->
<!-- editing saved transcripts, and re-evaluating commands from transcript -->
<!-- files). -->
   <p>R에 대한 지원은 R 소스코드를 편집하는데 필요한 코드 (구문적 띄어쓰기, 소스코드의 하이라이팅, 코드의 부분적 평가, 코드의 로딩과 오류 체크, 그리고 소스코드 수정 관리)과 문서화 (구문적 띄어쓰기, 소스코드의 하이라이팅, 실행 중인 <acronym>ESS</acronym> 프로세스에 예제 보내기, 그리고 미리보기), Emacs 내에서 R 프로세스와의 소통 (명령어 라인 편집, 검색이 가능한 명령어 히스토리, R 개체와 파일명에 대한 명령어 완성기능, 객체와 검색목록들에 대한 빠른 엑세스, 트랜스크립트 레코딩, 그리고 도움말과의 인터페이스), 그리고 기록의 조작 (레코딩과 트랜스크립트 파일들의 저장, 저장된 트랜스크립트의 편집과 조작, 트랜스크립 파일로부터의 명령어에 대한 재평가)를 포함합니다.

<!-- The latest stable version of @acronym{ESS} are available via @CRAN{} or -->
<!-- the @url{http://ESS.R-project.org/, ESS web page}.  The @HTML{} version -->
<!-- of the documentation can be found at @url{http://stat.ethz.ch/ESS/}. -->
   <p>가장 안정적인 버전의 <acronym>ESS</acronym>은 <acronym>CRAN</acronym> 또는 <a href="http://ESS.R-project.org/">ESS web page</a>를 통하여 얻을 수 있습니다. 
<acronym>HTML</acronym> 버전의 문서는 <a href="http://stat.ethz.ch/ESS/">http://stat.ethz.ch/ESS/</a>로부터 찾을 수 있습니다.

<!-- @acronym{ESS} comes with detailed installation instructions. -->
   <p><acronym>ESS</acronym>는 자세한 설치 사항들고 함께 주어집니다.

<!-- For help with @acronym{ESS}, send email to -->
<!-- @email{ESS-help@@stat.math.ethz.ch}. -->
   <p><acronym>ESS</acronym>에 대한 도움이 필요하다면 <a href="mailto:ESS-help@stat.math.ethz.ch">ESS-help@stat.math.ethz.ch</a>로 이메일을 보내시길 바랍니다.

<!-- Please send bug reports and suggestions on @acronym{ESS} to -->
<!-- @email{ESS-bugs@@stat.math.ethz.ch}.  The easiest way to do this from is -->
<!-- within Emacs by typing @kbd{M-x ess-submit-bug-report} or using the -->
<!-- [ESS] or [iESS] pulldown menus. -->
   <p><acronym>ESS</acronym>에 대한 버그 리포트 또는 제안사항들을 <a href="mailto:ESS-bugs@stat.math.ethz.ch">ESS-bugs@stat.math.ethz.ch</a>로 보내주세요. 
이를 위한 가장 쉬운 방법은 Emacs안에서 <kbd>M-x ess-submit-bug-report</kbd>을 입력하거나, [ESS] 또는 [iESS] 풀다운 메뉴를 이용하는 것입니다.

<div class="node">
<a name="Should-I-run-R-from-within-Emacs%3f"></a>
<a name="Should-I-run-R-from-within-Emacs_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Debugging-R-from-within-Emacs">Debugging R from within Emacs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Is-there-Emacs-support-for-R_003f">Is there Emacs support for R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-and-Emacs">R and Emacs</a>

</div>

<!-- @section Should I run R from within Emacs? -->
<h3 class="section">6.2 Emacs 안에서 R을 실행해야 하나요?</h3>

<!-- Yes, @emph{definitely}.  Inferior R mode provides a readline/history -->
<!-- mechanism, object name completion, and syntax-based highlighting of the -->
<!-- interaction buffer using Font Lock mode, as well as a very convenient -->
<!-- interface to the R help system. -->
<p>네, <em>물론입니다</em>. 
Inferior R 모드는 readline/history 메카니즘, 객체이름 완성, 폰트락모드 (Font Lock mode)를 이용한 인터랙션 버퍼(interaction buffer)의 구문강조기능, 또한 R도움말로의 편리한 인터페이스를 제공합니다.

<!-- Of course, it also integrates nicely with the mechanisms for editing R -->
<!-- source using Emacs.  One can write code in one Emacs buffer and send -->
<!-- whole or parts of it for execution to R; this is helpful for both data -->
<!-- analysis and programming.  One can also seamlessly integrate with a -->
<!-- revision control system, in order to maintain a log of changes in your -->
<!-- programs and data, as well as to allow for the retrieval of past -->
<!-- versions of the code. -->
   <p>물론, 이는 Emacs를 이용하여 R 소스를 편집하기 위한 메카니즘과도 잘 합쳐집니다. 
Emacs 버퍼에 코드를 작성하고, 전체 또는 부분을 실행하기 위해 R로 보낼 수 있습니다. 
이것은 데이터 분석과 프로그래밍에 도움이 됩니다. 
프로그램과 데이터의 변경에 대한 기록을 잘 유지하고 또한 이전 버전의 코드들을 다시 복구하기 위하여 버전관리시스템(revision control system)과도 통합할 수 있습니다.

<!-- In addition, it allows you to keep a record of your session, which can -->
<!-- also be used for error recovery through the use of the transcript mode. -->
   <p>추가로, 이는 트랜스크립트 모드(transcript mode)의 사용을 통하여 오류 복구(error recovery)에 이용될 수도 있는 세션의 기록을 보관하도록 허용합니다.

<!-- To specify command line arguments for the inferior R process, use -->
<!-- @kbd{C-u M-x R} for starting R. -->
   <p>Inferior R 프로세스를 위하여 명령어 라인 인자들을 지정하기 위해서는 <kbd>C-u M-x R</kbd>을 이용하여 R을 시작하세요.

<!-- This prompts you for the arguments; in particular, you can increase -->
<!-- the memory size this way (@pxref{Why does R run out of memory?}). -->
<!-- 이것은 인자들을 위한 프롬프트를 보여줄 것입니다. -->
<!-- 특히 사용자는 이러한 방법으로 메모리의 크기를 늘릴 수 있습니다 (@pxref{Why does R run out of memory?}). -->
<div class="node">
<a name="Debugging-R-from-within-Emacs"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Should-I-run-R-from-within-Emacs_003f">Should I run R from within Emacs?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-and-Emacs">R and Emacs</a>

</div>

<!-- @section Debugging R from within Emacs -->
<h3 class="section">6.3 Emacs내에서 R 디버깅하기</h3>

<!-- To debug R ``from within Emacs'', there are several possibilities.  To -->
<!-- use the Emacs GUD (Grand Unified Debugger) library with the recommended -->
<!-- debugger GDB, type @kbd{M-x gdb} and give the path to the R -->
<!-- @emph{binary} as argument.  At the @command{gdb} prompt, set -->
<!-- @env{R_HOME} and other environment variables as needed (using e.g.@: -->
<!-- @kbd{set env R_HOME /path/to/R/}, but see also below), and start the -->
<!-- binary with the desired arguments (e.g., @kbd{run -quiet}). -->
<p>&ldquo;from within Emacs&rdquo;(이맥스 안쪽에서) R을 디버그하기 위해서는, 몇 가지 가능성들이 있습니다. 
권장되어지는 디버거 GDB가 있는 Emacs GUD (Grand Unified Debugger) 라이브러리를 사용하기 위해서는 <kbd>M-x gdb</kbd>를 입력하고 R <em>binary</em>에 인자로서 경로를 줍니다. 
<samp><span class="command">gdb</span></samp> 프롬프트에서 <samp><span class="env">R_HOME</span></samp>과 필요하다면 다른 환경변수들 (즉, <kbd>set env R_HOME /path/to/R</kbd>을 이용하여, 그러나 아래도 살펴보세요)를 설정하고, 요구되어지는 인자들과 함께 바이너리를 시작합니다 (즉, <kbd>run --quiet</kbd>).

<!-- If you have @acronym{ESS}, you can do @kbd{C-u M-x R @key{RET} - d -->
<!-- @key{SPC} g d b @key{RET}} to start an inferior R process with arguments -->
<!-- @option{-d gdb}. -->
   <p>만약 <acronym>ESS</acronym>를 가지고 있다면, <samp><span class="option">-d gdb</span></samp> 인자와 함께 inferior R 프로세스를 실행하기 위해서 <kbd>C-u M-x R &lt;RET&gt; - d &lt;SPC&gt; g d b &lt;RET&gt;</kbd>를 할 수 있습니다.

<!-- A third option is to start an inferior R process via @acronym{ESS} -->
<!-- (@kbd{M-x R}) and then start GUD (@kbd{M-x gdb}) giving the R binary -->
<!-- (using its full path name) as the program to debug.  Use the program -->
<!-- @command{ps} to find the process number of the currently running R -->
<!-- process then use the @code{attach} command in gdb to attach it to that -->
<!-- process.  One advantage of this method is that you have separate -->
<!-- @code{*R*} and @code{*gud-gdb*} windows.  Within the @code{*R*} window -->
<!-- you have all the @acronym{ESS} facilities, such as object-name -->
<!-- completion, that we know and love. -->
   <p>세 번째 옵션은 <acronym>ESS</acronym>(<kbd>M-x R</kbd>)를 통해 inferior R 프로세스를 시작하고나서 디버그 할 프로그램 R 바이너리 (전체경로의 이름을 사용함으로서)를 주는 GUD (<kbd>M-x gdb</kbd>)를 시작합니다. 
현재 실행되고있는 R 프로세스의 프로세스 번호를 찾기 위해서 프로그램 <samp><span class="command">ps</span></samp>를 사용하고, 그 프로세스에 부착하기 위해서 gdb 내에서 <code>attach</code> 명령을 이용합니다. 
이렇게 하는 하나의 장점은 사용자가 <code>*R*</code>과 <code>*gud-gdb*</code>이라는 분리된 창을 가진다는 것입니다. 
<code>*R*</code> 창에서는 객체명완성 (object-name completion)과 같이 우리가 알고 사랑하는 모든 <acronym>ESS</acronym> 기능들이 있습니다.

<!-- When using GUD mode for debugging from within Emacs, you may find it -->
<!-- most convenient to use the directory with your code in it as the current -->
<!-- working directory and then make a symbolic link from that directory to -->
<!-- the R binary.  That way @file{.gdbinit} can stay in the directory with -->
<!-- the code and be used to set up the environment and the search paths for -->
<!-- the source, e.g.@: as follows: -->
   <p>Emacs 내에서 디버깅을 위하여 GUD 모드를 사용할 떄, 코드가 들어있는 디렉토리를 현재의 작업디렉토리로 사용하고 이로부터 R 바이너리에 심볼릭 링크(symbolic link)를 만드는 것이 가장 편리하다는 것을 아마도 알게 될 수도 있습니다. 
그렇게 하면 다음의 예제에서 보이는 바와 같이 <samp><span class="file">.gdbinit</span></samp>는 코드와 함께 디렉토리 안에 계속 있고, 소스에 대한 환경과 검색경로들을 설정하는데 사용될 수 있습니다.

<pre class="example">     set env R_HOME /opt/R
     set env R_PAPERSIZE letter
     set env R_PRINTCMD lpr
     dir /opt/R/src/appl
     dir /opt/R/src/main
     dir /opt/R/src/nmath
     dir /opt/R/src/unix
</pre>
   <div class="node">
<a name="R-Miscellanea"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#R-Programming">R Programming</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-and-Emacs">R and Emacs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter R Miscellanea -->
<h2 class="chapter">7 R Miscellanea</h2>

<ul class="menu">
<li><a accesskey="1" href="#How-can-I-set-components-of-a-list-to-NULL_003f">How can I set components of a list to NULL?</a>
<li><a accesskey="2" href="#How-can-I-save-my-workspace_003f">How can I save my workspace?</a>
<li><a accesskey="3" href="#How-can-I-clean-up-my-workspace_003f">How can I clean up my workspace?</a>
<li><a accesskey="4" href="#How-can-I-get-eval_0028_0029-and-D_0028_0029-to-work_003f">How can I get eval() and D() to work?</a>
<li><a accesskey="5" href="#Why-do-my-matrices-lose-dimensions_003f">Why do my matrices lose dimensions?</a>
<li><a accesskey="6" href="#How-does-autoloading-work_003f">How does autoloading work?</a>
<li><a accesskey="7" href="#How-should-I-set-options_003f">How should I set options?</a>
<li><a accesskey="8" href="#How-do-file-names-work-in-Windows_003f">How do file names work in Windows?</a>
<li><a accesskey="9" href="#Why-does-plotting-give-a-color-allocation-error_003f">Why does plotting give a color allocation error?</a>
<li><a href="#How-do-I-convert-factors-to-numeric_003f">How do I convert factors to numeric?</a>
<li><a href="#Are-Trellis-displays-implemented-in-R_003f">Are Trellis displays implemented in R?</a>
<li><a href="#What-are-the-enclosing-and-parent-environments_003f">What are the enclosing and parent environments?</a>
<li><a href="#How-can-I-substitute-into-a-plot-label_003f">How can I substitute into a plot label?</a>
<li><a href="#What-are-valid-names_003f">What are valid names?</a>
<li><a href="#Are-GAMs-implemented-in-R_003f">Are GAMs implemented in R?</a>
<li><a href="#Why-is-the-output-not-printed-when-I-source_0028_0029-a-file_003f">Why is the output not printed when I source() a file?</a>
<li><a href="#Why-does-outer_0028_0029-behave-strangely-with-my-function_003f">Why does outer() behave strangely with my function?</a>
<li><a href="#Why-does-the-output-from-anova_0028_0029-depend-on-the-order-of-factors-in-the-model_003f">Why does the output from anova() depend on the order of factors in the model?</a>
<li><a href="#How-do-I-produce-PNG-graphics-in-batch-mode_003f">How do I produce PNG graphics in batch mode?</a>
<li><a href="#How-can-I-get-command-line-editing-to-work_003f">How can I get command line editing to work?</a>
<li><a href="#How-can-I-turn-a-string-into-a-variable_003f">How can I turn a string into a variable?</a>
<li><a href="#Why-do-lattice_002ftrellis-graphics-not-work_003f">Why do lattice/trellis graphics not work?</a>
<li><a href="#How-can-I-sort-the-rows-of-a-data-frame_003f">How can I sort the rows of a data frame?</a>
<li><a href="#Why-does-the-help_002estart_0028_0029-search-engine-not-work_003f">Why does the help.start() search engine not work?</a>
<li><a href="#Why-did-my-_002eRprofile-stop-working-when-I-updated-R_003f">Why did my .Rprofile stop working when I updated R?</a>
<li><a href="#Where-have-all-the-methods-gone_003f">Where have all the methods gone?</a>
<li><a href="#How-can-I-create-rotated-axis-labels_003f">How can I create rotated axis labels?</a>
<li><a href="#Why-is-read_002etable_0028_0029-so-inefficient_003f">Why is read.table() so inefficient?</a>
<li><a href="#What-is-the-difference-between-package-and-library_003f">What is the difference between package and library?</a>
<li><a href="#I-installed-a-package-but-the-functions-are-not-there">I installed a package but the functions are not there</a>
<li><a href="#Why-doesn_0027t-R-think-these-numbers-are-equal_003f">Why doesn't R think these numbers are equal?</a>
<li><a href="#How-can-I-capture-or-ignore-errors-in-a-long-simulation_003f">How can I capture or ignore errors in a long simulation?</a>
<li><a href="#Why-are-powers-of-negative-numbers-wrong_003f">Why are powers of negative numbers wrong?</a>
<li><a href="#How-can-I-save-the-result-of-each-iteration-in-a-loop-into-a-separate-file_003f">How can I save the result of each iteration in a loop into a separate file?</a>
<li><a href="#Why-are-p_002dvalues-not-displayed-when-using-lmer_0028_0029_003f">Why are p-values not displayed when using lmer()?</a>
<li><a href="#Why-are-there-unwanted-borders">Why are there unwanted borders</a>
<li><a href="#Why-does-backslash-behave-strangely-inside-strings_003f">Why does backslash behave strangely inside strings?</a>
<li><a href="#How-can-I-put-error-bars-or-confidence-bands-on-my-plot_003f">How can I put error bars or confidence bands on my plot?</a>
<li><a href="#How-do-I-create-a-plot-with-two-y_002daxes_003f">How do I create a plot with two y-axes?</a>
<li><a href="#How-do-I-access-the-source-code-for-a-function_003f">How do I access the source code for a function?</a>
<li><a href="#Why-does-summary_0028_0029-report-strange-results-for-the-R_005e2-estimate-when-I-fit-a-linear-model-with-no-intercept_003f">Why does summary() report strange results for the R^2 estimate when I fit a linear model with no intercept?</a>
<li><a href="#Why-is-R-apparently-not-releasing-memory_003f">Why is R apparently not releasing memory?</a>
</ul>

<!-- @node Why does R run out of memory?, Why does sourcing a correct file fail?, R Miscellanea, R Miscellanea -->
<!-- @section Why does R run out of memory? -->
<!-- Versions of R prior to 1.2.0 used a @emph{static} memory model.  At -->
<!-- startup, R asked the operating system to reserve a fixed amount of -->
<!-- memory for it.  The size of this chunk could not be changed -->
<!-- subsequently.  Hence, it could happen that not enough memory was -->
<!-- allocated, e.g., when trying to read large data sets into R.  In such -->
<!-- cases, it was necessary to restart R with more memory available, as -->
<!-- controlled by the command line options @option{-nsize} and -->
<!-- @option{-vsize}. -->
<!-- R version 1.2.0 introduces a new ``generational'' garbage collector, -->
<!-- which will increase the memory available to R as needed.  Hence, user -->
<!-- intervention is no longer necessary for ensuring that enough memory is -->
<!-- available. -->
<!-- The new garbage collector does not move objects in memory, meaning that -->
<!-- it is possible for the free memory to become fragmented so that large -->
<!-- objects cannot be allocated even when there is apparently enough memory -->
<!-- for them. -->
<!-- @node Why does sourcing a correct file fail?, How can I set components of a list to NULL?, Why does R run out of memory?, R Miscellanea -->
<!-- @section Why does sourcing a correct file fail? -->
<!-- Versions of R prior to 1.2.1 may have had problems parsing files not -->
<!-- ending in a newline.  Earlier R versions had a similar problem when -->
<!-- reading in data files.  This should no longer happen. -->
<div class="node">
<a name="How-can-I-set-components-of-a-list-to-NULL%3f"></a>
<a name="How-can-I-set-components-of-a-list-to-NULL_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-save-my-workspace_003f">How can I save my workspace?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Miscellanea">R Miscellanea</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I set components of a list to NULL? -->
<h3 class="section">7.1 어떻게 해야 리스트(list)의 구성요소들을 NULL로 지정할 수 있나요?</h3>

<!-- You can use -->
<p>다음과 같이 할 수 있습니다.
<pre class="example">     x[i] &lt;- list(NULL)
</pre>
   <p class="noindent"><!-- to set component @code{i} of the list @code{x} to @code{NULL}, similarly -->
<!-- for named components.  Do not set @code{x[i]} or @code{x[[i]]} to -->
<!-- @code{NULL}, because this will remove the corresponding component from -->
<!-- the list. -->
이렇게 하는 것은 리스트 <code>x</code>의 <code>i</code>번째 구성요소를 <code>NULL</code>로 지정하게 해줍니다. 
동일한 방식이 구성요소의 이름을 이용할 때도 적용됩니다. 
그러나, <code>x[i]</code> 또는 <code>x[[i]]</code>를 <code>NULL</code>의 값을 대입하지는 마시길 바랍니다. 
그 이유는 이러한 대입은 해당 구성요소 자체를 리스트로부터 삭제합니다.

<!-- For dropping the row names of a matrix @code{x}, it may be easier to use -->
<!-- @code{rownames(x) <- NULL}, similarly for column names. -->
   <p>행렬 <code>x</code>의 행의 이름들을 없애기 위해서는 <code>rownames(x) &lt;- NULL</code>를 하세요. 
이러한 방법은 열의 이름들을 없애는데에도 유사하게 적용됩니다.

<div class="node">
<a name="How-can-I-save-my-workspace%3f"></a>
<a name="How-can-I-save-my-workspace_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-clean-up-my-workspace_003f">How can I clean up my workspace?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-set-components-of-a-list-to-NULL_003f">How can I set components of a list to NULL?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I save my workspace? -->
<h3 class="section">7.2 어떻게 하면 현재 나의 작업공간을 저장할 수 있나요?</h3>

<!-- @code{save.image()} saves the objects in the user's @code{.GlobalEnv} to -->
<!-- the file @file{.RData} in the R startup directory.  (This is also what -->
<!-- happens after @kbd{q("yes")}.)  Using @code{save.image(@var{file})} one -->
<!-- can save the image under a different name. -->
<p><code>save.image()</code> 함수는 사용자의 <code>.GlobalEnv</code>에 있는 객체들을 <samp><span class="file">.RData</span></samp>의 형식으로 R의 스타트업 디렉토리에 저장합니다. (이것은 <kbd>q("yes")</kbd>라고 하는 것과 동일합니다). 
<code>save.image(</code><var>file</var><code>)</code>을 이용하여 다른 이름으로 저장하는 할 수도 있습니다.

<div class="node">
<a name="How-can-I-clean-up-my-workspace%3f"></a>
<a name="How-can-I-clean-up-my-workspace_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-get-eval_0028_0029-and-D_0028_0029-to-work_003f">How can I get eval() and D() to work?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-save-my-workspace_003f">How can I save my workspace?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I clean up my workspace? -->
<h3 class="section">7.3 어떻게 해야 나의 작업공간을 깨끗하게 비울 수 있나요?</h3>

<!-- To remove all objects in the currently active environment (typically -->
<!-- @code{.GlobalEnv}), you can do -->
<p>현재 활성화 되어있는 프로그래밍 환경 (주로 <code>.GlobalEnv</code>를 의미함)에 있는 모든 객체를 지우려고 한다면 다음과 같이 하면 됩니다.

<pre class="example">     rm(list = ls(all = TRUE))
</pre>
   <p class="noindent"><!-- (Without @option{all = TRUE}, only the objects with names not starting -->
<!-- with a @samp{.} are removed.) -->
(만약 <samp><span class="option">all = TRUE</span></samp>을 사용하지 않는다면, &lsquo;<samp><span class="samp">.</span></samp>&rsquo;으로 시작하지 않는 객체들만이 삭제됩니다.)

<div class="node">
<a name="How-can-I-get-eval()-and-D()-to-work%3f"></a>
<a name="How-can-I-get-eval_0028_0029-and-D_0028_0029-to-work_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-do-my-matrices-lose-dimensions_003f">Why do my matrices lose dimensions?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-clean-up-my-workspace_003f">How can I clean up my workspace?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I get eval() and D() to work? -->
<h3 class="section">7.4 어떻게 해야 eval()와 D()가 제대로 작동하나요?</h3>

<!-- Strange things will happen if you use @code{eval(print(x), envir = e)} -->
<!-- or @code{D(x^2, "x")}.  The first one will either tell you that -->
<!-- "@code{x}" is not found, or print the value of the wrong @code{x}. -->
<!-- The other one will likely return zero if @code{x} exists, and an error -->
<!-- otherwise. -->
<p>만약 <code>eval(print(x), envir = e)</code> 또는 <code>D(x^2, "x")</code>를 실행하고자 한다면 예상치 않은 결과가 나타날 것입니다. 
전자는 "<code>x</code>"를 찾을 수 없다고 하거나, 잘못된 <code>x</code>의 값을 출력할 것입니다. 
후자는 만약 <code>x</code>가 존재한다면 0값을 돌려줄 수 있으며, 그렇지 않다면 에러를 보여줄 것입니다.

<!-- This is because in both cases, the first argument is evaluated in the -->
<!-- calling environment first.  The result (which should be an object of -->
<!-- mode @code{"expression"} or @code{"call"}) is then evaluated or -->
<!-- differentiated.  What you (most likely) really want is obtained by -->
<!-- ``quoting'' the first argument upon surrounding it with -->
<!-- @code{expression()}.  For example, -->
   <p>두가지 경우 모두 다 불러들어온 환경 내에서 첫번째 인자가 평가되기 때문입니다. 
객체의 모드가 반드시 <code>"expression"</code> 또는 <code>"call"</code>이어야 하고 그 결과가 평가되거나 미분된 것입니다. 
이를 해결하기 위해서는 아래와 같이 반드시 첫번째 인자를 큰 따옴표로 묶어줘야 한다는것입니다.

<pre class="example">     R&gt; D(expression(x^2), "x")
     2 * x
</pre>
   <!-- Although this behavior may initially seem to be rather strange, is -->
<!-- perfectly logical.  The ``intuitive'' behavior could easily be -->
<!-- implemented, but problems would arise whenever the expression is -->
<!-- contained in a variable, passed as a parameter, or is the result of a -->
<!-- function call.  Consider for instance the semantics in cases like -->
   <p>이렇게 하는 것이 처음에는 다소 이상해 보일 수 있으나, 이것은 논리적으로인 것 뿐입니다. 
직관적으로 작동하는 방식은 구현하기 쉬울 수도 있지만, 인자로서 변수를 포함하는 표현식 또는 호출하는 함수의 결과는 문제를 야기합니다. 
예를들면, 다음과 같은 경우들입니다.

<pre class="example">     D2 &lt;- function(e, n) D(D(e, n), n)
</pre>
   <p class="noindent"><!-- or -->

   <p>또는
<pre class="example">     g &lt;- function(y) eval(substitute(y), sys.frame(sys.parent(n = 2)))
     g(a * b)
</pre>
   <!-- See the help page for @code{deriv()} for more examples. -->
   <p>더 많은 예제들을 <code>deriv()</code>의 도움말 페이지를 통하여 확인할 수 있습니다.

<div class="node">
<a name="Why-do-my-matrices-lose-dimensions%3f"></a>
<a name="Why-do-my-matrices-lose-dimensions_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-does-autoloading-work_003f">How does autoloading work?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-get-eval_0028_0029-and-D_0028_0029-to-work_003f">How can I get eval() and D() to work?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why do my matrices lose dimensions? -->
<h3 class="section">7.5 왜 행렬이 차원정보를 잃어버리게 되나요?</h3>

<!-- When a matrix with a single row or column is created by a subscripting -->
<!-- operation, e.g., @code{row <- mat[2, ]}, it is by default turned into a -->
<!-- vector.  In a similar way if an array with dimension, say, @w{2 x 3 x 1 -->
<!-- x 4} is created by subscripting it will be coerced into a @w{2 x 3 x 4} -->
<!-- array, losing the unnecessary dimension.  After much discussion this has -->
<!-- been determined to be a @emph{feature}. -->
<p>하나의 열이나 행으로 이루어진 행렬은 서브스크립팅 연산(subscripting operation)에 의해 생성됩니다. 
예를들면 <code>row &lt;- mat[2,]</code>과 같습니다. 
이는 기본적으로 벡터로 변환됩니다. 
이와 유사하게 2&nbsp;x&nbsp;3&nbsp;x&nbsp;1&nbsp;x&nbsp;4<!-- /@w -->이라는 차원을 가고 있는 배열을 서브스크립팅에 의해서 생성되어진다고 하면, 불필요한 차원을 삭제되어 2&nbsp;x&nbsp;3&nbsp;x&nbsp;4<!-- /@w -->이라는 차원을 가진 배열로 강제변환이 되게 됩니다. 
많은 논의를 거쳐 이는 <em>feature</em>로 결정되었습니다.

<!-- To prevent this happening, add the option @option{drop = FALSE} to the -->
<!-- subscripting.  For example, -->
   <p>이러한 경우를 방지하기 위해는 서브스크립팅을 할 때 <samp><span class="option">drop=FALSE</span></samp>를 사용해보세요.

<pre class="example">     rowmatrix &lt;- mat[2, , drop = FALSE]  # <span class="roman">행 벡터를 생성합니다</span>
     colmatrix &lt;- mat[, 2, drop = FALSE]  # <span class="roman">열 벡터를 생성합니다</span>
     a &lt;- b[1, 1, 1, drop = FALSE]        # <span class="roman">1 x 1 x 1 인 배열이 생성됩니다</span>
</pre>
   <!-- The @option{drop = FALSE} option should be used defensively when -->
<!-- programming.  For example, the statement -->
   <p><samp><span class="option">drop = FALSE</span></samp> 옵션은 프로그래밍을 할 때에 디펜시브하게(defensively) 사용되어야만 합니다. 
예를들어, 다음과 같은 표현에서 <code>index</code>의 길이가 1 이라면 행렬이 아닌 벡터를 반환하므로 에러를 불러일으킬 것입니다.

<pre class="example">     somerows &lt;- mat[index, ]
</pre>
   <p class="noindent"><!-- will return a vector rather than a matrix if @code{index} happens to -->
<!-- have length 1, causing errors later in the code.  It should probably be -->
<!-- rewritten as -->
이것은 아래와 같이 쓰여야 할 것입니다.

<pre class="example">     somerows &lt;- mat[index, , drop = FALSE]
</pre>
   <div class="node">
<a name="How-does-autoloading-work%3f"></a>
<a name="How-does-autoloading-work_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-should-I-set-options_003f">How should I set options?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-do-my-matrices-lose-dimensions_003f">Why do my matrices lose dimensions?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How does autoloading work? -->
<h3 class="section">7.6 자동 로딩은 어떻게 이루어지는 것인가요?</h3>

<!-- R has a special environment called @code{.AutoloadEnv}.  Using -->
<!-- @kbd{autoload(@var{name}, @var{pkg})}, where @var{name} and -->
<!-- @var{pkg} are strings giving the names of an object and the package -->
<!-- containing it, stores some information in this environment.  When R -->
<!-- tries to evaluate @var{name}, it loads the corresponding package -->
<!-- @var{pkg} and reevaluates @var{name} in the new package's -->
<!-- environment. -->
<p>R은 <code>.AutoloadEnv</code>이라고 불리는 특별한 환경(environment)가 있습니다. 
<var>name</var>과  <var>pkg</var>가 객체의 이름과 이를 포함하는 패키지를 건네주는 문자열(string)인 곳에서 <kbd>autoload(</kbd><var>name</var><kbd>, </kbd><var>pkg</var><kbd>)</kbd>를 이용하여 이 환경내에 정보를 저장하게 됩니다. 
R이 <var>name</var>을 평가하려고 할때, 이에 해당하는 패키지 <var>pkg</var>를 로드하고 새로운 패키지의 환경내에서 <var>name</var>을 재 평가합니다.

<!-- Using this mechanism makes R behave as if the package was loaded, but -->
<!-- does not occupy memory (yet). -->
   <p>이러한 메카니즘을 이용하여 R은 만약 패키지가 로드되었더라도 (아직) 메모리를 차지않는 것과 같이 작동하도록 합니다.

<!-- See the help page for @code{autoload()} for a very nice example. -->
   <p>매우 좋은 예제들이 <code>autoload()</code> 도움말에 있으므로 살펴보시길 바랍니다.

<div class="node">
<a name="How-should-I-set-options%3f"></a>
<a name="How-should-I-set-options_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-file-names-work-in-Windows_003f">How do file names work in Windows?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-does-autoloading-work_003f">How does autoloading work?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How should I set options? -->
<h3 class="section">7.7 옵션들을 어떻게 조정할 수 있나요?</h3>

<!-- The function @code{options()} allows setting and examining a variety of -->
<!-- global ``options'' which affect the way in which R computes and displays -->
<!-- its results.  The variable @code{.Options} holds the current values of -->
<!-- these options, but should never directly be assigned to unless you want -->
<!-- to drive yourself crazy-simply pretend that it is a ``read-only'' -->
<!-- variable. -->
<p>함수 <code>options()</code>는 R이 연산을 수행하고 이의 결과를 보여주는데 방법들에 있어서 영향을 미치는 다양한 전역(global) 옵션들을 설정하고 확인하도록 해줍니다. 
<code>.Options</code>의 값은 이러한 옵션들의 현재 값을 가지고 있으나, 만약 당신이 미쳐버리고 싶지 않다면 (unless you want to drive yourself crazy) 가급적이면 이를 &ldquo;read-only&rdquo;(읽기 전용)으로 두고, 직접적으로 조절하지 마시길 바랍니다.

<!-- For example, given -->
   <p>예를들어, 아래의 예를 살펴보세요.

<pre class="example">     test1 &lt;- function(x = pi, dig = 3) {
       oo &lt;- options(digits = dig); on.exit(options(oo));
       cat(.Options$digits, x, "\n")
     }
     test2 &lt;- function(x = pi, dig = 3) {
       .Options$digits &lt;- dig
       cat(.Options$digits, x, "\n")
     }
</pre>
   <p class="noindent"><!-- we obtain: -->
위의 예제로부터 우리는 아래의 결과를 얻을 것입니다.

<pre class="example">     R&gt; test1()
     3 3.14
     R&gt; test2()
     3 3.141593
</pre>
   <!-- What is really used is the @emph{global} value of @code{.Options}, and -->
<!-- using @kbd{options(OPT = VAL)} correctly updates it.  Local copies of -->
<!-- @code{.Options}, either in @code{.GlobalEnv} or in a function -->
<!-- environment (frame), are just silently disregarded. -->
   <p>실제로 쓰여지는 것은 <code>.Options</code>가 가지고 있는 <em>global</em>(전역)값이며, <kbd>options(OPT=VAL)</kbd>을 이용하여 이를 정확하게 업데이트 합니다. 
<code>.GlobalEnv</code> 또는 함수환경 (function frame, 즉 frame)내에 있는 <code>.Options</code>내의 로컬카피(local copies)들은 조용히 무시될 것입니다.

<div class="node">
<a name="How-do-file-names-work-in-Windows%3f"></a>
<a name="How-do-file-names-work-in-Windows_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-does-plotting-give-a-color-allocation-error_003f">Why does plotting give a color allocation error?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-should-I-set-options_003f">How should I set options?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How do file names work in Windows? -->
<h3 class="section">7.8 Windows에서 파일명은 어떻게 작동하나요?</h3>

<!-- As R uses C-style string handling, @samp{\} is treated as an escape -->
<!-- character, so that for example one can enter a newline as @samp{\n}. -->
<!-- When you really need a @samp{\}, you have to escape it with another -->
<!-- @samp{\}. -->
<p>R은 C-스타일의 문자열조작(string handling)을 이용하기 때문에, &lsquo;<samp><span class="samp">\</span></samp>&rsquo;를 이스케이프 문자(escape character)와 같이 처리하게 됩니다. 
예를들면 &lsquo;<samp><span class="samp">\n</span></samp>&rsquo;은 개행문자(newline)을 입력하기 위해서 사용합니다. 
&lsquo;<samp><span class="samp">\</span></samp>&rsquo;이라는 문자가 정말로 필요할 때는 또 다른 &lsquo;<samp><span class="samp">\</span></samp>&rsquo;을 이용하여 함께 사용해야 합니다.

<!-- Thus, in filenames use something like @code{"c:\\data\\money.dat"}.  You -->
<!-- can also replace @samp{\} by @samp{/} (@code{"c:/data/money.dat"}). -->
   <p>따라서, <code>"c:\\data\\money.dat"</code>와 같은 파일명을 작성하게 됩니다. 
또한 &lsquo;<samp><span class="samp">\</span></samp>&rsquo;를 &lsquo;<samp><span class="samp">/</span></samp>&rsquo;로 변경하여 <code>"c:/data/money.dat"</code>와 같이 사용할 수도 있습니다.

<div class="node">
<a name="Why-does-plotting-give-a-color-allocation-error%3f"></a>
<a name="Why-does-plotting-give-a-color-allocation-error_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-I-convert-factors-to-numeric_003f">How do I convert factors to numeric?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-do-file-names-work-in-Windows_003f">How do file names work in Windows?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why does plotting give a color allocation error? -->
<h3 class="section">7.9 플랏팅에서 왜 색상을 할당할때 에러가 생기나요?</h3>

<!-- On an X11 device, plotting sometimes, e.g., when running -->
<!-- @code{demo("image")}, results in ``Error: color allocation error''. -->
<!-- This is an X problem, and only indirectly related to R.  It occurs when -->
<!-- applications started prior to R have used all the available colors. -->
<!-- (How many colors are available depends on the X configuration; sometimes -->
<!-- only 256 colors can be used.) -->
<p>X11 장치를 이용할 때 <code>demo("image")</code>와 같이 플랏팅(plotting) 할때 &ldquo;Error: color allocation error&rdquo; (오류: 색상 할당 에러입니다)라는 메시지들 보게 될 때가 있습니다. 
이것은 X의 문제이며 R과 간접적으로 관련이 있는 것입니다. 
이것은 R을 실행하기 전에 어플리케이션들이 가능한 모든 색상들을 사용했을 때 발생하게 됩니다. 
(얼마나 많은 색상의 사용이 가능한지는 X의 설정에 따라 다릅니다; 때때로 오로지 256색상만이 사용될 수도 있습니다).

<!-- One application which is notorious for ``eating'' colors is Netscape. -->
<!-- If the problem occurs when Netscape is running, try (re)starting it with -->
<!-- either the @option{-no-install} (to use the default colormap) or the -->
<!-- @option{-install} (to install a private colormap) option. -->
   <p>&ldquo;eating&rdquo; color (먹는 색, 즉 보여지지 않는 색)으로 악명이 높은 어플리케이션은  Netscape입니다. 
만약 Netscape를 실행할때 이러한 문제가 발생한다면, 기본 컬러맵(default colormap)을 이용하는 <samp><span class="option">-no-install</span></samp> 또는 특정컬러맵(private colormap)을 이용하는 <samp><span class="option">-install</span></samp> 옵션을 이용하여 재시작을 시도해보세요.

<!-- You could also set the @code{colortype} of @code{X11()} to -->
<!-- @code{"pseudo.cube"} rather than the default @code{"pseudo"}.  See the -->
<!-- help page for @code{X11()} for more information. -->
   <p><code>X11()</code>의 기본값인 <code>"pseudo"</code>를 사용하기 대신에 <code>"pseudo.cube"</code>로 설정할 수도 있습니다. 
더 많은 내용에 대해서는 <code>X11()</code> 도움말 페이지를 참고해주세요.

<!-- @node Is R Y2K-compliant?, How do I convert factors to numeric?, Why does plotting give a color allocation error?, R Miscellanea -->
<!-- @section Is R Y2K-compliant? -->
<!-- We expect R to be Y2K compliant when compiled and run on a Y2K compliant -->
<!-- system.  In particular R does not internally represent or manipulate -->
<!-- dates as two-digit quantities.  However, no guarantee of Y2K compliance -->
<!-- is provided for R.  R is free software and comes with @emph{no warranty -->
<!-- whatsoever}. -->
<!-- R, like any other programming language, can be used to write programs -->
<!-- and manipulate data in ways that are not Y2K compliant. -->
<div class="node">
<a name="How-do-I-convert-factors-to-numeric%3f"></a>
<a name="How-do-I-convert-factors-to-numeric_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Are-Trellis-displays-implemented-in-R_003f">Are Trellis displays implemented in R?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-does-plotting-give-a-color-allocation-error_003f">Why does plotting give a color allocation error?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How do I convert factors to numeric? -->
<h3 class="section">7.10 어떻게 요인을 숫자형으로 변경할 수 있나요?</h3>

<!-- It may happen that when reading numeric data into R (usually, when -->
<!-- reading in a file), they come in as factors.  If @code{f} is such a -->
<!-- factor object, you can use -->
<p>R로 수치형 데이터를 읽어 들일때 (일반적으로 파일을 읽을때), 이들은 요인형(factor)로 인식되어 읽어지는 경우가 있습니다. 
만약 <code>f</code>가 이러한 요인형 객체라면, 아래와 같이 한다면 수치형으로 다시 돌려주게 됩니다.

<pre class="example">     as.numeric(as.character(f))
</pre>
   <p class="noindent"><!-- to get the numbers back.  More efficient, but harder to remember, is -->
좀 더 효율적이지만, 기억하기는 어려운 방법으로는 아래와 같이 합니다.

<pre class="example">     as.numeric(levels(f))[as.integer(f)]
</pre>
   <!-- In any case, do not call @code{as.numeric()} or their likes directly for -->
<!-- the task at hand (as @code{as.numeric()} or @code{unclass()} give the -->
<!-- internal codes). -->
   <p>어떠한 경우라도 주어진 작업에 대해서 <code>as.numeric()</code> 또는 그 비슷한 것들을 호출하지 마시길 바랍니다 (그 이유는 <code>as.numeric()</code> 또는 <code>unclass()</code>는 내부코드들을 보여줄 것이기 때문입니다).

<div class="node">
<a name="Are-Trellis-displays-implemented-in-R%3f"></a>
<a name="Are-Trellis-displays-implemented-in-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-are-the-enclosing-and-parent-environments_003f">What are the enclosing and parent environments?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-do-I-convert-factors-to-numeric_003f">How do I convert factors to numeric?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Are Trellis displays implemented in R? -->
<h3 class="section">7.11 트레릴스 기능이 R에 있나요?</h3>

<!-- The recommended package @CRANpkg{lattice} (which is based on base -->
<!-- package @pkg{grid}) provides graphical functionality that is compatible -->
<!-- with most Trellis commands. -->
<p>추천 패키지인 <a href="http://CRAN.R-project.org/package=lattice"><strong>lattice</strong></a>는 베이스 패키지인 <strong>grid</strong>에 기초를 두고 있습니다. 
이 패키지는 대부분의 트렐리스(Trellis) 명령어와 호환되는 그래픽 기능을 제공하고 있습니다.

<!-- You could also look at @code{coplot()} and @code{dotchart()} which might -->
<!-- do at least some of what you want.  Note also that the R version of -->
<!-- @code{pairs()} is fairly general and provides most of the functionality -->
<!-- of @code{splom()}, and that R's default plot method has an argument -->
<!-- @code{asp} allowing to specify (and fix against device resizing) the -->
<!-- aspect ratio of the plot. -->
   <p>사용자가 원하는 것들 중 적어도 몇 가지는 가능한 <code>coplot()</code>과 <code>dotchart()</code>를 살펴보세요. 
R에서 제공하는 <code>pairs()</code>는 꽤 일반적이며, <code>splom()</code>의 대부분의 기능을 제공하고 있습니다. 
또한, R의 기본적인 플랏 메소드는 플랏의 영상비(aspect ratio)를 지정 (및 장치의 크기에 따라 수정)할 수 있는 인자를 가지고 있습니다.

<!-- (Because the word ``Trellis'' has been claimed as a trademark we do not -->
<!-- use it in R.  The name ``lattice'' has been chosen for the R -->
<!-- equivalent.) -->
   <p>(단어 &ldquo;Trellis&rdquo;라는 단어가 상표(trademark)와 같이 사용되기 때문에, R에서는 이 단어를 사용하지 않습니다. 
R과 같은 것들에 대해서는 &ldquo;lattice&rdquo;라는 단어를 사용합니다).

<div class="node">
<a name="What-are-the-enclosing-and-parent-environments%3f"></a>
<a name="What-are-the-enclosing-and-parent-environments_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-substitute-into-a-plot-label_003f">How can I substitute into a plot label?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Are-Trellis-displays-implemented-in-R_003f">Are Trellis displays implemented in R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section What are the enclosing and parent environments? -->
<h3 class="section">7.12 인클로징(enclosing)과 패런트(parent) 환경이란 무엇인가요?</h3>

<!-- Inside a function you may want to access variables in two additional -->
<!-- environments: the one that the function was defined in (``enclosing''), -->
<!-- and the one it was invoked in (``parent''). -->
<p>함수내에서 당신은 아마도 두 개의 추가적인 환경들에 있는 변수들에 접근하고 싶을 수도 있습니다. 
하나는 (&ldquo;enclosing(인클로징)&rdquo;)이라는 환경내에 정의된 함수이고, 다른 하나는 (&ldquo;parent(패런트)&rdquo;)로부터 실행된 환경입니다.

<!-- If you create a function at the command line or load it in a package its -->
<!-- enclosing environment is the global workspace.  If you define a function -->
<!-- @code{f()} inside another function @code{g()} its enclosing environment -->
<!-- is the environment inside @code{g()}.  The enclosing environment for a -->
<!-- function is fixed when the function is created.  You can find out the -->
<!-- enclosing environment for a function @code{f()} using -->
<!-- @code{environment(f)}. -->
   <p>만약 명령어 라인에서 함수를 생성하거나 패키지내에서 로드를 하였다면, 이것의 인클로징 환경은 글로벌 작업공간(global workspace)입니다. 
만약 <code>f()</code>라는 함수를 <code>g()</code>라는 또 다른 함수내에서 정의를 했다면, 이것의 인클로징 환경은 <code>g()</code>내에 있는 환경입니다. 
함수에 대한 인클로징 환경은 함수가 생설될때 고정됩니다. 
함수 <code>f()</code>에 대한 인클로징 환경은 <code>envrionment(f)</code>를 이용하여 찾을 수 있습니다.

<!-- The ``parent'' environment, on the other hand, is defined when you -->
<!-- invoke a function.  If you invoke @code{lm()} at the command line its -->
<!-- parent environment is the global workspace, if you invoke it inside a -->
<!-- function @code{f()} then its parent environment is the environment -->
<!-- inside @code{f()}.  You can find out the parent environment for an -->
<!-- invocation of a function by using @code{parent.frame()} or -->
<!-- @code{sys.frame(sys.parent())}. -->
   <p>반면에 &ldquo;parent(패런트)&rdquo;환경은 함수를 실행할 때 정의되어 집니다. 
만약 명령어 라인에서 <code>lm()</code>를 실행하면, 이것의 패런트 환경은 글로벌 작업공간(global workspace)가 됩니다. 
만약 함수 <code>f()</code>에서 이것이 실행된다면 이의 패런트 환경은 <code>f()</code>내에 있는 환경이 됩니다. 
<code>parent.frame()</code> 또는 <code>sys.frame(sys.parent())</code>를 이용하여 함수의 실행에 대한 패런트 환경을 찾을 수 있습니다.

<!-- So for most user-visible functions the enclosing environment will be the -->
<!-- global workspace, since that is where most functions are defined.  The -->
<!-- parent environment will be wherever the function happens to be called -->
<!-- from.  If a function @code{f()} is defined inside another function -->
<!-- @code{g()} it will probably be used inside @code{g()} as well, so its -->
<!-- parent environment and enclosing environment will probably be the same. -->
   <p>여지까지 사용자가 볼 수 있는 함수들의 인클로징 환경은 글로벌 작업공간일 것입니다. 
그 이유는 대부분의 함수들의 정의된 위치가 글로벌 작업공간이기 때문입니다. 
패런트 환경은 함수가 불러지는 곳이면 어디든지 될 수 있습니다. 
만약 함수 <code>f()</code>가 다른 함수 <code>g()</code>안에 정의 되어 있다고 한다면, 이것은 <code>g()</code>함수 내에서 사용될 수 있기 때문에 패런트 환경과 인클로징 환경은 아마도 동일할 것입니다.

<!-- Parent environments are important because things like model formulas -->
<!-- need to be evaluated in the environment the function was called from, -->
<!-- since that's where all the variables will be available.  This relies on -->
<!-- the parent environment being potentially different with each invocation. -->
   <p>패런트 환경들은 모델 포뮬러(model formulas)와 같은 것들이 모든 변수들을 이용가능한 장소인, 즉, 함수가 호출된 환경에서 평가되는 것이 필요하므로 매우 중요합니다. 
이것은 매번 실행에 따라 달라질 수도 있는 패런트 환경에 크게 영향을 받습니다.

<!-- Enclosing environments are important because a function can use -->
<!-- variables in the enclosing environment to share information with other -->
<!-- functions or with other invocations of itself (see the section on -->
<!-- lexical scoping).  This relies on the enclosing environment being the -->
<!-- same each time the function is invoked.  (In C this would be done with -->
<!-- static variables.) -->
   <p>인클로징 환경은 함수가 인크로징 환경내의 변수들을 다른 함수들 또는 자기 자신의 또다른 실행으로 가진 정보들을 공유하기 위하여 사용할 수 있기 때문에 중요합니다 (렉시컬 스코핑 섹션을 살펴보시길 바랍니다). 
이는 함수가 매번 실행될때마다 동일한 인클로징 환경을 가져야 한다는 것을 필요로 합니다 (C에서는 이것을 정적변수(static variable)로 행하게 됩니다).

<!-- Scoping @emph{is} hard.  Looking at examples helps.  It is particularly -->
<!-- instructive to look at examples that work differently in R and S and try -->
<!-- to see why they differ.  One way to describe the scoping differences -->
<!-- between R and S is to say that in S the enclosing environment is -->
<!-- @emph{always} the global workspace, but in R the enclosing environment -->
<!-- is wherever the function was created. -->
   <p>스코핑(scoping)은 어렵습니다. 
예제들을 살펴보는 것이 도움이 됩니다. 
왜 R과 S에서 다르게 실행이 되며, 이들이 왜 다른가를 살펴보는 것이 중요합니다. 
R과 S의 스코핑이 다른 점을 설명하는 하나의 방법은 S는 인클로징 환경이 항상 클로벌 작업공간인데 반해 R은 인클로징 환경이 함수가 생성되는 곳에서 발생하게 됩니다.

<div class="node">
<a name="How-can-I-substitute-into-a-plot-label%3f"></a>
<a name="How-can-I-substitute-into-a-plot-label_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-are-valid-names_003f">What are valid names?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-are-the-enclosing-and-parent-environments_003f">What are the enclosing and parent environments?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I substitute into a plot label? -->
<h3 class="section">7.13 플랏 라벨에 어떻게 값을 넣을 수 있나요?</h3>

<!-- Often, it is desired to use the value of an R object in a plot label, -->
<!-- e.g., a title.  This is easily accomplished using @code{paste()} if the -->
<!-- label is a simple character string, but not always obvious in case the -->
<!-- label is an expression (for refined mathematical annotation).  In such a -->
<!-- case, either use @code{parse()} on your pasted character string or use -->
<!-- @code{substitute()} on an expression.  For example, if @code{ahat} is an -->
<!-- estimator of your parameter @math{a} of interest, use -->
<p>종종 제목(title)과 같은 플랏 라벨(plot label)내에서 R 객체의 값을 사용하고자 할 때가 있습니다. 
만약 라벨이 단순한 문자열이라면 <code>paste()</code>를 이용하여 쉽게 이루어지지만, 라벨이 정교한 수식을 가지는 표현일 경우에는 다소 어려움이 있습니다. 
이 경우에는 연결된 문자열에 <code>parse()</code>를 이용하거나 수식에 대해서 <code>substitute()</code>를 이용합니다. 
예를 들면, 만약 <code>hat</code>이 파라미터 a의 추정치라면, 다음과 같이 해 볼 수 있습니다.

<pre class="example">     title(substitute(hat(a) == ahat, list(ahat = ahat)))
</pre>
   <p class="noindent"><!-- (note that it is @samp{==} and not @samp{=}).  Sometimes @code{bquote()} -->
<!-- gives a more compact form, e.g., -->
(여기에서 &lsquo;<samp><span class="samp">==</span></samp>&rsquo;는 &lsquo;<samp><span class="samp">=</span></samp>&rsquo;이 아닙니다). 
때때로 <code>bquote()</code>는 간결한 형식을 제공합니다.

<pre class="example">     title(bquote(hat(a) = .(ahat)))
</pre>
   <p class="noindent"><!-- where subexpressions enclosed in @samp{.()} are replaced by their -->
<!-- values. -->
여기에서 &lsquo;<samp><span class="samp">.()</span></samp>&rsquo;내에 닫혀진 부분은 값으로 대체됩니다.

<!-- There are more worked examples in the mailing list archives. -->
   <p>더 많은 예제들이 메일링 리스트 저장소에 있습니다.

<div class="node">
<a name="What-are-valid-names%3f"></a>
<a name="What-are-valid-names_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Are-GAMs-implemented-in-R_003f">Are GAMs implemented in R?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-substitute-into-a-plot-label_003f">How can I substitute into a plot label?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section What are valid names? -->
<h3 class="section">7.14 유효한 이름은 무엇인가요?</h3>

<!-- When creating data frames using @code{data.frame()} or -->
<!-- @code{read.table()}, R by default ensures that the variable names are -->
<!-- syntactically valid.  (The argument @option{check.names} to these -->
<!-- functions controls whether variable names are checked and adjusted by -->
<!-- @code{make.names()} if needed.) -->
<p><code>data.frame()</code> 또는 <code>read.table()</code>을 이용하여 데이터 프레임을 생성하고자 할 때, R은 기본적으로 변수명이 구문상 (syntactically) 올바른지 확인하게 됩니다. 
(이러한 함수들에 인자 <samp><span class="option">check.names</span></samp>는 변수명을 확인할 것인지에 대한 여부를 조정하고 만약 필요하다면 <code>make.names()</code>을 이용하여 조정하게 됩니다).

<!-- To understand what names are ``valid'', one needs to take into account -->
<!-- that the term ``name'' is used in several different (but related) ways -->
<!-- in the language: -->
   <p>어떠한 이름들이 &ldquo;유효한가&rdquo;를 이해하기 위해서는 &ldquo;name&rdquo;(이름)이 어떤 방법으로 사용되는가를 알아야 할 필요가 있습니다.

     <ol type=1 start=1>
<li><!-- A @emph{syntactic name} is a string the parser interprets as this type -->
<!-- of expression.  It consists of letters, numbers, and the dot and (for -->
<!-- version of R at least 1.9.0) underscore characters, and starts with -->
<!-- either a letter or a dot not followed by a number.  Reserved words are -->
<!-- not syntactic names. -->
<em>syntatic name</em>(구문명)은 파서(parser)가 마치 표현식(expression)과 같은 유형으로 해석하게 되는 문자열을 의미합니다. 
이것은 문자(letters), 숫자, 닷기호(dot), 언더스코어(underscore), 그리고 숫자바로 뒤에 오지 않는 문자 또는 닷기호로 시작하게 됩니다. 
예약어(reserved words)는 구문명이 아닙니다.

     <li><!-- An @emph{object name} is a string associated with an object that is -->
<!-- assigned in an expression either by having the object name on the left -->
<!-- of an assignment operation or as an argument to the @code{assign()} -->
<!-- function.  It is usually a syntactic name as well, but can be any -->
<!-- non-empty string if it is quoted (and it is always quoted in the call to -->
<!-- @code{assign()}). -->
<em>object name</em>(객체명)은 표현식내에서 객체와 연관된 문자열을 의미합니다. 
이 표현식은 할당연산자 (assignment operation)의 좌측에 있는 객체명을 가지거나 <code>assign()</code>함수에 이용되는 인자의 형태를 가지고 있습니다. 
이것은 주로 구문명(syntatic name)이기도 하지만, 만약 따옴표로 묶인다면 공백을 가지지 않는 어떠한 문자열이라도 될 수 있습니다 (그리고 <code>assign()</code> 함수에 호출되는 된다면 이는 항상 따옴표로 묶이게 됩니다).

     <li><!-- An @emph{argument name} is what appears to the left of the equals sign -->
<!-- when supplying an argument in a function call (for example, -->
<!-- @code{f(trim=.5)}).  Argument names are also usually syntactic names, -->
<!-- but again can be anything if they are quoted. -->
<em>argument name</em>(인자명)은 <code>f(trim=.5)</code>와 같이 함수호출(function call)에 사용되는 인자로서 등부호(equal sign) 좌측에 나타나는 것입니다. 
인자명은 또한 구문명(syntactic name)이기도 하지만, 위와 마찬가지로 따옴표로 묶여진다면 어떤 것이든 될 수 있습니다.

     <li><!-- An @emph{element name} is a string that identifies a piece of an object -->
<!-- (a component of a list, for example.)  When it is used on the right of -->
<!-- the @samp{$} operator, it must be a syntactic name, or quoted. -->
<!-- Otherwise, element names can be any strings.  (When an object is used as -->
<!-- a database, as in a call to @code{eval()} or @code{attach()}, the -->
<!-- element names become object names.) -->
<em>element name</em>(구성요소의 명칭 또는 요소명)은 리스트의 구성요소와 같이 객체의 조각을 구분하기 위한 문자열입니다. 
이것이 &lsquo;<samp><span class="samp">$</span></samp>&rsquo;연산자의 우측에 사용될 때에는 반드시 구문명(syntactic name)이거나 따옴표로 묶여져야 합니다. 
그렇지 않다면 요소명은 어떠한 문자열이든 될 수 있습니다. 
(객체가 <code>eval()</code> 또는 <code>attach()</code>에 호출될 때와 같이 데이터베이스로서 사용될 때, 요소명은 객체의 이름이 됩니다).

     <li><!-- Finally, a @emph{file name} is a string identifying a file in the -->
<!-- operating system for reading, writing, etc.  It really has nothing much -->
<!-- to do with names in the language, but it is traditional to call these -->
<!-- strings file ``names''. -->
마지막으로 <em>file name</em>(파일명)은 운영체제 내에서 읽거나 쓰기를 위한 파일을 구분하는데 이용되는 문자열입니다. 
이것은 R언어와는 아무런 연관이 없지만, 이러한 문자열 파일을 &ldquo;names&rdquo;라고 부르는 것은 관습입니다.
        </ol>

<div class="node">
<a name="Are-GAMs-implemented-in-R%3f"></a>
<a name="Are-GAMs-implemented-in-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-is-the-output-not-printed-when-I-source_0028_0029-a-file_003f">Why is the output not printed when I source() a file?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-are-valid-names_003f">What are valid names?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Are GAMs implemented in R? -->
<h3 class="section">7.15 R에서 GAM을 이용할 수 있나요?</h3>

<!-- Package @CRANpkg{gam} from @CRAN{} implements all the Generalized -->
<!-- Additive Models (GAM) functionality as described in the GAM chapter of -->
<!-- the White Book.  In particular, it implements backfitting with both -->
<!-- local regression and smoothing splines, and is extendable.  There is a -->
<!-- @code{gam()} function for GAMs in package @CRANpkg{mgcv}, but it is not -->
<!-- an exact clone of what is described in the White Book (no @code{lo()} -->
<!-- for example).  Package @CRANpkg{gss} can fit spline-based GAMs too.  And -->
<!-- if you can accept regression splines you can use @code{glm()}.  For -->
<!-- Gaussian GAMs you can use @code{bruto()} from package @CRANpkg{mda}. -->
<p><acronym>CRAN</acronym>으로부터 얻을 수 있는 패키지 <a href="http://CRAN.R-project.org/package=gam"><strong>gam</strong></a>은 화이트 북(the White book)의 GAM 챕터에 설명된 모든 Generalized Additive Models (GAM)을 구현하였습니다. 
특히, 이는 local regression과 smoothing spline를 사용하는 백피팅(backfitting)을 구현하였고, 확장할 수있습니다. 
패키지 <a href="http://CRAN.R-project.org/package=mgcv"><strong>mgcv</strong></a>는 GAM을 위한 <code>gam()</code> 함수가 있는데, 이는 화이트북에 설명된 것과 완전히 동일하지는 않습니다 (예를들면 <code>lo()</code>라는 것은 없습니다). 
패키지 <a href="http://CRAN.R-project.org/package=gss"><strong>gss</strong></a>는 스플라인 기반(spline-based)의 GAM을 이용할 수 있습니다. 
만약 리그레션 스플라인(regression spline)을 수용한다면, <code>glm()</code>을 사용할 수도 있습니다. 
Gaussian GAM의 경우에는 <a href="http://CRAN.R-project.org/package=mda"><strong>mda</strong></a>라는 패키지에 있는 <code>bruto()</code>를 사용할 수 있습니다.

<div class="node">
<a name="Why-is-the-output-not-printed-when-I-source()-a-file%3f"></a>
<a name="Why-is-the-output-not-printed-when-I-source_0028_0029-a-file_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-does-outer_0028_0029-behave-strangely-with-my-function_003f">Why does outer() behave strangely with my function?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Are-GAMs-implemented-in-R_003f">Are GAMs implemented in R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why is the output not printed when I source() a file? -->
<h3 class="section">7.16 source()를 이용하여 파일을 읽었는데 결과물이 왜 보이지 않나요?</h3>

<!-- Most R commands do not generate any output. The command -->
<p>대부분의 R 명령어들은 어떠한 결과물을 생성하지 않습니다.
<pre class="example">     1+1
</pre>
   <p class="noindent"><!-- computes the value 2 and returns it; the command -->
위와 같이 명령어를 입력하면 2라는 값을 반환합니다.

<pre class="example">     summary(glm(y~x+z, family=binomial))
</pre>
   <p class="noindent"><!-- fits a logistic regression model, computes some summary information and -->
<!-- returns an object of class @code{"summary.glm"} (@pxref{How should I -->
<!-- write summary methods?}). -->
위의 명령어는 로지스틱 리그레션 모델(logistic regression model)을 적합한뒤, 요약된 정보를 산출한뒤 <code>"summary.glm"</code>이라는 클래스의 객체를 반환합니다 (see <a href="#How-should-I-write-summary-methods_003f">How should I write summary methods?</a>).

<!-- If you type @samp{1+1} or @samp{summary(glm(y~x+z, family=binomial))} at -->
<!-- the command line the returned value is automatically printed (unless it -->
<!-- is @code{invisible()}), but in other circumstances, such as in a -->
<!-- @code{source()}d file or inside a function it isn't printed unless you -->
<!-- specifically print it. -->
   <p>만약 명령어 라인에서 &lsquo;<samp><span class="samp">1+1</span></samp>&rsquo; 또는 &lsquo;<samp><span class="samp">summary(glm(y~x+z, family=binomial))</span></samp>&rsquo; 이라고 입력한다면, 반환된 값들이 <code>invisible()</code>이 아닌 이상은 자동으로 출력됩니다. 
그러나, <code>source()</code>를 이용하여 파일을 읽어들이거나 함수내에서 사용되는 경우에는 특별히 프린트라는 명령을 지정하지 않는 이상은 보여지지 않습니다.

<!-- To print the value use -->
   <p>이러한 값을 출력하기 위해서는 다음과 같이 해야 합니다.

<pre class="example">     print(1+1)
</pre>
   <p class="noindent">또는

<pre class="example">     print(summary(glm(y~x+z, family=binomial)))
</pre>
   <p class="noindent"><!-- instead, or use @code{source(@var{file}, echo=TRUE)}. -->
혹은 <code>source(</code><var>file</var><code>, echo=TRUE)</code>라고 해야합니다.

<div class="node">
<a name="Why-does-outer()-behave-strangely-with-my-function%3f"></a>
<a name="Why-does-outer_0028_0029-behave-strangely-with-my-function_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-does-the-output-from-anova_0028_0029-depend-on-the-order-of-factors-in-the-model_003f">Why does the output from anova() depend on the order of factors in the model?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-is-the-output-not-printed-when-I-source_0028_0029-a-file_003f">Why is the output not printed when I source() a file?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why does outer() behave strangely with my function? -->
<h3 class="section">7.17 왜 outer()가 예상하지 못한 방식으로 작동하나요?</h3>

<!-- As the help for @code{outer()} indicates, it does not work on arbitrary -->
<!-- functions the way the @code{apply()} family does.  It requires functions -->
<!-- that are vectorized to work elementwise on arrays.  As you can see by -->
<!-- looking at the code, @code{outer(x, y, FUN)} creates two large vectors -->
<!-- containing every possible combination of elements of @code{x} and -->
<!-- @code{y} and then passes this to @code{FUN} all at once.  Your function -->
<!-- probably cannot handle two large vectors as parameters. -->
<p><code>outer()</code>의 도움말에 명시된 것과 같이, 이는 <code>apply()</code>계열의 함수들이 작동하는 방식을 가지는 함수들과는 함께 쓰일 수 없습니다. 
이를 사용하기 위해서는 배열의 구성요소단위별로 작동하는 벡터라이즈된 함수가 필요합니다. 
코드 <code>outer(x,y, FUN)</code>를 보면 알 수 있듯이, 이는 <code>x</code>와 <code>y</code>의 모든 가능한 조합들을 포함하는 두 개의 큰 벡터들을 생성한 뒤, 이를 <code>FUN</code>에 전달하게 됩니다. 
사용자의 함수는 아마도 이렇게 큰 두개의 벡터들을 파라미터로서 다룰 수 없을 것입니다.

<!-- If you have a function that cannot handle two vectors but can handle two -->
<!-- scalars, then you can still use @code{outer()} but you will need to wrap -->
<!-- your function up first, to simulate vectorized behavior.  Suppose your -->
<!-- function is -->
   <p>만약 두 개의 벡터를 다룰 수는 없지만 두개의 스칼라(scalars)를 다룰 수 있는 함수를 가지고 있다면, <code>outer()</code>를 사용할 수는 있으나, 사용자의 함수에 이를 둘러쌓아야만 합니다. 
아래와 같은 사용자 함수를 생각해 봅니다.

<pre class="example">     foo &lt;- function(x, y, happy) {
       stopifnot(length(x) == 1, length(y) == 1) # scalars only!
       (x + y) * happy
     }
</pre>
   <p class="noindent"><!-- If you define the general function -->
만약, 사용자가 다음과 같이 일반적인 함수를 정의한다면, <code>outer()</code>를 사용할 수 있습니다.

<pre class="example">     wrapper &lt;- function(x, y, my.fun, ...) {
       sapply(seq_along(x), FUN = function(i) my.fun(x[i], y[i], ...))
     }
</pre>
   <p class="noindent"><!-- then you can use @code{outer()} by writing, e.g., -->
아래와 같이 적용할 수 있습니다.

<pre class="example">     outer(1:4, 1:2, FUN = wrapper, my.fun = foo, happy = 10)
</pre>
   <div class="node">
<a name="Why-does-the-output-from-anova()-depend-on-the-order-of-factors-in-the-model%3f"></a>
<a name="Why-does-the-output-from-anova_0028_0029-depend-on-the-order-of-factors-in-the-model_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-I-produce-PNG-graphics-in-batch-mode_003f">How do I produce PNG graphics in batch mode?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-does-outer_0028_0029-behave-strangely-with-my-function_003f">Why does outer() behave strangely with my function?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why does the output from anova() depend on the order of factors in the model? -->
<h3 class="section">7.18 anova()의 결과가 왜 모델에 있는 요인들의 순서에 영향을 받나요?</h3>

<!-- In a model such as @code{~A+B+A:B}, R will report the difference in sums -->
<!-- of squares between the models @code{~1}, @code{~A}, @code{~A+B} and -->
<!-- @code{~A+B+A:B}.  If the model were @code{~B+A+A:B}, R would report -->
<!-- differences between @code{~1}, @code{~B}, @code{~A+B}, and -->
<!-- @code{~A+B+A:B} . In the first case the sum of squares for @code{A} is -->
<!-- comparing @code{~1} and @code{~A}, in the second case it is comparing -->
<!-- @code{~B} and @code{~B+A}.  In a non-orthogonal design (i.e., most -->
<!-- unbalanced designs) these comparisons are (conceptually and numerically) -->
<!-- different. -->
<p><code>~A+B+A:B</code>와 같은 모델내에서, R은 <code>~1</code>, <code>~A</code>, <code>~A+B</code>, <code>~A+B+A:B</code> 모델들의 제곱합(sums of squares)를 모두 다르게 보여줄 것입니다. 
만약, 모델이  <code>~B+A+A:B</code>이었다면 <code>~1</code>, <code>~B</code>, <code>~A+B</code>, <code>~A+B+A:B</code> 역시 다르게 보여줄 것입니다. 
첫번째의 경우에는 <code>A</code>에 대한 제곱합은 <code>~1</code>과 <code>~A</code>에 비교되고, 두번째의 경우에는 <code>~B</code>와 <code>~B+A</code>와 비교됩니다. 
대부분의 언밸런스드 디자인(unbalanced design)인 비직교디자인(Non-orthogonal design)에서는 이러한 비교는 개념상으로나 수치연산상으로 다릅니다.

<!-- Some packages report instead the sums of squares based on comparing the -->
<!-- full model to the models with each factor removed one at a time (the -->
<!-- famous `Type III sums of squares' from SAS, for example).  These do not -->
<!-- depend on the order of factors in the model.  The question of which set -->
<!-- of sums of squares is the Right Thing provokes low-level holy wars on -->
<!-- R-help from time to time. -->
   <p>일부 패키지들은 풀모델(full model)에서 요인(factor)를 한번에 하나씩 지워나가는 모델들과 비교한 제곱합 (예를들면, SAS 에서 `Type III sums of suqares')를 보고합니다. 
이는 모델에서 사용된 요인의 순서에 영향을 받지 않습니다. 
어떤 종류의 제곱합이 올바른것인지에 대한 질문은 때때로 R-help에서 많은 논쟁거리를 유발합니다 (provokes low-level holy wars).

<!-- There is no need to be agitated about the particular sums of squares -->
<!-- that R reports.  You can compute your favorite sums of squares quite -->
<!-- easily.  Any two models can be compared with @code{anova(@var{model1}, -->
<!-- @var{model2})}, and @code{drop1(@var{model1})} will show the sums of -->
<!-- squares resulting from dropping single terms. -->
   <p>R이 알려주는 특정한 제곱합에 대해서는 걱정할 필요는 없습니다. 
사용자가 선호하는 제곱합을 손쉽게 계산할 수 있습니다. 
두 모델은 <code>anova(</code><var>model1</var><code>, </code><var>model2</var><code>)</code>을 이용하여 비교되어지고, <code>drop1(</code><var>model1</var><code>)</code>은 한 개의 항을 빼낸뒤 얻어낸 제곱합을 보여줄 것입니다.

<div class="node">
<a name="How-do-I-produce-PNG-graphics-in-batch-mode%3f"></a>
<a name="How-do-I-produce-PNG-graphics-in-batch-mode_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-get-command-line-editing-to-work_003f">How can I get command line editing to work?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-does-the-output-from-anova_0028_0029-depend-on-the-order-of-factors-in-the-model_003f">Why does the output from anova() depend on the order of factors in the model?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How do I produce PNG graphics in batch mode? -->
<h3 class="section">7.19 배치모드에서 어떻게 PNG 그래픽스를 생성할 수 있나요?</h3>

<!-- Under a Unix-like, if your installation supports the -->
<!-- @code{type="cairo"} option to the @code{png()} device there should be no -->
<!-- problems, and the default settings should just work.  This option is not -->
<!-- available for versions of R prior to 2.7.0, or without support for -->
<!-- cairo.  From R 2.7.0 @code{png()} by default uses the Quartz device -->
<!-- on Mac OS X, and that too works in batch mode. -->
<p>Unix와 같은 환경에서 설치시 <code>png()</code> 장치에 대하여 <code>type="cairo"</code>를 지원된다면, 아무런 문제가 없어야 하며 기본설정대로 작동해야합니다. 
이 옵션은 2.7.0 이전 버전에서는 사용할 수 없거나, cario에 대한 지원이 없습니다. 
R 2.7.0부터는 기본적으로 <code>png()</code>는 Mac OS X에서는 Quartz 장치를 이용하며 이는 배치모드에서도 실행됩니다.

<!-- Earlier versions of the @code{png()} device uses the X11 driver, which -->
<!-- is a problem in batch mode or for remote operation.  If you have -->
<!-- Ghostscript you can use @code{bitmap()}, which produces a PostScript or -->
<!-- PDF file then converts it to any bitmap format supported by Ghostscript. -->
<!-- On some installations this produces ugly output, on others it is -->
<!-- perfectly satisfactory.  Many systems now come with Xvfb from -->
<!-- @url{http://www.x.org/Downloads.html, X.Org} (possibly as an optional -->
<!-- install), which is an X11 server that does not require a screen; and -->
<!-- there is the @CRANpkg{GDD} package from @CRAN{}, which produces PNG, -->
<!-- JPEG and GIF bitmaps without X11. -->
   <p><code>png()</code>장치의 이전 버전들은 배치모드 또는 원격조작시에 문제가 되기도 하는 X11 드라이버를 사용합니다. 
만약 Ghostscript를 가지고 있다면 Postscript나 PDF파일을 생성한뒤 고스트스크립트에 의하여 지원된는 어떠한 종류의 bitmap형식으로의 전환 할 수 있는 이미지를 <code>bitmap()</code>를 이용하여 생성할 수 있습니다. 
일부 설치에서는 이는 보기에 좋지 않는 결과를 생성하기도 하고, 매우 만족스러운 결과를 생성하기도 합니다. 
현재 많은 시스템들이  스크린을 필요로 하지 않는 X11 서버인 <a href="http://www.x.org/Downloads.html">X.Org</a>와 함께 나옵니다. 
그리고 X11 없이도 PNG, JPEG, 그리고 GIF 비트맵들을 생성해주는 <a href="http://CRAN.R-project.org/package=GDD"><strong>GDD</strong></a>를 <acronym>CRAN</acronym>에서 얻을 수 있습니다.

<div class="node">
<a name="How-can-I-get-command-line-editing-to-work%3f"></a>
<a name="How-can-I-get-command-line-editing-to-work_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-turn-a-string-into-a-variable_003f">How can I turn a string into a variable?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-do-I-produce-PNG-graphics-in-batch-mode_003f">How do I produce PNG graphics in batch mode?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I get command line editing to work? -->
<h3 class="section">7.20 명령어 라인 편집기능을 어떻게 사용할 수 있나요?</h3>

<!-- The Unix-like command-line interface to R can only provide the inbuilt -->
<!-- command line editor which allows recall, editing and re-submission of -->
<!-- prior commands provided that the @acronym{GNU} readline library is -->
<!-- available at the time R is configured for compilation.  Note that the -->
<!-- `development' version of readline including the appropriate headers is -->
<!-- needed: users of Linux binary distributions will need to install -->
<!-- packages such as @code{libreadline-dev} (Debian) or -->
<!-- @code{readline-devel} (Red Hat). -->
<p>R과 함께 사용되는 Unix와 같은 커맨드라인은 오로지 빌트인 커맨드 라인 편집기(inbuilt command line editor)만을 제공합니다. 
이 편집기는 만약 <acronym>GNU</acronym> readline 라이브러리가 컴파일에서 R에서 설정되었을때만 불러오기, 편집하기, 이전 명령어를 재실행할 수 있습니다. 
이를 위해서는 적합한 헤더(headers)를 포함하고 있는 개발버전의 readline이 필요하므로, 리눅스 바이너리 배포를 사용하는 사용자들은 <code>libreadline-dev</code> (Debian) 또는 <code>readline-devel</code> (Red Hat)과 같은 패키지가 필요할 수 있습니다.

<div class="node">
<a name="How-can-I-turn-a-string-into-a-variable%3f"></a>
<a name="How-can-I-turn-a-string-into-a-variable_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-do-lattice_002ftrellis-graphics-not-work_003f">Why do lattice/trellis graphics not work?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-get-command-line-editing-to-work_003f">How can I get command line editing to work?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I turn a string into a variable? -->
<h3 class="section">7.21 문자열을 변수로 어떻게 변경할 수 있나요?</h3>

<!-- If you have -->
<p>만약 아래와 같은 명령을 실행했다고 가정합니다.

<pre class="example">     varname &lt;- c("a", "b", "d")
</pre>
   <p class="noindent"><!-- you can do -->
다음과 같이 해보세요.

<pre class="example">     get(varname[1]) + 2
</pre>
   <p class="noindent"><!-- for -->
이는 다음을 계산해줍니다.

<pre class="example">     a + 2
</pre>
   <p class="noindent"><!-- or -->
또는 아래와 같이 해보시길 바랍니다.

<pre class="example">     assign(varname[1], 2 + 2)
</pre>
   <p class="noindent"><!-- for -->
이것은 다음을 계산해줍니다.

<pre class="example">     a &lt;- 2 + 2
</pre>
   <p class="noindent"><!-- or -->
또는 아래와 같이 해보세요.

<pre class="example">     eval(substitute(lm(y ~ x + variable),
                     list(variable = as.name(varname[1]))))
</pre>
   <p class="noindent"><!-- for -->
이것은 다음을 계산하게 됩니다.

<pre class="example">     lm(y ~ x + a)
</pre>
   <!-- At least in the first two cases it is often easier to just use a list, -->
<!-- and then you can easily index it by name -->
   <p>최소한 처음 두가지 경우에는 리스트(list)를 이용한 뒤, 아래와 같이 요소명을 이용하여 보다 쉽게 사용할 수 있습니다.

<pre class="example">     vars &lt;- list(a = 1:10, b = rnorm(100), d = LETTERS)
     vars[["a"]]
</pre>
   <p class="noindent"><!-- without any of this messing about. -->

<div class="node">
<a name="Why-do-lattice%2ftrellis-graphics-not-work%3f"></a>
<a name="Why-do-lattice_002ftrellis-graphics-not-work_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-sort-the-rows-of-a-data-frame_003f">How can I sort the rows of a data frame?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-turn-a-string-into-a-variable_003f">How can I turn a string into a variable?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why do lattice/trellis graphics not work? -->
<h3 class="section">7.22 lattice/trellis 그래픽스가 왜 작동하지 않나요?</h3>

<!-- The most likely reason is that you forgot to tell R to display the -->
<!-- graph.  Lattice functions such as @code{xyplot()} create a graph object, -->
<!-- but do not display it (the same is true of @CRANpkg{ggplot2} graphics, -->
<!-- and Trellis graphics in @SPLUS{}).  The @code{print()} method for the -->
<!-- graph object produces the actual display.  When you use these functions -->
<!-- interactively at the command line, the result is automatically printed, -->
<!-- but in @code{source()} or inside your own functions you will need an -->
<!-- explicit @code{print()} statement. -->
<p>가장 큰 이유는 R에 그래프를 보여줄 것을 명령하는 것을 잊은 것입니다. 
<code>xyplot()</code>과 같은 라띠스 함수(lattice function)들은 그래프 객체를 생성하지만, 보여주지는 않습니다. 
(<a href="http://CRAN.R-project.org/package=ggplot2"><strong>ggplot2</strong></a> 그래픽스와 <span class="sc">S-Plus</span>의 Trellis 그래픽스 또한 마찬가지입니다). 
그래프 객체를 실제적으로 보여주기 위해서는 <code>print()</code> 메소드를 이용해야 합니다. 
커맨드 라인에서 이러한 함수들이 대화식으로 사용될때에는 자동적으로 보여지게 되지만, <code>source()</code>를 이용하거나 사용자가 작성한 함수내에서 이용될 때에는 명시적으로 <code>print()</code>를 사용해야 합니다.

<div class="node">
<a name="How-can-I-sort-the-rows-of-a-data-frame%3f"></a>
<a name="How-can-I-sort-the-rows-of-a-data-frame_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-does-the-help_002estart_0028_0029-search-engine-not-work_003f">Why does the help.start() search engine not work?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-do-lattice_002ftrellis-graphics-not-work_003f">Why do lattice/trellis graphics not work?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I sort the rows of a data frame? -->
<h3 class="section">7.23 데이터 프레임에 있는 행들을 어떻게 정렬할 수 있나요?</h3>

<!-- To sort the rows within a data frame, with respect to the values in one -->
<!-- or more of the columns, simply use @code{order()} (e.g., -->
<!-- @code{DF[order(DF$a, DF[["b"]]), ]} to sort the data frame @code{DF} on -->
<!-- columns named @code{a} and @code{b}). -->
<p>데이터 프레임내에 있는 한 개 이상의 열들안에 있는 값들에 대해서 행들을 정렬하고자 한다면, <code>order()</code>를 이용하면 됩니다. 
(예를들어, <code>DF[order(DF$a, DF[["b"]]), ]</code> 라고 하는 것은 데이터 프레임 <code>DF</code>을 <code>a</code>와 <code>b</code>라는 열들을 이용하여 정렬해줍니다).

<div class="node">
<a name="Why-does-the-help.start()-search-engine-not-work%3f"></a>
<a name="Why-does-the-help_002estart_0028_0029-search-engine-not-work_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-did-my-_002eRprofile-stop-working-when-I-updated-R_003f">Why did my .Rprofile stop working when I updated R?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-sort-the-rows-of-a-data-frame_003f">How can I sort the rows of a data frame?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why does the help.start() search engine not work? -->
<h3 class="section">7.24 왜 help.start() 검색엔진이 작동하지 않나요?</h3>

<!-- The browser-based search engine in @code{help.start()} utilizes a Java -->
<!-- applet.  In order for this to function properly, a compatible version of -->
<!-- Java must installed on your system and linked to your browser, and both -->
<!-- Java @emph{and} JavaScript need to be enabled in your browser. -->
<p><code>help.start()</code>내의 브라우저 기반의 검색엔진은 Java applet을 이용합니다. 
이것이 올바르게 작동하게하기 위해서는 Java와 호환가능한 버전이 설치되어야 하고, Java와 Javascript 모두 브라우저에서 사용가능하도록 설정되어 있어야 합니다.

<!-- There have been a number of compatibility issues with versions of Java -->
<!-- and of browsers. -->
   <p>Java와 브라우저의 버전들에 많은 호환성 문제들이 존재합니다.

<!-- For further details please consult section ``Enabling search in HTML -->
<!-- help'' in @cite{R Installation and Administration}.  This manual is -->
<!-- included in the R distribution, @pxref{What documentation exists for -->
<!-- R?}, and its @acronym{HTML} version is linked from the @acronym{HTML} -->
<!-- search page. -->
   <p>더 자세한 사항은 <cite>R Installation and Administration</cite> 문서내의 &ldquo;Enabling search in HTML help&rdquo; 섹션을 살펴보세요. 
이 매뉴얼은 R 배포판에 포함 see <a href="#What-documentation-exists-for-R_003f">What documentation exists for R?</a>되어 있으며, 이의 <acronym>HTML</acronym> 버전은 <acronym>HTML</acronym> 검색페이지와도 링크가 되어 있습니다.

<div class="node">
<a name="Why-did-my-.Rprofile-stop-working-when-I-updated-R%3f"></a>
<a name="Why-did-my-_002eRprofile-stop-working-when-I-updated-R_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Where-have-all-the-methods-gone_003f">Where have all the methods gone?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-does-the-help_002estart_0028_0029-search-engine-not-work_003f">Why does the help.start() search engine not work?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why did my .Rprofile stop working when I updated R? -->
<h3 class="section">7.25 R을 업데이트 했을 때 왜 .Rprofile이 더이상 작동하지 않나요?</h3>

<!-- Did you read the @file{NEWS} file?  For functions that are not in the -->
<!-- @pkg{base} package you need to specify the correct package namespace, -->
<!-- since the code will be run @emph{before} the packages are loaded.  E.g., -->
<p><samp><span class="file">NEWS</span></samp> 파일을 읽어 보셨나요? 
<strong>base</strong> 패키지에 없는 함수들을 이용하기 위해서는 올바른 패키지 네임스페이지를 지정해야만 합니다. 
그 이유는 코드들은 패키지들이 로드되기 전에 실행될 것이기 때문입니다. 
예를들면, 다음을 살펴보세요.

<pre class="example">     ps.options(horizontal = FALSE)
     help.start()
</pre>
   <p class="noindent"><!-- needs to be -->

   <p>위의 코드들은 아래와 같이 될 필요가 있습니다.

<pre class="example">     grDevices::ps.options(horizontal = FALSE)
     utils::help.start()
</pre>
   <!-- <FIXME> -->
<!-- 3.0.0 -->
<p class="noindent">(<code>graphics::ps.options(horizontal = FALSE)</code> in R 1.9.x). 
<!-- </FIXME> -->

<div class="node">
<a name="Where-have-all-the-methods-gone%3f"></a>
<a name="Where-have-all-the-methods-gone_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-create-rotated-axis-labels_003f">How can I create rotated axis labels?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-did-my-_002eRprofile-stop-working-when-I-updated-R_003f">Why did my .Rprofile stop working when I updated R?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Where have all the methods gone? -->
<h3 class="section">7.26 메소드들은 어디로 옮겨졌나요?</h3>

<!-- Many functions, particularly S3 methods, are now hidden in namespaces. -->
<!-- This has the advantage that they cannot be called inadvertently with -->
<!-- arguments of the wrong class, but it makes them harder to view. -->
<p>현재 많은 함수들 (특히 S3 메소드들)은 네임스페이스(namespaces)에서 보여지지 않습니다. 
이렇게 하는 것은 부주의하게 잘못된 클래스들을 인자로 호출되지 않게 하는 장점이 있지만 확인하기가 더 힘들어 지게 됩니다.

<!-- To see the code for an S3 method (e.g., @code{[.terms}) use -->
   <p>S3 메소드 (즉, <code>[.terms]</code>)에 해당하는 원시코드를 확인하고 싶다면 아래의 함수를 이용해 보세요.
<pre class="example">     getS3method("[", "terms")
</pre>
   <p class="noindent"><!-- To see the code for an unexported function @code{foo()} in the namespace -->
<!-- of package @code{"bar"} use @code{bar:::foo}.  Don't use these -->
<!-- constructions to call unexported functions in your own code-they are -->
<!-- probably unexported for a reason and may change without warning. -->
패키지 <code>"bar"</code>의 네임스페이스 내에서 아직 내보지지 않은 함수 <code>foo()</code>의 원시코드를 확인하기 위해서는 <code>foo()</code>를 이용하세요. 
사용자가 작성한 코드내에서 내보어지지 않은 함수들을 호출하려고 할때는 이렇게 사용하지 마시길 바랍니다. 
그들은 아마도 어떠한 이유에서 내보어내어지지 않았거나 경고가 없이 변경될 수도 있기 때문입니다.

<div class="node">
<a name="How-can-I-create-rotated-axis-labels%3f"></a>
<a name="How-can-I-create-rotated-axis-labels_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-is-read_002etable_0028_0029-so-inefficient_003f">Why is read.table() so inefficient?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Where-have-all-the-methods-gone_003f">Where have all the methods gone?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I create rotated axis labels? -->
<h3 class="section">7.27 어떻게 회전된 축라벨을 생성할 수 있나요?</h3>

<!-- To rotate axis labels (using base graphics), you need to use -->
<!-- @code{text()}, rather than @code{mtext()}, as the latter does not -->
<!-- support @code{par("srt")}. -->
<p>(base 그래픽스를 이용하여) 축 라벨들을 회전시키기 위해서는 <code>mtext()</code> 보다는 <code>text()</code>를 사용해야 합니다. 
그 이유는 <code>par("srt")</code>를 지원하지 않기 때문입니다.

<pre class="example">     <!-- ## @r{Increase bottom margin to make room for rotated labels} -->
     ## <span class="roman">가장 아랫부분에 회전된 라벨을 위한 공간을 늘립니다</span>
     par(mar = c(7, 4, 4, 2) + 0.1)
     <!-- ## @r{Create plot with no x axis and no x axis label} -->
     ## <span class="roman">x축 라벨과 y축 라벨이 없는 플랏을 생성합니다</span>
     plot(1 : 8, xaxt = "n",  xlab = "")
     <!-- ## @r{Set up x axis with tick marks alone} -->
     ## <span class="roman">틱마크만 존재하는 x축을 생성합니다</span>
     axis(1, labels = FALSE)
     <!-- ## @r{Create some text labels} -->
     ## <span class="roman">일부 텍스트 라벨을 생성합니다</span>
     labels &lt;- paste("Label", 1:8, sep = " ")
     <!-- ## @r{Plot x axis labels at default tick marks} -->
     ## <span class="roman">기본 틱마크가 있는 자리에 x축 라벨들을 플랏합니다</span>
     text(1:8, par("usr")[3] - 0.25, srt = 45, adj = 1,
          labels = labels, xpd = TRUE)
     <!-- ## @r{Plot x axis label at line 6 (of 7)} -->
     ## <span class="roman">(7개의 라인들 중) 6번째 라인에 x축 라벨을 플랏합니다</span>
     mtext(1, text = "X Axis Label", line = 6)
</pre>
   <p class="noindent"><!-- When plotting the x axis labels, we use @code{srt = 45} for text -->
<!-- rotation angle, @code{adj = 1} to place the right end of text at the -->
<!-- tick marks, and @code{xpd = TRUE} to allow for text outside the plot -->
<!-- region.  You can adjust the value of the @code{0.25} offset as required -->
<!-- to move the axis labels up or down relative to the x axis.  See -->
<!-- @code{?par} for more information. -->
x 축라벨들을 플랏할때, 문자회전의 각도로 <code>srt=45</code>를 사용했고, 틱마크의 위치에 문자의 오른쪽 끝을 위치시키기 위해서 <code>adj=1</code>을 이용했으며, 플랏영역 바깥쪽의 텍스트를 위하여 <code>xpd=TRUE</code>가 사용되었습니다. 
x축에 비례하여 위 또는 아래로 축라벨을 이동시키는데 필요한 <code>0.25</code> 오프셋의 값을 조정할 수도 있습니다. 
더 많은 정보를 위해서는 <code>?par</code>를 살펴보세요.

<!-- Also see Figure 1 and associated code in Paul Murrell (2003), -->
<!-- ``Integrating grid Graphics Output with Base Graphics Output'', -->
<!-- @emph{R News}, @strong{3/2}, 7-12. -->
   <p>Figure 1를 보시고, 이와 관련된 코드를 Paul Murrell (2003), &ldquo;Integrating grid Graphics Output with Base Graphics Output&rdquo;, <em>R News</em>, <strong>3/2</strong>, 7&ndash;12 에서 찾아보시길 바랍니다.

<div class="node">
<a name="Why-is-read.table()-so-inefficient%3f"></a>
<a name="Why-is-read_002etable_0028_0029-so-inefficient_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#What-is-the-difference-between-package-and-library_003f">What is the difference between package and library?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-create-rotated-axis-labels_003f">How can I create rotated axis labels?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why is read.table() so inefficient? -->
<h3 class="section">7.28 왜 read.table()이 비효율적인가요?</h3>

<!-- By default, @code{read.table()} needs to read in everything as character -->
<!-- data, and then try to figure out which variables to convert to numerics -->
<!-- or factors.  For a large data set, this takes considerable amounts of -->
<!-- time and memory.  Performance can substantially be improved by using the -->
<!-- @code{colClasses} argument to specify the classes to be assumed for the -->
<!-- columns of the table. -->
<p>기본적으로 <code>read.table()</code>은 모든 것들을 문자형 데이터로서 읽어들인 뒤, 어떤 변수가 숫자 또는 요인으로 변경되어야 하는지에 대하여 결정을 하게 됩니다. 
크기가 큰 데이터셋의 경우에는 이러한 방식은 꽤 많은 시간과 메모리를 필요로 합니다. 
테이블의 열들을 어떤 클래스로 읽어들일 것인지를 지정하는데 이용되는 <code>colClasses</code> 인자를 사용하면 성능이 상당히 향상될 수 있습니다.

<div class="node">
<a name="What-is-the-difference-between-package-and-library%3f"></a>
<a name="What-is-the-difference-between-package-and-library_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#I-installed-a-package-but-the-functions-are-not-there">I installed a package but the functions are not there</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-is-read_002etable_0028_0029-so-inefficient_003f">Why is read.table() so inefficient?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section What is the difference between package and library? -->
<h3 class="section">7.29 패키지와 라이브러리와는 어떤 차이가 있나요?</h3>

<!-- A @dfn{package} is a standardized collection of material extending R, -->
<!-- e.g.@: providing code, data, or documentation.  A @dfn{library} is a -->
<!-- place (directory) where R knows to find packages it can use (i.e., which -->
<!-- were @dfn{installed}).  R is told to use a package (to ``load'' it and -->
<!-- add it to the search path) via calls to the function @code{library}. -->
<!-- I.e., @code{library()} is employed to load a package from libraries -->
<!-- containing packages. -->
<p><dfn>package</dfn>(패키지)는 표준화된 방식으로 코드, 데이터, 그리고 문서를 제공함으로서 R을 확장할 수 있는 자료들의 모음입니다. 
<dfn>library</dfn>(라이브러리)는 R이 사용할 수 있는 (설치된) 패키지들을 찾는 디렉토리를 의미압니다. 
R은 함수 <code>library</code>로의 호출을 통하여 패키지를 (&ldquo;load(로드)&rdquo;하고, 이를 검색경로에 추가하라고) 사용하라고 전달하게 됩니다. 
즉, <code>library()</code>는 패키지들을 포함하고 있는 라이브러리들로부터 패키지를 로드하는데 쓰입니다.

<!-- @xref{R Add-On Packages}, for more details.  See also Uwe Ligges (2003), -->
<!-- ``R Help Desk: Package Management'', @emph{R News}, @strong{3/3}, -->
<!-- 37-39. -->
   <p>더 자세한 사항은 <a href="#R-Add_002dOn-Packages">R Add-On Packages</a>을 살펴보시길 바랍니다. 
Uwe Ligges (2003), `R Help Desk: Package Management&rdquo;, <em>R News</em>, <strong>3/3</strong>, 37&ndash;39 또한 살펴보시면 도움이 됩니다.

<div class="node">
<a name="I-installed-a-package-but-the-functions-are-not-there"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-doesn_0027t-R-think-these-numbers-are-equal_003f">Why doesn't R think these numbers are equal?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-the-difference-between-package-and-library_003f">What is the difference between package and library?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section I installed a package but the functions are not there -->
<h3 class="section">7.30 패키지를 설치했지만 함수들이 없다고 합니다.</h3>

<!-- To actually @emph{use} the package, it needs to be @emph{loaded} using -->
<!-- @code{library()}. -->
<p>패키지를 실제적으로 이용하기 위해서는 <code>library()</code>를 이용하여 로드되어져야 합니다.

<!-- See @ref{R Add-On Packages} and @ref{What is the difference between -->
<!-- package and library?} for more information. -->
   <p>더 많은 정보는 <a href="#R-Add_002dOn-Packages">R Add-On Packages</a>와 <a href="#What-is-the-difference-between-package-and-library_003f">What is the difference between package and library?</a>를 살펴보시길 바랍니다.

<div class="node">
<a name="Why-doesn't-R-think-these-numbers-are-equal%3f"></a>
<a name="Why-doesn_0027t-R-think-these-numbers-are-equal_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-capture-or-ignore-errors-in-a-long-simulation_003f">How can I capture or ignore errors in a long simulation?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#I-installed-a-package-but-the-functions-are-not-there">I installed a package but the functions are not there</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why doesn't R think these numbers are equal? -->
<h3 class="section">7.31 왜 R은 이러한 숫자들이 같지 않다고 하나요?</h3>

<!-- The only numbers that can be represented exactly in R's numeric type -->
<!-- are integers and fractions whose denominator is a power of 2.  Other -->
<!-- numbers have to be rounded to (typically) 53 binary digits accuracy.  As a -->
<!-- result, two floating point numbers will not reliably be equal unless they -->
<!-- have been computed by the same algorithm, and not always even then.  For -->
<!-- example -->
<p>R의 숫자의 유형들 중에서 정확하게 표현될 수 있는 숫자들은 정수(intergers)과 분모가 2의 자승(power of 2)인 분수(fractions) 뿐입니다. 
다른 숫자들은 (일반적으로) 이진법으로 53자리숫자에서 반올림 되어집니다. 
그 결과 같은 알고리즘에 의하여 얻어진 결과가 아니라면 두 부동소수점(floating point numbers)들은 같지 않을 것입니다. 
예를들면, 다음과 같습니다.

<pre class="example">     R&gt; a &lt;- sqrt(2)
     R&gt; a * a == 2
     [1] FALSE
     R&gt; a * a - 2
     [1] 4.440892e-16
</pre>
   <!-- The function @code{all.equal()} compares two objects using a numeric -->
<!-- tolerance of @code{.Machine$double.eps ^ 0.5}.  If you want much greater -->
<!-- accuracy than this you will need to consider error propagation -->
<!-- carefully. -->
   <p>함수 <code>all.equal()</code>은 <code>.Machine$double.eps ^ 0.5</code>의 오차범위내에서 두개의 객체를 비교합니다. 
만약, 이보다 더 높은 수준의 정확도를 원한다면 에러전파(error propagation)을 조심스럽게 생각해보아야 합니다.

<!-- For more information, see e.g.@: David Goldberg (1991), ``What Every -->
<!-- Computer Scientist Should Know About Floating-Point Arithmetic'', -->
<!-- @emph{ACM Computing Surveys}, @strong{23/1}, 5-48, also available via -->
<!-- @url{http://www.validlab.com/goldberg/paper.pdf}. -->
   <p>더 많은 정보를 David Goldberg (1991), &ldquo;What Every Computer Scientist Should Know About Floating-Point Arithmetic&rdquo;, <em>ACM Computing Surveys</em>, <strong>23/1</strong>, 5&ndash;48 에서 찾아 볼 수 있으며, 또한 <a href="http://www.validlab.com/goldberg/paper.pdf">http://www.validlab.com/goldberg/paper.pdf</a>에서도 볼 수 있습니다.

<!-- To quote from ``The Elements of Programming Style'' by Kernighan and -->
<!-- Plauger: -->
   <p>Kernighan과 Plauger에 의해서 씌여진 &ldquo;The Elements of Programming Style&rdquo;에서 인용을 하자면, 다음과 같습니다.

   <blockquote>
<!-- @emph{10.0 times 0.1 is hardly ever 1.0}. -->
10.0 곱하기 0.1은 1.0이 되기 어렵다. 
</blockquote>

<div class="node">
<a name="How-can-I-capture-or-ignore-errors-in-a-long-simulation%3f"></a>
<a name="How-can-I-capture-or-ignore-errors-in-a-long-simulation_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-are-powers-of-negative-numbers-wrong_003f">Why are powers of negative numbers wrong?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-doesn_0027t-R-think-these-numbers-are-equal_003f">Why doesn't R think these numbers are equal?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I capture or ignore errors in a long simulation? -->
<h3 class="section">7.32 절차가 긴 시뮬레이션에서 에러들을 잡거나 무시하려면 어떻게 해야하나요?</h3>

<!-- Use @code{try()}, which returns an object of class @code{"try-error"} -->
<!-- instead of an error, or preferably @code{tryCatch()}, where the return -->
<!-- value can be configured more flexibly.  For example -->
<p>에러 대신에 <code>"try-error"</code>라는 클래스의 객체를 반환하고자 한다면 <code>try()</code>를 이용하거나, 좀 더 유연하게 다른 값을 반환할 수 있는 <code>tryCatch()</code>를 이용해 보세요. 
예를들어, 다음의 예제는 성공적으로 수행된다면 <code>lm()</code>의 계수(coefficients)를 반환하고, 실패할 경우에는 <code>c(NaN, NaN, NaN, NaN)</code>을 돌려주게 됩니다 (이 경우에는 계수가 4개라고 가정했습니다).

<pre class="example">     beta[i,] &lt;- tryCatch(coef(lm(formula, data)),
                          error = function(e) rep(NaN, 4))
</pre>
   <p class="noindent"><!-- would return the coefficients if the @code{lm()} call succeeded and -->
<!-- would return @code{c(NaN, NaN, NaN, NaN)} if it failed (presumably there -->
<!-- are supposed to be 4 coefficients in this example). -->

<div class="node">
<a name="Why-are-powers-of-negative-numbers-wrong%3f"></a>
<a name="Why-are-powers-of-negative-numbers-wrong_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-save-the-result-of-each-iteration-in-a-loop-into-a-separate-file_003f">How can I save the result of each iteration in a loop into a separate file?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-capture-or-ignore-errors-in-a-long-simulation_003f">How can I capture or ignore errors in a long simulation?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why are powers of negative numbers wrong? -->
<h3 class="section">7.33 왜 음수의 거듭제곱의 값이 틀리나요?</h3>

<!-- You are probably seeing something like -->
<p>아마 다음과 같은 경우에 이러한 질문이 생길 수 있으며, 이는 R의 표현식에 대한 우선순위 규칙(precedence rules)를 잘 못 이해한 경우에 해당합니다.

<pre class="example">     R&gt; -2^2
     [1] -4
</pre>
   <p class="noindent"><!-- and misunderstanding the precedence rules for expressions in R. -->
<!-- Write -->

   <p>올바른 결과를 얻기 위해서는 다음과 같이 해야 -2의 제곱에 대한 올바른 값을 얻을 수 있습니다.

<pre class="example">     R&gt; (-2)^2
     [1] 4
</pre>
   <p class="noindent"><!-- to get the square of @math{-2}. -->

<!-- The precedence rules are documented in @code{?Syntax}, and to see how R -->
<!-- interprets  an expression you can look at the parse tree -->
   <p>우선순위 규칙은 <code>?Syntax</code> 내에 정리되어 있으며, 어떻게 R이 해석하는지를 알기 위해서는 구문트리(parse tree)를 보시길 바랍니다.

<pre class="example">     R&gt; as.list(quote(-2^2))
     [[1]]
     `-`
     
     [[2]]
     2^2
</pre>
   <div class="node">
<a name="How-can-I-save-the-result-of-each-iteration-in-a-loop-into-a-separate-file%3f"></a>
<a name="How-can-I-save-the-result-of-each-iteration-in-a-loop-into-a-separate-file_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-are-p_002dvalues-not-displayed-when-using-lmer_0028_0029_003f">Why are p-values not displayed when using lmer()?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-are-powers-of-negative-numbers-wrong_003f">Why are powers of negative numbers wrong?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I save the result of each iteration in a loop into a separate file? -->
<h3 class="section">7.34 어떻게 해야 루프의 각 단계마다 생성되는 결과를 각각의 다른 파일에 저장할 수 있나요?</h3>

<!-- One way is to use @code{paste()} (or @code{sprintf()}) to concatenate a -->
<!-- stem filename and the iteration number while @code{file.path()} -->
<!-- constructs the path.  For example, to save results into files -->
<!-- @file{result1.rda}, @dots{}, @file{result100.rda} in the subdirectory -->
<!-- @file{Results} of the current working directory, one can use -->
<p>이를 수행하는 한가지 방법으로는 <code>file.path()</code>로 경로를 지정해주면서 파일명과 각 반복단계를 나타내는 숫자를 한데 결합시켜줄 수 있는 <code>paste()</code> (또는 <code>sprintf()</code>)를 이용하는 것입니다. 
예를들면, 결과물을 현재의 작업디렉토리인 <samp><span class="file">Results</span></samp>에 <samp><span class="file">result1.rda</span></samp>, <small class="dots">...</small>, <samp><span class="file">result100.rda</span></samp>이라는 파일에 저장하기 위해서는 다음과 같이 할 수 있습니다.

<pre class="example">     for(i in 1:100) {
       ## Calculations constructing "some_object" ...
       fp &lt;- file.path("Results", paste("result", i, ".rda", sep = ""))
       save(list = "some_object", file = fp)
     }
</pre>
   <div class="node">
<a name="Why-are-p-values-not-displayed-when-using-lmer()%3f"></a>
<a name="Why-are-p_002dvalues-not-displayed-when-using-lmer_0028_0029_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-are-there-unwanted-borders">Why are there unwanted borders</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-save-the-result-of-each-iteration-in-a-loop-into-a-separate-file_003f">How can I save the result of each iteration in a loop into a separate file?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why are @math{p}-values not displayed when using lmer()? -->
<h3 class="section">7.35 lmer()을 이용할 때 왜 p-values들이 보여지지 않나요?</h3>

<!-- Doug Bates has kindly provided an extensive response in a post to the -->
<!-- r-help list, which can be reviewed at -->
<!-- @uref{https://stat.ethz.ch/pipermail/r-help/2006-May/094765.html}. -->
<p>r-help 리스트에 포스트된 이 질문에 대해서 Doug Bates는 매우 친절하게 폭넓은 응답을 해주었으며, 이는 <a href="https://stat.ethz.ch/pipermail/r-help/2006-May/094765.html">https://stat.ethz.ch/pipermail/r-help/2006-May/094765.html</a>에서 확인할 수 있습니다.

<div class="node">
<a name="Why-are-there-unwanted-borders"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-does-backslash-behave-strangely-inside-strings_003f">Why does backslash behave strangely inside strings?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-are-p_002dvalues-not-displayed-when-using-lmer_0028_0029_003f">Why are p-values not displayed when using lmer()?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why are there unwanted borders, lines or grid-like artifacts when viewing a plot saved to a PS or PDF file? -->
<h3 class="section">7.36 PS 또는 PDF 파일로 플랏을 저장할 때 원하지 않는 경계선, 라인들 또는 격자와 같은 것들이 생기나요?</h3>

<!-- This can occur when using functions such as @code{polygon()}, -->
<!-- @code{filled.contour()}, @code{image()} or other functions which may -->
<!-- call these internally.  In the case of @code{polygon()}, you may observe -->
<!-- unwanted borders between the polygons even when setting the -->
<!-- @code{border} argument to @code{NA} or @code{"transparent"}. -->
<p>이것은 <code>polygon()</code>, <code>filled.contour()</code>, <code>image()</code>, 또는 이런 함수들을 내부적으로 호출하게 되는 함수들을 이용할 때 발생합니다. 
<code>polygon()</code>의 경우에는 <code>border</code>인자를 <code>NA</code> 또는 <code>"transparent"</code>로 지정해주었음에도 다각형(polygon)들 사이에 원하지 않는 경계(border)가 생기는 것을 볼 수 있을 수도 있습니다.

<!-- The source of the problem is the PS/PDF viewer when the plot is -->
<!-- anti-aliased.  The details for the solution will be different depending -->
<!-- upon the viewer used, the operating system and may change over time. -->
<!-- For some common viewers, consider the following: -->
   <p>이 문제의 원인은 플랏이 anti-aliased되어 있을때 PS/PDF 뷰어에 있습니다.

   <p>이 문제들의 근원은 plot이 안티얼라이스드(anti-aliased, 그래픽에서 계단식 모양의 가장자리를 제거하는 처리 과정)되었을 때의 PS/PDF 뷰어입니다. 
문제해결에 대한 자세한 사항은 사용하는 뷰어 및 운영체제에 따라 다르며, 시간이 지남에 따라서 달라질 수도 있습니다. 
일부 일반적인 뷰어들에서는 다음과 같이 해 볼 수 있습니다.

     <dl>
<dt>Acrobat Reader (cross platform)<a name="index-Acrobat-Reader-_0028cross-platform_0029-1"></a><dd><!-- There are options in Preferences to enable/disable text smoothing, image -->
<!-- smoothing and line art smoothing. -->
<!-- Disable line art smoothing. -->
개인설정(Preference)메뉴에 텍스트 스무딩(Text smoothing), 이미지 스무딩(image smoothing)과 라인아트 스무딩(line art smoothing)을 활성/비활성하는 옵션이 있습니다. 
여기에서 라인아트 스무딩을 사용하지 않도록 조정하세요.

     <br><dt>Preview (Mac OS X)<a name="index-Preview-_0028Mac-OS-X_0029-2"></a><dd><!-- There is an option in Preferences to enable/disable anti-aliasing of -->
<!-- text and line art. -->
<!-- Disable this option. -->
개인설정(Preference)에서 텍스트(text)와 라인아트(line art)에 대한 안티얼라이싱(anti-aliasing)을 활성/비활성하는 옵션션이 있습니다. 
이 옵션을 비활성화 하세요.

     <br><dt>GSview (cross platform)<a name="index-GSview-_0028cross-platform_0029-3"></a><dd><!-- There are settings for Text Alpha and Graphics Alpha. -->
<!-- Change Graphics Alpha from 4 bits to 1 bit to disable graphic -->
<!-- anti-aliasing. -->
텍스트 알파(Text Alpha)와 그래픽 알파(Graphics Alpha)를 설정하도록 합니다. 
그래픽 안티얼라이싱 (graphic anti-aliasing)을 비활성화 하기 위해서 그래픽 알파를 4비트에서 1비트로 변경하세요.

     <br><dt>gv (Unix-like X)<a name="index-gv-_0028Unix_002dlike-X_0029-4"></a><dd><!-- There is an option to enable/disable anti-aliasing. -->
<!-- Disable this option. -->
안티얼라이싱(anti-aliasing)을 활성/비활성화하는 옵션이 있습니다. 
이 옵션을 비활성화하세요.

     <br><dt>Evince (Linux/GNOME)<a name="index-Evince-_0028Linux_002fGNOME_0029-5"></a><dd><!-- There is not an option to disable anti-aliasing in this viewer. -->
이 뷰어에는 안티얼라이싱을 비활성하는 옵션이 없습니다.

     <br><dt>Okular (Linux/KDE)<a name="index-Okular-_0028Linux_002fKDE_0029-6"></a><dd><!-- There is not an option in the GUI to enable/disable anti-aliasing. -->
<!-- From a console command line, use: -->
GUI에서 안티얼라이싱의 활성/비활성을 조절하는 옵션이 없습니다. 
콘솔상에서 명령어라인으로 아래와 같이 해보세요.

     <pre class="smallexample">          $ kwriteconfig --file okularpartrc --group 'Dlg Performance' \
                         --key GraphicsAntialias Disabled
</pre>
     <!-- Then restart Okular.  Change the final word to @samp{Enabled} to restore -->
     <!-- the original setting. -->
     <p>Okular를 재실행 보세요. 
본래의 설정으로 되돌리기 위해서는 마지막 단어를 &lsquo;<samp><span class="samp">Enabled</span></samp>&rsquo;로 변경하세요. 
</dl>

<div class="node">
<a name="Why-does-backslash-behave-strangely-inside-strings%3f"></a>
<a name="Why-does-backslash-behave-strangely-inside-strings_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-put-error-bars-or-confidence-bands-on-my-plot_003f">How can I put error bars or confidence bands on my plot?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-are-there-unwanted-borders">Why are there unwanted borders</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why does backslash behave strangely inside strings? -->
<h3 class="section">7.37 왜 백슬래쉬가 문자열내에서 이상하게 작동하나요?</h3>

<!-- This question most often comes up in relation to file names (see -->
<!-- @ref{How do file names work in Windows?})  but it also happens that -->
<!-- people complain that they cannot seem to put a single @samp{\} character -->
<!-- into a text string unless it happens to be followed by certain other -->
<!-- characters. -->
<p>이 질문은 종종 파일명과 관계되어 올라오곤 하지만 (<a href="#How-do-file-names-work-in-Windows_003f">How do file names work in Windows?</a>를 살펴보세요), 만약 어떤 특정 문자들에 뒤이어 일어나지 않는 이상 문자열로 단일 &lsquo;<samp><span class="samp">\</span></samp>&rsquo; 문자를 넣을 수 없는 것처럼 보일때 불평이 나오곤 합니다.

<!-- To understand this, you have to distinguish between character strings -->
<!-- and @emph{representations} of character strings.  Mostly, the -->
<!-- representation in R is just the string with a single or double quote at -->
<!-- either end, but there are strings that cannot be represented that way, -->
<!-- e.g., strings that themselves contains the quote character.  So -->
   <p>이를 이해하기 위해서는ㄴ 문자열(character strings)와 문자열의 리프레젠테이션(represenation of character strings)를 구분해야만 합니다. 
대부분의 경우에는 R에서의 리프레젠테이션(representation)은 단순히 어느쪽이 끝이던지 작은 따옴표 또는 큰 따옴표가 함께 사용된 문자열입니다. 
그러나, 이런 방법으로 사용할 수 없는 문자열들이 있습니다. 
이러한 것에 해당하는 것은 따옴표 문자를 포함하고 있는 문자열들입니다.

<pre class="example">     &gt; str &lt;- "This \"text\" is quoted"
     &gt; str
     [1] "This \"text\" is quoted"
     &gt; cat(str, "\n")
     This "text" is quoted
</pre>
   <p class="noindent"><!-- The @emph{escape sequences} @samp{\"} and @samp{\n} represent a double -->
<!-- quote and the newline character respectively. Printing text strings, -->
<!-- using @code{print()} or by typing the name at the prompt will use the -->
<!-- escape sequences too, but the @code{cat()} function will display the -->
<!-- string as-is. Notice that @samp{"\n"} is a one-character string, not -->
<!-- two; the backslash is not actually in the string, it is just generated -->
<!-- in the printed representation. -->
이스케이프 시퀀스(escape sequences) 문자인 &lsquo;<samp><span class="samp">\"</span></samp>&rsquo;와 &lsquo;<samp><span class="samp">\n</span></samp>&rsquo;은 큰 따옴표와 개행을 나타냅니다. 
<code>print()</code> 또는 프롬프트에서 이름을 입력하여 텍스트 문자열을 출력하는 것 역시 이스케이프 시퀀스를 이용합니다. 
그러나, <code>cat()</code>함수는 문자열 그대로를 보여줄 것입니다. 
&lsquo;<samp><span class="samp">"\n"</span></samp>&rsquo;은 두개가 아닌 하나의 문자임을 알아두시길 바랍니다. 
백슬래쉬는 실제로 문자열내에 포함되는 것이 아니고 단지 프린트된 리프레젠테이션에서 생성된 것 뿐입니다.

<pre class="example">     &gt; nchar("\n")
     [1] 1
     &gt; substring("\n", 1, 1)
     [1] "\n"
</pre>
   <!-- So how do you put a backslash in a string? For this, you have to -->
<!-- escape the escape character. I.e., you have to double the backslash. -->
<!-- as in -->
   <p>어떻게 백슬래쉬를 문자열 안에 표현할 수 있나요? 
이렇게 하기 위해서는 이스케이프 문자를 피해야만 합니다. 
즉, 백슬래쉬를 두번 사용해야 합니다.

<pre class="example">     &gt; cat("\\n", "\n")
     \n
</pre>
   <!-- Some functions, particularly those involving regular expression -->
<!-- matching, themselves use metacharacters, which may need to be escaped by -->
<!-- the backslash mechanism.  In those cases you may need a @emph{quadruple} -->
<!-- backslash to represent a single literal one. -->
   <p>레귤러 익스프레이션 매칭 (regular expression matching)을 이용하는 종류의 일부 함수들은 백슬래쉬 메카니즘에 의하여 피해질 필요가 있는 메타문자들(metacharacters)들을 사용합니다. 
그러한 경우에는 한개의 문자를 표현하기 위해서 4개의 백슬래쉬를 써야 할 경우도 있습니다.

<!-- In versions of R up to 2.4.1 an unknown escape sequence like @samp{\p} -->
<!-- was quietly interpreted as just @samp{p}.  Current versions of R emit a -->
<!-- warning. -->
   <p>2.4.1Rkwlsms &lsquo;<samp><span class="samp">\p</span></samp>&rsquo;와 같은 알려지지 않는 이스케이프 문자들은 &lsquo;<samp><span class="samp">p</span></samp>&rsquo;로 에러의 출력없이 해석되었습니다. 
현재 버전의 R은 경고를 표시합니다.

<div class="node">
<a name="How-can-I-put-error-bars-or-confidence-bands-on-my-plot%3f"></a>
<a name="How-can-I-put-error-bars-or-confidence-bands-on-my-plot_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-I-create-a-plot-with-two-y_002daxes_003f">How do I create a plot with two y-axes?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-does-backslash-behave-strangely-inside-strings_003f">Why does backslash behave strangely inside strings?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How can I put error bars or confidence bands on my plot? -->
<h3 class="section">7.38 플랏에 어떻게 에러바 또는 신뢰구간을 표시할 수 있나요?</h3>

<!-- Some functions will display a particular kind of plot with error bars, -->
<!-- such as the @code{bar.err()} function in the @CRANpkg{agricolae} -->
<!-- package, the @code{plotCI()} function in the @CRANpkg{gplots} package, -->
<!-- the @code{plotCI()} and @code{brkdn.plot()} functions in the -->
<!-- @CRANpkg{plotrix} package and the @code{error.bars()}, -->
<!-- @code{error.crosses()} and @code{error.bars.by()} functions in the -->
<!-- @CRANpkg{psych} package.  Within these types of functions, some will -->
<!-- accept the measures of dispersion (e.g., @code{plotCI}), some will -->
<!-- calculate the dispersion measures from the raw values (@code{bar.err}, -->
<!-- @code{brkdn.plot}), and some will do both (@code{error.bars}).  Still -->
<!-- other functions will just display error bars, like the dispersion -->
<!-- function in the @CRANpkg{plotrix} package.  Most of the above functions -->
<!-- use the @code{arrows()} function in the base @pkg{graphics} package to -->
<!-- draw the error bars. -->
<p>특정한 종류의 플랏들에 대해서 에러바를 보여주는 일부 함수들이 있습니다. 
<a href="http://CRAN.R-project.org/package=agricolae"><strong>agricolae</strong></a> 패키지내의 <code>bar.err()</code> 함수, <a href="http://CRAN.R-project.org/package=gplots"><strong>gplots</strong></a> 패키지내의 <code>plotCI()</code> 함수, <a href="http://CRAN.R-project.org/package=plotrix"><strong>plotrix</strong></a> 패키지내의 <code>plotCI()</code>와 <code>brkdn.plot()</code> 함수, <a href="http://CRAN.R-project.org/package=psych"><strong>psych</strong></a> 패키지내의 <code>error.bars()</code>, <code>error.crosses()</code>, 그리고 <code>error.bars.by()</code> 함수가 있습니다. 
이러한 유형의 함수 중 <code>plotCI()</code>과 같은 몇몇 함수들은 dispersion(분산)을 계산해주고, <code>bar.err</code>와 <code>brkdn.plot</code>와 같은 것들은 원래의 값들 (raw values)로부터의 dispersion measure(분산 측도)를 계산해주며, <code>error.bars</code>와 같은 것들은 두가지 모두를 제공합니다. 
<code>plotrix</code> 패키지내에 있는 dispersion 함수와 같은 것들은 에러바들만을 보여주기도 합니다. 
위에서 언급한 함수들의 대부분은 에러바를 그리기 위해서 base <strong>graphics</strong> 패키지 내에 있는 <code>arrows()</code>를 사용합니다.

<!-- The above functions all use the base graphics system.  The grid and -->
<!-- lattice graphics systems also have specific functions for displaying -->
<!-- error bars, e.g., the @code{grid.arrow()} function in the @pkg{grid} -->
<!-- package, and the @code{geom_errorbar()}, @code{geom_errorbarh()}, -->
<!-- @code{geom_pointrange()}, @code{geom_linerange()}, -->
<!-- @code{geom_crossbar()} and @code{geom_ribbon()} functions in the -->
<!-- @CRANpkg{ggplot2} package.  In the lattice system, error bars can be -->
<!-- displayed with @code{Dotplot()} or @code{xYplot()} in the -->
<!-- @CRANpkg{Hmisc} package and @code{segplot()} in the -->
<!-- @CRANpkg{latticeExtra} package. -->
   <p>위에서 언급한 함수 모두는 base graphics 시스템 (즉, base 배포에 있는 graphics 패키지를 이용한 그래픽 시스템)을 이용합니다. 
grid와 lattice 그래픽 시스템들 또한 에러바를 보여주는데 필요한 특정한 함수들을 가지고 있습니다. 
예를들면, <strong>grid</strong> 패키지내의 <code>grid.arrow()</code> 함수와 <a href="http://CRAN.R-project.org/package=ggplot2"><strong>ggplot2</strong></a> 패키지 내의 <code>geom_errorbar()</code>, <code>geom_errorbarh()</code>, <code>geom_pointrange()</code>, <code>geom_linerange()</code>, <code>geom_crossbar()</code>, 그리고 <code>geom_ribbon()</code>함수등입니다. 
라띠스 시스템에서는 <a href="http://CRAN.R-project.org/package=Hmisc"><strong>Hmisc</strong></a> 패키지에 있는 <code>Dotplot()</code> 또는 <code>xYplot()</code> 함수들, <a href="http://CRAN.R-project.org/package=latticeExtra"><strong>latticeExtra</strong></a> 패키지에 있는 <code>segplot()</code> 함수가 에러바를 보여줄 수 있습니다.

<div class="node">
<a name="How-do-I-create-a-plot-with-two-y-axes%3f"></a>
<a name="How-do-I-create-a-plot-with-two-y_002daxes_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-do-I-access-the-source-code-for-a-function_003f">How do I access the source code for a function?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-put-error-bars-or-confidence-bands-on-my-plot_003f">How can I put error bars or confidence bands on my plot?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How do I create a plot with two y-axes? -->
<h3 class="section">7.39 어떻게 해야 두 개의 y 축을 가진 플랏을 생성할 수 있나요?</h3>

<!-- Creating a graph with two y-axes, i.e., with two sorts of data that are -->
<!-- scaled to the same vertical size and showing separate vertical axes on -->
<!-- the left and right sides of the plot that reflect the original scales of -->
<!-- the data, is possible in R but is not recommended.  The basic approach -->
<!-- for constructing such graphs is to use @code{par(new=TRUE)} (see -->
<!-- @code{?par}); functions @code{twoord.plot()} (in the @CRANpkg{plotrix} -->
<!-- package) and @code{doubleYScale()} (in the @CRANpkg{latticeExtra} -->
<!-- package) automate the process somewhat.  See -->
<!-- @url{http://rwiki.sciviews.org/@/doku.php?id=tips:graphics-base:2yaxes} -->
<!-- for more information, including strong arguments against this sort of -->
<!-- graph. -->
<p>예를들어, 두가지 다른 종류의 데이터가 같은 높이를 가지도록 스케일되어 있으되, 플랏의 좌측과 우측이 서로 다른 값의 범위를 가지는 두개의 y 축을 가지는 그래프를 생성하고자 한다면, 이는 R에서 가능합니다. 
그러나, 권장되지는 않습니다. 
이러한 그래프를 생성하기 위해서는 기본적으로 <code>par(new=TRUE)</code> (<code>?par</code>를 참조하세요)를 이용하는 것입니다. 
<a href="http://CRAN.R-project.org/package=plotrix"><strong>plotrix</strong></a> 패키지내의 <code>twoord.plot()</code> 함수와 <a href="http://CRAN.R-project.org/package=latticeExtra"><strong>latticeExtra</strong></a> 패키지의 <code>doubleYScale()</code> 함수들이 어느정도 자동화 된 프로세스를 제공합니다. 
더 많은 정보를 위해서는 <a href="http://rwiki.sciviews.org/doku.php?id=tips:graphics-base:2yaxes">http://rwiki.sciviews.org/doku.php?id=tips:graphics-base:2yaxes</a>를 살펴보시길 바랍니다.

<div class="node">
<a name="How-do-I-access-the-source-code-for-a-function%3f"></a>
<a name="How-do-I-access-the-source-code-for-a-function_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-does-summary_0028_0029-report-strange-results-for-the-R_005e2-estimate-when-I-fit-a-linear-model-with-no-intercept_003f">Why does summary() report strange results for the R^2 estimate when I fit a linear model with no intercept?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-do-I-create-a-plot-with-two-y_002daxes_003f">How do I create a plot with two y-axes?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section How do I access the source code for a function? -->
<h3 class="section">7.40 어떻게 함수의 원시코드에 접근할 수 있나요?</h3>

<!-- In most cases, typing the name of the function will print its source -->
<!-- code. However, code is sometimes hidden in a namespace, or compiled.  For -->
<!-- a complete overview on how to access source code, see Uwe Ligges (2006), -->
<!-- ``Help Desk: Accessing the sources'', @emph{R News}, @strong{6/4}, -->
<!-- 43-45 (@url{http://CRAN.R-project.org/doc/Rnews/Rnews_2006-4.pdf}). -->
<p>대부분의 경우에, 함수의 이름을 입력하면 원시 코드를 확인할 수 있습니다. 
그런데, 네임스페이스 내에 있어 보여지지 않거나 컴파일되어 보여지지 않는 경우가 있습니다. 
원시코드에 대한 접근을 어떻게 하는가에 대한 전반적인 개요는 Uwe Ligges (2006), &ldquo;Help Desk: Accessing the sources&rdquo;, <em>R News</em>, <strong>6/4</strong>, 43&ndash;45 (<a href="http://CRAN.R-project.org/doc/Rnews/Rnews_2006-4.pdf">http://CRAN.R-project.org/doc/Rnews/Rnews_2006-4.pdf</a>)를 살펴보시길 바랍니다.

<div class="node">
<a name="Why-does-summary()-report-strange-results-for-the-R%5e2-estimate-when-I-fit-a-linear-model-with-no-intercept%3f"></a>
<a name="Why-does-summary_0028_0029-report-strange-results-for-the-R_005e2-estimate-when-I-fit-a-linear-model-with-no-intercept_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Why-is-R-apparently-not-releasing-memory_003f">Why is R apparently not releasing memory?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-do-I-access-the-source-code-for-a-function_003f">How do I access the source code for a function?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why does summary() report strange results for the R^2 estimate when I fit a linear model with no intercept? -->
<h3 class="section">7.41 절편이 없는 선형모형을 적합했을때 summary()가 보여주는 R^2 값이 왜 이상한가요?</h3>

<!-- As described in @code{?summary.lm}, when the intercept is zero (e.g., -->
<!-- from @code{y ~ x - 1} or @code{y ~ x + 0}), @code{summary.lm()} uses the -->
<!-- formula -->
<p><code>?summary.lm</code>에 설명되어 있는 것과 같이 절편이 0일때 (즉, <code>y~x-1</code> 또는 <code>y~x+0</code> 이라고 사용하는 경우), <code>summary.lm()</code>은 다음의 포뮬러를 사용합니다.

   <p>R^2 = 1 - Sum(R[i]^2) / Sum((y[i])^2)
<!-- which is different from the usual -->
위의 포뮬러는 다음의 일반적인 포뮬러와 다릅니다. 
  R^2 = 1 - Sum(R[i]^2) / Sum((y[i] - mean(y))^2). 
<!-- There are several reasons for this: -->
여기에는 다음과 같은 몇 가지의 이유들이 있습니다:

     <ul>
<li><!-- Otherwise the @math{R^2} could be negative (because the model with zero -->
<!-- intercept can fit @emph{worse} than the constant-mean model it is -->
<!-- implicitly compared to). -->
R^2는 음수가 될 수 있습니다 (절편이 없는 모델은 비교되어지는 상수-평균(constant-mean) 모델보다 설명력이 안 좋게 적합될수도 있기 때문입니다).

     <li><!-- If you set the slope to zero in the model with a line through the -->
<!-- origin you get fitted values y*=0 -->
만약 원점을 지나는 직선을 가진 모델의 기울기가 0으로 설정되면, 적합된 값 y*=0를 가지게 됩니다.

     <li><!-- The model with constant, non-zero mean is not nested in the model -->
<!-- with a line through the origin. -->
원점을 지나는 직선을 가진 모델에 상수, 즉 0이 아닌 평균을 가지는 모델은 중첩되지 않습니다. 
</ul>

<!-- All these come down to saying that if you know @emph{a priori} that -->
<!-- @math{E[Y]=0} when @math{x=0} then the `null' model that you should -->
<!-- compare to the fitted line, the model where @math{x} doesn't explain any -->
<!-- of the variance, is the model where @math{E[Y]=0} everywhere.  (If you -->
<!-- don't know a priori that @math{E[Y]=0} when @math{x=0}, then you -->
<!-- probably shouldn't be fitting a line through the origin.) -->
   <p>만약 x=0이면 E[Y]=0이라는 것을 미리 알고 있다면 적합된 직선에 비교해야 할 `null' 모델은 모든 곳에서 E[Y]=0인, 즉 x가 어떠한 분산도 설명할 수 없는 모델입니다 (만약 x=0일 때 E[Y]=0이라는 것을 사전에 모른다면 원점을 지나는 직선에 적합하는 것은 아마도 하지 말아야 할 것입니다).

<div class="node">
<a name="Why-is-R-apparently-not-releasing-memory%3f"></a>
<a name="Why-is-R-apparently-not-releasing-memory_003f"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-does-summary_0028_0029-report-strange-results-for-the-R_005e2-estimate-when-I-fit-a-linear-model-with-no-intercept_003f">Why does summary() report strange results for the R^2 estimate when I fit a linear model with no intercept?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Miscellanea">R Miscellanea</a>

</div>

<!-- @section Why is R apparently not releasing memory? -->
<h3 class="section">7.42 왜 R은 마치 메모리를 풀어주지 않는것처럼 보이나요?</h3>

<!-- This question is often asked in different flavors along the lines of -->
<!-- ``I have removed objects in R and run @code{gc()} and yet -->
<!-- @code{ps}/@code{top} still shows the R process using a lot of -->
<!-- memory'', often on Linux machines. -->
<p>종종 리눅스를 이용하는 사용자들은 &ldquo;R 내부의 객체들을 지우고 <code>gc()</code>를 실행하여 보니 <code>ps</code>/<code>top</code>에 따르면 R 프로세스가 많은 양의 메모리를 사용하는 것으로 보인다&rdquo;라는 의미와는 다른 의미로 질문이 되어집니다.

<!-- This is an artifact of the way the operating system (OS) allocates -->
<!-- memory.  In general it is common that the OS is not capable of -->
<!-- releasing all unused memory.  In extreme cases it is possible that even -->
<!-- if R frees almost all its memory, the OS can not release any of it due -->
<!-- to its design and thus tools such as @code{ps} or @code{top} will -->
<!-- report substantial amount of resident RAM used by the R process even -->
<!-- though R has released all that memory.  In general such tools do -->
<!-- @emph{not} report the actual memory usage of the process but rather -->
<!-- what the OS is reserving for that process. -->
   <p>이것은 운영체제가 메모리를 인공적으로 할당하는 방법입니다. 
일반적으로 운영체제가 사용되지 않은 모든 메모리를 풀어줄 수 없습니다. 
극단적인 경우에, 만약 R이 거의 모든 메모리를 자유롭게 할지라도 운영체제는 자체 설계 때문에 이들 중 어떤 것이라도 풀수 없습니다. 
따라서, <code>ps</code>와 <code>top</code>과 같은 도구들은 R이 메모리를 아예 사용하지 않을지라도 R 프로세스에 의하여 사용되어진 상주된 RAM의 실질적인 양을 보고하게 됩니다. 
일반적으로 이러한 도구들은 프로세스의 실제 메모리 사용을 보고 하지 않고 운영체제가 해당 프로세스를 위하여 예약해 둔 것을 보고 합니다.

<!-- The short answer is that this is a limitation of the memory allocator -->
<!-- in the operating system and there is nothing R can do about it. That -->
<!-- space is simply kept by the OS in the hope that R will ask for it -->
<!-- later.  The following paragraph gives more in-depth answer with -->
<!-- technical details on how this happens. -->
   <p>간단히 말하면 이는 운영체제 내의 메모리 할당기(memory allocator)의 한계이며 이것과 관련하여 R이 할 수 있는 것은 아무것도 없습니다. 
그 공간은 R이 나중에 물어볼 것이라는 기대하에 단순히 운영체제에 잡혀있습니다. 
다음의 내용은 어떻게 이것이 발생되는지에 대한 다소 심도있는 답변을 줍니다.

<!-- Most systems use two separate ways to allocate memory. For allocation -->
<!-- of large chunks they will use @code{mmap} to map memory into the -->
<!-- process address space.  Such chunks can be released immediately when -->
<!-- they are completely free, because they can reside anywhere in the -->
<!-- virtual memory.  However, this is a relatively expensive operation and -->
<!-- many OSes have a limit on the number of such allocated chunks, so this -->
<!-- is only used for allocating large memory regions. For smaller -->
<!-- allocations the system can expand the data segment of the process -->
<!-- (historically using the @code{brk} system call), but this whole area -->
<!-- is always contiguous.  The OS can only move the end of this space, it -->
<!-- cannot create any ``holes''. Since this operation is fairly cheap, it -->
<!-- is used for allocations of small pieces of memory.  However, the -->
<!-- side-effect is that even if there is just one byte that is in use -->
<!-- at the end of the data segment, the OS cannot release any memory -->
<!-- at all, because it cannot change the address of that byte.  This is -->
<!-- actually more common than it may seem, because allocating a lot of -->
<!-- intermediate objects, then allocating a result object and removing all -->
<!-- intermediate objects is a very common practice.  Since the result is -->
<!-- allocated at the end it will prevent the OS from releasing any memory -->
<!-- used by the intermediate objects.  In practice, this is not necessarily -->
<!-- a problem, because modern operating systems can page out unused -->
<!-- portions of the virtual memory so it does not necessarily reduce the -->
<!-- amount of real memory available for other applications.  Typically, -->
<!-- small objects such as strings or pairlists will be affected by this -->
<!-- behavior, whereas large objects such as long vectors will be allocated -->
<!-- using @code{mmap} and thus not affected.  On Linux (and possibly other -->
<!-- Unix-like systems) it is possible to use the @code{mallinfo} system call -->
<!-- (also see the @url{http://rforge.net/mallinfo, mallinfo} package) to -->
<!-- query the allocator about the layout of the allocations, including the -->
<!-- actually used memory as well as unused memory that cannot be released. -->
   <p>대부분의 시스템들은 메모리를 지정하기 위해 두 가지 다른 방법을 사용합니다. 
큰 청크(chunks, 즉 지정한 데이터의 양)의 할당에 대해서 그들은 프로세스 주소공간(process address space)로 맵 메모리(map memory)로 안내하기 위해서 <code>mmap</code>을 이용합니다. 
이러한 조각들은 그들이 사용되지 않을때 즉각적으로 풀려집니다. 
그러나, 이것은 상대적으로 비싼 연산에 해당되며 많은 운영체제들이 그러한 할당된 청크의 양에는 한계를 가지고 있으므로 이것은 오로지 큰 메모리 영역(memory regions)을 할당하는 목적으로만 사용됩니다.

   <p>작은 청크의 할당에 대해서는 시스템은 프로세스의 데이터 세그멘트(data segment)를 확장할 수 있습니다 (역사상으로는 <code>brk</code> 시스템 호출을 이용합니다). <!-- 그러나 이 전체 area는 항상 근접합니다. -->
운영체제는 이 공간의 끝만을 이동할 수 있고, 어떠한 &ldquo;holes&rdquo;를 생성할 수 없습니다. 
이러한 작동에 대한 비용은 꽤 싼 편에 속하기 때문에 메모리의 작은 조작들에 대한 할당을 위한 목적으로 사용됩니다. 
그러나, 부작용으로는 데이터 세그먼트의 끝에서 오로지 1 바이트만이 사용되고 있을지라도 운영체제는 어떠한 메모리라도 풀어주지 않습니다. 
그 이유는 해당 바이트의 주소를 변경할 수 없기 때문입니다. 
이것은 실제로 보기 흔합니다. 
그 이유는 중간단계의 객체들을 할당하고 난뒤에 결과 객체를 할당하고 모든 중간단계의 객체를 삭제하는 것은 흔하기 때문입니다. 
결과는 맨 마지막에 할당되기 때문에 중간단계의 객체에 의해서 사용된 어떤 메모리를 운영체제는 풀어주지 않습니다.

   <p>실제로 이것이 큰 문제가 되는 것은 아닙니다. 
왜냐하면 현대의 운영체제는 쓰이지 않는 가상 메모리 부분을 페이지 아웃(page out)을 할 수 있어, 다른 어플리케이션에 이용될 실제 메모리의 양을 줄이는 것이 아니기 때문입니다. 
일반적으로 문자열(strings)과 페어리스트(pairlists)와 같은 작은 객체들은 이러한 작동방식에 의하여 영향을 받을 것입니다. 
반면에 긴 벡터와 같은 큰 객체들은 <code>mmap</code>을 이용하게 될것이므로 영향을 받지 않습니다. 
리눅스 (그리고 Unix와 같은 시스템들)에서는 실제적으로 사용되지 않은 메모리, 풀어줄 수 없는 메모리를 포함하여 할당 레이아웃(layout of allocation)에 관하여 할당기(allocator)를 질의하기 위하여 <code>mallinfo</code> 시스템호출을 이용하는 것이 가능합니다 (<a href="http://rforge.net/mallinfo">mallinfo</a> 패키지를 살펴보세요)

<div class="node">
<a name="R-Programming"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#R-Bugs">R Bugs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Miscellanea">R Miscellanea</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter R Programming -->
<h2 class="chapter">8 R 프로그래밍</h2>

<ul class="menu">
<li><a accesskey="1" href="#How-should-I-write-summary-methods_003f">How should I write summary methods?</a>
<li><a accesskey="2" href="#How-can-I-debug-dynamically-loaded-code_003f">How can I debug dynamically loaded code?</a>
<li><a accesskey="3" href="#How-can-I-inspect-R-objects-when-debugging_003f">How can I inspect R objects when debugging?</a>
<li><a accesskey="4" href="#How-can-I-change-compilation-flags_003f">How can I change compilation flags?</a>
<li><a accesskey="5" href="#How-can-I-debug-S4-methods_003f">How can I debug S4 methods?</a>
</ul>

<div class="node">
<a name="How-should-I-write-summary-methods%3f"></a>
<a name="How-should-I-write-summary-methods_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-debug-dynamically-loaded-code_003f">How can I debug dynamically loaded code?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Programming">R Programming</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Programming">R Programming</a>

</div>

<!-- @section How should I write summary methods? -->
<h3 class="section">8.1 어떻게 summary 메소드를 작성해야 하나요?</h3>

<!-- Suppose you want to provide a summary method for class @code{"foo"}. -->
<!-- Then @code{summary.foo()} should not print anything, but return an -->
<!-- object of class @code{"summary.foo"}, @emph{and} you should write a -->
<!-- method @code{print.summary.foo()} which nicely prints the summary -->
<!-- information and invisibly returns its object.  This approach is -->
<!-- preferred over having @code{summary.foo()} print summary information and -->
<!-- return something useful, as sometimes you need to grab something -->
<!-- computed by @code{summary()} inside a function or similar.  In such -->
<!-- cases you don't want anything printed. -->
<p>만약 <code>"foo"</code>라는 클래스에 대한 summary 메소드를 만들고 싶다면, <code>summary.foo()</code>는 아무것도 출력해서는 안됩니다. 
그러나, 클래스의 객체 <code>"summary.foo"</code>를 반환해야 하며, summary의 정보를 보기 좋게 출력해주며 이 객체를 보이지 않게 반환하는 <code>print.summary.foo()</code>라는 메소드를 작성해야 합니다. 
이러한 접근은 요약정보를 출력하는 <code>summary.foo()</code> 보다 선호됩니다. 
그 이유는 때때로 함수 또는 유사한 곳의 내부에서 <code>summary()</code>에 의하여 계산된 결과를 사용할 필요가 때때로 있기 때문입니다. 
그런 경우에 메소드 작성자는 어떠한 것도 출력되기를 원하지 않을 것입니다.

<div class="node">
<a name="How-can-I-debug-dynamically-loaded-code%3f"></a>
<a name="How-can-I-debug-dynamically-loaded-code_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-inspect-R-objects-when-debugging_003f">How can I inspect R objects when debugging?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-should-I-write-summary-methods_003f">How should I write summary methods?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Programming">R Programming</a>

</div>

<!-- @section How can I debug dynamically loaded code? -->
<h3 class="section">8.2 어떻게 로드된 코드를 다이나믹하게 디버그 할 수 있나요?</h3>

<!-- Roughly speaking, you need to start R inside the debugger, load the -->
<!-- code, send an interrupt, and then set the required breakpoints. -->
<p>대략적으로 말하면, 디버거 내에서 R을 시작할 필요가 있고, 코드를 로드하고, 인터럽트(interrupt)를 보내고, 브레이크포인트(breakpoint)을 설정해야만 합니다.

<!-- See section ``Finding entry points in dynamically loaded code'' in -->
<!-- @cite{Writing R Extensions}.  This manual is included in the R -->
<!-- distribution, @pxref{What documentation exists for R?}. -->
   <p><cite>Writing R Extensions</cite> 문서에서 &ldquo;Finding entry points in dynamically loaded code&rdquo; 섹션을 참고하시길 바랍니다. 
이 매뉴얼은 R 배포에 포함되어 있습니다, see <a href="#What-documentation-exists-for-R_003f">What documentation exists for R?</a>.

<div class="node">
<a name="How-can-I-inspect-R-objects-when-debugging%3f"></a>
<a name="How-can-I-inspect-R-objects-when-debugging_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-change-compilation-flags_003f">How can I change compilation flags?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-debug-dynamically-loaded-code_003f">How can I debug dynamically loaded code?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Programming">R Programming</a>

</div>

<!-- @section How can I inspect R objects when debugging? -->
<h3 class="section">8.3 디버깅 할 때 어떻게 R 객체들을 조사할 수 있나요?</h3>

<!-- The most convenient way is to call @code{R_PV} from the symbolic -->
<!-- debugger. -->
<p>가장 편리한 방법은 심볼릭 디버거(symbolic debugger)로부터 <code>R_PV</code>를 호출하는 것입니다.

<!-- See section ``Inspecting R objects when debugging'' in @cite{Writing R -->
<!-- Extensions}. -->
   <p><cite>Writing R Extensions</cite> 문서에서 &ldquo;Inspecting R objects when debugging&rdquo; 섹션을 참고하세요.

<div class="node">
<a name="How-can-I-change-compilation-flags%3f"></a>
<a name="How-can-I-change-compilation-flags_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-can-I-debug-S4-methods_003f">How can I debug S4 methods?</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-inspect-R-objects-when-debugging_003f">How can I inspect R objects when debugging?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Programming">R Programming</a>

</div>

<!-- @section How can I change compilation flags? -->
<h3 class="section">8.4 컴파일레이션 플래그를 어떻게 변경할 수 있나요?</h3>

<!-- Suppose you have C code file for dynloading into R, but you want to use -->
<!-- @code{R CMD SHLIB} with compilation flags other than the default ones -->
<!-- (which were determined when R was built). -->
<p>R로 dynloading하기위한 C 코드 파일이 있지만, 기본값(R이 빌드되었을때 정해놓은)이 아닌 컴파일레이션 플래그들을 가지고 있는 <code>R CMD SHLIB</code>를 사용하고 싶다고 가정합니다.

<!-- Starting with R 2.1.0, users can provide personal Makevars configuration -->
<!-- files in @file{$@env{HOME}/.R} to override the default flags. -->
   <p>R 2.1.0 부터 사용자는 디폴트 플래그를 덮어쓰기 위하여 <samp><span class="file">$</span><samp><span class="env">HOME</span></samp><span class="file">/.R</span></samp>내에 있는 개인 Makevars 설정파일을 제공합니다. 
<!-- See section ``Add-on packages'' in @cite{R Installation and -->
<!-- Administration}. -->
<cite>R Installation and Administration</cite> 문서의 &ldquo;Add-on packages&rdquo; 섹션을 살펴보세요

<!-- For earlier versions of R, you could change the file -->
<!-- @file{@var{R_HOME}/etc/Makeconf} to reflect your preferences, or (at -->
<!-- least for systems using @acronym{GNU} Make) override them by the -->
<!-- environment variable @env{MAKEFLAGS}. -->
   <p>이전 버전의 R에서는 개인설정을 반영하기 위하여 <samp><var>R_HOME</var><span class="file">/etc/Makeconf</span></samp> 파일을 변경할 수 있거나, (최소한 <acronym>GNU</acronym> Make를 이용하는 시스템들에서) 환경변수 <samp><span class="env">MAKEFLAGS</span></samp>를 이용하여 값들을 덮어 쓸 수 있었습니다.

<!-- See section ``Creating shared objects'' in @cite{Writing R Extensions}. -->
   <p><cite>Writing R Extensions</cite> 문서에서 &ldquo;Creating shared objects&rdquo; 섹션을 참조하세요.

<div class="node">
<a name="How-can-I-debug-S4-methods%3f"></a>
<a name="How-can-I-debug-S4-methods_003f"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-can-I-change-compilation-flags_003f">How can I change compilation flags?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Programming">R Programming</a>

</div>

<!-- @section How can I debug S4 methods? -->
<h3 class="section">8.5 S4 메소드를 어떻게 디버그 하나요?</h3>

<!-- Use the @code{trace()} function with argument @code{signature=} to add -->
<!-- calls to the browser or any other code to the method that will be -->
<!-- dispatched for the corresponding signature.  See @code{?trace} for -->
<!-- details. -->
<p>브라우저로 호출을 추가하기 위하여 인자 <code>signature=</code>와 함께 <code>trace()</code> 함수를 이용하거나 상응하는 서명에 대해서 디스패치될 다른 코드를 이용하세요. 
더 자세한 내용은 <code>?trace</code>를 참조하세요.

<div class="node">
<a name="R-Bugs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Acknowledgments">Acknowledgments</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Programming">R Programming</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter R Bugs -->
<h2 class="chapter">9 R 버그</h2>

<ul class="menu">
<li><a accesskey="1" href="#What-is-a-bug_003f">What is a bug?</a>
<li><a accesskey="2" href="#How-to-report-a-bug">How to report a bug</a>
</ul>

<div class="node">
<a name="What-is-a-bug%3f"></a>
<a name="What-is-a-bug_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-to-report-a-bug">How to report a bug</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Bugs">R Bugs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Bugs">R Bugs</a>

</div>

<!-- @section What is a bug? -->
<h3 class="section">9.1 버그란 무엇인가요?</h3>

<!-- If R executes an illegal instruction, or dies with an operating system -->
<!-- error message that indicates a problem in the program (as opposed to -->
<!-- something like ``disk full''), then it is certainly a bug.  If you call -->
<!-- @code{.C()}, @code{.Fortran()}, @code{.External()} or @code{.Call()} (or -->
<!-- @code{.Internal()}) yourself (or in a function you wrote), you can -->
<!-- always crash R by using wrong argument types (modes).  This is not a -->
<!-- bug. -->
<p>만약 R이 정의되어 있는 방식대로 작동하지 않거나, 운영체제로부터의 프로그램에 문제가 있다 (디스크가 꽉 찼다는 것과 반대)는 에러메시지와 함께 프로그램이 죽는다면 이는 확실히 버그입니다. 
만약 <code>.C()</code>, <code>.Fortran()</code>, <code>.External()</code>, 또는 <code>.Call()</code> (또는 <code>.Internal()</code>), 작성한 함수내에서 자기자신을 호출할때, 잘못된 인자유형을 사용하면 R은 작동하지 않을 수도 있습니다. 
이것은 버그가 아닙니다.

<!-- Taking forever to complete a command can be a bug, but you must make -->
<!-- certain that it was really R's fault.  Some commands simply take a long -->
<!-- time.  If the input was such that you @emph{know} it should have been -->
<!-- processed quickly, report a bug.  If you don't know whether the command -->
<!-- should take a long time, find out by looking in the manual or by asking -->
<!-- for assistance. -->
   <p>명령을 수행시 명령이 끝나지 않고 계속 지속되는 것은 버그일 수도 있으나, 이것이 정말 R의 잘못인지를 반드시 확인해 보아야 합니다. 
일부 명령어들은 단순히 오랜 시간이 걸릴 수도 있기 때문입니다. 
만약 입력이 빨리 프로세스 되어야 한다는 것을 명백히 알고 있다면, 버그로 보고하시길 바랍니다. 
만약에 명령어가 오래 걸릴지 안 걸릴지를 확신할 수 없다면 도움을 청하거나 매뉴얼을 읽어보면서 이를 알아내길 바랍니다.

<!-- If a command you are familiar with causes an R error message in a case -->
<!-- where its usual definition ought to be reasonable, it is probably a bug. -->
<!-- If a command does the wrong thing, that is a bug.  But be sure you know -->
<!-- for certain what it ought to have done.  If you aren't familiar with the -->
<!-- command, or don't know for certain how the command is supposed to work, -->
<!-- then it might actually be working right.  For example, people sometimes -->
<!-- think there is a bug in R's mathematics because they don't understand -->
<!-- how finite-precision arithmetic works.  Rather than jumping to -->
<!-- conclusions, show the problem to someone who knows for certain. -->
<!-- Unexpected results of comparison of decimal numbers, for example -->
<!-- @code{0.28 * 100 != 28} or @code{0.1 + 0.2 != 0.3}, are not a bug. -->
<!-- @xref{Why doesn't R think these numbers are equal?}, for more details. -->
   <p>만약 익숙한 명령어가 정상적으로 작동해야 할 경우에 에러메시지를 발생시킨다면, 이것은 아마도 버그일 것입니다. 
만약 명령어가 잘못된 작업을 수행한다면, 이는 버그입니다. 
그러나, 사용자는 반드시 무엇이 수행되어야 하는지를 반드시 알고 있어야 합니다. 
만약 명령어가 익숙한 것이 아니라면 또는 어떻게 명령어가 작동되는가를 정확히 모른다면, 실제로 정상적으로 작동하는 것일 수도 있습니다. 
예를들면, 일부 사용자들은 때때로 R의 수학적 연산에 버그가 있다고 생각합니다. 
그러나, 이는 finite-precision arithmetic work를 이해하지 못하기 때문입니다. 
결론을 내리기 전에 문제를 확실히 알고있는 누군가에게 보여주길 바랍니다. 
예를들어 <code>0.28 * 100 != 28</code> 또는 <code>0.1 + 0.2 != 0.3</code>과 같은 것은 버그가 아닙니다. 
더 자세한 사항은 <a href="#Why-doesn_0027t-R-think-these-numbers-are-equal_003f">Why doesn't R think these numbers are equal?</a>를 참고해주세요.

<!-- Finally, a command's intended definition may not be best for statistical -->
<!-- analysis.  This is a very important sort of problem, but it is also a -->
<!-- matter of judgment.  Also, it is easy to come to such a conclusion out -->
<!-- of ignorance of some of the existing features.  It is probably best not -->
<!-- to complain about such a problem until you have checked the -->
<!-- documentation in the usual ways, feel confident that you understand it, -->
<!-- and know for certain that what you want is not available.  If you are -->
<!-- not sure what the command is supposed to do after a careful reading of -->
<!-- the manual this indicates a bug in the manual.  The manual's job is to -->
<!-- make everything clear.  It is just as important to report documentation -->
<!-- bugs as program bugs.  However, we know that the introductory -->
<!-- documentation is seriously inadequate, so you don't need to report this. -->
   <p>마지막으로, 명령어의 계획된 정의가 통계분석에 가장 잘 맞는 것은 아닙니다. 
이것은 매우 중요한 문제이기도 한데, 이는 또한 문제에 대한 판단의 문제이기도 합니다. 
또한, 이들은 이전에 존재하는 기능들에 대해서 모르기 때문에 내리는 결론이기도 합니다. 
이러한 종류의 문제에 대해서는 일반적인 방법으로 문서를 확인하고, 이를 제대로 이해했다고 확신한뒤, 원하는 무엇인가를 이용가능하지 않다는 것을 확실하게 알기전까지는 불평하지 않는 것이 좋습니다. 
만약 매뉴얼을 정독한 후에도 명령어가 어떻게 무엇을 수행해야 하는지를 정확히 이해할 수 없다면, 이는 매뉴얼에 버그가 있음을 의미합니다. 
매뉴얼의 역할은 모든 것을 확실히 보여주는 것입니다. 
프로그램 버그도 중요하지만 문서의 버그를 보고하는 것도 중요합ㄴ디ㅏ. 
그런데, introductory documentation은 심각하게 불충분하다는 것을 알고 이미 알고 있기 때문에 이것을 보고할 필요는 없습니다.

<!-- If the online argument list of a function disagrees with the manual, one -->
<!-- of them must be wrong, so report the bug. -->
   <p>만약 함수의 온라인 인자목록이 매뉴얼과 일치하지 않는다면, 둘 중에 하나가 잘 못된 것이므로 버그로 보고해 주시길 바랍니다.

<div class="node">
<a name="How-to-report-a-bug"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#What-is-a-bug_003f">What is a bug?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-Bugs">R Bugs</a>

</div>

<!-- @section How to report a bug -->
<h3 class="section">9.2 어떻게 버그를 보고하나요?</h3>

<!-- When you decide that there is a bug, it is important to report it and to -->
<!-- report it in a way which is useful.  What is most useful is an exact -->
<!-- description of what commands you type, starting with the shell command -->
<!-- to run R, until the problem happens.  Always include the version of R, -->
<!-- machine, and operating system that you are using; type @kbd{version} in -->
<!-- R to print this. -->
<p>버그가 있다고 판단될때, 이것을 보고하는 것도 중요하고, 어떻게 잘 보고하는가도 중요합니다. 
가장 좋은 방법은 쉘 커맨드에서 R을 입력하면서부터 문제가 발생한 부분까지의 사용된 명령어들에 대한 설명을 제공하는 것입니다. 
항상 사용하는 R의 버전, 사용기기, 운영체제를 함께 알려주시길 바랍니다. 
이들에 대한 정보는 <kbd>version</kbd>이라고 입력하면 출력됨을 확인할 수 있습니다.

<!-- The most important principle in reporting a bug is to report -->
<!-- @emph{facts}, not hypotheses or categorizations.  It is always easier to -->
<!-- report the facts, but people seem to prefer to strain to posit -->
<!-- explanations and report them instead.  If the explanations are based on -->
<!-- guesses about how R is implemented, they will be useless; others will -->
<!-- have to try to figure out what the facts must have been to lead to such -->
<!-- speculations.  Sometimes this is impossible.  But in any case, it is -->
<!-- unnecessary work for the ones trying to fix the problem. -->
   <p>버그를 보고할 때 가장 중요한 원칙은 가설이나 분류를 하지 않고 실제 일어난 사실들만을 보고 하는 것입니다. 
사실만을 보고하는 것이 더 쉬움에도 불구하고, 많은 분들은 이러한 사실이 왜 일어났는가를 설명하곤 합니다. 
만약 이러한 설명들이 R이 어떻게 구현되었는가에 대한 추측에 기초한 것이라면, 쓸모가 없을 것입니다. 
그 이유는 그러한 추측이 나오게 된 어떤 사실들을 밝혀내야만 하기 때문입니다. 
때때로 이것은 불가능합니다. 
그러나, 대부분의 경우에는 문제를 고치려고 노력하는 사람에게는 불필요한 일입니다.

<!-- For example, suppose that on a data set which you know to be quite large -->
<!-- the command -->
   <p>예를들어, 꽤 큰 크기의 데이터셋을 가지고 있다고 가정하고, 다음과 같은 명령어를 입력합니다.

<pre class="example">     R&gt; data.frame(x, y, z, monday, tuesday)
</pre>
   <p class="noindent"><!-- never returns.  Do not report that @code{data.frame()} fails for large -->
<!-- data sets.  Perhaps it fails when a variable name is a day of the week. -->
<!-- If this is so then when others got your report they would try out the -->
<!-- @code{data.frame()} command on a large data set, probably with no day of -->
<!-- the week variable name, and not see any problem.  There is no way in the -->
<!-- world that others could guess that they should try a day of the week -->
<!-- variable name. -->
이것은 절대로 반환되지 않습니다. 
<code>data.frame()</code>이 큰 데이터셋에서 실패했다고 보고하지는 말아 주세요. 
아마도 변수명이 요일로 되어 있을 때 실패하는 것일수도 있습니다. 
data.frame()이 큰 데이터에 대해 실패했다고 보고하지 마십시오. 
만약 정말 그러하다면 다른 사람들이 보고되어진 것을 보았을때 요일명이 아닌 변수명을 이용하여 아무런 문제가 일어나지 않는 것을 확인할 것입니다.

<!-- Or perhaps the command fails because the last command you used was a -->
<!-- method for @code{"["()} that had a bug causing R's internal data -->
<!-- structures to be corrupted and making the @code{data.frame()} command -->
<!-- fail from then on.  This is why others need to know what other commands -->
<!-- you have typed (or read from your startup file). -->
   <p>혹은 마지막으로 사용한 명령어가 내부 데이터 구조에 오류를 발생시키고 그 이후부터 <code>data.frame()</code> 명령어가 실패하게 되는 원인을 가진 버그를 가졌던 <code>"["()</code>에 대한 메소드일 수도 있기 때문입니다. 
이것은 왜 어떤 명령어들이 (시작파일부터) 이전에 입력되었는가를 알아야 하는 이유이기도 합니다.

<!-- It is very useful to try and find simple examples that produce -->
<!-- apparently the same bug, and somewhat useful to find simple examples -->
<!-- that might be expected to produce the bug but actually do not.  If you -->
<!-- want to debug the problem and find exactly what caused it, that is -->
<!-- wonderful.  You should still report the facts as well as any -->
<!-- explanations or solutions.  Please include an example that reproduces -->
<!-- (e.g., @url{http://en.wikipedia.org/wiki/Reproducibility}) the problem, -->
<!-- preferably the simplest one you have found. -->
   <p>겉으로 보기에 똑같은 버그를 생성하는 간단한 예제를 찾아 시도하는 것은 매우 유익합니다. 
실제로는 버그가 아니지만 버그를 생성할 것이라고 예상되는 단순한 예제를 테스트 하는 것도 유용합니다. 
만약 문제를 디버그하고 무엇이 문제를 야기하는지 정확히 찾아내고 싶다면, 이것은 매우 훌륭합니다. 
당신은 실제로 일어난 사실만을 보고해야 하면서도 어떠한 설명 또는 해법을 함께 보고할 수 있습니다. 
당신이 찾았던 문제들중에서 그 문제가 똑같이 일어남을 확인해 줄 수 있는 가장 단순한 예제를 꼭 포함해주시길 부탁드립니다  (즉, <a href="http://en.wikipedia.org/wiki/Reproducibility">http://en.wikipedia.org/wiki/Reproducibility</a> 입니다).

<!-- Invoking R with the @option{-vanilla} option may help in isolating a -->
<!-- bug.  This ensures that the site profile and saved data files are not -->
<!-- read. -->
   <p><samp><span class="option">--vanilla</span></samp> 옵션과 함께 R을 실행하는 것은 버그를 분리해 내는데 도움을 줄 것입니다. 
이것은 사이트 프로파일과 저장된 데이터 파일들이 읽혀지지 않도록 합니다.

<!-- Before you actually submit a bug report, you should check whether the -->
<!-- bug has already been reported and/or fixed.  First, try the ``Show open -->
<!-- bugs new-to-old'' or the search facility on -->
<!-- @url{http://bugs.R-project.org/}.  Second, consult -->
<!-- @url{https://svn.R-project.org/@/R/@/trunk/@/doc/@/NEWS.Rd}, which -->
<!-- records changes that will appear in the @emph{next} release of R, -->
<!-- including bug fixes that do not appear on the Bug Tracker. -->
<!-- Third, if possible try the current r-patched or r-devel version of R. -->
<!-- If a bug has already been reported or fixed, please do not submit -->
<!-- further bug reports on it.  Finally, check carefully whether the bug is -->
<!-- with R, or a contributed package.  Bug reports on contributed packages -->
<!-- should be sent first to the package maintainer, and only submitted to -->
<!-- the R-bugs repository by package maintainers, mentioning the package in -->
<!-- the subject line. -->
   <p>버그리포트를 실제로 제출하기 전에, 해당 버그가 이미 보고되었거나 수정되었는지를 확인하시길 바랍니다. 
제일 먼저 <a href="http://bugs.R-project.org/">http://bugs.R-project.org/</a>에 있는 검색 기능 또는 &ldquo;Show open bugs new-to-old&rdquo;을 시도해보시길 바랍니다. 
그리고 나서 버그트래커에는 고쳤다고 나오지 않았는지 혹은 다음에 배포되는 R에 변경사항을 기록한 <a href="https://svn.R-project.org/R/trunk/doc/NEWS.Rd">https://svn.R-project.org/R/trunk/doc/NEWS.Rd</a>에는 있는지 없는지 확인해 보시길 바랍니다. 
세번째로 가능하다면 R의 현재 r-patched나 r-devel 버전을 시도해 보십시오. 
만약 버그가 이미 보고되거나 고쳐졌다면, 추가적인 버그 보고서를 제출하지 말아주시길 바랍니다. 
마지막으로 버그가 R에 존재하는지 기여 패키지에 존재하는지에 대해서 주의 깊게 확인해 주시길 부탁드립니다. 
기여된 패키지들에 대한 버그보고서는 가장 먼저 패키지 관리자에게 보내져야 하며, 패키지 관라자에 의해서 해당패키지명이 제목에 명시된 버그리포드만이 R-bug 저장소에 제출될 수 있습니다.

<!-- A bug report can be generated using the function @code{bug.report()}. -->
<!-- For reports on R this will open the Web page at -->
<!-- @url{http://bugs.R-project.org/}: for a contributed package it will open -->
<!-- the package's bug tracker Web page or help you compose an email to the -->
<!-- maintainer. -->
   <p>버그 리포트는 함수 <code>bug.report()</code>을 이용하여 생성할 수 있습니다. 
이것은 <a href="http://bugs.R-project.org/">http://bugs.R-project.org/</a>이라는 웹페이지를 열어줄 것입니다. 
사용자 기여패키지(contributed package)에 대해서는 패키지의 버그 트래커 웹 페이지 또는 패키지 관리자에게 이메일을 작성할 수 있도록 도와줄 것입니다.

<!-- There is a section of the bug repository for suggestions for -->
<!-- enhancements for R labelled @samp{wishlist}.  Suggestions can be -->
<!-- submitted in the same ways as bugs, but please ensure that the subject -->
<!-- line makes clear that this is for the wishlist and not a bug report, for -->
<!-- example by starting with @samp{Wishlist:}. -->
   <p>&lsquo;<samp><span class="samp">wishlist</span></samp>&rsquo;라고 라벨과 함께 R의 기능강화에 관한 제안들을 위한 버그저장소 섹션이 있습니다. 
제안사항들은 버그를 보고하는 것과 같은 방법으로 할 수 있으나, 제목에 반드시 이것은 wishlist 이지 버그리포트가 아니라는 것을 명시해주셔야 합니다. 
예를들면, &lsquo;<samp><span class="samp">Wishlist:</span></samp>&rsquo; 라고 시작해 주시면 됩니다.

<!-- Comments on and suggestions for the Windows port of R should be sent to -->
<!-- @email{R-windows@@R-project.org}. -->
   <p>R의 Windows 포트에 대한 조언 및 제안사항들은 <a href="mailto:R-windows@R-project.org">R-windows@R-project.org</a>로 보내져야 합니다.

<!-- Corrections to and comments on message translations should be sent to the -->
<!-- last translator (listed at the top of the appropriate @samp{.po} file) -->
<!-- or to the translation team as listed at -->
<!-- @url{http://developer.R-project.org/TranslationTeams.html}. -->
   <p>메시지 번역에 관련한 수정 및 제안사항들은 해당 내용을 담고 있는 &lsquo;<samp><span class="samp">.po</span></samp>&rsquo; 파일 상단에 명시된 마지막 번역자 또는 <a href="http://developer.R-project.org/TranslationTeams.html">http://developer.R-project.org/TranslationTeams.html</a>에 나열되어 있는 번역팀에게 보내어져야 합니다.

<div class="node">
<a name="Acknowledgments"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-Bugs">R Bugs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<!-- @chapter Acknowledgments -->
<h2 class="chapter">10 감사의 말씀</h2>

<!-- Of course, many many thanks to Robert and Ross for the R system, and to -->
<!-- the package writers and porters for adding to it. -->
<!-- Special thanks go to Doug Bates, Peter Dalgaard, Paul Gilbert, Stefano -->
<!-- Iacus, Fritz Leisch, Jim Lindsey, Thomas Lumley, Martin Maechler, Brian -->
<!-- D. Ripley, Anthony Rossini, and Andreas Weingessel for their comments -->
<!-- which helped me improve this @acronym{FAQ}. -->
<!-- More to come soon @dots{} -->
<p>R 시스템을 제공해 준 Robert와 Ross에게 감사의 말씀을 올리며, 패키지 작성자들과 포터(porters)들에게 또한 감사드립니다. 
특히 본 <acronym>FAQ</acronym> 문서를 향상시킬 수 있는 코멘트를 제공해준 Doug Bates, Peter Dalgaard, Paul Gilbert, Stefano
Iacus, Fritz Leisch, Jim Lindsey, Thomas Lumley, Martin Maechler, Brian D. Ripley, Anthony Rossini, 그리고 Andreas Weingessel에게 감사드립니다.

   <p>더 많은 내용들이 추가될 것입니다<small class="dots">...</small>

   <p>본 한국어 문서는 <strong>R Development Translation Teams</strong> (<a href="http://developer.r-project.org/TranslationTeams.html">http://developer.r-project.org/TranslationTeams.html</a>) <strong>Korean</strong> 섹션리더 Chel Hee Lee (University of Saskatchewan, Saskatoon, Saskatchewan, Canada, <a href="mailto:gnustats@gmail.com">gnustats@gmail.com</a>)에 의해서 번역되었습니다. 
제 2역자로서 Heather Kim (University of Mantioba, Winnipeg, Manitoba, Canada)이 함께 이 문서의 번역작업에 참가 하였습니다.

   <p>문서의 수정과 재배포를 허락해 준 <strong>Kurt Hornik과 R Development Core Team</strong>에게 감사를 드립니다. 
<!-- 또한, 우리의 이러한 활동에 많은 관심과 아낌없는 지원을 해주는 Prof. Friedrich Leisch (Austria), Prof. Duncan Murdoch (Canada), Prof. Mikelis Bickis (Canada)에 깊은 감사의 뜻을 표현합니다. -->

   <p>본 문서는 언급된 전문용어들에 대한 추가적인 해석, 오역교정, 그리고 이해를 돕기 위한 내용을 추가함으로서, 새로운 R의 배포에 맞추어 지속적으로 관리되어집니다. 
본 문서에 대한 참여 및 제안은 <a href="mailto:ihelp-translators@ihelp.r-forge.r-project.org">ihelp-translators@ihelp.r-forge.r-project.org</a>으로 보내주신다면 감사하겠습니다.

</body></html>

