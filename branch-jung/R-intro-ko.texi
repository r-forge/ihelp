\input texinfo

@c %**start of header
@setfilename R-intro.info
@settitle An Introduction to R
@setchapternewpage on
@c %**end of header

@c Authors: If you edit/add @example(s) ,  please keep
@c  ./R-intro.R   up-to-date !
@c  ~~~~~~~~~~~
@syncodeindex fn vr


@dircategory Programming
@direntry
* R Introduction: (R-intro).    An introduction to R.
@end direntry

@finalout

@include R-defs.texi
@include version.texi

@ifnottex
@macro RIcopyright{}
Copyright @copyright{} 1990 W.@: N.@: Venables@*
Copyright @copyright{} 1992 W.@: N.@: Venables & D.@: M.@: Smith@*
Copyright @copyright{} 1997 R.@: Gentleman & R.@: Ihaka@*
Copyright @copyright{} 1997, 1998 M.@: Maechler@*
Copyright @copyright{} 1997-- R Core Team@*
@Rcopyright{1999}@*
Korean translation copyright @copyright{} 2008--2013 Korean R Translation Team and Chel Hee Lee.
@end macro
@end ifnottex

@iftex
@macro RIcopyright{}
@noindent
Copyright @copyright{} 1990 W.@: N.@: Venables
Copyright @copyright{} 1992 W.@: N.@: Venables & D.@: M.@: Smith
Copyright @copyright{} 1997 R.@: Gentleman & R.@: Ihaka
Copyright @copyright{} 1997, 1998 M.@: Maechler
Copyright @copyright{} 1997-- R Core Team@*
@Rcopyright{1999}@*
Korean translation copyright @copyright{} 2008--2013 Korean R Translation Team and Chel Hee Lee.
@end macro
@end iftex

@c <FIXME>
@c Apparently AUCTeX 11.06 has a problem with '@appendixsection' entries
@c when updating nodes---the equivalent '@appendixsec' seems to work.
@c Hence changed (temporarily?) ...
@c </FIXME>

@c <NOTE>
@c Conversion to PDF fails if sectioning titles contain (user-defined)
@c macros such as @R{}.  Hence in section titles we changed @R{} to R.
@c Revert when this is fixed.
@c </NOTE>

@titlepage
@title An Introduction to R (한국어 사용자를 위한 R 입문서)
@subtitle Notes on @R{}: A Programming Environment for Data Analysis and Graphics
@subtitle Version @value{VERSION}
@author W. N. Venables, D. M. Smith
@author and the R Core Team

@page
@vskip 0pt plus 1filll

@flushleft
@RIcopyright{}
@end flushleft

@permission{}

@value{ISBN-intro}
@end titlepage

@c @ifnothtml
@contents
@c @end ifnothtml

@ifnottex
@node Top, Preface, (dir), (dir)
@top An Introduction to R

@c This is an introduction to R (``GNU S''), a language and environment for
@c statistical computing and graphics.  R is similar to the award-winning S
@c system, which was developed at Bell Laboratories by John Chambers et al.
@c It provides a wide variety of statistical and graphical techniques
@c (linear and nonlinear modelling, statistical tests, time series
@c analysis, classification, clustering, ...).

@c This manual provides information on data types, programming elements,
@c statistical modelling and graphics.

@c The current version of this document is @value{VERSION}.

이 문서는 통계계산 및 그래픽를 위한 언어이며 환경이기도 한 R에 대한 기초안내서 입니다. R은 벨연구소에서 John Chambers 외 다수에 의해서 개발된 이래 수상을 받은 적이 있는 S 시스템과 유사하므로 ``GNU S''라고도 불리우고, 매우 다양한 분야에 걸친 통계분석 및 그래픽 기능들을 제공합니다. 예를들면, 선형 및 비선형 모델링, 다양한 통계 테스트들, 시계열분석, 클래시피케이션, 그리고 클러스터링 등이 있습니다.

이 문서는 R을 시작하는 분들에게 반드시 필요한 기본적인 데이터형에 대한 이해, 프로그래밍의 기본요소들, 그리고 통계적 모델링과 그래픽에 대한 정보를 제공합니다.

현재 이 문서의 버전은 @value{VERSION}이며, 한국어 버전의 마지막 업데이트는 2013년 03월 14일에 이루어졌습니다.

@c 서문 의역완료 on 2013-MAR-01 

@value{ISBN-intro}

@RIcopyright{}

@permission{}

@end ifnottex

@menu
* Preface::                     
* Introduction and preliminaries::  
* Simple manipulations numbers and vectors::  
* Objects::                     
* Factors::                     
* Arrays and matrices::         
* Lists and data frames::       
* Reading data from files::     
* Probability distributions::   
* Loops and conditional execution::  
* Writing your own functions::  
* Statistical models in R::     
* Graphics::                    
* Packages::                    
* A sample session::            
* Invoking R::                  
* The command-line editor::     
* Function and variable index::  
* Concept index::               
* References::                  
@end menu

@node Preface, Introduction and preliminaries, Top, Top
@unnumbered Preface

@c This introduction to @R{} is derived from an original set of notes
@c describing the @Sl{} and @SPLUS{} environments written in 1990--2 by
@c Bill Venables and David M. Smith when at the University of Adelaide.  We
@c have made a number of small changes to reflect differences between the
@c @R{} and @Sl{} programs, and expanded some of the material.

@c We would like to extend warm thanks to Bill Venables (and David Smith)
@c for granting permission to distribute this modified version of the notes
@c in this way, and for being a supporter of @R{} from way back.

@c Comments and corrections are always welcome.  Please address email
@c correspondence to @email{R-core@@R-project.org}.

본래 @R{}에 대한 이 안내서는 1990년부터 1992년 사이에 Bill Venables과 David M. Smith가 Adelaide 대학에서 @Sl{}와 @SPLUS{}에 대하여 작성한 노트를 토대로 하고 있습니다.
그러나, @R{}과 @Sl{} 사이의 다른 점들을 반영하기 위하여 우리는 원래 노트의 내용에 적절한 수정을 가하고 일부의 내용들을 더욱 보강하였습니다.
이렇게 원래의 노트에 대한 수정과 재배포를 수락하고, @R{}을 지지해주는 Bill Venables (그리고 David Smith)에게 우리는 깊은 감사의 뜻을 전합니다. 

이 한국어 문서는 R Development Translation Teams의 이철희에 의해서 번역되었으며, @R{}의 빠른 변화를 충분히 반영하되 사용의 혼돈을 줄이고 전산학 또는 통계학이 전공이 아닌 독자들을 위하여 전문용어에 대한 개념풀이와 해석을 덧붙임으로서 @R{}이 가진 기능들을 한국어 독자들에게 맞추어 쉽게 전달하고자 하였습니다. 
본 한국어 문서에 대한 제안사항 및 정정에 관련된 내용을 @email{gnustats@@korea.gnu.org}으로 보내주시면 매우 감사드리겠습니다.

@c @subheading Suggestions to the reader
@subheading 처음 접하는 사용자에게 

@c Most @R{} novices will start with the introductory session in Appendix
@c A.  This should give some familiarity with the style of @R{} sessions
@c and more importantly some instant feedback on what actually happens.

@c Many users will come to @R{} mainly for its graphical facilities.  In
@c this case, @ref{Graphics} on the graphics facilities can be read at
@c almost any time and need not wait until all the preceding sections have
@c been digested.

만약 독자가 @R{}을 처음 접하는 것이라면 @R{}이 어떻게 동작하는가에 대한 즉각적인 이해를 가지기 위하여 Appendix A를 가장 먼저 보기를 권합니다.

많은 사용자들은 @R{}이 가진 그래픽 기능들 때문에 이를 사용하곤 합니다. 따라서, 그래픽 관련주제들을 @ref{Graphics}에 따로 모아 독자가 필요할때마다 쉽게 찾아볼 수 있도록 하였습니다. 

@menu
* Introduction and preliminaries::
@end menu

@node Introduction and preliminaries, Simple manipulations numbers and vectors, Preface, Top
@chapter 1 Introduction and preliminaries

@menu
* The R environment::           
* Related software and documentation::  
* R and statistics::            
* R and the window system::     
* Using R interactively::       
* Getting help::                
* R commands; case sensitivity etc::  
* Recall and correction of previous commands::  
* Executing commands from or diverting output to a file::  
* Data permanency and removing objects::  
@end menu

@node The R environment, Related software and documentation, Introduction and preliminaries, Introduction and preliminaries
@section The R environment

@c @R{} is an integrated suite of software facilities for data
@c manipulation, calculation and graphical display.  Among other things it
@c has

@c @itemize @bullet
@c @item
@c an effective data handling and storage facility,
@c @item
@c a suite of operators for calculations on arrays, in particular matrices,
@c @item
@c a large, coherent, integrated collection of intermediate tools for data
@c analysis,
@c @item
@c graphical facilities for data analysis and display either directly at
@c the computer or on hardcopy, and
@c @item
@c a well developed, simple and effective programming language (called `S')
@c which includes conditionals, loops, user defined recursive functions and
@c input and output facilities.  (Indeed most of the system supplied
@c functions are themselves written in the @Sl{} language.)
@c @end itemize

@R{}은 데이터의 조작 및 수치연산, 그리고 시각화를 수행할 수 있는 소프트웨어 기능들을 한데 모아 놓은 통합개발환경이라고 할 수 있으며, 특히 다음과 같은 기능들을 제공하고 있습니다. 
 
@itemize @bullet
@item 
효과적인 데이터 관리 및 저장 기능들,  
@item 
배열기반의 연산을 수행하기 위한 연산자들 (행렬에 더욱 특화되어 있음),
@item 
데이터 분석에서 중간과정의 단계를 모두 확인하는데 필요한 기능들을 일관성 있게 잘 조합해 놓은 통합적 분석도구들, 
@item 
데이터 분석 및 시각화된 결과물을 컴퓨터에서 확인 및 하드카피로의 출력할 수 있는 기능들, 
@item 
조건문, 반복문, 사용자 정의 함수, 그리고 입출력을 관리할 수 있는 기능들을 가지고 있는 프로그래밍 언어를 제공합니다. 
특히 이 언어는 'S'라고도 불리우며 단순하면서도 효율적이며 매우 잘 개발되어 있습니다.
(실제로 시스템의 대다수의 함수들은 @Sl{}언어로 작성되었습니다). 
@end itemize

@c The term ``environment'' is intended to characterize it as a fully
@c planned and coherent system, rather than an incremental accretion of
@c very specific and inflexible tools, as is frequently the case with other
@c data analysis software.

@c @R{} is very much a vehicle for newly developing methods of interactive
@c data analysis.  It has developed rapidly, and has been extended by a
@c large collection of @emph{packages}.  However, most programs written in
@c @R{} are essentially ephemeral, written for a single piece of data
@c analysis.

``environment''(인바이런먼트 또는 개발환경)라는 용어는 다른 분석소프트웨어들의 경우처럼 사용방법에 제약이 많아 유용성이 없는 도구들을 추가적으로 계속 제공하는 것과는 달리 완전하게 잘 계획되어 있는 일관성있는 시스템 자체를 지칭하고자 사용합니다. 
@emph{이 문서에서 역자는 environment라는 용어를 영문 그대로 environment라고 사용할 것입니다. 
그 이유는 environment라는 개념은 이 소개서의 이 부분내 문맥상 개발환경이라고 이해해도 무난하지만, 이 소개서의 내용을 뛰어넘는 프로그램의 개발에서는 environment라는 용어에 대한 개념이 단순히 개발환경은 아닙니다. 
따라서, 역자는 개념적 혼돈을 주지않기 위해서 영문 environment를 그대로 사용할 것이고, 필요시에는 추가설명을 덧붙여줄것입니다. 
프로그래머에게 필요한 더 자세한 사항은 R language definition 문서에서 다루도록 하겠습니다}.

@R{}은 시스템과 분석자간의 쌍방향 데이터 분석에 사용될 방법들을 새로이 개발하는데 사용되는 수단이라고 할 수 있습니다.
따라서, 방대한 양의 @emph{packages}(패키지)에 의해서 더욱 빠르게 확장되어 개발될 수 있습니다. 
그러나, @R{}로 쓰여진 대부분의 프로그램들은 단 하나의 데이터 분석을 위해 개발된 프로그램들이 대다수 이므로, 범용성에 제한이 있다는 것을 기억해야 합니다. 

@node Related software and documentation, R and statistics, The R environment, Introduction and preliminaries
@section Related software and documentation

@c @R{} can be regarded as an implementation of the @Sl{} language which
@c was developed at Bell Laboratories by Rick Becker, John Chambers and
@c Allan Wilks, and also forms the basis of the @SPLUS{} systems.

@c The evolution of the @Sl{} language is characterized by four books by
@c John Chambers and coauthors.  For @R{}, the basic reference is @emph{The
@c New @Sl{} Language: A Programming Environment for Data Analysis and
@c Graphics} by Richard A.@: Becker, John M.@: Chambers and Allan R.@:
@c Wilks.  The new features of the 1991 release of @Sl{}
@c (@Sl{} version 3) JMC says the 1988 version is S3.
@c are covered in @emph{Statistical Models in @Sl{}} edited by John M.@:
@c Chambers and Trevor J.@: Hastie.  The formal methods and classes of the
@c @pkg{methods} package are based on those described in @emph{Programming
@c with Data} by John M.@: Chambers.  @xref{References}, for precise
@c references.

@c There are now a number of books which describe how to use @R{} for data
@c analysis and statistics, and documentation for @Sl{}/@SPLUS{} can
@c typically be used with @R{}, keeping the differences between the @Sl{}
@c implementations in mind.  @xref{What documentation exists for R?, , ,
@c R-FAQ, The R statistical system FAQ}.

@R{}을 Bell 연구실에서 근무하던 Rick Becker, John Chambers 그리고 Allan Wilks에 의해 개발되어 @SPLUS{} 시스템의 기반을 형성한 @Sl{} 언어의 구현물이라고 생각하셔도 괜찮습니다. 

@Sl{}언어의 진화과정은 John Chambers와 그의 동료들이 쓴 네 권의 책에 의해서 정리될 수 있습니다.
@R{}의 가장 기본적인 참고자료라고 한다면 Richard A.@: Becker, John M.@: Chambers 그리고 Allan R.@: Wilks가 저술한 @emph{The New @Sl{} Language: A Programming Environment for Data Analysis and Graphics}라는 책을 들 수 있습니다. 
1991년에 릴리즈된 @Sl{}의 새로운 기능들에 대해서는 John M.@: Chambers와 Trevor J.@: Hastie가 편집한 @emph{Statistical Models in @Sl{}}이라는 책을 참고하시길 바랍니다. 
@pkg{methods} 패키지의 method(메소드)와 class(클래스)들은 John M.@: Chambers가 저술한 @emph{Programming with Data}에서 찾아 볼 수 있습니다. 
더 정확한 참고자료들은 다음을 참조하세요 @xref{References}.

현재 @R{}을 이용한 데이터 분석과 통계학에 관련된 많은 서적들이 나와 있으며, @Sl{}/@SPLUS{}를 위한 문서들 역시 @R{}을 사용하는데 도움이 될 것입니다. 
그러나, 반드시  @Sl{}과 @R{}은 다르게 구현이 되어 있다는 것을 반드시 기억하고 계셔야 합니다.
더 자세한 사항은 다음을 참조하세요. @xref{What documentation exists for R?, , , R-FAQ, The R statistical system FAQ}.

@node R and statistics, R and the window system, Related software and documentation, Introduction and preliminaries
@section R and statistics
@cindex Packages

@c Our introduction to the @R{} environment did not mention
@c @emph{statistics}, yet many people use @R{} as a statistics system.  We
@c prefer to think of it of an environment within which many classical and
@c modern statistical techniques have been implemented.  A few of these are
@c built into the base @R{} environment, but many are supplied as
@c @emph{packages}.  There are about 25 packages supplied with @R{} (called
@c ``standard'' and ``recommended'' packages) and many more are available
@c through the @acronym{CRAN} family of Internet sites (via
@c @uref{http://CRAN.R-project.org}) and elsewhere.  More details on
@c packages are given later (@pxref{Packages}).

@c Most classical statistics and much of the latest methodology is
@c available for use with @R{}, but users may need to be prepared to do a
@c little work to find it.

@c There is an important difference in philosophy between @Sl{} (and hence
@c @R{}) and the other main statistical systems.  In @Sl{} a statistical
@c analysis is normally done as a series of steps, with intermediate
@c results being stored in objects.  Thus whereas SAS and SPSS will give
@c copious output from a regression or discriminant analysis, @R{} will
@c give minimal output and store the results in a fit object for subsequent
@c interrogation by further @R{} functions.

@R{}의 개발환경에 대한 이 안내서에서는 @emph{statistics}(통계학)을 다루고 있지 않지만, 많은 독자들은 @R{}을 통계시스템으로서 사용합니다. 
우리는 독자들이 @R{}을 과거부터 현대에 이르기까지 개발되어온 많은 통계학적 방법론들이 구현되어 있는 하나의 개발환경이라고 생각해주었으면 합니다. 
이들중 일부는 기본 @R{} 개발환경내에 포함되어 있으나, 대부분은 @emph{packages}(패키지들)의 형태로 제공이 됩니다. 
@R{}은 ``standard''(기본) 혹은 ``recommended''(추천) 패키지라고 불리는 총 25개의 패키지들과 함께 제공되며, 더 많은 패키지들을 인터넷 저장소인 @acronym{CRAN}을 통하여 @uref{http://CRAN.R-project.org}) 얻을 수 있습니다. 
더 자세한 내용은 (@pxref{Packages}) 부분에서 설명합니다.

가장 고전적인 통계적 방법부터 최근에 개발된 대부분의 통계적 방법들을 @R{}과 함께 사용할 수 있으나, 이들을 찾기 위해서는 다소의 노력이 필요할 수 있습니다. 

독자들은 @Sl{} (여기에서는 @R{})이 다른 주요 통계시스템들과는 근본적으로 다르다는 점을 반드시 인지하고 있어야 합니다. 
예를들면, @Sl{}에서는 통계적 분석을 일련의 절차를 통해서 할 수 있게 되어 있으며, 중간과정마다 얻어진 결과물을 객체라는 중간매체에 저장해 둡니다. 
따라서, SAS 또는 SPSS가 회귀분석 또는 판별분석을 수행하여 한 번에 방대한 양의 결과를 제공하는 것과는 달리, @R{}은 최소한의 결과물만으르 제공하고, 더 자세한 중간 수행과정 및 결과를 확인하고 싶다면 추가적인 @R{} 함수들을 이용해야 합니다. 

@node R and the window system, Using R interactively, R and statistics, Introduction and preliminaries
@section R and the window system

@c The most convenient way to use @R{} is at a graphics workstation running
@c a windowing system.  This guide is aimed at users who have this
@c facility.  In particular we will occasionally refer to the use of @R{}
@c on an X window system although the vast bulk of what is said applies
@c generally to any implementation of the @R{} environment.

@c Most users will find it necessary to interact directly with the
@c operating system on their computer from time to time.  In this guide, we
@c mainly discuss interaction with the operating system on UNIX machines.
@c If you are running @R{} under Windows or Mac OS you will need to make
@c some small adjustments.

@c Setting up a workstation to take full advantage of the customizable
@c features of @R{} is a straightforward if somewhat tedious procedure, and
@c will not be considered further here.  Users in difficulty should seek
@c local expert help.

@R{}을 사용하는 가장 손쉬운 방법은 윈도잉 시스템(windowing sytem, 즉 여러개의 창을 띄어줄 수 있는 시스템)을 사용하는 그래픽 워크스테이션을 이용하는 것입니다.  
본 문서는 이러한 기능이 있는 시스템을 가진 독자를 위한 것입니다.
주로 X 윈도우 시스템에서의 @R{}의 사용을 얘기할 것이지만, 이러한 설명들은 어떠한 실행된 @R{}의 사용환경에서도 일반적으로 동일하게 적용됩니다. 

때때로, 대부분 사용자들은 사용자의 컴퓨터에 있는 운영체제와 직접적인 소통을 해야할 필요성을 느낄 것입니다.
본 문서에서는 사용자가 UNIX에서의 운영체제를 다룬다고 가정한 상태에서 작성되었습니다. 
만약, @R{}을 윈도우즈 혹은 Mac 운영체제에서 사용하시는 분들은 본문서에서 설명하는 사용법이 약간 다를 수 있다는 점을 인지해주셨으면 합니다. 

최적화된 성능의 @R{}을 워크스테이션에서 사용하기 위해서 설정하는 방법은 다소 기술적인 조정이 필요한 것을 제외하고는 단순하지만, 이 안내서에서는 이러한 기술적인 부분에서는 다루지 않습니다.  
이러한 조정에 어려움이 있는 사용자는 해당분야의 전문가의 도움을 받기를 부탁드립니다.

@node Using R interactively, Getting help, R and the window system, Introduction and preliminaries
@section Using R interactively

@c When you use the @R{} program it issues a prompt when it expects input
@c commands.  The default prompt is @samp{@code{>}}, which on UNIX might be
@c the same as the shell prompt, and so it may appear that nothing is
@c happening.  However, as we shall see, it is easy to change to a
@c different @R{} prompt if you wish.  We will assume that the UNIX shell
@c prompt is @samp{@code{$}}.

@R{} 프로그램을 실행시키면, 사용자의 입력을 기다리는 표시 @samp{@code{>}} (프롬프트라고 읽음)를 볼 수 있을 것입니다.
이 표시는 아마 UNIX에서의 쉘프로프트와도 동일할 수 있습니다. 
따라서, 사용자가 원한다면 @R{}의 프롬프트를 다른 모양으로 변경하여 사용할 수 있도록 해두었습니다.
이 문서에서는 내용의 명확성을 위해서 유닉스의 쉘 프롬프트를 @samp{@code{$}}라는 표시를 이용하도록 하겠습니다. 

@c In using @R{} under UNIX the suggested procedure for the first occasion
@c is as follows:

유닉스내에서 @R{}을 사용하기 위해서는 먼저 아래의 과정들을 따라 해주시길 권장합니다.

@enumerate
@item
@c Create a separate sub-directory, say @file{work}, to hold data files on
@c which you will use @R{} for this problem.  This will be the working
@c directory whenever you use @R{} for this particular problem.

먼저 아래와 같이 @R{}에서 사용할 데이터 파일들을 저장할 장소를 위한 @file{work}라는 별도의 서브 디렉토리를 생성합니다. 
그리고, 이곳이 바로 데이터와 관련하여 @R{}을 사용하게 될 working directory (워킹 디렉토리 또는 작업디렉토리)라고 합니다. 

@example
$ mkdir work
$ cd work
@end example

@item
@c Start the @R{} program with the command

아래의 명령어를 이용하여 @R{}프로그램을 시작하세요.
@example
$ R
@end example

@item
@c At this point @R{} commands may be issued (see later).
이제부터 @R{} 명령어들을 이용하여 작업을 할 수 있습니다.

@item
@c To quit the @R{} program the command is
@R{} 프로그램을 종료하기 위해서는 다음의 명령어를 사용합니다. 

@example
> q()
@end example

@c At this point you will be asked whether you want to save the data from
@c your @R{} session.  On some systems this will bring up a dialog box, and
@c on others you will receive a text prompt to which you can respond
@c @kbd{yes}, @kbd{no} or @kbd{cancel} (a single letter abbreviation will
@c do) to save the data before quitting, quit without saving, or return to
@c the @R{} session.  Data which is saved will be available in future @R{}
@c sessions.

이처럼 종료명령어를 사용했을때에는 @R{}프로그램은 현재 @R{}세션에서 작업하던 데이터를 종료전에 저장할 것인지 아닌지에 대한 @kbd{yes}(예), @kbd{no}(아니요) 혹은 명령을 취소하고 다시 @R{}세션으로 돌아갈 것인지에 대한 @kbd{cancel} (취소)를 할 것인지를 물어볼 것입니다. 
이 저장여부에 대한 메시지는 일부 시스템에서는 대화창을 통해 보여질 수도 있고, 종료명령어 다음줄에 텍스트 형식으로 나타날 수도 있습니다. 
만약, 저장을 선택한다면 저장된 데이터는 다음번에 @R{}을 실행하였을때 다시 사용할 수 있습니다. 
@end enumerate

@c Further @R{} sessions are simple.
새로운 @R{}세션을 시작하는 것은 간단합니다. 
@enumerate

@item
@c Make @file{work} the working directory and start the program as before:
@file{work}이라는 작업 (혹은 워킹) 디렉토리를 만들고 위에서 했던 것과 같이 아래의 명령을 이용하여 프로그램을 시작하면 됩니다. 
@example
$ cd work
$ R
@end example

@item
@c Use the @R{} program, terminating with the @code{q()} command at the end
@c of the session.

@R{}프로그램을 사용하고 난뒤에 세션의 끝에서 @code{q()} 명령어를 이용하여 종료할 수 있습니다.  
@end enumerate

@c To use @R{} under Windows the procedure to
@c follow is basically the same.  Create a folder as the working directory,
@c and set that in the @file{Start In} field in your @R{} shortcut.
@c Then launch @R{} by double clicking on the icon.

윈도우즈에서 @R{}을 사용하는 방법은 기본적으로 유닉스에서의 사용방법과 동일합니다.
먼저 워킹 디렉토리에 해당하는 폴더를 생성하고, @file{Start In} 메뉴에서 @R{} 바로가기를 바탕화면에 생성합니다.
그런 다음부터는 바탕화면의 바로가기 아이콘을 이용하여 @R{}을 실행시킬 수 있습니다. 

@section An introductory session

@c Readers wishing to get a feel for @R{} at a computer before proceeding
@c are strongly advised to work through the introductory session
@c given in @ref{A sample session}.

다음의 내용들을 읽어보기 전에 @R{}에 대해서 좀 더 친숙해보고자 하는 독자들은 @ref{A sample session}에 있는 기초세션을 따라 입력해 봄으로서 어떤식으로 작동하는지 알아보기를 강력히 권장합니다. 

@node Getting help, R commands; case sensitivity etc, Using R interactively, Introduction and preliminaries
@section Getting help with functions and features
@findex help

@c @R{} has an inbuilt help facility similar to the @code{man} facility of
@c UNIX.  To get more information on any specific named function, for
@c example @code{solve}, the command is

@R{}은 UNIX에서 @code{man}이라는 명령어를 도움말 기능을 사용하는 것과 유사한 기능을 제공하고 있습니다. 
예를들어, @code{solve}라는 함수와 같이 어떤 특정한 이름을 가지고 있는 함수들에 대한 도움말을 보고자 한다면 다음의 명령어(즉, 함수)를 이용해보세요.

@example
> help(solve)
@end example
@findex help

@c An alternative is
아래와 같은 방법으로도 동일한 도움말 기능을 사용할 수 있습니다. 

@example
> ?solve
@end example
@findex ?

@c For a feature specified by special characters, the argument must be
@c enclosed in double or single quotes, making it a ``character string'':
@c This is also necessary for a few words with syntactic meaning including
@c @code{if}, @code{for} and @code{function}.

아래와 같이 special character (특수문자)의 기능들을 알고 싶을 때에는 반드시 큰 따옴표 혹은 작은 따옴표를 함께 사용하여 ``character string(문자열)''의 형식을 갖추어 검색을 하도록 합니다.
이러한 형식을 갖추어야 할 또 다른 경우는 @code{if}, @code{for} 그리고 @code{function}과 같은 @R{}의 예약어 또는 문법에 해당하는 내용을 검색하고자 할 때입니다.

@example
> help("[[")
@end example

@c Either form of quote mark may be used to escape the other, as in the
@c string @code{"It's important"}.  Our convention is to use
@c double quote marks for preference.

일반적으로 두 가지 종류의 따옴표를 이용할 수 있으나, 큰 따옴표를 사용하는 것을 권장합니다.
그 이유는 @code{"It's important"}와 같은 경우도 있을 수 있기 때문입니다.

@c On most @R{} installations help is available in @HTML{} format by
@c running

대부분의 경우 @R{}을 설치할때 @HTML{}형식의 도움말이 함께 설치되며, 아래와 같은 함수를 이용하여 해당기능을 이용할 수 있습니다. 

@example
> help.start()
@end example
@findex help.start

@noindent
@c which will launch a Web browser that allows the help pages to be browsed
@c with hyperlinks.  On UNIX, subsequent help requests are sent to the
@c @HTML{}-based help system.  The `Search Engine and Keywords' link in the
@c page loaded by @code{help.start()} is particularly useful as it is
@c contains a high-level concept list which searches though available
@c functions.  It can be a great way to get your bearings quickly and to
@c understand the breadth of what @R{} has to offer.

위의 함수를 입력하면, 하이퍼링크로 서로 연결이 되어 있어 도움말을 탐색할 수 있는 @HTML{} 기반의 도움말 시스템을 위한 웹브라우저가 실행되게 됩니다. 
최초 @code{help.start()}에 의해서 로딩된 'Search Engine and Keywords'라는 링크가 나타는 페이지가 특히 유용한데 현재 이용가능한 함수들을 모두 보여주는 고차원 (high-level) 개념들에 대한 목록을 포함하고 있기 때문입니다.
이것은 자신이 @R{}시스템에 대한 이해정도를 확인하고 @R{}이 제공해 줄 수 있는 것이 무엇인지 확인이 가능하도록 해줍니다.

@findex help.search
@c The @code{help.search} command (alternatively @code{??}) 
@c allows searching for help in various
@c ways. For example,

@code{help.search} 명령어 (또 다른 표현으로 @code{??})는 좀 더 다양한 방식으로 도움말을 검색합니다. 
예를들어, 아래와 같이 입력해보세요.

@example
> ??solve
@end example
@findex ??

더 자세한 내용과 예제들을 확인해보고 싶으시다면 @code{?help.search}를 이용하여 확인하시길 바랍니다.

특별히 찾고자 하는 도움말 주제와 연관된 예제들은 아래와 같은 방법으로 실행할 수가 있습니다. 

@example
> example(@var{topic})
@end example
@findex example

윈도우즈 버전의 @R{}은 또 다른 방법의 도움말 시스템을 가지고 있습니다. 이에 대해서 알고 싶으시다면 다음과 같이 @code{help}의 도움말을 살펴보시길 부탁드립니다.
@c Windows versions of @R{} have other optional help systems: use

@example
> ?help
@end example

@noindent
@c for further details.

@node R commands; case sensitivity etc, Recall and correction of previous commands, Getting help, Introduction and preliminaries
@section R commands, case sensitivity, etc.

@c Technically @R{} is an @emph{expression language} with a very simple
@c syntax.  It is @emph{case sensitive} as are most UNIX based packages, so
@c @code{A} and @code{a} are different symbols and would refer to different
@c variables.  The set of symbols which can be used in @R{} names depends
@c on the operating system and country within which @R{} is being run
@c (technically on the @emph{locale} in use).  Normally all alphanumeric
@c symbols are allowed@footnote{For portable @R{} code (including that to
@c be used in @R{} packages) only A--Za--z0--9 should be used.} (and in
@c some countries this includes accented letters) plus @samp{@code{.}} and
@c @samp{@code{_}}, with the restriction that a name must start with
@c @samp{@code{.}} or a letter, and if it starts with @samp{@code{.}} the
@c second character must not be a digit.  Names are currently effectively
@c unlimited, but were limited to 256 bytes prior to @R{} 2.13.0

기술적인 측면에서 말하자면, 아주 단순한 문법을 가진 @R{}은 @emph{expression language}(표현식을 기초로 하는 언어)입니다. 
UNIX를 기반으로 하는 다른 패키지들과 같이 @emph{case sensitive}(대소문자를 구별)하므로, @code{A}와 @code{a}는 다른 심볼(즉, 기호)로 인식되어 서로 다른 변수들을 가리키게 되는 것을 유념하시길 바랍니다.
@R{}에서 사용될 수 있는 기호들은 사용자의 운영체제 및 @emph{locale}(로케일, 즉 언어설정과 관계된 운영체제의 사용국가설정)에 따라 달라질 수 있습니다.
일반적으로 모든 알파벳 기호들@footnote{@R{}패키지들에서 사용되는 @R{}코드들을 포함하여, 오로지 A--Za--z0--9 (즉, 대문자 A부터 Z, 소문자 a부터 z, 그리고 숫자 0부터 9)을 지칭함}은 사용이 가능하며, 일부국가에서 사용되는 엑센트가 있는 문자들 역시 사용이 가능합니다.
또한, @samp{@code{.}}와 @samp{@code{_}}을 함께 조합하여 사용할 수도 있습니다.
그러나, @samp{@code{.}} 또는 문자로만 시작을 해야하며, 만약 @samp{@code{.}}로 시작하는 표현식이 있다면 그 두번째 문자는 반드시 숫자가 아닌 문자가 와야 합니다. 
@R{} 2.13.0 이전버전들은 표현식의 길이가 256바이트를 넘을 수 없었으나, 현재는 제약이 없습니다. 


@c Elementary commands consist of either @emph{expressions} or
@c @emph{assignments}.  If an expression is given as a command, it is
@c evaluated, printed (unless specifically made invisible), and the value
@c is lost.  An assignment also evaluates an expression and passes the
@c value to a variable but the result is not automatically printed.

@c Commands are separated either by a semi-colon (@samp{@code{;}}), or by a
@c newline.  Elementary commands can be grouped together into one compound
@c expression by braces (@samp{@code{@{}} and @samp{@code{@}}}).
@c @emph{Comments} can be put almost@footnote{@strong{not} inside strings,
@c nor within the argument list of a function definition} anywhere,
@c starting with a hashmark (@samp{@code{#}}), everything to the end of the
@c line is a comment.

기본적인 명령어(command)란 @emph{expressions}(표현식)과 @emph{assignment}(할당)이라는 두가지 요소로 구성됩니다. 
만약 표현식이 할당없이 홀로 사용되게 된다면, 이는 단순 명령어와 같이 처리되어 표현식이 처리된 후에는 어떠한 값도 저장되지 않은 채로 결과를 출력하게 됩니다. 
반면에, 표현식이 할당과 같이 함께 쓰여진다면, 표현식이 처리된 후의 값을 변수에 넘겨주게 되고 할당된 결과에 대해서는 자동으로 출력되지 않도록 되어 있습니다. 

일반적으로 명령어들은 세미콜론(@samp{@code{;}}) 또는 새로운 행 (newline)에 의해서 구분되어지게 되어 있습니다. 
기본적인 명령어들은 열린 중괄호 @samp{@code{@{}}와 닫힌 중괄호 @samp{@code{@}}} 내에 사용되어 짐으로서 한개의 작업단위를 구분할 수 있도록 그룹을 형성할 수 있습니다.  그리고, 이러한 그룹된 표현식을 compound expression(복합 표현식)이라고 합니다. 
해쉬마크 (@samp{@code{#}})로 시작하는 @emph{Comments}(주석)이라는 것은 해쉬마크가 있는 곳으로부터 해당 행 (또는 라인)의 끝까지 컴퓨터가 수행하지 않도록 처리해 줍니다.  
이러한 주석처리는 사용자가 프로그램을 읽기 쉽도록 도와주며 프로그램내 어디에든 위치할 수 있습니다 @footnote{@strong{단, } 문자열내에서 사용할 수 없으며, 또한 함수를 정의하는 인자목록에서는 사용될 수 없다는 점을 명심해 주시길 바랍니다}.

@c If a command is not complete at the end of a line, @R{} will
@c give a different prompt, by default

만약, 명령어가 현재행에서 끝나지 않고 다음행으로 계속 이어지게 된다면, @R{}은 아래와 같이 다른 프로프트 기호를 이용하여 명령어가 계속이어짐을 사용자에게 알려주며, 문법적으로 명령어가 완성이 될때까지 입력을 계속 받게됩니다.  

@example
+
@end example

@noindent
@c on second and subsequent lines and continue to read input until the
@c command is syntactically complete.  This prompt may be changed by the
@c user.  We will generally omit the continuation prompt
@c and indicate continuation by simple indenting.

이 프롬프트의 기호를 continuation (컨티뉴에이션) 프롬프트라고 하고, 이는 사용자에 의해서 변경될 수 있습니다. 
이 문서에서는 컨티뉴에이션 프롬프트를 사용하지 않고 단순히 인덴팅 (한 문자를 들여씀)을 이용하여 명령어가 계속 이어짐을 표현할 것입니다.

@c Command lines entered at the console are limited@footnote{some of the
@c consoles will not allow you to enter more, and amongst those which do
@c some will silently discard the excess and some will use it as the start
@c of the next line.} to about 4095 bytes (not characters).

콘솔내에서 입력할 수 있는 명령어 라인은 대략 4095바이트입니다 @footnote{일부 콘솔들은 이 크기 이상이 입력될 경우에 더 이상 입력할 수 없거나, 자동으로 그 이상되는 범위의 명령어들을 잘라내는 경우도 있습니다.  어떤 경우에는 이 부분을 명령어의 새로운 시작으로 받아들일 수 있다는 점에 유의하시길 바랍니다}.

@node Recall and correction of previous commands, Executing commands from or diverting output to a file, R commands; case sensitivity etc, Introduction and preliminaries
@section Recall and correction of previous commands

@c Under many versions of UNIX and on Windows, @R{} provides a mechanism
@c for recalling and re-executing previous commands.  The vertical arrow
@c keys on the keyboard can be used to scroll forward and backward through
@c a @emph{command history}.  Once a command is located in this way, the
@c cursor can be moved within the command using the horizontal arrow keys,
@c and characters can be removed with the @key{DEL} key or added with the
@c other keys.  More details are provided later: @pxref{The command-line
@c editor}.

@c The recall and editing capabilities under UNIX are highly customizable.
@c You can find out how to do this by reading the manual entry for the
@c @strong{readline} library.

@c Alternatively, the Emacs text editor provides more general support
@c mechanisms (via @acronym{ESS}, @emph{Emacs Speaks Statistics}) for
@c working interactively with @R{}.  @xref{R and Emacs, , , R-FAQ, The R
@c statistical system FAQ}.

다양한 종류의 UNIX와 윈도우즈에서 @R{}은 이전에 사용되었던 명령어들을 다시 불러오고 이를 재실행을 시킬 수 있는 매커니즘(mechanism)을 가지고 있습니다.
이전에 실행된 명령어들의 기록 (@emph{command history})을 확인하기 위해서는 단순히 키보드의 위 또는 아래로 이동하는 화살표 키를 이용하시면 됩니다. 
만약 재실행하고자 하는 명령어를 찾았다면 좌 또는 우로 이동하는 화살표 키를 이용하여 커서를 변경하고자 하는 위치에 두고, @key{DEL}키 또는 다른 키들을 이용하여 추가 및 수정 역시 가능합니다. 
더 자세한 사항은 @pxref{The command-line editor}을 살펴보시길 바랍니다.

UNIX상에서는 이러한 기능들을 사용자의 취향에 따라 매우 손쉽게 조정(customizable)이 가능합니다. 
이런 것들을 어떻게 하는지에 대해서는 @strong{readline} 라이브러리와 관련된 매뉴얼 항목을 읽어보시길 바랍니다. 
또한, Emacs라는 텍스트 에디터는 @R{}을 보다 파워풀하게 사용할 수 있도록 도와주는 @acronym{ESS}(@emph{Emacs Speaks Statistics})라는 보조시스템을 제공해줍니다.  
이와 관련해서는 다음을 참조하세요 @xref{R and Emacs, , , R-FAQ, The R statistical system FAQ}. 

@node Executing commands from or diverting output to a file, Data permanency and removing objects, Recall and correction of previous commands, Introduction and preliminaries
@section Executing commands from or diverting output to a file
@cindex Diverting input and output

@c If commands@footnote{of unlimited length.} are stored in an external
@c file, say @file{commands.R} in the working directory @file{work}, they
@c may be executed at any time in an @R{} session with the command

만약 @file{work}이라는 워킹디렉토리내에 @file{commands.R}라는 이름을 가진 외부파일 내에 작업하고자 하는 @footnote{매우 방대한 양의 길이의} 명령문이 있다면, 언제든지 다음의 명령어를 이용하여 현재 실행되고 있는 @R{}세션에서 실행시킬 수 있습니다. 

@example
> source("commands.R")
@end example
@findex source

@c For Windows @strong{Source} is also available on the
@c @strong{File} menu.  The function @code{sink},

윈도우즈에서는 위의 명령어 외에도 @strong{File} 메뉴내에 있는 @strong{Source}를 이용하여 동일한 기능을 수행할 수 있습니다.
아래에서 보여지는 @code{sink}라는 함수는 @file{record.lis}라는 외부파일을 생성한 뒤 모든 결과를 이 외부파일에 저장하게 합니다. 
따라서, 콘솔에서는 아무런 출력을 볼 수 없을 것입니다.
@example
> sink("record.lis")
@end example
@findex sink

@noindent
@c will divert all subsequent output from the console to an external file,
@c @file{record.lis}.  The command
외부파일로 결과물 출력을 마쳤다면, 아래의 명령어를 이용하여 출력의 방향을 다시 외부파일에서 콘솔로 되돌려 주도록 합니다.
따라서, 결과물이 더 이상 외부파일로 출력되지 않고, 콘솔에서 그 내용을 확인할 수 있을 것입니다. 
@example
> sink()
@end example

@noindent
@c restores it to the console once again.

@node Data permanency and removing objects,  , Executing commands from or diverting output to a file, Introduction and preliminaries
@section Data permanency and removing objects

@c The entities that @R{} creates and manipulates are known as
@c @emph{objects}.  These may be variables, arrays of numbers, character
@c strings, functions, or more general structures built from such
@c components.

@R{}을 사용하면서 생성하고 다루게 되루어지게 되는 그 모든 것들을 @emph{objects}(객체)라고 합니다. 
변수(variables), 숫자들로 이루어진 배열들(arrays of numbers), 문자열(character strings), 함수(functions), 그리고 이러한 것들로 구성된 좀 더 일반적인 형태의 모든 것들이 객체에 해당하게 됩니다. 

@c During an @R{} session, objects are created and stored by name (we
@c discuss this process in the next session).  The @R{} command

@R{} 세션내에서, 객체들은 이름(name)을 부여함으로서 생성되고 저장되어 집니다 (우리는 다음세션에서 이과정에 대해서 더 자세히 설명할 것입니다).
현재 @R{} 세션내에서 사용되는 객체들을 확인하고자 한다면 다음의 명령어를 사용해보세요.

@example
> objects()
@end example

@noindent
@c (alternatively, @code{ls()}) can be used to display the names of (most
@c of) the objects which are currently stored within @R{}.  The collection
@c of objects currently stored is called the @emph{workspace}.

@code{ls()}라는 명령어 역시 현재 @R{} 세션내에 저장되어 있는 (대부분의) 객체들의 이름을 보여줄 것입니다. 
그리고, 이렇게 현재 객체들이 저장되어 있는 곳을 @emph{workspace}(워크스페이스 또는 작업공간)이라고 합니다. 
@cindex Workspace

@c To remove objects the function @code{rm} is available:
객체들을 삭제하기 위해서는 함수 @code{rm}을 아래와 같은 방법으로 이용할 수 있습니다.

@example
> rm(x, y, z, ink, junk, temp, foo, bar)
@end example
@findex rm
@cindex Removing objects

@c All objects created during an @R{} session can be stored permanently in
@c a file for use in future @R{} sessions.  At the end of each @R{} session
@c you are given the opportunity to save all the currently available
@c objects.  If you indicate that you want to do this, the objects are
@c written to a file called @file{.RData}@footnote{The leading ``dot'' in
@c this file name makes it @emph{invisible} in normal file listings in
@c UNIX.} in the current directory, and the command lines used in the
@c session are saved to a file called @file{.Rhistory}.

@R{}세션내에서 생성된 모든 객체들은 파일의 형태로서 영구저장이 가능하여 다음번 @R{}세션에서 사용될 수 있습니다. 
이러한 영구저장은 @R{}세션의 마지막에서 현재 사용한 모든 객체들에 대한 저장여부를 사용자에게 확인함으로서 이루어지게 됩니다. 
만약, 사용자가 이를 희망한다면 객체들은 @file{.RData}@footnote{유닉스 시스템에서 ``dot''으로 시작하는 파일명은 파일목록을 출력시 일반적으로 파일을 @emph{보여지지 않습니다}.}의 형태로 현재 디렉토리에 저장되며, 이 세션에서 사용된 명령어들 역시 @file{.Rhistory}라는 파일에 저장됩니다. 

@c When @R{} is started at later time from the same directory it reloads
@c the workspace from this file.  At the same time the associated commands
@c history is reloaded.

추후에 @R{}이 같은 디렉토리에서 실행된다면, 이 파일들로부터 이전 세션에서 사용했던 객체들과 명령어들이 워크스페이스로 자동적으로 불러들여오지게 됩니다.

@c It is recommended that you should use separate working directories for
@c analyses conducted with @R{}.  It is quite common for objects with names
@c @code{x} and @code{y} to be created during an analysis.  Names like this
@c are often meaningful in the context of a single analysis, but it can be
@c quite hard to decide what they might be when the several analyses have
@c been conducted in the same directory.

@R{}을 이용하여 통계분석을 하고자 한다면 분석별로 각각의 다른 이름을 가진 워킹디렉토리를 생성할 것을 권장합니다.
그 이유는 분석을 하는 동안에 @code{x}와 @code{y} 같은 이름을 사용하여 객체를 관리하게 되는 경우가 매우 흔하기 때문입니다.
이러한 이름들은 일회성 단순 분석에서는 의미가 있을 수 있으나, 여러개의 분석을 같은 디렉토리에서 수행하게 될때에는 매우 큰 혼란을 초래하게 됩니다.

@node Simple manipulations numbers and vectors, Objects, Introduction and preliminaries, Top
@chapter Simple manipulations; numbers and vectors
@cindex Vectors

@menu
* Vectors and assignment::      
* Vector arithmetic::           
* Generating regular sequences::  
* Logical vectors::             
* Missing values::              
* Character vectors::           
* Index vectors::               
* Other types of objects::      
@end menu

@node Vectors and assignment, Vector arithmetic, Simple manipulations numbers and vectors, Simple manipulations numbers and vectors
@section Vectors and assignment

@c @R{} operates on named @emph{data structures}.  The simplest such
@c structure is the numeric @emph{vector}, which is a single entity
@c consisting of an ordered collection of numbers.  To set up a vector
@c named @code{x}, say, consisting of five numbers, namely 10.4, 5.6, 3.1,
@c 6.4 and 21.7, use the @R{} command

@R{}은 소위 말하는 @emph{data structures}(데이터 구조)를 기반으로 작동합니다.
가장 단순한 구조는 일련의 숫자들이 오름차순의 형태로 하나로 묶여있는 수치형(numeric) @emph{vector}(벡터)입니다.
예를들어, 10.4, 5.6, 3.1, 6.4, 그리고 21.7 이라는 일련의 숫자로 구성된 @code{x}라는 이름을 가진 벡터를 생성하기 위해서는 다음과 같은 @R{} 명령어를 입력합니다

@example
> x <- c(10.4, 5.6, 3.1, 6.4, 21.7)
@end example
@findex c
@findex vector

@c This is an @emph{assignment} statement using the @emph{function}
@c @code{c()} which in this context can take an arbitrary number of vector
@c @emph{arguments} and whose value is a vector got by concatenating its
@c arguments end to end.@footnote{With other than vector types of argument,
@c such as @code{list} mode arguments, the action of @code{c()} is rather
@c different.  See @ref{Concatenating lists}.}

위에서 사용된 표현식을 @emph{assignment statement}(할당문) 이라고 하며, @code{c()}라는 @emph{function}(함수)를 이용하여 입력되어진 임의의 벡터들을 묶어 다시 하나의 벡터로 만들어 주는 역할을 하고 있습니다.
이때 함수 @code{c()}내에서 컴마로 구분된 하나하나를 구성요소를 @emph{arguments}(입력인자 또는 인자)라고 하고, 이 예제에서는 숫자 하나 하나가 각각의 길이가 1인 벡터로 간주되었습니다.
@footnote{@code{list}형과 같은 벡터형의 인자가 아닌 데이터형에 대해서는 @code{c()}함수는 다소 다르게 동작합니다. @ref{Concatenating lists}를 참고하하시길 바랍니다.}

@c A number occurring by itself in an expression is taken as a vector of
@c length one.

@c Notice that the assignment operator (@samp{@code{<-}}), which consists
@c of the two characters @samp{@code{<}} (``less than'') and
@c @samp{@code{-}} (``minus'') occurring strictly side-by-side and it
@c `points' to the object receiving the value of the expression.
@c In most contexts the @samp{@code{=}} operator can be used as an alternative.
@c In this text, the assignment operator is printed as @samp{<-}, rather
@c than ``@code{<-}''.

또한, 띄어쓰기 없이 @samp{@code{<}}(좌측이 우측보다 작음을 표시하는 수학적 기호) 와 @samp{@code{-}}(마이너스 기호)를 한데 묶어 사용된 @samp{@code{<-}}라는 기호는 할당연산자(assignment operator)라고 불리며, 표현식에 의해 생성된 값을 넘겨받는 객체를 지시 (또는 지정)하도록 한다는 것을 의미합니다. 
많은 경우에 이를 @samp{@code{=}} 연산자를 이용하여 나타내기도 합니다.
@cindex Assignment

@c Assignment can also be made using the function @code{assign()}.  An
@c equivalent way of making the same assignment as above is with:

할당이라는 것은 또한 @code{assign()} 함수를 통해 이루어질 수 있습니다.
위에서 수행한 동일한 연산을 아래와 같은 방법으로 수행할 수 있습니다.

@example
> assign("x", c(10.4, 5.6, 3.1, 6.4, 21.7))
@end example

@noindent
@c The usual operator, @code{<-}, can be thought of as a syntactic
@c short-cut to this.
독자는 할당연산자 @code{<-}를 단순히 @code{assign()}함수에 문법적으로 상응하는 손쉬운 방법(short-cut)으로 생각하셔도 좋습니다.

@c Assignments can also be made in the other direction, using the obvious
@c change in the assignment operator.  So the same assignment could be made
@c using

또한, 기호의 방향을 바꾸어 아래와 같은 방법으로 할당문을 표현할 수 있습니다.

@example
> c(10.4, 5.6, 3.1, 6.4, 21.7) -> x
@end example

@c If an expression is used as a complete command, the value is printed
@c @emph{and lost}@footnote{Actually, it is still available as
@c @code{.Last.value} before any other statements are executed.}.  So now if we
@c were to use the command

만약 아래와 같이 할당연산자의 사용없이 표현식 자체만으로 완전한 형태의 명령문 형식으로 사용된다면 결과물은 출력이되나, @emph{값들을 저장하지 안ㅎ고 잃어버리게 됩니다}@footnote{실제로 이 값은 어떠한 명령문이라도 추후에 실행되지 않았다면 @code{.Last.value}를 통하여 확인할 수 있습니다.}.

@example
> 1/x
@end example

@noindent
@c the reciprocals of the five values would be printed at the terminal (and
@c the value of @code{x}, of course, unchanged).

만약, 위의 명령문을 실행한다면 @code{x}를 구성하는 다섯개의 숫자들에 대한 각각의 역수들을 터미널에 보여줄 것입니다 (물론, @code{x}의 값은 변하지 않습니다).

@c The further assignment
이제 할당연산자를 적용해보도록 합니다.
다음의 할당문은 2개의 @code{x}벡터사이에 0 이 끼워진 형태로 총 11개의 구성요소로 이루어진 @code{y}라는 새로운 벡터를 생성해냅니다.

@example
> y <- c(x, 0, x)
@end example

@noindent
@c would create a vector @code{y} with 11 entries consisting of two copies
@c of @code{x} with a zero in the middle place.

@node Vector arithmetic, Generating regular sequences, Vectors and assignment, Simple manipulations numbers and vectors
@section Vector arithmetic

@c Vectors can be used in arithmetic expressions, in which case the
@c operations are performed element by element.  Vectors occurring in the
@c same expression need not all be of the same length.  If they are not,
@c the value of the expression is a vector with the same length as the
@c longest vector which occurs in the expression.  Shorter vectors in the
@c expression are @emph{recycled} as often as need be (perhaps
@c fractionally) until they match the length of the longest vector.  In
@c particular a constant is simply repeated.  So with the above assignments
@c the command

벡터(vector)는 요소단위(element by element)의 산술연산 표현식(arithmetic expression)에서 이용됩니다. 
이 때, 같은 표현식 내의 벡터가 꼭 같은 길이를 가질 필요는 없습니다.
만약, 길이가 다르다면 상대적으로 짧은 길이를 가지는 벡터는 긴 벡터의 길이를 맞추기 위해서 그 구성요소를 재활용(@emph{recycled} 또는 리사이클링)하게 됩니다. 
특히, 벡터의 길이가 하나인 상수(constant)를 사용한 경우에는 다른 벡터의 길이만큼 상수를 반복하여 길이를 맞춘 뒤 요소단위의 연산을 수행하게 됩니다. 
위의 예제를 활용하여 다음의 다음의 명령문을 수행한다면 @R{}은 제일 먼저 @code{x}의 길이를 @code{y}에 맞추기 위해서 그 구성요소를 2.2배만큼 리사이클링합니다. 
그리고, @code{x}앞에 있는 상수 2를 각 요소별로 곱한뒤에 (즉, 11번의 연산이 필요합니다), @code{y}의 더하기 연산을 요소단위별로 수행합니다.
마지막으로 상수 @code{1} 역시 11번 리사이클링된 후 이전의 결과와 새로운 더하기 연산을 요소단위로 수행한 뒤 그 결과를 @code{v}에 할당하게 됩니다. 
따라서, @code{v}의 길이는 11이어야 합니다.
 
@cindex Recycling rule

@example
> v <- 2*x + y + 1
@end example

@noindent
@c generates a new vector @code{v} of length 11 constructed by adding
@c together, element by element, @code{2*x} repeated 2.2 times, @code{y}
@c repeated just once, and @code{1} repeated 11 times.


@cindex Arithmetic functions and operators
@c The elementary arithmetic operators are the usual @code{+}, @code{-},
@c @code{*}, @code{/} and @code{^} for raising to a power.

@R{}에서 제공하는 요소단위의 기초연산자는 @code{+}(더하기), @code{-}(빼기), @code{*}(곱하기), @code{/}(나누기), 그리고 @code{^}(자승)입니다.

@findex +
@findex -
@findex *
@findex /
@findex ^

@c In addition all of the common arithmetic functions are available.
@c @code{log}, @code{exp}, @code{sin}, @code{cos}, @code{tan}, @code{sqrt},
@c and so on, all have their usual meaning.

@R{}은 또한 일반적인 수학적 연산에 자주 사용되는 @code{log}, @code{exp}, @code{sin}, @code{cos}, @code{tan}, @code{sqrt}와 같은 함수를 제공하며, 이들의 의미는 수학에서 사용하는 것과 동일합니다. 

@findex log
@findex exp
@findex sin
@findex cos
@findex tan
@findex sqrt

@c @code{max} and @code{min} select the largest and smallest elements of a
@c vector respectively.

@code{max}와 @code{min}는 벡터의 구성요소들 중에서 가장 큰 값과 작은 값을 알려주는 함수입니다. 

@findex max
@findex min

@c @code{range} is a function whose value is a vector of length two, namely
@c @code{c(min(x), max(x))}.
@code{range}는 주어진 벡터 @code{x}의 최소값과 최대값을 @code{c(min(x), max(x))}의 형태로 알려주며, 함수명 그대로 범위를 구하고자 할 때 사용됩니다.

@findex range

@c @code{length(x)} is the number of elements in @code{x},
@code{length(x)}는 벡터의 @code{x}의 구성요소가 몇 개인가를 알려주며, 이를 보통 @code{x}의 길이라고 합니다.

@findex length

@c @code{sum(x)} gives the total of the elements in @code{x},
@code{sum(x)}는 @code{x}의 모든 구성요소들의 합을 구하고자 할 때 사용하고, 

@findex sum

@c and @code{prod(x)} their product.
@code{prod(x)}는 모든 구성요소들의 곱을 구할 때 이용됩니다.
@findex prod

@c Two statistical functions are @code{mean(x)} which calculates the sample
@c mean, which is the same as @code{sum(x)/length(x)},

통계에서 자주 이용되는 평균과 분산을 계산해 주는 함수들도 제공됩니다.
샘플평균(sample mean)은 @code{sum(x)/length(x)}을 통해 얻을 수 있는데, 이를 @code{mean(x)}를 사용하여 그 값을 구할 수 있습니다. 
@findex mean
@c and @code{var(x)} which gives
그리고, 샘플분산(sample variance)은 아래와 같은 공식을 통해서 얻을 수 있는데, 이 역시 @code{var(x)}를 사용하여 보다 편리하게 값을 구할 수 있습니다. 
@example
sum((x-mean(x))^2)/(length(x)-1)
@end example
@findex var

@noindent
@c or sample variance.  If the argument to @code{var()} is an
@c @math{n}-by-@math{p} matrix the value is a @math{p}-by-@math{p} sample
@c covariance matrix got by regarding the rows as independent
@c @math{p}-variate sample vectors.
만약, @code{var()}에 사용되는 입력인자(argument)가 @math{n}-by-@math{p} 크기의 행렬이라면, @math{p}개의 변수들에 대한 @math{n}개의 관측치를 갖는 데이터로 인식되어 @math{p}-by-@math{p}크기의 샘플 공분산 행렬(sample covariance matrix)를 알려줍니다. 

@c @code{sort(x)} returns a vector of the same size as @code{x} with the
@c elements arranged in increasing order; however there are other more
@c flexible sorting facilities available (see @code{order()} or
@c @code{sort.list()} which produce a permutation to do the sorting).
@code{sort(x)}는 벡터 @code{x}를 인수로 받아 @code{x}의 모든 구성요소들을 오름차순(increasing order, 즉, 작은 값에서 큰 값의 순서로) 재배열하여 @code{x}와 같은 길이의 벡터를 돌려주게 되며, 보다 유용한 정렬기능들도 제공이 됩니다.
예를들면, 인자로 사용된 @code{x} 벡터의 정렬된 순서를 확인하고 할 때는 @code{order()} 또는 @code{sort.list()}를 사용할 수도 있습니다.

@findex sort
@findex order

@c Note that @code{max} and @code{min} select the largest and smallest
@c values in their arguments, even if they are given several vectors.  The
@c @emph{parallel} maximum and minimum functions @code{pmax} and
@c @code{pmin} return a vector (of length equal to their longest argument)
@c that contains in each element the largest (smallest) element in that
@c position in any of the input vectors.

@code{max}와 @code{min}에 여러개의 벡터가 입력인수로 사용되었을지라도, 이들을 구성하는 모든 구성요소들중에서 최대값과 최소값을 찾아줍니다.
만약, 주어진 여러개의 입력인자들로부터 대한 최대값과 최소값을 병렬적(@emph{parallel})로 찾고자 한다면 @code{pmax}와 @code{pmin} 함수들을 이용할 수 있으며, 반환되는 벡터의 길이는 입력 인자중에서 가장 길이가 긴 벡터와 동일합니다. 

@findex pmax
@findex pmin

@c For most purposes the user will not be concerned if the ``numbers'' in a
@c numeric vector are integers, reals or even complex.  Internally
@c calculations are done as double precision real numbers, or double
@c precision complex numbers if the input data are complex.

대부분의 경우 사용자들은 수치형 벡터(numeric vector)를 구성하는 ``numbers''(숫자)들의 종류가 정수(integer), 실수(real) 또는 허수(complex)인지 신경을 쓰지 않습니다. 
@R{}은 내부적으로 입력된 벡터가 실수라면 double precision을 가지는 실수로, 복소수라면 double precision을 가지는 복소수 연산을 수행하게 됩니다. 

@c To work with complex numbers, supply an explicit complex part.  Thus
단, 복소수를 다루게 된다면, 어느 부분이 허수부분(copmlex part)인지를 정확히 명시해주어야 합니다. 
그렇지 않고 아래와 같이 사용한다면 @code{NaN}이라는 값과 경고(warning) 메시지를 보게 될 것입니다. 

@example
sqrt(-17)
@end example

@noindent
@c will give @code{NaN} and a warning, but

따라서, 아래와 같이 사용을 해야지만 복소수 연산을 올바르게 수행하게 됩니다. 

@example
sqrt(-17+0i)
@end example

@noindent
@c will do the computations as complex numbers.

@menu
* Generating regular sequences::
@end menu

@node Generating regular sequences, Logical vectors, Vector arithmetic, Simple manipulations numbers and vectors
@section Generating regular sequences
@cindex Regular sequences

@c @R{} has a number of facilities for generating commonly used sequences
@c of numbers.  For example @code{1:30} is the vector @code{c(1, 2,
@c @dots{}, 29, 30)}.
@R{}은 시퀀스(sequence 또는 수열)을 생성하는 다양한 방법을 제공하고 있습니다.
예를들면, @code{1:30}이라는 명령어는 @code{c(1, 2, @dots{}, 29, 30)}이라는 벡터를 생성합니다. 
@c <NOTE>
@c Info cannot handle ':' as an index entry.
@ifnotinfo
@findex :
@end ifnotinfo
@c </NOTE>
@c The colon operator has high priority within an expression, so, for
@c example @code{2*1:15} is the vector @code{c(2, 4, @dots{}, 28, 30)}.
@c Put @code{n <- 10} and compare the sequences @code{1:n-1} and
@c @code{1:(n-1)}.
콜론(colon) 연산자는 어떤 표현식보다도 최우선으로 처리됩니다. 
예를들면, @code{2*1:15}은 @code{c(2, 4, @dots{}, 28, 30)}이라는 벡터를 생성합니다. 
그럼, @code{n <- 10}을 입력하고 난뒤에 @code{1:n-1}과 @code{1:(n-1)}로부터 생성되는 두개의 벡터들을 비교해보시길 바랍니다.

@c The construction @code{30:1} may be used to generate a sequence
@c backwards.

만약 @code{30:1}이라는 명령을 통하여 역순으로 나열된 수열 역시 생성할 수 있습니다.

@findex seq
@c The function @code{seq()} is a more general facility for generating
@c sequences.  It has five arguments, only some of which may be specified
@c in any one call.  The first two arguments, if given, specify the
@c beginning and end of the sequence, and if these are the only two
@c arguments given the result is the same as the colon operator.  That is
@c @code{seq(2,10)} is the same vector as @code{2:10}.

@code{seq()}라는 함수는 수열을 좀 더 일반적인 방식으로 생성하는 기능을 가지고 있습니다. 
@code{seq()}는 5개의 인자를 가지고 있는데, 이중의 일부만을 가지고도 다양한 수열의 생성이 가능합니다.
먼저, 처음 두개의 인자는 수열의 처음과 마지막 값을 지정합니다.
이 두 개의 인자마나 지정된다면, 콜론 연산자를 사용한 것과 동일한 벡터를 생성합니다. 
즉, @code{seq(2,10)}에 의하여 생성된 수열은 @code{2:10}으로부터 생성된 수열과 동일합니다. 

@c Parameters to @code{seq()}, and to many other @R{} functions, can also
@c be given in named form, in which case the order in which they appear is
@c irrelevant.  The first two parameters may be named
@c @code{from=@var{value}} and @code{to=@var{value}}; thus
@c @code{seq(1,30)}, @code{seq(from=1, to=30)} and @code{seq(to=30,
@c from=1)} are all the same as @code{1:30}.  The next two parameters to
@c @code{seq()} may be named @code{by=@var{value}} and
@c @code{length=@var{value}}, which specify a step size and a length for
@c the sequence respectively.  If neither of these is given, the default
@c @code{by=1} is assumed.

@R{}에 사용되는 다른 많은 함수들과 같이 함수 @code{seq()}에 넘겨지는 파라미터들은 named form(즉, 인자의 이름과 이에 해당하는 파라미터의 값을 사용하고자 하는 함수에 함께 쓰는것)의 형태로 사용됩니다. 
위에서 사용한 예제 @code{seq(1,30)}를 이용하여 다시 설명하면, @code{seq()}의 처음 두 파라미터들은 처음 시작값 @code{from=@var{value}}을 의미하고, 마지막 값 @code{to=@var{value}}을 의미하기 때문에, @code{seq(1,30)}, @code{seq(from=1, to=30)}, @code{seq(to=30, from=1)} 모두 @code{1:30}으로부터 생성된 수열과 동일한 수열을 생성합니다.  
@code{seq()}의 다음 두개의 인자들은 @code{by=@var{value}}와 @code{length=@var{value}}입니다. 
@code{by=@var{value}}는 나열되어질 숫자들간의 차이 (step size)를 지정하며, @code{length=@var{value}}는 나열되어질 숫자들 사이의 구간의 개수(length)를 지정하게 됩니다. 
만약, 이 두가지 모두 지정되어지지 않는다면, 기본적으로  @code{by=1}로 가정한 상태에서 수열을 생성하게 됩니다. 

@c For example

다음의 예를 살펴봅니다.

@example
> seq(-5, 5, by=.2) -> s3
@end example

@noindent
@c generates in @code{s3} the vector @code{c(-5.0, -4.8, -4.6, @dots{},
@c 4.6, 4.8, 5.0)}.  Similarly

위의 명령어는 @code{c(-5.0, -4.8, -4.6, @dots{}, 4.6, 4.8, 5.0)}이라는 수열을 생성한 뒤, 이를 @code{s3}이라는 이름을 가진 벡터형 객체로서 저장하라는 의미입니다.
이와 비슷한 논리로 아래와 같이 @code{s3}와 같은 수열을 가지는 @code{s4}를 생성할 수 있습니다. 

@example
> s4 <- seq(length=51, from=-5, by=.2)
@end example

@noindent
@c generates the same vector in @code{s4}.

@c The fifth parameter may be named @code{along=@var{vector}}, which if
@c used must be the only parameter, and creates a sequence @code{1, 2,
@c @dots{}, length(@var{vector})}, or the empty sequence if the vector is
@c empty (as it can be).

@code{seq()} 함수의 다섯번째 인자는 @code{along=@var{vector}}입니다.
만약 다른 인자들에 대한 입력없이 독립적으로 사용된다면 @code{1, 2, @dots{}, length(@var{vector})}이라는 수열을 생성하게 됩니다. 

@c A related function is @code{rep()}
@findex rep
@c which can be used for replicating an object in various complicated ways.
@c The simplest form is

@code{seq()}유사한 함수로서 다양한 방법으로 객체를 반복하는데 사용될 수 있는 @code{rep()}라는 함수가 있습니다. 
이 함수에 대한 가장 간단한 형태는 아래와 같습니다.

@example
> s5 <- rep(x, times=5)
@end example

@noindent
@c which will put five copies of @code{x} end-to-end in @code{s5}.  Another
@c useful version is

위의 명령어는 @code{x}라는 벡터를 5번 반복하여 나열함으로서 생성한 객체에 @code{s5}에 두는 것입니다.
이에 대한 또다른 사용법을 아래의 예제를 통해 알 수 있습니다. 

@example
> s6 <- rep(x, each=5)
@end example

@noindent
@c which repeats each element of @code{x} five times before moving on to
@c the next.

이것은 @code{x}란 벡터가 가지고 있는 각각의 요소들을 5번씩 반복하여 생성한 수열을 의미합니다. 

@node Logical vectors, Missing values, Generating regular sequences, Simple manipulations numbers and vectors
@section Logical vectors

@c As well as numerical vectors, @R{} allows manipulation of logical
@c quantities.  The elements of a logical vector can have the values
@c @code{TRUE}, @code{FALSE}, and @code{NA} (for ``not available'', see
@c below).  The first two are often abbreviated as @code{T} and @code{F},
@c respectively.  Note however that @code{T} and @code{F} are just
@c variables which are set to @code{TRUE} and @code{FALSE} by default, but
@c are not reserved words and hence can be overwritten by the user.  Hence,
@c you should always use @code{TRUE} and @code{FALSE}.
수치형 벡터 외에도 @R{}은 논리값에 대한 조작이 가능합니다.
논리형 벡터는 그 구성요소의 값들이 @code{TRUE}, @code{FALSE}, 그리고 @code{NA} (즉 ``not available'' - 이용가능하지 않아 유용하지 않음)을 가지는 것을 의미합니다.
처음 두 개의 값들을 각각 @code{T}와 @code{F}라는 약어로도 표기하기도 합니다. 
그러나, 예약어가 아닌 기본값인 @code{TRUE}와 @code{FALSE}를 가지는 변수명으로서의 @code{T}와 @code{F}를 사용할 수도 있어 사용자가 사용자가 사용하는 동일한 변수명에 의해서 덮여씌여질 수도 있습니다. 
따라서, 논리값을 표현할 때에는 @code{TRUE}와 @code{FALSE}라고 완전하게 사용해야 합니다. 
@findex FALSE
@findex TRUE
@findex F
@findex T

Logical vectors are generated by @emph{conditions}.  For example
논리형 벡터는 조건문 (@emph{conditions})에 의해서 생성됩니다.
예를 들면, 아래의 명령문과 같이 @code{x}라는 벡터의 구성요소들을 13 보다 크다는 조건을 만족한다면 @code{TRUE}라는 논리값을 생성하고, 그렇지 않다면 @code{FALSE}라는 논리값을 저장하는 새로운 벡터를 생성하여 @code{temp}에 대입할 수 있습니다. 

@example
> temp <- x > 13
@end example

@noindent
@c sets @code{temp} as a vector of the same length as @code{x} with values
@c @code{FALSE} corresponding to elements of @code{x} where the condition
@c is @emph{not} met and @code{TRUE} where it is.

@c The logical operators are @code{<}, @code{<=}, @code{>}, @code{>=},
@c @code{==} for exact equality and @code{!=} for inequality.
논리연산자로는 @code{<} (작음), @code{<=} (작거나 같음), @code{>} (큼), @code{>=} (크거나 같음), @code{==} (같음), 그리고 @code{!=} (다름)가 있습니다. 
@findex <
@findex <=
@findex >
@findex >=
@findex ==
@findex !=
@c In addition if @code{c1} and @code{c2} are logical expressions, then
@c @w{@code{c1 & c2}} is their intersection (@emph{``and''}), @w{@code{c1 | c2}}
@c is their union (@emph{``or''}), and @code{!c1} is the negation of
@c @code{c1}.
또한, @code{c1}과 @code{c2}라는 논리적 표현이 있다면, @w{@code{c1 & c2}}는 (@emph{``and''})를 나타내는 교집합을 @w{@code{c1 | c2}}는 (@emph{``or''})를 나타내는 합집합을 나타내며, @code{!c1}는 @code{c1}이 아닌 차집합을 나타낼 수 있습니다.  
@findex !
@findex |
@findex &

@c Logical vectors may be used in ordinary arithmetic, in which case they
@c are @emph{coerced} into numeric vectors, @code{FALSE} becoming @code{0}
@c and @code{TRUE} becoming @code{1}.  However there are situations where
@c logical vectors and their coerced numeric counterparts are not
@c equivalent, for example see the next subsection.

논리값을 가지는 벡터들은 일반적인 산술연산에 사용될 수도 있습니다.
이것은 논리형 벡터를 강제적으로 수치형 벡터로 변환하게 되는데, @code{FALSE}는 @code{0}으로 @code{TRUE}는 @code{1}로 변환됩니다. 
이러한 변환을 @emph{coerced}(강제형변환)이라고 합니다. 
그런데, 이러한 논리형 벡터들과 강제형변환된 수치형 벡터들이 방금 설명한 것과 같이 동작하지 않는 경우가 있다는 점을 알고 있어야 하며, 이러한 예제는 다음섹션에서 보도록 하겠습니다. 

@node Missing values, Character vectors, Logical vectors, Simple manipulations numbers and vectors
@section Missing values
@cindex Missing values

@c In some cases the components of a vector may not be completely
@c known.  When an element or value is ``not available'' or a ``missing
@c value'' in the statistical sense, a place within a vector may be
@c reserved for it by assigning it the special value @code{NA}.
가끔 벡터의 구성요소들에 대해서 완전하게 알 수 없는 경우가 있습니다.
통계학적 의미에서 이러한 구성요소 또는 값들은 ``not available'' (사용이 가능하지 않음) 또는 ``missing value''(결측치 혹은 누락된 값)인 경우, 이들을 벡터내에서 @code{NA}라는 특수한 값을 이용하여 표시합니다. 
@findex NA
@c In general any operation on an @code{NA} becomes an @code{NA}.  The
@c motivation for this rule is simply that if the specification of an
@c operation is incomplete, the result cannot be known and hence is not
@c available.
일반적으로 @code{NA}에 대한 연산의 결과는 @code{NA}가 됩니다.
이러한 규칙을 만들게 된 동기는 단순히 만약 연산에 대한 지정이 완전하지 않다면 그 연산결과를 알 수 없거나 이용가능하지 않기 때문입니다. 
@findex is.na
@c The function @code{is.na(x)} gives a logical vector of the same size as
@c @code{x} with value @code{TRUE} if and only if the corresponding element
@c in @code{x} is @code{NA}.
함수 @code{is.na(x)}는 @code{x}의 각 구성요소가 가지는 값이 @code{NA}인지를 확인하여 만약 그렇다면 @code{TRUE}를, 그렇지 않다면 @code{FALSE}를 가지는 새로운 벡터를 생성하게 됩니다. 
따라서, 생성된 벡터의 길이는 @code{x}와 같아야 하며, 이는 아래의 명령문을 통해 확인해 볼 수 있습니다. 

@example
> z <- c(1:3,NA);  ind <- is.na(z)
@end example

@c Notice that the logical expression @code{x == NA} is quite different
@c from @code{is.na(x)} since @code{NA} is not really a value but a marker
@c for a quantity that is not available.  Thus @code{x == NA} is a vector
@c of the same length as @code{x} @emph{all} of whose values are @code{NA}
@c as the logical expression itself is incomplete and hence undecidable.

그러나, @code{NA}라는 것은 실제로 단순히 벡터를 구성하는 요소에 값이 사용가능한지에 대한 마커일 뿐이기 때문에 @code{x == NA}이라는 논리적 표현식은 @code{is.na(x)}와의 결과와는 다르다는 것을 아셔야 합니다. 
따라서, @code{x == NA}는 벡터 @code{x}와 길이는 같지만 그 구성요소  @emph{모두}가 @code{NA}값을 가지게 됩니다. 
그 이유는 논리적 표현식 자체가 @code{==}라는 연산을 수행하기에는 불완전하고 결정할 수 없기 때문입니다. 

@c Note that there is a second kind of ``missing'' values which are
@c produced by numerical computation, the so-called @emph{Not a Number},
@c @code{NaN},
@findex NaN
@c values.  Examples are
또한 수치연산의 결과로서 발생하는 ``missing''이라는 의미의 @code{NaN}은 @emph{Not a Number}(숫자가 아님)이라고 하며, 다음의 두 예제를 통해서 알 수 있습니다. 

@example
> 0/0
@end example

@noindent
또는 

@example
> Inf - Inf
@end example

@noindent
@c which both give @code{NaN} since the result cannot be defined sensibly.
위의 두가지 경우 모두 수학적 정의에 따라 계산을 수행할 수 없기 때문에 @code{NaN}이라는 결과를 주게 됩니다. 

@c In summary, @code{is.na(xx)} is @code{TRUE} @emph{both} for @code{NA}
@c and @code{NaN} values.  To differentiate these, @code{is.nan(xx)} is only
@c @code{TRUE} for @code{NaN}s.
@findex is.nan
요약해보면, @code{is.na(xx)}는 @code{NA}와 @code{NaN}라는 두가지 경우 모두 @code{TRUE} 값을 돌려줍니다.
그러나, @code{is.nan(xx)}은 오로지 값이 @code{NaN}일때만 @code{TRUE}가 됩니다. 

@c Missing values are sometimes printed as @code{<NA>} when character
@c vectors are printed without quotes.
어떤 경우에는 이렇게 알 수 없는 값들에 대해서 @code{<NA>}로 표시가 되는 경우가 있는데 이는 문자형 벡터가 사용되었기 때문입니다. 

@node Character vectors, Index vectors, Missing values, Simple manipulations numbers and vectors
@section Character vectors
@cindex Character vectors

@c Character quantities and character vectors are used frequently in @R{},
@c for example as plot labels.  Where needed they are denoted by a sequence
@c of characters delimited by the double quote character, e.g.,
@c @code{"x-values"}, @code{"New iteration results"}.
문자 또는 문자열은 주로 @R{}에서 플랏의 라벨들에 자주 사용되며, @code{"x-values"} 또는 @code{"New iteration results"}와 문자열의 앞과 뒤쪽에 큰 따옴표를 붙여줌으로서 이를 표시하도록 합니다.

@c Character strings are entered using either matching double (@code{"}) or
@c single (@code{'}) quotes, but are printed using double quotes (or
@c sometimes without quotes).  They use C-style escape sequences, using
@c @code{\} as the escape character, so @code{\\} is entered and printed as
@c @code{\\}, and inside double quotes @code{"} is entered as @code{\"}.
@c Other useful escape sequences are @code{\n}, newline, @code{\t}, tab and
@c @code{\b}, backspace---see @command{?Quotes} for a full list.

실은 큰 따옴표 (@code{"}) 말고도 작은 따옴표 (@code{'})도 문자열을 사용하기 위해서 이용될 수 있으나 이 문자열에 대한 출력은 큰 따옴표를 이용하여 보여지게 됩니다 (어떤 경우에는 큰 따옴표가 보이지 않을 때도 있습니다).
이 문자열에서는 @code{\}를 사용하는 C 언어의 이스케이프 시퀀스(escape sequence)를 이용하여 문자열을 처리합니다. 
따라서, 출력에 @code{\\}를 나타내기 위해서는 문자열 내에 @code{\\}을 사용하고, 큰 따옴표 @code{"}를 출력하기 위해서는 @code{\"}를 문자열 내에 사용하도록 합니다. 
또다른 유용한 이스케이프 시퀀스들로는 @code{\n}이 있는데 이는 새로운 행(즉, 개행)을 나타내고, @code{\t}는 탭(tab)을, @code{\b}는 백스페이스에 사용됩니다. 
만약, 이에 대한 전체 목록을 확인하고 싶으시다면 @command{?Quotes}이라고 입력해 보시길 바랍니다. 

@c Character vectors may be concatenated into a vector by the @code{c()}
@c function; examples of their use will emerge frequently.
문자형 벡터들은 @code{c()}라는 함수를 이용하여 새로운 문자열 벡터를 만들어 낼 수도 있습니다. 
이에 대한 예제는 앞으로 자주 보게 될 것입니다. 
@findex c

@findex paste
@c The @code{paste()} function takes an arbitrary number of arguments and
@c concatenates them one by one into character strings.  Any numbers given
@c among the arguments are coerced into character strings in the evident
@c way, that is, in the same way they would be if they were printed.  The
@c arguments are by default separated in the result by a single blank
@c character, but this can be changed by the named parameter,
@c @code{sep=@var{string}}, which changes it to @code{@var{string}},
@c possibly empty.

@code{paste()} 함수는 임의의 개수의 인자들을 입력받아, 이들을 한데 묶어 하나의 문자열을 생성해줍니다.
이 때, 주어진 인자들중에서 만약 숫자형이 있을지라도 문자형으로 강제형변환이 이루어짐을 알아두셔야 합니다. 
또한, 출력시에는 기본적으로 입력된 인자들 사이에 한개의 빈공간 (white space 또는 blank character)을 넣어 각 인자들을 구분하여 보여지도록 합니다. 
이렇게 화이트 스페이스를 이용한 문자열 출력은 @code{sep=@var{string}}을 통하여 변경이 가능하며, 다음의 예제에서 보는 바와 같이 @code{@var{string}}은 아무것도 입력되지 않은 빈상태임을 표현할 수도 있습니다.  
@c For example
@example
> labs <- paste(c("X","Y"), 1:10, sep="")
@end example

@noindent
@c makes @code{labs} into the character vector

위에서 사용된 명령문에서 @code{paste()}라는 함수는 @code{c("X", "Y")}라는 문자형 벡터와 @code{1:10}이라는 숫자형 벡터를 한데 묶을 것인데, 두 벡터의 길이가 다르므로 @code{c("X", "Y")}는 5번 반복되게 될 것입니다. 
또한, 구분자가 @code{sep=""}되어 있으므로 두 문자열사이에 아무런 공백이 없을 것입니다. 
따라서, 위의 명령문의 수행은 아래의 명령문을 수행한 것과 동일합니다. 

@example
c("X1", "Y2", "X3", "Y4", "X5", "Y6", "X7", "Y8", "X9", "Y10")
@end example

@c Note particularly that recycling of short lists takes place here too;
@c thus @code{c("X", "Y")} is repeated 5 times to match the sequence
@c @code{1:10}.

@footnote{@code{paste(..., collapse=@var{ss})} joins the
arguments into a single character string putting @var{ss} in between.
There are more tools for character manipulation, see the help
for @code{sub} and @code{substring}.}

@footnote{@code{paste(..., collapse=@var{ss})}라고 하게되면 인자들 사이에 @var{ss}를 넣어 하나의 문자열을 만듭니다.
문자열을 다루는 도구들에 대해서 더 많은 것을 알고 싶으시다면 @code{sub}와 @code{substring}를 살펴보시길 바랍니다.}

@node Index vectors, Other types of objects, Character vectors, Simple manipulations numbers and vectors
@section Index vectors; selecting and modifying subsets of a data set
@cindex Indexing vectors

@c Subsets of the elements of a vector may be selected by appending to the
@c name of the vector an @emph{index vector} in square brackets.  More
@c generally any expression that evaluates to a vector may have subsets of
@c its elements similarly selected by appending an index vector in square
@c brackets immediately after the expression.

벡터의 구성요소들은 벡터의 이름 바로뒤에 열린 대괄호를 사용하여 @emph{index vector}(인덱스 벡터)을 이용하여 부분적으로 선택할 수 있습니다.
여기에서 인덱스 벡터란 대괄호 내부에 쓰여지는 벡터의 이름입니다.
좀 더 일반적으로, 벡터를 결과적으로 생성하게 되는 어떠한 표현식에 대한 구성요소들을 부분선택하고자 할때 역시 벡터의 경우에서 설명한 것과 유사한 방법이 사용될 수 있습니다. 
즉, 표현식 바로뒤에 대괄호와 인덱스 벡터를 사용하시면 됩니다. 

@c FIXME: Add a forward reference to  subset()  here
@c FIXME  and  add a paragraph about subset() {which needs to come after
@c FIXME  data frames ...

@c Such index vectors can be any of four distinct types.
이러한 인덱스 벡터에는 다음과 같은 네가지 유형이 있습니다. 

@enumerate

@item
@c @strong{A logical vector}.  In this case the index vector must be of the
@c same length as the vector from which elements are to be selected.
@c Values corresponding to @code{TRUE} in the index vector are selected and
@c those corresponding to @code{FALSE} are omitted.  For example

@strong{논리형 벡터}.  이 경우는 인덱스 벡터는 반드시 선택되어질 구성요소를 가지고 있는 벡터의 길이와 같아야 합니다. 
인덱스 벡터에서 @code{TRUE}에 상응하는 요소들만이 선택되고, @code{FALSE}에 상응하는 요소들은 제거되어 질 것입니다. 
예를 들면 다음과 같습니다. 
아래의 명령문은 @code{x}의 값이 빠져있지 않은 요소들만을 포함하는 객체 @code{y}를 생성할 것입니다. 
만약 @code{x}에 정말로 결측으로 표현된 값들이 있다면  @code{y}의 길이는 @code{x}보다 짧을 것입니다. 
@example
> y <- x[!is.na(x)]
@end example

@noindent
@c creates (or re-creates) an object @code{y} which will contain the
@c non-missing values of @code{x}, in the same order.  Note that if
@c @code{x} has missing values, @code{y} will be shorter than @code{x}.
@c Also

다음은 또 다른 예제입니다. 
아래의 명령어는 @code{x}에 결측값들이 없고 양수인 @code{x}의 구성요소들만을 모아 이들에 1을 더하여 얻어진 객체 @code{z}를 생성합니다.

@example
> (x+1)[(!is.na(x)) & x>0] -> z
@end example

@noindent
@c creates an object @code{z} and places in it the values of the vector
@c @code{x+1} for which the corresponding value in @code{x} was both
@c non-missing and positive.

@item
@c @strong{A vector of positive integral quantities}.  In this case the
@c values in the index vector must lie in the set @{1, 2, @dots{},
@c @code{length(x)}@}.  The corresponding elements of the vector are
@c selected and concatenated, @emph{in that order}, in the result.  The
@c index vector can be of any length and the result is of the same length
@c as the index vector.  For example @code{x[6]} is the sixth component of
@c @code{x} and

@strong{양의 값만을 가지는 벡터}.  이 경우의 인덱스벡터는 반드시 @{1, 2, @dots{}, @code{length(x)}@} 범위내에 있어야 합니다.
인덱스벡터에 @emph{주어진 순서}대로 선택된 뒤 묶여지게 됩니다. 
이로부터 나온 결과의 벡터는 인덱스 벡터의 길이와 동일하며, 인덱스 벡터의 길이에 대한 선택은 임의적입니다. 
예를 들어, @code{x[6]}는 @code{x}의 여섯번째 구성요소를 나타내며, 다음과 같이 사용하는 것은 만약 @code{x}의 길이가 10보다 작지만 않다면, @code{x}가 가진 구성요소중 처음 10개의 요소들을 선택하게 됩니다. 

@example
> x[1:10]
@end example

@noindent
@c selects the first 10 elements of @code{x} (assuming @code{length(x)} is
@c not less than 10).  Also

또한, 아래와 같이 사용하는 것 (거의 이렇게 사용하는 적은 없지만)은  @code{"x", "y", "y", "x"}가 4번씩 반복되어 구성되어진 총 길이가 16인 문자형 벡터를 생성하게 됩니다. 

@example
> c("x","y")[rep(c(1,2,2,1), times=4)]
@end example

@noindent
@c (an admittedly unlikely thing to do) produces a character vector of
@c length 16 consisting of @code{"x", "y", "y", "x"} repeated four times.

@item
@c @strong{A vector of negative integral quantities}.  Such an index vector
@c specifies the values to be @emph{excluded} rather than included.  Thus
@strong{음의 값만을 가지는 벡터}.  이 경우의 인덱스 벡터는 선택된 요소들을 포함하기 보다는 @emph{제외}라는 목적으로 사용됩니다. 
따라서, 아래와 같이 사용하는 것은 @code{x}의 처음 5개의 요소들이 제외된 @code{x}의 벡터를 @code{y}에 대입하라는 의미가 됩니다. 

@example
> y <- x[-(1:5)]
@end example

@noindent
@c gives @code{y} all but the first five elements of @code{x}.

@item
@c @strong{A vector of character strings}.  This possibility only applies
@c where an object has a @code{names} attribute to identify its components.
@c In this case a sub-vector of the names vector may be used in the same way
@c as the positive integral labels in item 2 further above.
@strong{문자열 벡터}. 이 경우는 객체의 각 구성요소들이 @code{names}라는 속성을 가지고 있을 때에만 이용이 가능합니다. 
이때, @code{names}를 한 데 묶어 나열한 벡터를 네임벡터 (names vector)하며, 위에서 설명한 바 있는 양의 값만을 가지는 인덱스 벡터와 동일한 방식으로 작동하게 됩니다.
다음의 예제를 살펴보면, @code{fruit}이라는 수치형 벡터에 @code{names()} 라는 함수를 이용하여 각각의 구성요소에 @code{"orange", "banana", "apple", "peach"}라는 @code{names} 속성을 부여했습니다.
만약, @code{fruit} 벡터의 세번째와 첫번째 요소를 선택하고자 할 때, @code{[c("apple","orange")]}라고 하면 됩니다.
  
@example
> fruit <- c(5, 10, 1, 20)
> names(fruit) <- c("orange", "banana", "apple", "peach")
> lunch <- fruit[c("apple","orange")]
@end example

@c The advantage is that alphanumeric @emph{names} are often easier to
@c remember than @emph{numeric indices}.  This option is particularly
@c useful in connection with data frames, as we shall see later.

이렇게 @emph{names}속성을 이용하는 것은 @emph{수치형 인덱스}를 이용하여 그 구성요소들을 찾아내는 것보다 종종 편리한 경우가 있습니다. 
이 옵션은 추후에 보게될 데이터 프레임과 연관이 있습니다. 
@end enumerate

@c An indexed expression can also appear on the receiving end of an
@c assignment, in which case the assignment operation is performed
@c @emph{only on those elements of the vector}.  The expression must be of
@c the form @code{vector[@var{index_vector}]} as having an arbitrary
@c expression in place of the vector name does not make much sense here.

인덱스를 활용한 표현식은 또한 벡터의 결과를 할당을 받게 되는 대입문의 마지막에 나타나기도 합니다. 
이 경우는 주로 대입문이 사용되는 벡터의 그 자신에게 적용됩니다. 
아래의 예제는 @code{x}에 결측값이 있는 위치를 확인하여 이 위치에 해당하는 @code{x}의 값들 (즉, 결측값)을 0으로 대체하는 방법을 알려줍니다. 
@c For example

@example
> x[is.na(x)] <- 0
@end example

@noindent
@c replaces any missing values in @code{x} by zeros and

아래의 예제를 살펴보면 @code{y}의 값들중 0 보다 작은 값들의 위치를 찾아 이 위치에 상응하는 @code{y}의 값의 부호를 바꾸어줍니다.
@example
> y[y < 0] <- -y[y < 0]
@end example

@noindent
@c has the same effect as
결과적으로 위의 예제는 아래와 같은 명령문을 수행한 것과 동일합니다. 

@example
> y <- abs(y)
@end example

@node Other types of objects,  , Index vectors, Simple manipulations numbers and vectors
@section Other types of objects

@c Vectors are the most important type of object in @R{}, but there are
@c several others which we will meet more formally in later sections.

벡터는 @R{}에서 가장 중요한 객체입니다. 
다음은 앞으로 다루게 될 다른 형태들의 객체들에 대한 간략한 설명입니다. 그러나, 이들은 모두 벡터를 기반으로 하는 것입니다. 

@itemize @bullet
@item
@c @emph{matrices} or more generally @emph{arrays} are multi-dimensional
@c generalizations of vectors.  In fact, they @emph{are} vectors that can
@c be indexed by two or more indices and will be printed in special ways.
@c @xref{Arrays and matrices}.

@emph{matrices}(행렬) 또는 좀 더 일반적으로 @emph{arrays} (배열)이라는 것은 1차원적인 벡터를 다차원에 일반화 시킨 것입니다.
사실은 행렬과 배열 @emph{모두} 단순히 두개 또는 그 이상의 인덱스를 이용하여 특정한 방법으로 표현되도록 한 벡터입니다.
@xref{Arrays and matrices}.

@item
@c @emph{factors} provide compact ways to handle categorical data.
@c @xref{Factors}.

@emph{factors}(요인)은 카테고리컬 데이터 (categorical data)를 처리하는 편리한 방법을 제공합니다.
@xref{Factors}. 

@item
@c @emph{lists} are a general form of vector in which the various elements
@c need not be of the same type, and are often themselves vectors or lists.
@c Lists provide a convenient way to return the results of a statistical
@c computation.  @xref{Lists}.

@emph{lists}는 가장 일반적인 형태의 벡터로서 각 구성요소들이 같은 데이터형을 가지고 있어야 한다는 제약이 없으며, 이들 자체가 벡터 또는 리스트이기도 합니다. 
리스트는 통계연산의 결과를 반환할 때 매우 편리한 방법을 제공해주니다.
@xref{Lists}.

@item
@c @emph{data frames} are matrix-like structures, in which the columns can
@c be of different types.  Think of data frames as `data matrices' with one
@c row per observational unit but with (possibly) both numerical and
@c categorical variables.  Many experiments are best described by data
@c frames: the treatments are categorical but the response is numeric.
@c @xref{Data frames}.

@emph{data frames}은 행렬과 같은 구조를 가지고 있는데 각각의 열들은 다른 데이터형을 가질 있습니다. 
데이터 프레임을 각 행들이 하나의 관측단위이며 열들은 이 관측단위로부터 얻어진 연속형과 이산형 변수들에 대한 값을 가지고 있는 `데이터 행렬'로 생각해도 무방합니다. 
예를들어, 실험의 종류 및 방법들을 이산형으로 정리하고, 이에 해당하는 결과들은 연속형으로서 데이터 프레임내에 잘 정리될 수 있습니다. 
@xref{Data frames}.

@item
@c @emph{functions} are themselves objects in @R{} which can be stored in
@c the project's workspace.  This provides a simple and convenient way to
@c extend @R{}.  @xref{Writing your own functions}.
@R{}에서 @emph{functions}(함수)는 그 자신이 프로젝트의 작업공간내에 저장이 될 수 있는 객체입니다.
이것은 @R{}을 확장하는데 매우 간편한 방법을 제공합니다. 
@xref{Writing your own functions}.
@end itemize

@node Objects, Factors, Simple manipulations numbers and vectors, Top
@chapter Objects, their modes and attributes
@cindex Objects
@cindex Attributes

@c <FIXME>
@c This needs to be re-written for R.  We really have data types (as
@c returned by typeof()) and that functions mode() and storage.mode()
@c are for S compatibility mostly.  Hence in particular, there is no
@c intrinsic attribute `mode'.

@menu
* The intrinsic attributes mode and length::  
* Changing the length of an object::  
* Getting and setting attributes::  
* The class of an object::      
@end menu

@node The intrinsic attributes mode and length, Changing the length of an object, Objects, Objects
@section Intrinsic attributes: mode and length

@c The entities @R{} operates on are technically known as @emph{objects}.
@c Examples are vectors of numeric (real) or complex values, vectors of
@c logical values and vectors of character strings.  These are known as
@c ``atomic'' structures since their components are all of the same type,
@c or @emph{mode}, namely @emph{numeric}@footnote{@emph{numeric} mode is
@c actually an amalgam of two distinct modes, namely @emph{integer} and
@c @emph{double} precision, as explained in the manual.}, @emph{complex},
@c @emph{logical}, @emph{character} and @emph{raw}.

전문적으로 말해보자면 @R{}에서 정보처리 (연산 및 수행)의 기본단위는 @emph{objects}(객체)라고 알려진 것입니다.
이러한 객체들에 가장 간단한 예는 (실수) 수치형 및 복소수형 벡터, 논리형 또는 문자열 벡터등과 같은 벡터입니다.
이들은 ``atomic'' 구조로서 알려져 있습니다. 
왜냐하면 이들 벡터들에 대한 구성요소는 반드시 같은 타입 또는 @emph{numeric} 
@footnote{@emph{numeric}(수치형) 모드라는 것은 실제로는 @emph{integer}(정수형)과 @emph{double} precision (배정밀도)라는 두가지의 다른 모드가 합쳐진 것입니다}, @emph{complex}, @emph{logical}, @emph{character}, 그리고 @emph{raw}와 같은 @emph{mode}(모드)를 가지고 있기 때문입니다. 

@c Vectors must have their values @emph{all of the same mode}.  Thus any
@c given vector must be unambiguously either @emph{logical},
@c @emph{numeric}, @emph{complex}, @emph{character} or @emph{raw}.  (The
@c only apparent exception to this rule is the special ``value'' listed as
@c @code{NA} for quantities not available, but in fact there are several
@c types of @code{NA}).  Note that a vector can be empty and still have a
@c mode.  For example the empty character string vector is listed as
@c @code{character(0)} and the empty numeric vector as @code{numeric(0)}.

벡터는 반드시 @emph{각 구성요소가 가질 수 있는 값에 대한 모드가 모든 구성요소에 있어서 같아야 합니다}.
그러므로 어떠한 벡터라도 반드시 @emph{logical}(논리형), @emph{numeric}(수치형), @emph{complex}(복소수형), @emph{character}(문자형) or @emph{raw} 모드 중 하나입니다.
(이 규칙에 대한 예외가 있다면 그것은 @code{NA}로 표기되는 값입니다. 
그러나, 사실은 여러가지 종류의 @code{NA}가 있습니다).
벡터는 empty(아무런 구성요소가 없이 비어있는 상태)일 수 있음에도 불구하고 모드를 가질 수 있습니다. 
예를들어, 비어있는 문자열은 @code{character(0)}이며, 비어있는 수치형 벡터는 @code{numeric(0)}입니다. 

@c @R{} also operates on objects called @emph{lists}, which are of mode
@c @emph{list}.  These are ordered sequences of objects which individually
@c can be of any mode.  @emph{lists} are known as ``recursive'' rather than
@c atomic structures since their components can themselves be lists in
@c their own right.

@R{}은 또한 @emph{list}(리스트)라는 모드를 가지고 있는 @emph{lists}(리스트)라고 불리는 객체를 특정한 방식으로 조작하고 있습니다. 
이것은 모든 구성요소가 동일한 모드를 가지지 않는 일련의 순서에 의해서 정리된 시퀀스입니다.
@emph{lists}(리스트)는 또한 atomic structure (가장 근본적인 기본구조)이기 보다는 ``recursive''(재귀적) 구조를 가집니다.
그 이유는 이 객체의 구성요소 자체가 리스트가 될 수 있기 때문입니다. 

@c The other recursive structures are those of mode @emph{function} and
@c @emph{expression}.  Functions are the objects that form part of the @R{}
@c system along with similar user written functions, which we discuss in
@c some detail later.  Expressions as objects form an
@c advanced part of @R{} which will not be discussed in this guide, except
@c indirectly when we discuss @emph{formulae} used with modeling in @R{}.

또 다른 재귀적 구조는 모드가 @emph{function}(함수) 또는 @emph{expression}(표현식)으로부터 찾을 수 있습니다.
함수의 경우는 나중에 설명하게 될 사용자 정의 함수와 함께 @R{}시스템의 부분을 구성하는 객체이기 때문이며,
표현식의 경우는 @R{}에서 모델링을 할때 사용하는 @emph{formulae}(모델식)을 언급하면서 간접적으로 얘기할 때를 제외하고는 이 문서에서는 설명하지 않지만 이 또한 @R{}시스템의 고급적 부분을 형성하는 객체이기 때문입니다.

@c By the @emph{mode} of an object we mean the basic type of its
@c fundamental constituents.  This is a special case of a ``property''
@c of an object.  Another property of every object is its @emph{length}.  The
@c functions @code{mode(@var{object})} and @code{length(@var{object})} can be
@c used to find out the mode and length of any defined structure
@c @footnote{Note however that @code{length(@var{object})} does not always
@c contain intrinsic useful information, e.g., when @code{@var{object}} is a
@c function.}.
객체의 @emph{mode}(모드)는 우리가 다루는 객체를 구성하는 요소들에 대한 기본형(basic type)을 알 수 있습니다.
모든 객체에 있는 또 다른 속성은 @emph{length}(길이)입니다. 
@code{mode(@var{object})}와 @code{mode(@var{object})}라는 명령어를 통하여 객체에 정의된 구조의 모드와 길이를 알 수 있습니다. 
@footnote{그러나, @code{length(@var{object})}가 항상 본질적인 정보를 포함하는 것은 아닙니다.  @code{@var{object}}의 경우가 이에 해당합니다.}.


@c Further properties of an object are usually provided by
@c @code{attributes(@var{object})}, see @ref{Getting and setting attributes}.
@c Because of this, @emph{mode} and @emph{length} are also called ``intrinsic
@c attributes'' of an object.
객체에 대한 더 많은 속성들은 @code{attributes(@var{object})}를 통해서 알 있으며, @ref{Getting and setting attributes}를 참고하시길 바랍니다.
이러한 이유로 @emph{mode}(모드)와 @emph{length}(길이)는 객체의 ``intrinsic attributes''(본질적 속성들)이라고도 합니다.
@findex mode
@findex length

@c For example, if @code{z} is a complex vector of length 100, then in an
@c expression @code{mode(z)} is the character string @code{"complex"} and
@c @code{length(z)} is @code{100}.

예를들어, 만약 @code{z}가 길이가 100인 복소수형 벡터라고 한다면, @code{mode(z)}는 문자열 @code{"complex"}(복소수)이고 @code{length(z)}은 @code{100}입니다.
@c @R{} caters for changes of mode almost anywhere it could be considered
@c sensible to do so, (and a few where it might not be).  For example with
@R{}은 어디에서든지 모드를 변경할 수 있도록 해줍니다. 
아래의 예제를 보도록 합니다.

@example
> z <- 0:9
@end example

@noindent
@c we could put
위에서 생성한 0 부터 9까지의 숫자로 된 수열 @code{z}는 아래와 같이 @code{c("0", "1", "2", @dots{}, "9")}와 문자로 된 벡터로 변환할 수 있습니다.
 
@example
> digits <- as.character(z)
@end example

@noindent
@c after which @code{digits} is the character vector @code{c("0", "1", "2",
@c @dots{}, "9")}.  A further @emph{coercion}, or change of mode,
@c reconstructs the numerical vector again:
수치형 벡터로의 @emph{coercion}(강제형변환) 또는 모드의 변환은 아래에서 보이는 것과 같이 다시 한 번 이루어질 수 있습니다. 

@example
> d <- as.integer(digits)
@end example

@noindent
@c Now @code{d} and @code{z} are the same.@footnote{In general, coercion
@c from numeric to character and back again will not be exactly reversible,
@c because of roundoff errors in the character representation.}  There is a
@c large collection of functions of the form @code{as.@var{something}()}
@c for either coercion from one mode to another, or for investing an object
@c with some other attribute it may not already possess.  The reader should
@c consult the different help files to become familiar with them.

이제 @code{d}와 @code{z}는 동일한 벡터임을 확인하실 수 있을 것입니다.
@footnote{일반적으로 숫자에서 문자로의 강제형변환 한 뒤 다시 숫자로 변경할때에는 본래의 숫자와 완전히 똑같지 않습니다. 
그 이유는 문자로서 표현될때의 roundoff errors(반올림 오차)때문입니다.}  
이와 같이 형의 변환을 도와주는 강제형변환 기능은 @code{as.@var{something}} 형태의 함수로서 이루어지며, 
객체가 어떤 속성을 가지고 있는가 혹은 없는가에 확인하기 위한 방대한 양의 함수들이 제공되고 있습니다.
이러한 함수들의 사용에 익숙해지기 위해서는 도움말 파일을 참고하시길 부탁드립니다.

@c </FIXME>

@node Changing the length of an object, Getting and setting attributes, The intrinsic attributes mode and length, Objects
@section Changing the length of an object

@example
> e <- numeric()
@end example

@noindent
@c makes @code{e} an empty vector structure of mode numeric.  Similarly
@c @code{character()} is a empty character vector, and so on.  Once an
@c object of any size has been created, new components may be added to it
@c simply by giving it an index value outside its previous range.  Thus

위의 명령문은 @code{e}라는 수치형 모드를 가지며 아무런 구성요소도 가지지 않은 (즉, 비어있는) 벡터를 생성합니다.
유사한 방식으로 @code{character()}은 아무런 구성요소를 가지고 있는 문자형 벡터를 생성하는데 쓰입니다.
이렇게 하는 것은 임의의 크기를 가지는 객체를 생성하는데 쓰이며, 
새로운 구성요소는 아래와 같이 벡터가 원래 가지고 있던 인덱스의 범위 밖의 값을 넣어줌으로서 추가할 수 있습니다. 

@example
> e[3] <- 17
@end example

@noindent
@c now makes @code{e} a vector of length 3, (the first two components of
@c which are at this point both @code{NA}).  This applies to any structure
@c at all, provided the mode of the additional component(s) agrees with the
@c mode of the object in the first place.

이제 길이가 3인 @code{e}라는 벡터가 만들어진 것입니다 (처음 두개의 구성요소들은 @code{NA}가 될 것입니다). 
이러한 방식으로 구성요소를 추가하는 것은 새로 추가되는 구성요소의 모드가 존재하는 객체를 구성하는 객체의 모드와 일치만 한다면 어떠한 구조를 가진 객체에 모두 적용이 가능합니다. 

@c This automatic adjustment of lengths of an object is used often, for
@c example in the @code{scan()} function for input.  (@pxref{The scan()
@c function}.)

종종 자동적으로 객체의 길이가 조정될 때가 있습니다. 
예를들면, 입력을 받기 위한 @code{scan()}가 사용될 때입니다. 
(@pxref{The scan() function}.)

@c Conversely to truncate the size of an object requires only an assignment
@c to do so.  Hence if @code{alpha} is an object of length 10, then
이와는 반대로 객체의 크기를 줄이고자 한다면 단순히 대입문을 사용하면 됩니다.
예를들어, @code{alpha}가 길이가 10인 객체라고 가정합니다.
아래의 대입문은 @code{alpha}의 인덱스 벡터의 길이가 5인데, 이 벡터에 2를 곱하였으므로, @code{alpha}의 인덱스 벡터가 짝수에 해당하는 @code{alpha}의 구성요소들만 선택된 새로운 @code{alpha}를 생성하는 것입니다. 
 
@example
> alpha <- alpha[2 * 1:5]
@end example

@noindent
@c makes it an object of length 5 consisting of just the former components
@c with even index.  (The old indices are not retained, of course.)  We can
@c then retain just the first three values by
(물론 이전에 사용한 인덱스는 더 이상 유효하지 않습니다). 
벡터의 길이를 변경하여 처음 세가의 구성요소만을 가지는 @code{alpha}를 생성하고자 한다면 아래와 같은 방법을 사용할 수도 있습니다. 

@example
> length(alpha) <- 3
@end example

@noindent
@c and vectors can be extended (by missing values) in the same way.

@node Getting and setting attributes, The class of an object, Changing the length of an object, Objects
@section Getting and setting attributes
@findex attr
@findex attributes

@c The function @code{attributes(@var{object})}
@c @findex attributes
@c returns a list of all the non-intrinsic attributes currently defined for
@c that object.  The function @code{attr(@var{object}, @var{name})}
@c @findex attr
@c can be used to select a specific attribute.  These functions are rarely
@c used, except in rather special circumstances when some new attribute is
@c being created for some particular purpose, for example to associate a
@c creation date or an operator with an @R{} object.  The concept, however,
@c is very important.

함수 @code{attributes(@var{object})}는 현재 정의되어 있는 객체들의 모든 속성들의 목록을 보여줍니다.
@findex attributes
단, 이 속성들은 본질적으로 내재되어 있는 것들이 아닙니다.
함수 @code{attr(@var{object}, @var{name})}은 특정한 속성을 선택하는데 사용되어 집니다.
@findex attr
그러나, @R{}객체에 날짜 및 연산자의 결합과 같은 어떤 새로운 속성이 어떤 특정한 목적으로 생성되는 것과 같은 특별한 경우가 아니라면 이러한 함수들은 거의 사용되지 않습니다. 
그러나, 이 속성에 대한 개념은 매우 중요합니다.

@c Some care should be exercised when assigning or deleting attributes
@c since they are an integral part of the object system used in @R{}.

속성을 새로이 추가하거나 삭제할때는 사용의 주의가 매우 요구되어 집니다. 
그 이유는 @R{}에서 사용되는 객체 시스템의 주요한 부분이기 때문입니다.

@c When it is used on the left hand side of an assignment it can be used
@c either to associate a new attribute with @code{@var{object}} or to
@c change an existing one.  For example

대입문의 좌측에 @code{@var{object}}를 이용하여 새로운 속성을 연결하거나 존재하는 속성을 변경할 수 있습니다. 
다음의 예제는 @code{z}라는 벡터의 크기가 10행 10열이라는 행렬로 다루라는 의미입니다.

@example
> attr(z, "dim") <- c(10,10)
@end example

@noindent
@c allows @R{} to treat @code{z} as if it were a 10-by-10 matrix.

@node The class of an object,  , Getting and setting attributes, Objects
@section The class of an object
@cindex Classes

@c All objects in @R{} have a @emph{class}, reported by the function
@c @code{class}.  For simple vectors this is just the mode, for example
@c @code{"numeric"}, @code{"logical"}, @code{"character"} or @code{"list"},
@c but @code{"matrix"}, @code{"array"}, @code{"factor"} and
@c @code{"data.frame"} are other possible values.

@R{}에 존재하는 모든 객체들은 @emph{class}(클래스)라는 것을 가집니다.
이는 함수 @code{class}의 사용으로 확인할 수 있습니다.
간단한 벡터의 예를 들어보면, @code{"numeric"}, @code{"logical"}, @code{"character"} 또는 @code{"list"}와 같이 이것은 단순하게 벡터의 모드라는 것을 알 수 있습니다.
그러나, @code{"matrix"}, @code{"array"}, @code{"factor"} 그리고 @code{"data.frame"}는 다른 값들을 가집니다.

@c A special attribute known as the @emph{class} of the object is used to
@c allow for an object-oriented style@footnote{A different style using
@c `formal' or `S4' classes is provided in package @code{methods}.} of
@c programming in @R{}.  For example if an object has class
@c @code{"data.frame"}, it will be printed in a certain way, the
@c @code{plot()} function will display it graphically in a certain way, and
@c other so-called generic functions such as @code{summary()} will react to
@c it as an argument in a way sensitive to its class.

객체의 @emph{class}(클래스)로서 알려진 특별한 속성은 @R{}의 object-oriented style (객체지향스타일) 프로그래밍에서 사용됩니다 @footnote{`formal' 또는 `S4' 클래스들을 사용하는 다른 종류의 스타일들은 패키지 @code{methods}내에서 제공되어지고 있습니다.}.
예를들면, 만약 객체가 @code{"data.frame"}를 가진다고 할때, 
이 객체에 @code{plot()} 함수의 이용은 이 객체는 @code{plot()}내에 미리 정해져 있는 특정한 방식대로 데이터를 불러와 해당 클래스에 정의되어 있는대로 시각화처리를 하게 됩니다. 
또한, 일명 @code{summary()}라고 불리는 제네릭 함수가 사용될 때 객체가 가지고 있는 클래스를 인자의 형태로 받아, 이에 따라 정의되어 있는대로 결과물에 대한 요약을 보여주게 됩니다. 

@c To remove temporarily the effects of class, use the function
@c @code{unclass()}.
@findex unclass
@c For example if @code{winter} has the class @code{"data.frame"} then

클래스의 미치는 영향을 일시적으로 제거하기 위해서는 @code{unclass()}라는 함수를 사용하면 됩니다.
예를들어 만약 @code{winter}라는 객체가 클래스 @code{"data.frame"}(데이터 프레임)을 가지고 있다면, 아래의 명령문은 행렬처럼 보이기 보다는 데이터 프레임의 형식에 맞춰 결과를 보여주게 됩니다. 
@example
> winter
@end example

@noindent
@c will print it in data frame form, which is rather like a matrix, whereas
반면에 아래와 같은 명령문을 수행하게 된다면 본래 가지고 있던 리스트의 형식으로 출력되게 됩니다.
@example
> unclass(winter)
@end example

@noindent
@c will print it as an ordinary list.  Only in rather special situations do
@c you need to use this facility, but one is when you are learning to come
@c to terms with the idea of class and generic functions.

이러한 클래스의 활용은 매우 특수한 경우에 사용할 수 있으나, 지금은 단순히 클래스와 제네릭 함수의 개념에만 익숙해지시면 됩니다.

@c Generic functions and classes will be discussed further in @ref{Object
@c orientation}, but only briefly.
이것들에 대해서 @ref{Object orientation}에서 더 자세히 살펴보게 되겠지만, 여기에서는 간단히 마치도록 합니다.

@node Factors, Arrays and matrices, Objects, Top
@chapter Ordered and unordered factors
@cindex Factors
@cindex Ordered factors

@c A @emph{factor} is a vector object used to specify a discrete
@c classification (grouping) of the components of other vectors of the same length.
@c @R{} provides both @emph{ordered} and @emph{unordered} factors.
@c While the ``real'' application of factors is with model formulae
@c (@pxref{Contrasts}), we here look at a specific example.

@emph{factor}(요인)은 같은 길이를 가지고 있는 다른 벡터들의 구성요소들을 이산형 클래시피케이션 또는 그룹핑을 하는데 쓰이는 벡터형 객체입니다.
@R{}은 @emph{ordered}(순위형)과 @emph{unordered}(비순위형) 두가지 종류의 요인을 제공하고 있습니다.
요인을 활용하는 실 응용예제는 @pxref{Contrasts}에서 설명하는 model formulae(모델식)을 통해 알수 있지만, 여기에서는 특수한 예제를 통해서 요인이 무엇인지 이해하는데 중점을 둡니다.

@section A specific example

@c Suppose, for example, we have a sample of 30 tax accountants from all
@c the states and territories of Australia@footnote{Readers should note
@c that there are eight states and territories in Australia, namely the
@c Australian Capital Territory, New South Wales, the Northern Territory,
@c Queensland, South Australia, Tasmania, Victoria and Western Australia.}
@c and their individual state of origin is specified by a character vector
@c of state mnemonics as

예를들어, Australia(오스트레일리아, 호주)의 모든 지역@footnote{호주에는 Australian Capital Territory, New South Wales, the Northern Territory, Queensland, South Australia, Tasmania, Victoria and Western Australia 이라는 총 8개의 주와 영토가 있다는 점을 알면 도움이 될 것입니다.}에 있는 30명의 회계사들에 대한 정보를 가지고 있는 샘플이 있다고 가정합니다. 
그리고, 그들의 근무지에 대한 정보가 @code{state}에 문자형 벡터의 형식으로 다음과 같이 입력되어 있습니다.


@example
> state <- c("tas", "sa",  "qld", "nsw", "nsw", "nt",  "wa",  "wa",
             "qld", "vic", "nsw", "vic", "qld", "qld", "sa",  "tas",
             "sa",  "nt",  "wa",  "vic", "qld", "nsw", "nsw", "wa",
             "sa",  "act", "nsw", "vic", "vic", "act")
@end example

@c Notice that in the case of a character vector, ``sorted'' means sorted
@c in alphabetical order.

문자형 벡터의 경우에는 ``sorted''(정렬)이라는 것은 알파벳순서로 나열하는 것을 의미합니다.

@c A @emph{factor} is similarly created using the @code{factor()} function:
@emph{factor}(요인)는 @code{factor()}함수를 이용하여 생성하게 됩니다.

@findex factor

@example
> statef <- factor(state)
@end example

@c The @code{print()} function handles factors slightly differently from
@c other objects:

@code{print()}함수는 아래와 같이 요인의 구성요소들을 다른 객체들과는 다소 다른 방식으로 출력하여 보여줍니다.

@example
> statef
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa
[16] tas sa  nt  wa  vic qld nsw nsw wa  sa  act nsw vic vic act
Levels:  act nsw nt qld sa tas vic wa
@end example

@c To find out the levels of a factor the function @code{levels()} can be
@c used.
요인의 수준(levels)를 알기 위해서는 함수 @code{levels()}를 아래와 같은 방법으로 사용합니다.
@findex levels

@example
> levels(statef)
[1] "act" "nsw" "nt"  "qld" "sa"  "tas" "vic" "wa"
@end example

@menu
* The function tapply() and ragged arrays::  
* Ordered factors::             
@end menu

@node The function tapply() and ragged arrays, Ordered factors, Factors, Factors
@section The function @code{tapply()} and ragged arrays
@findex tapply

@c To continue the previous example, suppose we have the incomes of the
@c same tax accountants in another vector (in suitably large units of
@c money)

이전에 사용된 예제를 계속 이용해봅니다.
그리고, 이제는 동일한 회계사의 수입(income)에 대한 정보가 아래와 같은 다른 벡터에 저장되어 있다고 가정합니다.

@example
> incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,
               61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,
               59, 46, 58, 43)
@end example

@c To calculate the sample mean income for each state we can now use the
@c special function @code{tapply()}:

각 근무지별 평균소득을 계산을 하고 싶다면 @code{tapply()}를 아래와 같이 이용하면 됩니다.

@example
> incmeans <- tapply(incomes, statef, mean)
@end example

@noindent
@c giving a means vector with the components labelled by the levels

위 명령어의 결과는 아래와 같이 수준(levels)별로 그 평균값을 보여주게 됩니다.

@example
   act    nsw     nt    qld     sa    tas    vic     wa
44.500 57.333 55.500 53.600 55.000 60.500 56.000 52.250
@end example

@c The function @code{tapply()} is used to apply a function, here
@c @code{mean()}, to each group of components of the first argument, here
@c @code{incomes}, defined by the levels of the second component, here
@c @code{statef}@footnote{Note that @code{tapply()} also works in this case
@c when its second argument is not a factor, e.g.,
@c @samp{@code{tapply(incomes, state)}}, and this is true for quite a few
@c other functions, since arguments are @emph{coerced} to factors when
@c necessary (using @code{as.factor()}).}, as if they were separate vector
@c structures.  The result is a structure of the same length as the levels
@c attribute of the factor containing the results.  The reader should
@c consult the help document for more details.

함수 @code{tapply()}는 첫번째 인자에 30명의 회계사들의 소득을 포함하고 있는 @code{incomes} 이라는 벡터를 불러들이고, 두번째 인자는 회계사들의 근무지가 어디에 속하는지에 대한 정보가 있는 @code{statef}가 이용되며, 마지막으로 세번째 인자는 각 근무지별로 분류된 데이터에 평균을 산출해 내는 @code{mean}이라는 함수명이 사용되었습니다
@footnote{@samp{@code{tapply(incomes, state)}}와 같이 @code{tapply()}의 두번째 인자가 꼭 요인(factor)이 아니어도 괜찮습니다.
그 이유는 인자는 필요에 의하여 @code{as.factor()}를 이용하여 강제형변환 @emph{coerced}이 내부적으로 수행되기 때문입니다}
따라서, 생성된 벡터의 길이는 반드시 요인의 수준들의 개수와 같아야 합니다.
더 자세한 사항들에 대해서는 도움말을 참고하시길 바랍니다.

@c Suppose further we needed to calculate the standard errors of the state
@c income means.  To do this we need to write an @R{} function to calculate
@c the standard error for any given vector.  Since there is an builtin
@c function @code{var()} to calculate the sample variance, such a function
@c is a very simple one liner, specified by the assignment:

아마도 독자는 평균소득에 대한 표준오차(standard error)를 알고 싶을 수도 있습니다.
이것을 하기 위해서 우리는 아래와 같이 표준오차를 계산하는 @R{}함수를 작성하였습니다.
@code{var()}는 샘플의 분산을 계산해주는 빌트인 함수이기 때문에, 아래와 같이 한줄로 표시가 가능합니다.
 
@example
> stderr <- function(x) sqrt(var(x)/length(x))
@end example

@noindent
@c (Writing functions will be considered later in @ref{Writing your own
@c functions}, and in this case was unnecessary as @R{} also has a builtin
@c function @code{sd()}.)
(함수를 작성하는 방법에 대해서는 추후에 @ref{Writing your own functions}에서 다룰 것입니다. 
또한, 이러한 함수를 작성하는 것은 다소 무의미합니다.
그 이유는 @R{}은 또한 @code{sd()}를 제공하기 때문입니다).
@findex sd
@findex var
@c After this assignment, the standard errors are calculated by
위의 대입문을 수행한 뒤에 표준오차는는 아래와 같은 방법으로 계산되어 집니다.

@example
> incster <- tapply(incomes, statef, stderr)
@end example

@noindent
@c and the values calculated are then
그리고, 아래와 같이 보여지게 됩니다.

@example
> incster
act    nsw  nt    qld     sa tas   vic     wa
1.5 4.3102 4.5 4.1061 2.7386 0.5 5.244 2.6575
@end example

@c As an exercise you may care to find the usual 95% confidence limits for
@c the state mean incomes.  To do this you could use @code{tapply()} once
@c more with the @code{length()} function to find the sample sizes, and the
@c @code{qt()} function to find the percentage points of the appropriate
@c @math{t}-distributions.  (You could also investigate @R{}'s facilities
@c for @math{t}-tests.)

연습삼아서 평균소득에 대한 95% 신뢰구간을 찾고자 하시는 독자도 있을 것입니다.
이것을 하기 위해서는 아마도 @code{tapply()}, @code{length()}, @code{qt()}라는 함수들이 필요한데,
@code{length()}는 샘플 사이즈를, @code{qt()}는 t-분포에서 95% 에 해당하는 계수 를 찾아 줄 것입니다.
(@R{}에서 제공하는 @math{t}-테스트 기능을 이용할 수도 있습니다).

@c The function @code{tapply()} can also be used to handle more complicated
@c indexing of a vector by multiple categories.  For example, we might wish
@c to split the tax accountants by both state and sex.  However in this
@c simple instance (just one factor) what happens can be thought of as
@c follows.  The values in the vector are collected into groups
@c corresponding to the distinct entries in the factor.  The function is
@c then applied to each of these groups individually.  The value is a
@c vector of function results, labelled by the @code{levels} attribute of
@c the factor.

위의 예제에서 살펴 본 @code{tapply()}는 다소 복잡한 구조를 가지는 그룹핑 벡터에도 유용하게 사용될 수 있습니다.
예를들어, 회계사의 평균 소득을 근무지와 성별이라는 요인들에 따라서 분석을 해 본다고 가정해 봅니다.
이것이 @code{tapply()}내에서 처리되는 방법은 다음과 같습니다.
먼저, 요인의 수준들에 맞추어 데이터를 그룹화합니다. 
이렇게 그룹화된 데이터에 함수가 적용이 된 후, 최종결과물에 @code{levels} 속성을 라벨링 해주는 것입니다.

@c The combination of a vector and a labelling factor is an example of what
@c is sometimes called a @emph{ragged array}, since the subclass sizes are
@c possibly irregular.  When the subclass sizes are all the same the
@c indexing may be done implicitly and much more efficiently, as we see in
@c the next section.

벡터와 요인의 값들에 대한 라벨링을 조합하는 것은 @emph{ragged array}(레그드 어레이)라고도 불리는 하나의 예제입니다.
그 이윤는 각 그룹내의 데이터 개수가 동일하지 않기 때문입니다.
만약, 각 그룹의 사이즈가 동일하다면 우리가 다음섹션에서 살펴보게 될 것과 같이 훨씬 효율적으로 다루어질 수 있습니다.

@node Ordered factors,  , The function tapply() and ragged arrays, Factors
@section Ordered factors
@findex ordered

@c The levels of factors are stored in alphabetical order, or in the order
@c they were specified to @code{factor} if they were specified explicitly.

요인(factor)에 대한 수준(levels)들은 기본적으로 알파벳순서로 저장이 되지만, @code{factor}를 이용하여 사용자가 그 순서를 지정할 수도 있습니다.

@c Sometimes the levels will have a natural ordering that we want to record
@c and want our statistical analysis to make use of.  The @code{ordered()}
@findex ordered
@c function creates such ordered factors but is otherwise identical to
@c @code{factor}.  For most purposes the only difference between ordered
@c and unordered factors is that the former are printed showing the
@c ordering of the levels, but the contrasts generated for them in fitting
@c linear models are different.
어떤 경우에는 레벨들이 우리가 원하고자 했던 대로 이미 기록이 되어 있거나, 통계분석시 필요로 하는 데이터 형태를 미리 가지고 있을 수도 있습니다. 
@code{ordered()}라는 함수는 순위형 요인들을 생성하는 것외에는 @code{factor}와 다른 점은 없습니다.
순위형과 비순위형의 다른점이라고 한다면 순위형은 레벨의 정렬된 순서대로 출력을 하게 되지만, 이로부터 적합된 선형모델을 이용하여 contrasts(대조)를 할 경우에는 다른 결과값을 산출한다는 점에서 주의를 해야합니다.


@node Arrays and matrices, Lists and data frames, Factors, Top
@chapter Arrays and matrices

@menu
* Arrays::                      
* Array indexing::              
* Index matrices::              
* The array() function::        
* The outer product of two arrays::  
* Generalized transpose of an array::  
* Matrix facilities::           
* Forming partitioned matrices::  
* The concatenation function c() with arrays::  
* Frequency tables from factors::  
@end menu

@node Arrays, Array indexing, Arrays and matrices, Arrays and matrices
@section Arrays
@cindex Arrays
@cindex Matrices

@c An array can be considered as a multiply subscripted collection of data
@c entries, for example numeric.  @R{} allows simple facilities for
@c creating and handling arrays, and in particular the special case of
@c matrices.

배열(array)은 데이터 엔트리 (data entries)를 다차원 인덱스를 이용하여 표현해 낸 구조라고 생각할 수 있습니다. 
@R{}은 이러한 배열들을 생성하고 다룰 수 있는 간편한 기능들을 제공합니다.
행렬은 배열의 특수한 예입니다.

@c A dimension vector is a vector of non-negative integers.  If its length is
@c @math{k} then the array is @math{k}-dimensional, e.g.@ a matrix is a
@c @math{2}-dimensional array.  The dimensions are indexed from one up to
@c the values given in the dimension vector.

차원벡터는 음수가 아닌 정수들로 이루어진 벡터입니다. 
만약, 길이가 @math{k}라면, @math{k}-차원을 가지는 배열입니다.
즉, 행렬은 @math{2}-차원 배열입니다. 
각 차원의 인덱스는 1부터 차원벡터에 주어져 있는 값들까지 가질 수 있습니다. 

@c A vector can be used by @R{} as an array only if it has a dimension
@c vector as its @emph{dim} attribute.  Suppose, for example, @code{z} is a
@c vector of 1500 elements.  The assignment

벡터는 @R{}에서 배열의 차원을 알려주는 @emph{dim}이라는 속성이 1인 특수한 경우에 해당합니다.
예를들어, @code{z}는 1500개의 구성요소를 가지는 벡터를 생각해 봅니다.

@example
> dim(z) <- c(3,5,100)
@end example
@findex dim

@noindent
@c gives it the @emph{dim} attribute that allows it to be treated as a
@c @math{3} by @math{5} by @math{100} array.

위의 대입문은 @emph{dim}이라는 속성에 의해서 길이가 3이므로 3차원 데이터 구조를 가지는데, 각 차원은 @math{3}, @math{5}, @math{100}의 인덱스를 가지고 있다는 것을 의미합니다. 

@c Other functions such as @code{matrix()} and @code{array()} are available
@c for simpler and more natural looking assignments, as we shall see in
@c @ref{The array() function}.

@code{matrix()}와 @code{array()}와 같이 보다 더 간편하고 자연스러운 대입을 가능하게 하는 함수들이 제공됩니다.
@ref{The array() function}를 살펴보시길 바랍니다.

@c The values in the data vector give the values in the array in the same
@c order as they would occur in FORTRAN, that is ``column major order,''
@c with the first subscript moving fastest and the last subscript slowest.

데이터 벡터에 있는 값들이 배열에 나열될때는 FORTRAN 프로그램에서 사용되는 것과 같은 ``column major order''이 이용됩니다.
다시 말해서, 차원벡터의 첫번째 인덱스가 제일 빠르게 업데이트 되고, 마지막 인덱스가 제일 나중에 업데이트 됩니다.

@c For example if the dimension vector for an array, say @code{a}, is
@c @code{c(3,4,2)} then there are @eqn{3 \times 4 \times 2 = 24, 3 * 4 * 2
@c = 24} entries in @code{a} and the data vector holds them in the order
@c @code{a[1,1,1], a[2,1,1], @dots{}, a[2,4,2], a[3,4,2]}.

예를들면, 만약 배열에 있는 @code{a}라는 차원벡터가 @code{c(3,4,2)}라면, @code{a}에는 총 @eqn{3 \times 4 \times 2 = 24, 3 * 4 * 2 = 24}의 데이터 엔트리들이 있을 것입니다. 
그리고, 데이터 벡터는 @code{a[1,1,1], a[2,1,1], @dots{}, a[2,4,2], a[3,4,2]}의 순서로 이들을 기억하는 것입니다.


@c Arrays can be one-dimensional: such arrays are usually treated in the
@c same way as vectors (including when printing), but the exceptions can
@c cause confusion.

배열은 1차원일 수 있는데, 이들은 벡터와 같이 사용이 되기도 합니다.  그러나, 예외의 경우 사용의 혼란을 가져올 수 있습니다.

@node Array indexing, Index matrices, Arrays, Arrays and matrices
@section Array indexing.  Subsections of an array
@cindex Indexing of and by arrays

@c Individual elements of an array may be referenced by giving the name of
@c the array followed by the subscripts in square brackets, separated by
@c commas.

배열의 각 구성요소들은 배열의 이름 바로뒤에 컴마로 구분된 인덱스 벡터를 포함하는 대괄호를 이용하여 표현할 수 있습니다.

@c More generally, subsections of an array may be specified by giving a
@c sequence of @emph{index vectors} in place of subscripts; however
@c @emph{if any index position is given an empty index vector, then the
@c full range of that subscript is taken}.

보다 일반적으로, 배열의 일부분들은 @emph{index vectors}(인덱스 벡터)에 의해서 표현될 수 있습니다. 
그런데, 만약 인덱스 벡터내 특정 위치이 비어있다면, 이것은 해당 첨자에 해당하는 모든 값들을 의미합니다.

@c Continuing the previous example, @code{a[2,,]} is a @eqn{4 \times 2, 4 *
@c 2} array with dimension vector @code{c(4,2)} and data vector containing
@c the values

위에서 사용한 예제를 다시 살펴보면 @code{a[2,,]}는 @code{c(4,2)} 차원벡터를 가지는 배열이며, 아래와 같은 값들을 가지고 있습니다.

@example
c(a[2,1,1], a[2,2,1], a[2,3,1], a[2,4,1],
  a[2,1,2], a[2,2,2], a[2,3,2], a[2,4,2])
@end example

@noindent
@c in that order.  @code{a[,,]} stands for the entire array, which is the
@c same as omitting the subscripts entirely and using @code{a} alone.

@code{a[,,]}은 @code{a} 배열 그자체를 의미합니다.

@c For any array, say @code{Z}, the dimension vector may be referenced
@c explicitly as @code{dim(Z)} (on either side of an assignment).

만약, @code{Z}라고 불리는 배열이 있다면 이 배열의 차원은 @code{dim(Z)}에 의해서 확인될 수 있습니다.

@c Also, if an array name is given with just @emph{one subscript or index
@c vector}, then the corresponding values of the data vector only are used;
@c in this case the dimension vector is ignored.  This is not the case,
@c however, if the single index is not a vector but itself an array, as we
@c next discuss.

또한, 만약 배열의 이름 뒤에 @emph{오로지 한개의 첨자 또는 인덱스 벡터}가 함께 주어지게 된다면 이에 상응하는 데이터 벡터가 사용되게 됩니다.
이러한 경우에는 차원벡터가 무시되는 것입니다.
그렇지 않고, 만약 인덱스가 배열의 형태로서 주어질 경우에 대해서는 다음 섹션에서 다룰 것입니다. 

@menu
* Index matrices::
* The array() function::
@end menu

@node Index matrices, The array() function, Array indexing, Arrays and matrices
@section Index matrices

@c As well as an index vector in any subscript position, a matrix may be
@c used with a single @emph{index matrix} in order either to assign a vector
@c of quantities to an irregular collection of elements in the array, or to
@c extract an irregular collection as a vector.

어느 첨자의 위치에 있는 인덱스 벡터외에도 배열내에 있는 불특정 위치에 있는 구성요소들에 새로운 값을 대입하거나 값을 추출할때 @emph{index matrix}(인덱스 행렬)을 사용할 수도 있습니다. 

A matrix example makes the process clear.  In the case of a doubly
indexed array, an index matrix may be given consisting of two columns
and as many rows as desired.  The entries in the index matrix are the
row and column indices for the doubly indexed array.  Suppose for
example we have a @math{4} by @math{5} array @code{X} and we wish to do
the following:

@c 아래의 행렬의 예제를 살펴본다면 이를 더욱 확실히 알수 있습니다.
@c 아래의 예제와 같이 배열의 크기가 @math{4} by @math{5}인 배열 @code{X}가 있다고 가정하고, 우리는 @code{X}에 대해서 다음과 같은 것을 수행하고 싶다고 합니다.

@itemize @bullet
@item
Extract elements @code{X[1,3]}, @code{X[2,2]} and @code{X[3,1]} as a
vector structure, and
@item
Replace these entries in the array @code{X} by zeroes.
@end itemize
In this case we need a @math{3} by @math{2} subscript array, as in the
following example.

@example
> x <- array(1:20, dim=c(4,5))   # 4행 5열로 구성된 2차원 배열을 생성합니다. 
                                 @c @r{Generate a 4 by 5 array.}
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> i <- array(c(1:3,3:1), dim=c(3,2))
> i                             # i 이라는 3행 2열의 인덱스행렬을 생성했습니다.
                                 @c @r{@code{i} is a 3 by 2 index array.}
     [,1] [,2]
[1,]    1    3
[2,]    2    2
[3,]    3    1
> x[i]                          # 인덱스행렬에 해당하는 값만 뽑아냅니다
                                @c @r{Extract those elements}
[1] 9 6 3
> x[i] <- 0                     # 인덱스 행렬에 해당하는 값들을 0으로 교체합니다.
                                @c @r{Replace those elements by zeros.}
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    0   13   17
[2,]    2    0   10   14   18
[3,]    0    7   11   15   19
[4,]    4    8   12   16   20
>
@end example
@noindent
@c Negative indices are not allowed in index matrices.  @code{NA} and zero
@c values are allowed: rows in the index matrix containing a zero are
@c ignored, and rows containing an @code{NA} produce an @code{NA} in the
@c result.

인덱스 행렬에서 음의 값을 지시자 (index) 를 사용할 수는 없지만, @code{NA} 와 영(0) 은 사용할 수 있습니다. 만약,인덱스 행렬이 0을 포함하고 있는 행이 있다면 이는 무시 될 것이고, @code{NA}를 포함하고 있다면 모두 @code{NA}를 출력할 것입니다.

@c As a less trivial example, suppose we wish to generate an (unreduced)
@c design matrix for a block design defined by factors @code{blocks}
@c (@code{b} levels) and @code{varieties} (@code{v} levels).  Further
@c suppose there are @code{n} plots in the experiment.  We could proceed as
@c follows:

다소 쉬운 예제는 아니지만 , @code{b} 개의 레벨이 있는 @code{blocks} 이라는 요인과 @code{v} 개의 레벨이 있는 @code{varieties} 라는 요인을 이용하여, @code{n}개의 플랏에 적용될 실험에 사용될 디자인 매트릭스는 다음의 절차를 통하여 얻어질 수 있습니다.

@example
> Xb <- matrix(0, n, b)
> Xv <- matrix(0, n, v)
> ib <- cbind(1:n, blocks)
> iv <- cbind(1:n, varieties)
> Xb[ib] <- 1
> Xv[iv] <- 1
> X <- cbind(Xb, Xv)
@end example

@c To construct the incidence matrix, @code{N} say, we could use

만약 N 이라는 the incidence matrix (인시던스 매트릭스)를 생성하고자 한다면 다음과 같이 하면 됩니다.

@example
> N <- crossprod(Xb, Xv)
@end example
@findex crossprod

@c However a simpler direct way of producing this matrix is to use

위와 동일한 인시던스 매트릭스는 @code{table()} 이라는 함수를 이용하면 더욱 쉽게 생성할 수 있습니다.

@findex table

@example
> N <- table(blocks, varieties)
@end example

@c Index matrices must be numerical: any other form of matrix (e.g.@ a
@c logical or character matrix) supplied as a matrix is treated as an
@c indexing vector.

인덱스 행렬은 반드시 수치형으로 구성되어야 합니다.

@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================

@node The array() function, The outer product of two arrays, Index matrices, Arrays and matrices
@section The @code{array()} function
@findex array

@c As well as giving a vector structure a @code{dim} attribute, arrays can
@c be constructed from vectors by the @code{array} function, which has the
@c form

배열은 벡터에 @code{dim} 이라는 속성을 부여하여 얻는 방법외에도, 아래와 같은 방법으로 @code{array} 라는 함수를 이용하여 생성할 수 있습니다.

@example
> Z <- array(@var{data_vector}, @var{dim_vector})
@end example

@c For example, if the vector @code{h} contains 24 or fewer, numbers then
@c the command

예를 들어 벡터 @code{h}가 24개의 수치형 원소를 가진다면, 아래의 명령어는 3행 4열로 구성된 2개의 행렬을 나란히 3차원 공간에 배열 한 뒤 이를 Z 에 할당했음을 의미합니다.

@example
> Z <- array(h, dim=c(3,4,2))
@end example

위에서는 배열 @code{Z} 를 array() 란 함수를 이용하였으나, 아래의 명령어는 벡터 @code{h}의 속성을 조정하여 동일한 배열 @code{Z}를 생성함을 보여줍니다.

@noindent
would use @code{h} to set up @math{3} by @math{4} by @math{2} array in
@code{Z}.  If the size of @code{h} is exactly 24 the result is the same as

@example
> Z <- h ; dim(Z) <- c(3,4,2)
@end example

@c However if @code{h} is shorter than 24, its values are recycled from the
@c beginning again to make it up to size 24 (@pxref{The recycling rule})
@c but @code{dim(h) <- c(3,4,2)} would signal an error about mismatching
@c length.

그런데, 만약 벡터 @code{h} 가 24개보다 적은 수의 원소를 가진다면, 24개라고 지정된 배열의 크기를 맞추기 위해서 벡터 @code{h}의 첫번째 원소부터 재사용되게 됩니다. 이것에 대해서는 (see @pxref{The recycling rule}). 그러나, @code{dim(h) <- c(3,4,2)} 와 같이 속성을 조정하고자 할 때에는 에러를 보여줄 것입니다.

As an extreme but common example

@example
> Z <- array(0, c(3,4,2))
@end example

@noindent
makes @code{Z} an array of all zeros.

@c At this point @code{dim(Z)} stands for the dimension vector
@c @code{c(3,4,2)}, and @code{Z[1:24]} stands for the data vector as it was
@c in @code{h}, and @code{Z[]} with an empty subscript or @code{Z} with no
@c subscript stands for the entire array as an array.

다음은 배열 @code{dim(Z)}의 모든 원소가 0 이라는 값을 가지는 특수한 경우입니다. 여기에서의 dim(Z) 는 차원벡터를 의미하고, @code{Z[1:24]} 는 @code{h} 와 동일한 데이터벡터를 의미합니다. @code{Z[]}와 같이 아무런 서브스크립트를 가지지 않거나 단순히 @code{Z}라고 배열이름을 사용하는 것은 배열 전체를 의미합니다.

@c Arrays may be used in arithmetic expressions and the result is an array
@c formed by element-by-element operations on the data vector.  The
@c @code{dim} attributes of operands generally need to be the same, and
@c this becomes the dimension vector of the result.  

배열에서의 산술연산은 기본적으로 배열을 구성하는 원소단위에서 이루어집니다. 이때, 각각의 배열이 가지는 dim 이라는 차원속성이 모두 동일해야 하며, 동일한 차원의 결과값을 얻을 수 있게 됩니다. 따라서 아래의 명령문은 A, B, 그리고 C 가 모두 같은 dim 차원속성을 가지고 있다는 전제하에서, 원소단위의 연산을 수행한뒤 D 에 할당함을 의미합니다. 그러나, 배열과 벡터가 혼합된 경우의 연산을 수행할 경우에는 많은 주의가 요구됩니다.

So if @code{A},
@code{B} and @code{C} are all similar arrays, then

@example
> D <- 2*A*B + C + 1
@end example

@noindent
@c makes @code{D} a similar array with its data vector being the result of
@c the given element-by-element operations.  However the precise rule
@c concerning mixed array and vector calculations has to be considered a
@c little more carefully.

@menu
* The recycling rule::          
@end menu

@node The recycling rule,  , The array() function, The array() function
@subsection Mixed vector and array arithmetic.  The recycling rule
@cindex Recycling rule

@c The precise rule affecting element by element mixed calculations with
@c vectors and arrays is somewhat quirky and hard to find in the
@c references.  From experience we have found the following to be a reliable
@c guide.

벡터와 배열이 혼합된 연산을 수행하는 것을 설명하기에는 다소 복잡하지만, 우리의 경험으로 아래와 같은 내용을 알려드립니다.

@itemize @bullet
@item
The expression is scanned from left to right.
@item
Any short vector operands are extended by recycling their values until
they match the size of any other operands.
@item
As long as short vectors and arrays @emph{only} are encountered, the
arrays must all have the same @code{dim} attribute or an error results.
@item
Any vector operand longer than a matrix or array operand generates an error.
@item
If array structures are present and no error or coercion to vector has
been precipitated, the result is an array structure with the common
@code{dim} attribute of its array operands.
@end itemize

수식연산은 기본적으로 좌에서 우로 진행합니다. 만약, 연산에 이용되는 벡터들의 길이가 서로 다를 경우,길이가 짧은 벡터는 원소를 재사용하여 길이가 긴 벡터의 길이 만큼 맞추게 됩니다. 만약, 동일한 dim 속성을 가지지 않는 배열끼리 연산될 경우에는 에러가 출력됩니다. 만약, 벡터의 길이가 행렬과 배열의 길이 보다 큰 경우에도 에러가 출력됩니다.

@node The outer product of two arrays, Generalized transpose of an array, The array() function, Arrays and matrices
@section The outer product of two arrays
@cindex Outer products of arrays

@C An important operation on arrays is the @emph{outer product}.  If
@c @code{a} and @code{b} are two numeric arrays, their outer product is an
@c array whose dimension vector is obtained by concatenating their two
@c dimension vectors (order is important), and whose data vector is got by
@c forming all possible products of elements of the data vector of @code{a}
@c with those of @code{b}.  The outer product is formed by the special
@c operator @code{%o%}:

배열의 연산에서 가장 중요한 것은 %o% 라는 연산자기호를 이용하여 연산을 수행하는 외적(outer product)이라는 것입니다. 예를 들어 a와 b 라는 두개의 수치형 배열이 있다면, 외적(outer product)의 결과로 얻어지는 차원속성은 c(dim(a), dim(b)) 이고, 데이터 벡터는 a 의 모든 원소와 b 의 모든 원소로 얻어진 모든 조합의 곱입니다.

@findex %o%

@example
> ab <- a %o% b
@end example

@c An alternative is

다음은 outer()란 함수를 이용하여 동일한 외적(outer product) 연산을 수행하는 것입니다.

@example
> ab <- outer(a, b, "*")
@end example
@findex outer

@c The multiplication function can be replaced by an arbitrary function of
@c two variables.  For example if we wished to evaluate the function
@c @eqn{f(x; y) = \cos(y)/(1 + x^2), f(x; y) = cos(y)/(1 + x^2)}
@c over a regular grid of values with @math{x}- and @math{y}-coordinates
@c defined by the @R{} vectors @code{x} and @code{y} respectively, we could
@c proceed as follows:

outer product 는 두개의 변수를 가지고 있는 임의의 함수에 대한 결과값을 연산하고자 할때 유용하게 사용됩니다. 예를 들어, x- 와 y- 좌표평면상에 있는 모든 좌표에 대하여 f(x;y)=cos(y)/(1+x^2) 라는 함수가 가질 수 있는 모든 값은 다음의 명령을 수행함으로서 쉽게 얻을 수 있습니다.

@example
> f <- function(x, y) cos(y)/(1 + x^2)
> z <- outer(x, y, f)
@end example

In particular the outer product of two ordinary vectors is a doubly
subscripted array (that is a matrix, of rank at most 1).  Notice that
the outer product operator is of course non-commutative.  Defining your
own @R{} functions will be considered further in @ref{Writing your own
functions}.

@subsubheading An example: Determinants of 2 by 2 single-digit matrices

@c As an artificial but cute example, consider the determinants of @math{2}
@c by @math{2} matrices @math{[a, b; c, d]} where each entry is a
@c non-negative integer in the range @math{0, 1, @dots{}, 9}, that is a
@c digit.

다소 인위적이긴 하지만 이해가 쉬운 예를 하나 들어보겠습니다. 먼저, [a, b; c,d] 라는 2행 2열의 행렬이 있다고 가정합니다. 그리고, 0 부터 9까지 정수가 각각의 원소 a, b, c, d에 할당될 확률은 균등하며, 독립적으로 할당됩니다. 이때, ad-bc 라는 행렬계수 (determinant) 의 분포를 구하고자 한다면, 다음과 같이 두번의 outer() 함수를 사용함으로 해결할 수 있습니다.

The problem is to find the determinants, @math{ad - bc}, of all possible
matrices of this form and represent the frequency with which each value
occurs as a @emph{high density} plot.  This amounts to finding the
probability distribution of the determinant if each digit is chosen
independently and uniformly at random.

A neat way of doing this uses the @code{outer()} function twice:

@example
> d <- outer(0:9, 0:9)
> fr <- table(outer(d, d, "-"))
> plot(as.numeric(names(fr)), fr, type="h",
       xlab="Determinant", ylab="Frequency")
@end example

Notice the coercion of the @code{names} attribute of the frequency table
to numeric in order to recover the range of the determinant values.  The
``obvious'' way of doing this problem with @code{for} loops, to be
discussed in @ref{Loops and conditional execution}, is so inefficient as
to be impractical.

여기에서 한가지 주의 할 점은 fr 이라는 상대도수표에서 행렬계수가 가지는 범위를 나타내는 name 이라는 속성을 수치형으로 강제변환해야 한다는 것입니다. 가장 확실한 방법은 for 라는 반복문을 이용하는 것인데, 이것은 비효율적이므로 실용적이지 못합니다. 그러나, 반복문에 대해서는 Loops and conditional execution 에서 다루어 질 것입니다.

It is also perhaps surprising that about 1 in 20 such matrices is
singular.


@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================

@node Generalized transpose of an array, Matrix facilities, The outer product of two arrays, Arrays and matrices
@section Generalized transpose of an array
@cindex Generalized transpose of an array

@c The function @code{aperm(a, perm)}
@c @findex aperm
@c may be used to permute an array, @code{a}.  The argument @code{perm}
@c must be a permutation of the integers @math{@{1, @dots{}, k@}}, where
@c @math{k} is the number of subscripts in @code{a}.  The result of the
@c function is an array of the same size as @code{a} but with old dimension
@c given by @code{perm[j]} becoming the new @code{j}-th dimension.  The
@c easiest way to think of this operation is as a generalization of
@c transposition for matrices.  Indeed if @code{A} is a matrix, (that is, a
@c doubly subscripted array) then @code{B} given by

aperm(a, perm) 이라는 함수는 배열의 차원을 재배열하는 역할을 합니다. 이것의 가장 쉬운예제는 행렬의 전치를 들 수 있습니다. 행렬 A의 차원벡터 dim(A)는 c(1,2) 이므로, 이것의 순서를 c(2,1) 로 바꾸는 것은 행렬 A를 전치 (transpose) 한 t(A) 와 동일한 결과를 줍니다. (즉, B <- t(A)).

@example
> B <- aperm(A, c(2,1))
@end example

@noindent
is just the transpose of @code{A}.  For this special case a simpler
function @code{t()}
@findex t
is available, so we could have used @code{B <- t(A)}.

@node Matrix facilities, Forming partitioned matrices, Generalized transpose of an array, Arrays and matrices
@section Matrix facilities

@macro xTx{}
 @eqn{@strong{x}^T @strong{x}, x'x}
@end macro
@macro xxT{}
 @eqn{@strong{x}@strong{x}^T, x x'}
@end macro

@c As noted above, a matrix is just an array with two subscripts.  However
@c it is such an important special case it needs a separate discussion.
@c @R{} contains many operators and functions that are available only for
@c matrices.  For example @code{t(X)} is the matrix transpose function, as
@c noted above.  The functions @code{nrow(A)} and @code{ncol(A)} give the
@c number of rows and columns in the matrix @code{A} respectively.

위에서 언급했던것과 같이, 행렬은 단순히 2개의 서브스크립트로 이루어진 배열의 특수한 경우입니다. R은 다양하고 풍부한 행렬의 연산기능을 제공하고 있습니다. 예를 들면, t(X) 는 행렬 X 의 전치입니다. 함수 nrow(A) 과 ncol(A) 은 행렬 A 의 행의 개수와 열의 개수를 알려줍니다.

@findex nrow
@findex ncol


@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================

@menu
* Multiplication::              
* Linear equations and inversion::  
* Eigenvalues and eigenvectors::  
* Singular value decomposition and determinants::  
* Least squares fitting and the QR decomposition::  
@end menu

@node  Multiplication, Linear equations and inversion, Matrix facilities, Matrix facilities
@subsection Matrix multiplication

@cindex Matrix multiplication
The operator @code{%*%} is used for matrix multiplication.
@findex %*%

@c An @math{n} by @math{1} or @math{1} by @math{n} matrix may of course be
@c used as an @math{n}-vector if in the context such is appropriate.
@c Conversely, vectors which occur in matrix multiplication expressions are
@c automatically promoted either to row or column vectors, whichever is
@c multiplicatively coherent, if possible, (although this is not always
@c unambiguously possible, as we see later).

@c If, for example, @code{A} and @code{B} are square matrices of the same
@c size, then

%*% 라는 연산자는 행렬의 곱에 사용됩니다. 본래 1개의 행 또는 1개의 열로 구성된 행렬은 정확히 말하면, n 개의 요소를 가진 행 벡터 혹은 열벡터입니다. 그러나, 행렬곱셈에서 사용되는 벡터는 수학적 표현이 논리적으로 정확하다면 행 혹은 열벡터로 적절하게 변경되어 연산을 수행합니다.

만약, A 와 B 가 정방행렬이라면, 다음의 표현은 원소단위의 곱을 수행합니다.

@example
> A * B
@end example

@noindent

@c is the matrix of element by element products and

그러나, 다음의 표현은 원소의 곱이 아닌 행렬곱셈을 의미합니다.

@example
> A %*% B
@end example

@noindent

@c is the matrix product.  If @code{x} is a vector, then

만약, 아래와 같이 행렬곱셈에서 사용되는 x가 벡터라면 스칼라 값을 돌려주는 이차(quadratic)연산을 수행합니다.

@example
> x %*% A %*% x
@end example

@noindent
is a quadratic form.@footnote{Note that @code{x %*% x} is ambiguous, as
it could mean either @xTx{} or @xxT{}, where @eqn{@strong{x},x} is the
column form.  In such cases the smaller matrix seems implicitly to be
the interpretation adopted, so the scalar @xTx{} is in this case the
result.  The matrix @xxT{} may be calculated either by @code{cbind(x)
%*% x} or @code{x %*% rbind(x)} since the result of @code{rbind()} or
@code{cbind()} is always a matrix.  However, the best way to compute
@xTx{} or @xxT{} is @code{crossprod(x)} or @code{x %o% x}
respectively.}

@findex crossprod
@c The function @code{crossprod()} forms ``crossproducts'', meaning that
@c @code{crossprod(X, y)} is the same as @code{t(X) %*% y} but the
@c operation is more efficient.  If the second argument to
@c @code{crossprod()} is omitted it is taken to be the same as the first.

@findex diag
@c The meaning of @code{diag()} depends on its argument.  @code{diag(v)},
@c where @code{v} is a vector, gives a diagonal matrix with elements of the
@c vector as the diagonal entries.  On the other hand @code{diag(M)}, where
@c @code{M} is a matrix, gives the vector of main diagonal entries of
@c @code{M}.  This is the same convention as that used for @code{diag()} in
@c @sc{Matlab}.  Also, somewhat confusingly, if @code{k} is a single
@c numeric value then @code{diag(k)} is the @code{k} by @code{k} identity
@c matrix!

crossprod() 이라는 함수는 연산속도가 더 효율적이라는 점만 제외한다면 t(X)%*%y 와 동일한 연산을 수행합니다. 만약, 두번째 인자와 첫번째 인자와 동일하다면 두번째 인자는 생략해도 무방합니다.

diag() 라는 함수가 v 라는 벡터를 인자를 가진다면 대각원소가 v인 대각 행렬을 생성합니다. 하지만, diag() 의 인자가 M 이라는 행렬이라면, 행렬 M 의 대각원소를 출력하게 됩니다. 이것은 Matlab 에서 사용되는 diag() 이라는 함수의 기능과 동일합니다. 다소 혼돈스러울 수도 있으나, diag() 의 인자가 k라는 스칼라라면 k 행 k열을 가지는 단위행렬 (identity matrix) 를 생성합니다.

@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================

@node Linear equations and inversion, Eigenvalues and eigenvectors, Multiplication, Matrix facilities
@subsection Linear equations and inversion

@cindex Linear equations
@findex solve
@c Solving linear equations is the inverse of matrix multiplication.
@c When after

다음의 표현과 같은 선형 방정식이 존재할 때, A 의 계수값들과 b 의 값을 미리 알고 있다고 가정한다면, x를 찾아내는 것을 선형방정식의 해를 찾는다고 합니다.

@example
> b <- A %*% x
@end example

@noindent
@c only @code{A} and @code{b} are given, the vector @code{x} is the
@c solution of that linear equation system.  In @R{},

R 은 다음의 명령어를 통하여 선형방정식의 해 x 를 구합니다.

@example
> solve(A,b)
@end example

@noindent
@c solves the system, returning @code{x} (up to some accuracy loss).
@c Note that in linear algebra, formally
@c @eqn{@strong{x} = @strong{A}^{-1} @strong{b}, @code{x = A^@{-1@} %*% b}}
@c where
@c @eqn{@strong{A}^{-1}, @code{A^@{-1@}}} denotes the @emph{inverse} of
@c @eqn{@strong{A},@code{A}}, which can be computed by

즉, 이것은 x = A^{-1} %*% b 입니다. 여기에서 A^{-1} 은 A 의 역행렬이며, 다음의 명령어를 수행하여 얻을 수 있습니다.

@example
solve(A)
@end example

@noindent
@c but rarely is needed.  Numerically, it is both inefficient and
@c potentially unstable to compute @code{x <- solve(A) %*% b} instead of
@c @code{solve(A,b)}.

하지만, 위와 같이 역행렬을 이용하여 x <- solve(A) %*% b 와 같은 연산을 하는 것은 solve(A,b) 라는 함수를 이용하는 것보다 비효율적입니다.

The quadratic form @eqn{@strong{x^T  A^{-1} x},@ @code{x %*% A^@{-1@} %*%
x} @ } which is used in multivariate computations, should be computed by
something like@footnote{Even better would be to form a matrix square
root @eqn{B, B} with @eqn{A = BB^T, A = BB'} and find the squared length of the
solution of @eqn{By = x, By = x}, perhaps using the Cholesky or
eigendecomposition of @eqn{A, A}.} @code{x %*% solve(A,x)}, rather than
computing the inverse of @code{A}.

@node Eigenvalues and eigenvectors, Singular value decomposition and determinants, Linear equations and inversion, Matrix facilities
@subsection Eigenvalues and eigenvectors
@cindex Eigenvalues and eigenvectors

@findex eigen
@c The function @code{eigen(Sm)} calculates the eigenvalues and
@c eigenvectors of a symmetric matrix @code{Sm}.  The result of this
@c function is a list of two components named @code{values} and
@c @code{vectors}.  The assignment

eigen(Sm) 이라는 함수는 대칭행렬 Sm 의 기저값 (eigenvalues) 와 기저벡터 (eigenvectors) 를 계산해줍니다. 예를들어, 아래와 같이 이 함수를 적용한 결과는 values 라는 기저값으로 구성된 벡터와 vectors 라는 기저벡터로 구성된 행렬을 반환하는 리스트의 형식을 가지고 있습니다. 따라서 기저값은 ev$val을, 기저벡터는 ev$vec을 통하여 얻을 수 있습니다.

@example
> ev <- eigen(Sm)
@end example

@noindent
@c will assign this list to @code{ev}.  Then @code{ev$val} is the vector of
@c eigenvalues of @code{Sm} and @code{ev$vec} is the matrix of
@c corresponding eigenvectors.  Had we only needed the eigenvalues we could
@c have used the assignment:

만약 사용자가 단순히 기저값만을 원한다면 아래와 같이 표현할 수 있습니다. 즉, evals 은 기저값에 대한 결과만을 가지게 되고 기저벡터에 대한 결과는 저장되지 않습니다.

@example
> evals <- eigen(Sm)$values
@end example

@noindent
@c @code{evals} now holds the vector of eigenvalues and the second
@c component is discarded.  If the expression

만약 아래와 같이 단순히 함수를 적용하는 것은 기저값과 기저벡터의 결과를 동시에 출력해줍니다.

@example
> eigen(Sm)
@end example

@noindent
@c is used by itself as a command the two components are printed, with
@c their names.  For large matrices it is better to avoid computing the
@c eigenvectors if they are not needed by using the expression

행렬의 크기가 크고, 기저벡터보다는 기저값만 요구될 경우 연산속도를 높이기 위해서 아래와 같이 사용할 수도 있습니다.

@example
> evals <- eigen(Sm, only.values = TRUE)$values
@end example


@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================

@node Singular value decomposition and determinants, Least squares fitting and the QR decomposition, Eigenvalues and eigenvectors, Matrix facilities
@subsection Singular value decomposition and determinants
@cindex Singular value decomposition

@findex svd
The function @code{svd(M)} takes an arbitrary matrix argument, @code{M},
and calculates the singular value decomposition of @code{M}.  This
consists of a matrix of orthonormal columns @code{U} with the same
column space as @code{M}, a second matrix of orthonormal columns
@code{V} whose column space is the row space of @code{M} and a diagonal
matrix of positive entries @code{D} such that @code{M = U %*% D %*%
t(V)}.  @code{D} is actually returned as a vector of the diagonal
elements.  The result of @code{svd(M)} is actually a list of three
components named @code{d}, @code{u} and @code{v}, with evident meanings.

If @code{M} is in fact square, then, it is not hard to see that

svd(M) 이라는 함수는 M 이라는 임의의 행렬을 인자로 가지며 the singular value decomposion 을 수행합니다. 이 함수로부터 세가지의 결과를 얻어낼 수 있습니다. 첫번째는 M 행렬의 열을 기초
로 한 orthonormal matrix U이고, 두번째는 M 행렬의 행을 기초로 한 orthonormal matrix V 이며, 세번째는 M = U %*% D %*% t(V)라는 조건을 만족하는 D 라는 대각행렬 계산해냅니다. svd(M) 의 실제 계산 결과는 위의 세가지를 한데 묶은 리스트의 형식으로 d, u, v 라는 이름으로 저장되어집니다.

예를 들어 행렬 M의 행렬계수(determinant)의 절대값을 구하고자 한다면, singular value decomposition을 이용하여 아래와 같이 쉽게 얻을 수있습니다.

@example
> absdetM <- prod(svd(M)$d)
@end example

@noindent
@c calculates the absolute value of the determinant of @code{M}.  If this
@c calculation were needed often with a variety of matrices it could be
@c defined as an @R{} function

만약 사용자가 위와 같은 행렬계수 (determinant)의 절대값을 자주 사용해야 한다면, R은 아래와 같이 사용자가 정의하는 함수 absdet() 를 작성하여 사용할 수 있도록 도와줍니다.

@example
> absdet <- function(M) prod(svd(M)$d)
@end example

@cindex Determinants
@noindent
@c after which we could use @code{absdet()} as just another @R{} function.
@c As a further trivial but potentially useful example, you might like to
@c consider writing a function, say @code{tr()}, to calculate the trace of
@c a square matrix.  [Hint: You will not need to use an explicit loop.
@c Look again at the @code{diag()} function.]

또 다른 직관적인 예로 여러분은 함수의 trace (한국말 모름) 을 계산해주는 tr() 이라는 singular decomposition 을 이용하여 얻어낸 대각행렬과 diag()이라는 함수를 이용하여 쉽게 작성할 수 도 있습니다.

@findex det
@findex determinant
@c @R{} has a builtin function @code{det} to calculate a determinant,
@c including the sign, and another, @code{determinant}, to give the sign
@c and modulus (optionally on log scale),

실은 R은 행렬계수 (determinant)를 연산하기 위한 det 를 제공하고 있으며, 행렬계수 외에도 계수의 부호와 로그값이 취해진 모듈러스 (modulus) 의 결과를 함께 계산해주는 determinant 라는 함수또한 제공하고 있습니다.

@c Functions will be discussed formally later in these notes.


@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================

@node Least squares fitting and the QR decomposition,  , Singular value decomposition and determinants, Matrix facilities
@subsection Least squares fitting and the QR decomposition
@cindex Least squares fitting
@cindex QR decomposition

@c The function @code{lsfit()} returns a list giving results of a least
@c squares fitting procedure.  An assignment such as

아래의 표현은 만약 여러분이 관측치들을 y 라는 벡터에 저장하고, X 라는 디자인 매트릭스를 지정했을때,lsfit() 이라는 함수가 최소제곱법 (least square)을 이용하여 적합된 (fitted) 된 값을 ans 에 할당하는 것을 보여줍니다.

@example
> ans <- lsfit(X, y)
@end example
@findex lsfit

@noindent
@c gives the results of a least squares fit where @code{y} is the vector of
@c observations and @code{X} is the design matrix.  See the help facility
@c for more details, and also for the follow-up function @code{ls.diag()}
@c for, among other things, regression diagnostics.  Note that a grand mean
@c term is automatically included and need not be included explicitly as a
@c column of @code{X}.  Further note that you almost always will prefer
@c using @code{lm(.)} (@pxref{Linear models}) to @code{lsfit()} for
@c regression modelling.

더 자세한 사항은 도움말을 참조하세요. 그리고 최소제곱법을 이용한 회귀분석을 통한 모델진단에 대해서 조금 더 알고 싶으시다면 이와 연관된 ls.diag() 라는 함수를 살펴보시길 바랍니다. 그러나, 여러분들이 회귀분석을 수행하고자 한다면 lsfit() 이라는 함수를 이용하는 것보다 lm(.) (see Linear models) 을 사용하는 것이 더 편리합니다.

@findex qr
@c Another closely related function is @code{qr()} and its allies.
@c Consider the following assignments

아래의 코드는 lsfit() 이라는 함수를 통한 회귀분석을 qr() 이라는 함수를 이용하여 동일한 작업을 할 수 있음을 보여줍니다.

@example
> Xplus <- qr(X)
> b <- qr.coef(Xplus, y)
> fit <- qr.fitted(Xplus, y)
> res <- qr.resid(Xplus, y)
@end example

@noindent
@c These compute the orthogonal projection of @code{y} onto the range of
@c @code{X} in @code{fit}, the projection onto the orthogonal complement in
@c @code{res} and the coefficient vector for the projection in @code{b},
@c that is, @code{b} is essentially the result of the @sc{Matlab}
@c `backslash' operator.

여기에서 b 는 회귀계수를, fit 은 벡터 y 가 X 에 직사영(orthogonal projection)된 값 (즉, fitted 된 값)을, 그리고 res 란 값은 오차 (the projection onto the orthogonal complement)를 가지고 있습니다. 여러분들은 디자인 매트릭스 X 가 꼭 full column rank 이라는 조건을 만족해야 하는 것에 대해서 걱정할 필요는 없습니다. 만약 full column rank 가 아니라면, R 은 자동으로 redundancies을 수행합니다.

It is not assumed that @code{X} has full column rank.  Redundancies will
be discovered and removed as they are found.

This alternative is the older, low-level way to perform least squares
calculations.  Although still useful in some contexts, it would now
generally be replaced by the statistical models features, as will be
discussed in @ref{Statistical models in R}.

@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================



@node Forming partitioned matrices, The concatenation function c() with arrays, Matrix facilities, Arrays and matrices
@section Forming partitioned matrices, @code{cbind()} and @code{rbind()}
@findex cbind
@findex rbind

@c As we have already seen informally, matrices can be built up from other
@c vectors and matrices by the functions @code{cbind()} and @code{rbind()}.
@c Roughly @code{cbind()} forms matrices by binding together matrices
@c horizontally, or column-wise, and @code{rbind()} vertically, or
@c row-wise.

위에서도 잠깐 언급했었지만, cbind() 와 rbind() 이라는 함수는 벡터와 행렬을 열방향 혹은 행방향으로 묶어 새로운 행렬을 생성할 때 이용됩니다.

In the assignment

@example
> X <- cbind(@var{arg_1}, @var{arg_2}, @var{arg_3}, @dots{})
@end example

@noindent
@c the arguments to @code{cbind()} must be either vectors of any length, or
@c matrices with the same column size, that is the same number of rows.
@c The result is a matrix with the concatenated arguments @var{arg_1},
@c @var{arg_2}, @dots{} forming the columns.

위에서 사용된 cbind() 라는 함수는 임의의 크기를 가진 벡터나 행렬을 인자로 가질 수 있으나, 모든 인자들의 행의 길이는 같아야만 합니다.

If some of the arguments to @code{cbind()} are vectors they may be
shorter than the column size of any matrices present, in which case they
are cyclically extended to match the matrix column size (or the length
of the longest vector if no matrices are given).

@c The function @code{rbind()} does the corresponding operation for rows.
@c In this case any vector argument, possibly cyclically extended, are of
@c course taken as row vectors.

rbind()이라는 함수역시 cbind() 라는 함수와 사용방법은 동일하지만, 모든 인자들의 열의 길이는 같아야만 합니다.

@c Suppose @code{X1} and @code{X2} have the same number of rows.  To
@c combine these by columns into a matrix @code{X}, together with an
@c initial column of @code{1}s we can use

예를 들어, X1 과 X2 이라는 두 행렬이 같은 행의 길이를 가지고 있다고 가정합니다. 아래의 명령문은 1 이란 인자는 X1 이 가진 행의 길이만큼 1 을 리사이클링 시켜서 1 이라는 열벡터를 생성한뒤, 1, X1, X2 를 열방향으로 한데 묶어 X 라는 새로운 벡터를 생성시켜 줍니다.

@example
> X <- cbind(1, X1, X2)
@end example

The result of @code{rbind()} or @code{cbind()} always has matrix status.
Hence @code{cbind(x)} and @code{rbind(x)} are possibly the simplest ways
explicitly to allow the vector @code{x} to be treated as a column or row
matrix respectively.

@node The concatenation function c() with arrays, Frequency tables from factors, Forming partitioned matrices, Arrays and matrices
@section The concatenation function, @code{c()}, with arrays

@c It should be noted that whereas @code{cbind()} and @code{rbind()} are
@c concatenation functions that respect @code{dim} attributes, the basic
@c @code{c()} function does not, but rather clears numeric objects of all
@c @code{dim} and @code{dimnames} attributes.  This is occasionally useful
@c in its own right.

만약, cbind()와 rbind() 이라는 함수가 행렬의 dim 속성을 기초로 여러개의 행렬을 한데 묶어준다고 한다면, c() 이라는 함수는 dim 과 dimnames 라는 속성을 모두 무시한채 결합을 수행한다고 할 수 있습니다. c() 를 이용하는 것이 때때로 더 유용한 경우가 있습니다.

@c The official way to coerce an array back to a simple vector object is to
@c use @code{as.vector()}

원래 이렇게 속성들을 무시하고, 배열을 단순 벡터로 강제변환하는 방법은 아래와 같이 as.vector()이라는 함수를 이용하는 것입니다.

@example
> vec <- as.vector(X)
@end example
@findex as.vector

@c However a similar result can be achieved by using @code{c()} with just
@c one argument, simply for this side-effect:

위에서 얻은 동일한 결과를 아래와 같이 c()라는 함수를 이용해서도 얻을 수 있습니다. 

@example
> vec <- c(X)
@end example
@findex c

@c There are slight differences between the two, but ultimately the choice
@c between them is largely a matter of style (with the former being
@c preferable).

실은 약간 다른 점은 있으나, 어느 것을 사용하는가는 프로그래밍 스타일의 차이일 뿐입니다 .

@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================

@node Frequency tables from factors,  , The concatenation function c() with arrays, Arrays and matrices
@section Frequency tables from factors
@cindex Tabulation

@c Recall that a factor defines a partition into groups.  Similarly a pair
@c of factors defines a two way cross classification, and so on.
@c @findex table
@c The function @code{table()} allows frequency tables to be calculated
@c from equal length factors.  If there are @math{k} factor arguments,
@c the result is a @math{k}-way array of frequencies.

위에서 요인 (factor) 라는 것은 데이터를 요인이 가진 레벨에 따라서 분류할 때 사용한다고 했습니다. 만약 2개의 요인이 존재한다면 2차원 분류 (two way cross classification) 가 가능할 것이고, 더 나아가 k 개의 요인이 있다면 k-차원의 분류가 가능할 것입니다.

@c Suppose, for example, that @code{statef} is a factor giving the state
@c code for each entry in a data vector.  The assignment

함수 table() 은 배열을 이용하여 이러한 분류가 가능하도록 도와줍니다. 예를 들어, 여러개의 레벨을 가진 지역코드란 요인에 대한 정보가 statef 에 저장되어 있다면, 다음의 코드는 지역코드별 도수분포를 statefr에 저장하게 됩니다. 이때 각 레벨별 도수는 레벨이 가진 이름순으로 정렬됩니다.

@example
> statefr <- table(statef)
@end example

@noindent
@c gives in @code{statefr} a table of frequencies of each state in the
@c sample.  The frequencies are ordered and labelled by the @code{levels}
@c attribute of the factor.  This simple case is equivalent to, but more
@c convenient than,

이와 동일한 역할을 수행하는 또 다른 편리한 방법은 아래와 같습니다.

@example
> statefr <- tapply(statef, statef, length)
@end example

@c Further suppose that @code{incomef} is a factor giving a suitably
@c defined ``income class'' for each entry in the data vector, for example
@c with the @code{cut()} function:

지역별 코드의 경우에는 데이터값이 이산형이지만, 소득수준의 경우는 연속형의 데이터를 가집니다. 이런 경우, 소득수준에 대한 구간을 나누는 편리한 방법은 아래와 같이 cut() 이라는 함수를 사용하는 것입니다.

@example
> factor(cut(incomes, breaks = 35+10*(0:7))) -> incomef
@end example
@findex cut

@c Then to calculate a two-way table of frequencies:

아래의 코드는 cut() 이라는 함수에 의해 구간화된 incomef 이라는 요인을 이용하여 지역코드별 소득수준에 대한 도수분포를 보여줍니다.

@example
> table(incomef,statef)
         statef
incomef   act nsw nt qld sa tas vic wa
  (35,45]   1   1  0   1  0   0   1  0
  (45,55]   1   1  1   1  2   0   1  3
  (55,65]   0   3  1   3  2   2   2  1
  (65,75]   0   1  0   0  0   0   1  0
@end example

Extension to higher-way frequency tables is immediate.

@node Lists and data frames, Reading data from files, Arrays and matrices, Top
@chapter Lists and data frames

@menu
* Lists::                       
* Constructing and modifying lists::  
* Data frames::                 
@end menu

@node Lists, Constructing and modifying lists, Lists and data frames, Lists and data frames
@section Lists
@cindex Lists

@c An @R{} @emph{list} is an object consisting of an ordered collection of
@c objects known as its @emph{components}.

R 에서 list 라는 것은 여러개의 컴포넌트 (components) 라고 불리는 객체들의 집합입니다. 

@c There is no particular need for the components to be of the same mode or
@c type, and, for example, a list could consist of a numeric vector, a
@c logical value, a matrix, a complex vector, a character array, a
@c function, and so on.  Here is a simple example of how to make a list:

리스트가 벡터, 매트릭스, 혹은 배열과 구분되는 점은 컴포넌트들의 데이터형이 같지 않아도 된다는 것입니다. 예를들어, 수치형 벡터의 모든 원소는 수치형 데이터를 가져야만 했습니다. 그러나 리스트는 각각의 컴포넌트가 수치형 벡터, 논리형 벡터, 행렬, 배열, 그리고 함수로 구성될 수 있습니다. 다음은 리스트를 생성하는 간단한 예를 보여줍니다.

@example
> Lst <- list(name="Fred", wife="Mary", no.children=3,
              child.ages=c(4,7,9))
@end example
@findex list

@c Components are always @emph{numbered} and may always be referred to as
@c such.  Thus if @code{Lst} is the name of a list with four components,
@c these may be individually referred to as @code{Lst[[1]]},
@c @code{Lst[[2]]}, @code{Lst[[3]]} and @code{Lst[[4]]}.  If, further,
@c @code{Lst[[4]]} is a vector subscripted array then @code{Lst[[4]][1]} is
@c its first entry.

리스트의 구성요소인 각각의 컴포넌트를 구분하는 방법은 컴포넌트 인덱스를 사용하는 것입니다. 예를 들어, 위와 같이 4개의 컴포넌트들로 구성된 리스트가 있다면, 각각의 컴포넌트는 Lst1, Lst2, Lst3, Lst4 에 의해서 엑세스 되어 집니다. 더 나아가, 마지막 네번째 컴포넌트 Lst4 의 첫번째 구성요소의 값을 알고자 한다면, Lst4[1] 이라고 하면 됩니다.

@c If @code{Lst} is a list, then the function @code{length(Lst)} gives the
@c number of (top level) components it has.

만약 사용자가 접한 리스트가 몇개의 컴포넌트로 구성된지 모를 경우 length() 명령어를 사용하면 컴포넌트의 개수를 알수 있습니다. 위에 사용된 Lst 이라는 리스트를 예를 들면, length(Lst) 은 4란 값을 알려줍니다.

@c Components of lists may also be @emph{named}, and in this case the
@c component may be referred to either by giving the component name as a
@c character string in place of the number in double square brackets, or,
@c more conveniently, by giving an expression of the form

리스트를 구성하는 컴포넌트들은 인덱스를 사용하여 엑세스 하는 방법외에도 일반적으로 아래와 같이 컴포넌트의 이름을 사용하여 엑세스 할 수 도 있습니다. 아래에서 name 이라는 것은 리스트의 이름에 해당되고 스트링 ($) 이라는 문자 다음에 오는 component_name 이라는 것은 컴포넌트의 이름입니다

@example
> @var{name}$@var{component_name}
@end example

@noindent
for the same thing.

@c This is a very useful convention as it makes it easier to get the right
@c component if you forget the number.

@c So in the simple example given above:

@c @code{Lst$name} is the same as @code{Lst[[1]]} and is the string
@c @code{"Fred"},

@c @code{Lst$wife} is the same as @code{Lst[[2]]} and is the string
@c @code{"Mary"},

@c @code{Lst$child.ages[1]} is the same as @code{Lst[[4]][1]} and is the
@c number @code{4}.

이렇게 이름을 사용하는 방법은 사용자가 컴포넌트 인덱스를 일일이 기억하지 않도록 도와줍니다. 위에서 사용된 예제를 다시 보면, Lst$name 이라는 것은 Lst1와 동일하고, "Fred" 라는 값을 가집니다. Lst$wife는 Lst2와 동일하고 "Mary"라는 값을 가집니다. Lst$child.ages[1] 역시 Lst4[1] 동일하며, 4 라는 값을 가집니다.

@c Additionally, one can also use the names of the list components in
@c double square brackets, i.e., @code{Lst[["name"]]} is the same as
@c @code{Lst$name}.  This is especially useful, when the name of the
@c component to be extracted is stored in another variable as in

추가적으로, Lst$name 과 Lst"name" 은 Lst 라는 리스트의 첫번째 컴포넌트를 엑세스 하기 위한 동일한 표현법입니다. 이것은 아래와 같이 리스트의 이름을 다른 변수에 따로 저장하여 활용 할 수 있도록 하는 아주 유용한 기능입니다.

@example
> x <- "name"; Lst[[x]]
@end example

It is very important to distinguish @code{Lst[[1]]} from @code{Lst[1]}.
@samp{@code{[[@var{@dots{}}]]}} is the operator used to select a single
element, whereas @samp{@code{[@var{@dots{}}]}} is a general subscripting
operator.  Thus the former is the @emph{first object in the list}
@code{Lst}, and if it is a named list the name is @emph{not} included.
The latter is a @emph{sublist of the list @code{Lst} consisting of the
first entry only.  If it is a named list, the names are transferred to
the sublist.}

리스트를 활용함에 있어서 Lst1 와 Lst[1] 를 구분하는 것은 매우 중요합니다. ‘...’ 은 리스트에서 컴포넌트를 구별하기 위해서 사용되고, ‘[...]’ 은 컴포넌트가 가지는 원소들을 구분하기 위해서 사용됩니다. 그러므로, 리스트 이름뒤에는 항상 ‘...’ 이 먼저 오고, ‘[...]’ 이 나중에 와야 합니다.

@c The names of components may be abbreviated down to the minimum number of
@c letters needed to identify them uniquely.  Thus @code{Lst$coefficients}
@c may be minimally specified as @code{Lst$coe} and @code{Lst$covariance}
@c as @code{Lst$cov}.

만약 리스트를 구성하는 컴포넌트들의 이름이 길지만, 동일한 이름이 없다면, R 은 컴포넌트들을 구분할 수 있는 약어기능을 제공합니다. 예를들면, Lst 라는 리스트가 coefficients 와 covariance 라는 두개의 컴포넌트를 가지고 있다면, 굳이 Lst$coefficients 혹은 Lst$covariance 이라는 이름을 다 사용할 필요가 없습니다. R 은 Lst$coe 와 Lst$cov 만으로도 충분히 두개의 컴포넌트를 구분해 낼 수 있습니다.

The vector of names is in fact simply an attribute of the list like any
other and may be handled as such.  Other structures besides lists may,
of course, similarly be given a @emph{names} attribute also.

@node Constructing and modifying lists, Data frames, Lists, Lists and data frames
@section Constructing and modifying lists

@c New lists may be formed from existing objects by the function
@c @code{list()}.  An assignment of the form

만약 여러분이 이미 작업하고 있던 여러개의 객체를 가지고 있었다면, list() 라는 함수를 이용하여 새로운 리스트를 생성할 수 도 있습니다. 아래의 명령문은 object_1 이라는 객체를 첫번째 컴포넌트로 name_1 이라는 이름과 함께 사용할 것이며, 이와 같은 방법으로 m 개의 객체를 새로운 리스트를 정의하겠다는 의미입니다.

@example
> Lst <- list(@var{name_1}=@var{object_1}, @var{@dots{}}, @var{name_m}=@var{object_m})
@end example

@noindent
@c sets up a list @code{Lst} of @math{m} components using @var{object_1},
@c @dots{}, @var{object_m} for the components and giving them names as
@c specified by the argument names, (which can be freely chosen).  If these
@c names are omitted, the components are numbered only.  The components
@c used to form the list are @emph{copied} when forming the new list and
@c the originals are not affected.

만약, 컴포넌트에 사용할 이름이 정해지지 않았다면, R 은 자동으로 몇 번째 컴포넌트인지 숫자를 이름으로 정합니다. 새로운 리스트가 생성될 때 기존의 객체들은 단순히 컴포넌트로서 복사 되는 것이기 때문에 새로운 리스트가 정의되어도 기존의 객체들은 아무런 영향을 받지 않습니다.

@c Lists, like any subscripted object, can be extended by specifying
@c additional components.  For example

만약, 리스트에 새로운 컴포넌트를 추가하고 싶을 경우에는 아래의 명령문과 같이 서브스크립트를 이용하면 편리합니다.

@example
> Lst[5] <- list(matrix=Mat)
@end example

@menu
* Concatenating lists::         
@end menu

@node Concatenating lists,  , Constructing and modifying lists, Constructing and modifying lists
@subsection Concatenating lists
@cindex Concatenating lists

@findex c
@c When the concatenation function @code{c()} is given list arguments, the
@c result is an object of mode list also, whose components are those of the
@c argument lists joined together in sequence.

만약 여러개의 리스트를 한데 묶고 싶다면 아래와 같이 함수 c() 를 이용하면 사용된 인자의 순서대로 한데 묶인 새로운 리스트를 생성해 줍니다.

@example
> list.ABC <- c(list.A, list.B, list.C)
@end example

Recall that with vector objects as arguments the concatenation function
similarly joined together all arguments into a single vector structure.
In this case all other attributes, such as @code{dim} attributes, are
discarded.

@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================
@c =======================================================================================================================================


@node Data frames,  , Constructing and modifying lists, Lists and data frames
@section Data frames
@cindex Data frames

@c A @emph{data frame} is a list with class @code{"data.frame"}.  There are
@c restrictions on lists that may be made into data frames, namely
@c @itemize @bullet

데이터 프레임 (data frame) 이라는 것은 특수한 형태의 리스트로서 "data.frame" 라는 클래스로 따로 구분 됩니다. 데이터 프레임은 리스트와 구분되는 몇가지 특징이 있습니다.

@c @item
@c The components must be vectors (numeric, character, or logical),
@c factors, numeric matrices, lists, or other data frames.
@c @item
@c Matrices, lists, and data frames provide as many variables to the new
@c data frame as they have columns, elements, or variables, respectively.

데이터 프레임에 입력될 수 있는 자료는 반드시 (수치형, 문자형, 혹은 논리형) 벡터, 수치형 행렬, 리스트, 또는 다른 데이터 프레임이어야만 합니다. 데이터 프레임을 구성하는 각각의 열은 변수로 인식되므로, 새로운 데이터 프레임은 입력되는 행렬의 열, 리스트의 컴포넌트, 혹은 데이터 프레임의 변수의 개수만큼 자동으로 확장되어 생성되어 집니다. 데이터 프레임에 입력되는 수치형, 문자형, 그리고 논리형 벡터는 모두 요인으로 강제변환되어지고, 입력된 벡터내에 중복되지 않은 값들이 요인의 레벨로 간주되어 집니다.  

@item
Numeric vectors, logicals and factors are included as is, and by
default@footnote{Conversion of character columns to factors is
overridden using the @code{stringsAsFactors} argument to the
@code{data.frame()} function.} character vectors are coerced to be
factors, whose levels are the unique values appearing in the vector.

@c @item
@c Vector structures appearing as variables of the data frame must all have
@c the @emph{same length}, 

and matrix structures must all have the same
@emph{row size}.
@c @end itemize

데이터프레임 내에 있는 모든 변수 (즉, 벡터) 는 동일한 길이를 가져야 합니다.

@c A data frame may for many purposes be regarded as a matrix with columns
@c possibly of differing modes and attributes.  It may be displayed in
@c matrix form, and its rows and columns extracted using matrix indexing
@c conventions.

데이터 프레임을 단순히 추가적인 모드와 속성을 가진 행렬로 보아도 무방합니다. 행렬에서 인덱스 벡터와 인덱스 행렬을 이용하여 행렬의 서브셋을 구한 것과 동일한 방법으로 데이터프레임의 일부분을 서브셋 할 수 있습니다.

@menu
* Making data frames::          
* attach() and detach()::       
* Working with data frames::    
* Attaching arbitrary lists::   
* Managing the search path::    
@end menu

@node Making data frames, attach() and detach(), Data frames, Data frames
@subsection Making data frames

@c Objects satisfying the restrictions placed on the columns (components)
@c of a data frame may be used to form one using the function
@c @code{data.frame}:
@c @findex data.frame

데이터 프레임은 아래의 명령문에서 보여지는 바와 같이 data.frame이라는 함수내에 데이터 프레임에서 사용될 각각의 열에 대한 변수명과 이에 상응하는 데이터 벡터를 지정함으로서 생성할수 있습니다. 위의 예제에서 사용된 statef 는 이산형 데이터를 가지는 벡터이고, incomes 는 연속형 데이터를 가지는 벡터, 그리고 incomef는 구간화 된 값을 가지는 벡터입니다. 따라서 새로이 생성될 데이터 프레임 accountants은 home, loot, 그리고 shot 이라는 세가지 변수를 가질 것인데, home 이라는 변수는 statef의 데이터가, loot라는 변수에는 incomes의 데이터가, 그리고 shot 이라는 변수에는 incomef 이라는 데이터 벡터가 이용될 것이라는 것을 의미하게 됩니다.


@example
> accountants <- data.frame(home=statef, loot=incomes, shot=incomef)
@end example

@c A list whose components conform to the restrictions of a data frame may
@c be @emph{coerced} into a data frame using the function
@c @code{as.data.frame()}
@c @findex as.data.frame

@c The simplest way to construct a data frame from scratch is to use the
@c @code{read.table()} function to read an entire data frame from an
@c external file.  This is discussed further in @ref{Reading data from
@c files}.

만약 사용자가 이미 벡터로 구성된 리스트를 가지고 있다면, as.data.frame() 이라는 함수를 이용하여 리스트를 데이터 프레임의 형식으로 강제변환 시킬 수 있습니다. 데이터 프레임을 생성하는 가장 편리한 방법은 read.table() 이라는 함수를 이용하여 컴퓨터에 저장되어 있는 데이터 파일을 불러들어오는 것입니다. 이것에 대해서는 Reading data from files 에서 자세히 소개합니다.

@node attach() and detach(), Working with data frames, Making data frames, Data frames
@subsection @code{attach() and @code{detach()}}
@findex attach
@findex detach

@c The @code{$} notation, such as @code{accountants$home}, for list
@c components is not always very convenient.  A useful facility would be
@c somehow to make the components of a list or data frame temporarily
@c visible as variables under their component name, without the need to
@c quote the list name explicitly each time.

여러분은 스트링 ($) 연산자를 이미 리스트를 구성하는 개별 컴포넌트를 엑세스할때 사용해 보았습니다. 그러나, 데이터 프레임 accountants 에 정의 되어 있는 home 이라는 변수를 엑세스 하기 위해서 매번 accountants$home와 같이 사용하는것은 많은 불편함이 있습니다. 따라서 R 은 attach() 라는 함수를 제공하여 이러한 불편함을 줄이고자 했습니다.

@c The @code{attach()} function takes a `database' such as a list or data
@c frame as its argument.  Thus suppose @code{lentils} is a
@c data frame with three variables @code{lentils$u}, @code{lentils$v},
@c @code{lentils$w}.  The attach

예를들어 lentils$u, lentils$v, lentils$w라는 세개의 변수로 구성된 lentils 이라는 데이터 프레임이 있다고 가정합니다. 아래의 명령문에 사용된 attach() 란 함수의 사용은 R의 내부탐색경로를 자동으로 position 1(워크 스페이스에 있는 객체를 검색하는 최우선 탐색경로) 에서 position 2 (워크 스페이스 내에 존재하는 특정 객체의 내부를 검색하는 차선 탐색경로)로 변경하는 역할을 수행합니다. 따라서, attach(lentils) 라는 명령은 워크스페이스 내의 특정한 lentils 라는 데이터 프레임의 내부에서 이용되고 있는 u, v, w 이라는 객체들을 데이터 프레임의 이름없이 사용할 수 있도록 해줍니다. (만약, 전산지식이 있는 분이시라면 네이스페이스의 개념으로 이해하시는 것이 편리합니다).

@example
> attach(lentils)
@end example

@c @noindent
@c places the data frame in the search path at @w{position 2}, and provided
@c there are no variables @code{u}, @code{v} or @code{w} in @w{position 1},
@c @code{u}, @code{v} and @code{w} are available as variables from the data
@c frame in their own right.  At this point an assignment such as

attach() 를 사용하기 전에 반드시 알아야 할 점이 있습니다. 예를들어, 아래의 명령은 lentils 내 에 정의되어 있는 변수 v 와 w 를 이용하여 연산을 수행한 결과를 u 에 할당할 것을 의미합니다. 그러나 연산결과는 데이터 프레임 lentils 내에 정의된 u 에 저장되지 않습니다. 연산결과의 할당은 최우선 탐색경로 position 1로 재변경되어 새로운 u 라는 벡터를 생성해 내기 때문입니다.

@example
> u <- v+w
@end example

@c @noindent
@c does not replace the component @code{u} of the data frame, but rather
@c masks it with another variable @code{u} in the working directory at
@c @w{position 1} on the search path.  To make a permanent change to the
@c data frame itself, the simplest way is to resort once again to the
@c @code{$} notation:

만약, lentils 라는 데이터 프레임내에 있는 u 라는 변수에 연산결과를 할당하고 싶다면 반드시 아래의 명령문에서 보이는 것과 같이 $ 연산자를 사용하여야 합니다. 그러나, 변경된 u 의 값들은 lentils 라는 데이터 프레임이 detach() 라는 함수가 사용될 때까지는 육안으로 확인할 수 없습니다.

@example
> lentils$u <- v+w
@end example

@c However the new value of component @code{u} is not visible until the
@c data frame is detached and attached again.

@c To detach a data frame, use the function

아래의 detach() 란 함수는 현재 사용하고 있는 특정 데이터 프레임에 대한 탐색경로 position 2 를 position 1 로 재변경을 해주는 역할을 합니다.

@example
> detach()
@end example

@c More precisely, this statement detaches from the search path the entity
@c currently at @w{position 2}.  Thus in the present context the variables
@c @code{u}, @code{v} and @code{w} would be no longer visible, except under
@c the list notation as @code{lentils$u} and so on.  Entities at positions
@c greater than 2 on the search path can be detached by giving their number
@c to @code{detach}, but it is much safer to always use a name, for example
@c by @code{detach(lentils)} or @code{detach("lentils")}

여러 개의 데이터의 프레임을 동시에 attach()라는 함수를 이용하여 사용할 수 있기 때문에 detach(lentils) 혹은 ("lentils") 라고 데이터 프레임의 이름을 정확히 명시하는게 프로그래밍의 오류를 줄이는 방법입니다.

@quotation Note
In @R{} lists and data frames can only be attached at position 2 or
above, and what is attached is a @emph{copy} of the original object.
You can alter the attached values @emph{via} @code{assign}, but the
original list or data frame is unchanged.
@end quotation

@node Working with data frames, Attaching arbitrary lists, attach() and detach(), Data frames
@subsection Working with data frames

@c A useful convention that allows you to work with many different problems
@c comfortably together in the same working directory is

@c @itemize @bullet
@c @item
@c gather together all variables for any well defined and separate problem
@c in a data frame under a suitably informative name;
@c @item
@c when working with a problem attach the appropriate data frame at
@c @w{position 2}, and use the working directory at @w{level 1} for
@c operational quantities and temporary variables;
@c @item
@c before leaving a problem, add any variables you wish to keep for future
@c reference to the data frame using the @code{$} form of assignment, and
@c then @code{detach()};
@c @item
@c finally remove all unwanted variables from the working directory and
@c keep it as clean of left-over temporary variables as possible.
@c @end itemize

만약 여러분들이 여러 가지 분석작업을 동일한 워킹 디렉토리에서 수행하고 있다면, 아래에 나열한 몇 가지 방법들이 오류를 최소화하는데 도움이 될 것입니다. 문제를 세분화하여, 문제별로 의미가 분명한 데이터 프레임의 이름을 부여하고, 데이터 프레임내에 정의된 변수들도 그 의미를 쉽게 알수있는 변수명을 사용하도록 합니다. 특정 데이터 프레임을 position 2 로 이동시켜 작업을 하되, 임시변수의 생성 및 연산은 position 1 에서 수행하도록 합니다. position 2 에서의 특정 데이터 프레임과 연관된 연산이 끝났다면 $ 를 이용하여 그 연산결과를 저장한뒤 detach()를 이용하여 position 1 으로 돌아옵니다. 마지막으로 워킹 디렉토리에 있는 임시적으로 사용했던 변수들은 모두 삭제하도록 합니다.

In this way it is quite simple to work with many problems in the same
directory, all of which have variables named @code{x}, @code{y} and
@code{z}, for example.

@node Attaching arbitrary lists, Managing the search path, Working with data frames, Data frames
@subsection Attaching arbitrary lists

@c @code{attach()} is a generic function that allows not only directories
@c and data frames to be attached to the search path, but other classes of
@c object as well.  In particular any object of mode @code{"list"} may be
@c attached in the same way:

실제로 attach() 는 제네릭 함수 (generic function) 이므로 데이터 프레임을 특정탐색경로에 연결하는 작업 외에도 다른 크래스의 객체와의 연결에도 사용이 가능합니다. 특히 객체의 모드가 "list" 이라면 데이터 프레임과 동일한 방법으로 사용이 됩니다.

@example
> attach(any.old.list)
@end example

@c Anything that has been attached can be detached by @code{detach}, by
@c position number or, preferably, by name.

즉, attach() 에 의해서 연결된 리스트형의 객체는 detach 라는 함수에 의해서 그 연결이 종료됩니다.

@node Managing the search path,  , Attaching arbitrary lists, Data frames
@subsection Managing the search path
@findex search
@cindex Search path

@c The function @code{search} shows the current search path and so is
@c a very useful way to keep track of which data frames and lists (and
@c packages) have been attached and detached.  Initially it gives

아래에서 사용된 search 라는 함수는 현재의 객체탐색경로를 보여줌으로서 사용자가 현재 연결하여 작업하고 있는 데이터 프레임 및 리스트를 확인할 수 있도록 해줍니다. 만약, 어떠한 객체도 연결되지 않았다면 아래와 같은 결과를 보여줍니다. 여기에서 .GlobalEnv 이라는 것은 현재 작업하고 있는 워크 스페이스를 의미합니다.

@example
> search()
[1] ".GlobalEnv"   "Autoloads"    "package:base"
@end example
@noindent
where @code{.GlobalEnv} is the workspace.@footnote{See the on-line help
for @code{autoload} for the meaning of the second term.}

@c After @code{lentils} is attached we have

만약 lentils 이라는 데이터 프레임이 연결되었다면, 아래와 같은 결과를 보여지게 됩니다.

@example
> search()
[1] ".GlobalEnv"   "lentils"      "Autoloads"    "package:base"
> ls(2)
[1] "u" "v" "w"
@end example

@c @noindent
@c and as we see @code{ls} (or @code{objects}) can be used to examine the
@c contents of any position on the search path.

ls 혹은 objects 함수를 이용하여 우리는 lentils 라는 데이터 프레임이라는 어떤 객체가 있는지 확인해 볼 수 있습니다. 여기에서 함수 ls() 안에 사용된 인자 2 이라는 것은 2단계 탐색경로를 의미하는 것입니다.

@c Finally, we detach the data frame and confirm it has been removed from
@c the search path.

마지막으로 사용하고 있던 lentils 라는 데이터 프레임을 탐색경로로부터 연결해제를 한다면 아래와 같은 결과를 볼 수 있습니다.

@example
> detach("lentils")
> search()
[1] ".GlobalEnv"   "Autoloads"    "package:base"
@end example

@node Reading data from files, Probability distributions, Lists and data frames, Top
@chapter Reading data from files
@cindex Reading data from files

@c Large data objects will usually be read as values from external files
@c rather than entered during an @R{} session at the keyboard.  @R{} input
@c facilities are simple and their requirements are fairly strict and even
@c rather inflexible.  There is a clear presumption by the designers of
@c @R{} that you will be able to modify your input files using other tools,
@c such as file editors or Perl@footnote{Under UNIX, the utilities Sed or
@c Awk can be used.} to fit in with the requirements of @R{}.  Generally
@c this is very simple.

@c If variables are to be held mainly in data frames, as we strongly
@c suggest they should be, an entire data frame can be read directly with
@c the @code{read.table()} function.  There is also a more primitive input
@c function, @code{scan()}, that can be called directly.

@c For more details on importing data into @R{} and also exporting data,
@c see the @emph{R Data Import/Export} manual.

용량이 큰 데이터는 키보드로 입력하는 것보다는 외부에 저장되어 있는 데이터파일을 현재 작업하고 있는 R 세션으로 불러들이는 것이 편리하고 빠른 방법입니다. R 의 입력기능은 간단하지만, 다소 불편한 점이 없는 것은 아닙니다. R 의 개발자는 사용자가 파일 에디터 혹은 Perl 이라는 프로그래밍 언어를 이용하여 R이 데이터를 읽어들일수 있는 형식으로 변경할 수 있을 것이라는 가정하에 입력기능을 개발하였습니다. 번거로워 보이지만, 실제로 이 과정은 매우 간단합니다. 우리는 R이 데이터를 쉽게 불러올 수 있도록 사용자가 데이터 파일을 데이터프레임과 같은 형식을 가지도록 편집하는 것을 권장합니다. 만약, 데이터가 데이터 프레임과 같이 정리가 되어 있다면 read.table() 이라는 함수를 이용하여 데이터 파일안에 있는 모든 데이터를 R 세션내로 불러들일 수 있습니다. read.table() 외에도 scan() 이라는 함수를 이용하여 직접적으로 불러올 수 도 있습니다.

데이터의 입출력에 관한 더 자세한 사항에 대해서는 R Data Import/Export 이라는 문서를 참조하시길 바랍니다.

@menu
* The read.table() function::   
* The scan() function::         
* Accessing builtin datasets::  
* Editing data::                
@end menu

@node The read.table() function, The scan() function, Reading data from files, Reading data from files
@section The @code{read.table()} function
@findex read.table

@c To read an entire data frame directly, the external file will normally
@c have a special form.

데이터 프레임 전체를 한번에 불러오기 위해서는, 외부 파일이 특정한 형식을 가지고 있어야만 합니다.

@c @itemize @bullet
@c @item
@c The first line of the file should have a @emph{name} for each variable
@c in the data frame.

@c @item
@c Each additional line of the file has as its first item a @emph{row label}
@c and the values for each variable.
@c @end itemize

@c If the file has one fewer item in its first line than in its second, this
@c arrangement is presumed to be in force.  So the first few lines of a file
@c to be read as a data frame might look as follows.

데이터 파일내의 첫번째 줄은 데이터 프레임 안으로 불러올 데이터들의 변수명이 저장되어 있어야 합니다. 데이터 파일내의 변수명 다음 줄 부터는 행번호와 함께 변수값이 저장되어 있어야 합니다. 따라서 우리는 사용자가 데이터 파일을 아래와 같은 데이터 프레임의 형식을 갖출 것을 권장합니다.

@quotation
@cartouche
@example
@r{Input file form with names and row labels:}

     Price    Floor     Area   Rooms     Age  Cent.heat
01   52.00    111.0      830     5       6.2      no
02   54.75    128.0      710     5       7.5      no
03   57.50    101.0     1000     5       4.2      no
04   57.50    131.0      690     6       8.8      no
05   59.75     93.0      900     5       1.9     yes
...
@end example
@end cartouche
@end quotation

@c By default numeric items (except row labels) are read as numeric
@c variables and non-numeric variables, such as @code{Cent.heat} in the
@c example, as factors.  This can be changed if necessary.

@c The function @code{read.table()} can then be used to read the data frame
@c directly

기본적으로 R이 데이터 파일을 읽어올때, 행번호를 제외하고서 변수가 수치형 값을 가지면 수치형으로 변수가 수치형이 아니면 요인 (factor) 의 형식으로 자동변환되어 집니다. 위에 사용된 데이터 파일을 예로 들면, Price, Floor, Area, Rooms, Age 는 수치형으로 읽어들이지만, Cent.heat 라는 변수는 요인으로 읽어들입니다. 따라서 위와 같은 데이터 프레임의 형식을 가지고 있는 데이터 파일이라면 read.table() 이라는 함수를 아래와 같이 사용하여 데이터를 불러들이면 됩니다.

@example
> HousePrice <- read.table("houses.data")
@end example

@c Often you will want to omit including the row labels directly and use the
@c default labels.  In this case the file may omit the row label column as in
@c the following.

아래에 보이는 것과 같이 종종 데이터 파일에는 행번호가 없는 경우가 있거나, 혹은 사용자가 행번호를 원하지 않는 경우가 존재합니다.

@quotation
@cartouche
@example
@r{Input file form without row labels:}

Price    Floor     Area   Rooms     Age  Cent.heat
52.00    111.0      830     5       6.2      no
54.75    128.0      710     5       7.5      no
57.50    101.0     1000     5       4.2      no
57.50    131.0      690     6       8.8      no
59.75     93.0      900     5       1.9     yes
...
@end example
@end cartouche
@end quotation

@c The data frame may then be read as


이런경우에는 아래와 같이 read.table() 이라는 함수를 사용할 때 header 라는 옵션을 이용하면 됩니다.

@example
> HousePrice <- read.table("houses.data", header=TRUE)
@end example

@c @noindent
@c where the @code{header=TRUE} option specifies that the first line is a
@c line of headings, and hence, by implication from the form of the file,
@c that no explicit row labels are given.


@menu
* The scan() function::
@end menu

@node The scan() function, Accessing builtin datasets, The read.table() function, Reading data from files
@section The @code{scan()} function
@findex scan

Suppose the data vectors are of equal length and are to be read in
parallel.  Further suppose that there are three vectors, the first of
mode character and the remaining two of mode numeric, and the file is
@file{input.dat}.  The first step is to use @code{scan()} to read in the
three vectors as a list, as follows

@example
> inp <- scan("input.dat", list("",0,0))
@end example

The second argument is a dummy list structure that establishes the mode
of the three vectors to be read.  The result, held in @code{inp}, is a
list whose components are the three vectors read in.  To separate the
data items into three separate vectors, use assignments like

@example
> label <- inp[[1]]; x <- inp[[2]]; y <- inp[[3]]
@end example

More conveniently, the dummy list can have named components, in which
case the names can be used to access the vectors read in.  For example

@example
> inp <- scan("input.dat", list(id="", x=0, y=0))
@end example

If you wish to access the variables separately they may either be
re-assigned to variables in the working frame:

@example
> label <- inp$id; x <- inp$x; y <- inp$y
@end example

@noindent
or the list may be attached at @w{position 2} of the search path
(@pxref{Attaching arbitrary lists}).

If the second argument is a single value and not a list, a single vector
is read in, all components of which must be of the same mode as the
dummy value.

@example
> X <- matrix(scan("light.dat", 0), ncol=5, byrow=TRUE)
@end example

There are more elaborate input facilities available and these are
detailed in the manuals.

@node Accessing builtin datasets, Editing data, The scan() function, Reading data from files
@section Accessing builtin datasets
@cindex Accessing builtin datasets
@findex data

Around 100 datasets are supplied with @R{} (in package @pkg{datasets}),
and others are available in packages (including the recommended packages
supplied with @R{}).  To see the list of datasets currently available
use

@example
data()
@end example

@noindent
As from @R{} version 2.0.0 all the datasets supplied with @R{} are
available directly by name.  However, many packages still use the
earlier convention in which @code{data} was also used to load datasets
into @R{}, for example

@example
data(infert)
@end example

@noindent
and this can still be used with the standard packages (as in this
example).  In most cases this will load an @R{} object of the same name.
However, in a few cases it loads several objects, so see the on-line
help for the object to see what to expect.

@subsection Loading data from other R packages

To access data from a particular package, use the @code{package}
argument, for example

@example
data(package="rpart")
data(Puromycin, package="datasets")
@end example

If a package has been attached by @code{library}, its datasets are
automatically included in the search.

User-contributed packages can be a rich source of datasets.

@node Editing data,  , Accessing builtin datasets, Reading data from files
@section Editing data

@findex edit
When invoked on a data frame or matrix, @code{edit} brings up a separate
spreadsheet-like environment for editing.  This is useful for making
small changes once a data set has been read.  The command

@example
> xnew <- edit(xold)
@end example

@noindent
will allow you to edit your data set @code{xold}, and on completion the
changed object is assigned to @code{xnew}.  If you want to alter the
original dataset @code{xold}, the simplest way is to use
@code{fix(xold)}, which is equivalent to @code{xold <- edit(xold)}.

Use

@example
> xnew <- edit(data.frame())
@end example

@noindent
to enter new data via the spreadsheet interface.


@node Probability distributions, Loops and conditional execution, Reading data from files, Top
@chapter Probability distributions
@cindex Probability distributions

@menu
* R as a set of statistical tables::  
* Examining the distribution of a set of data::  
* One- and two-sample tests::   
@end menu

@node R as a set of statistical tables, Examining the distribution of a set of data, Probability distributions, Probability distributions
@section R as a set of statistical tables

One convenient use of @R{} is to provide a comprehensive set of
statistical tables.  Functions are provided to evaluate the cumulative
distribution function @eqn{P(X \le x), P(X <= x)},
the probability density function and the quantile function (given
@math{q}, the smallest @math{x} such that @eqn{P(X \le x) > q, P(X <= x) > q}),
and to simulate from the distribution.

@c @quotation

@multitable{Distribution namessss}{names, names}{arguments, arguments}
@headitem Distribution @tab @R{} name @tab additional arguments
@item beta @tab @code{beta} @tab @code{shape1, shape2, ncp}
@item binomial @tab  @code{binom} @tab @code{size, prob}
@item Cauchy @tab @code{cauchy} @tab @code{location, scale}
@item chi-squared @tab @code{chisq} @tab @code{df, ncp}
@item exponential @tab @code{exp} @tab @code{rate}
@item F @tab @code{f} @tab @code{df1, df2, ncp}
@item gamma @tab @code{gamma} @tab @code{shape, scale}
@item geometric @tab @code{geom} @tab @code{prob}
@item hypergeometric @tab @code{hyper} @tab @code{m, n, k}
@item log-normal @tab @code{lnorm} @tab @code{meanlog, sdlog}
@item logistic @tab @code{logis} @tab @code{location, scale}
@item negative binomial @tab @code{nbinom} @tab @code{size, prob}
@item normal @tab @code{norm} @tab @code{mean, sd}
@item Poisson @tab @code{pois} @tab @code{lambda}
@item signed rank @tab @code{signrank} @tab @code{n}
@item Student's t @tab @code{t} @tab @code{df, ncp}
@item uniform @tab @code{unif} @tab @code{min, max}
@item Weibull @tab @code{weibull} @tab @code{shape, scale}
@item Wilcoxon @tab @code{wilcox} @tab @code{m, n}
@end multitable

@c @end quotation

@noindent
Prefix the name given here by @samp{d} for the density, @samp{p} for the
CDF, @samp{q} for the quantile function and @samp{r} for simulation
(@emph{r}andom deviates).  The first argument is @code{x} for
@code{d@var{xxx}}, @code{q} for @code{p@var{xxx}}, @code{p} for
@code{q@var{xxx}} and @code{n} for @code{r@var{xxx}} (except for
@code{rhyper}, @code{rsignrank} and @code{rwilcox}, for which it is
@code{nn}).  In not quite all cases is the non-centrality parameter
@code{ncp} currently available: see the on-line help for details.

The @code{p@var{xxx}} and @code{q@var{xxx}} functions all have logical
arguments @code{lower.tail} and @code{log.p} and the @code{d@var{xxx}}
ones have @code{log}.  This allows, e.g., getting the cumulative (or
``integrated'') @emph{hazard} function, @eqn{H(t) = - \log(1 - F(t)),
H(t) = - log(1 - F(t))}, by

@example
 - p@var{xxx}(t, ..., lower.tail = FALSE, log.p = TRUE)
@end example

@noindent
or more accurate log-likelihoods (by @code{d@var{xxx}(..., log =
TRUE)}), directly.

In addition there are functions @code{ptukey} and @code{qtukey} for the
distribution of the studentized range of samples from a normal
distribution, and @code{dmultinom} and @code{rmultinom} for the
multinomial distribution. Further distributions are available in
contributed packages, notably @CRANpkg{SuppDists}.

Here are some examples

@example
> ## @r{2-tailed p-value for t distribution}
> 2*pt(-2.43, df = 13)
> ## @r{upper 1% point for an F(2, 7) distribution}
> qf(0.01, 2, 7, lower.tail = FALSE)
@end example

See the on-line help on @code{RNG} for how random-number generation is
done in @R{}.

@node  Examining the distribution of a set of data, One- and two-sample tests, R as a set of statistical tables, Probability distributions
@section Examining the distribution of a set of data

Given a (univariate) set of data we can examine its distribution in a
large number of ways.  The simplest is to examine the numbers.  Two
slightly different summaries are given by @code{summary} and
@code{fivenum}
@findex summary
@findex fivenum
and a display of the numbers by @code{stem} (a ``stem and leaf'' plot).
@findex stem

@example
> attach(faithful)
> summary(eruptions)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  1.600   2.163   4.000   3.488   4.454   5.100
> fivenum(eruptions)
[1] 1.6000 2.1585 4.0000 4.4585 5.1000
> stem(eruptions)

  The decimal point is 1 digit(s) to the left of the |

  16 | 070355555588
  18 | 000022233333335577777777888822335777888
  20 | 00002223378800035778
  22 | 0002335578023578
  24 | 00228
  26 | 23
  28 | 080
  30 | 7
  32 | 2337
  34 | 250077
  36 | 0000823577
  38 | 2333335582225577
  40 | 0000003357788888002233555577778
  42 | 03335555778800233333555577778
  44 | 02222335557780000000023333357778888
  46 | 0000233357700000023578
  48 | 00000022335800333
  50 | 0370
@end example

A stem-and-leaf plot is like a histogram, and @R{} has a function
@code{hist} to plot histograms.
@findex hist

@example
> hist(eruptions)
## @r{make the bins smaller, make a plot of density}
> hist(eruptions, seq(1.6, 5.2, 0.2), prob=TRUE)
> lines(density(eruptions, bw=0.1))
> rug(eruptions) # @r{show the actual data points}
@end example

@findex density
@cindex Density estimation
More elegant density plots can be made by @code{density}, and we added a
line produced by @code{density} in this example.  The bandwidth
@code{bw} was chosen by trial-and-error as the default gives too much
smoothing (it usually does for ``interesting'' densities).  (Better
automated methods of bandwidth choice are available, and in this example
@code{bw = "SJ"} gives a good result.)

@c @iftex
@c @image{images/hist,9cm} @c deleted by Chel Hee Lee
@c @end iftex

We can plot the empirical cumulative distribution function by using the
function @code{ecdf}.
@findex ecdf
@cindex Empirical CDFs

@example
> plot(ecdf(eruptions), do.points=FALSE, verticals=TRUE)
@end example

This distribution is obviously far from any standard distribution.
How about the right-hand mode, say eruptions of longer than 3 minutes?
Let us fit a normal distribution and overlay the fitted CDF.

@example
> long <- eruptions[eruptions > 3]
> plot(ecdf(long), do.points=FALSE, verticals=TRUE)
> x <- seq(3, 5.4, 0.01)
> lines(x, pnorm(x, mean=mean(long), sd=sqrt(var(long))), lty=3)
@end example

@c @iftex
@c @image{images/ecdf,9cm} @c deleted by Chel Hee Lee 
@c @end iftex

Quantile-quantile (Q-Q) plots can help us examine this more carefully.
@cindex Quantile-quantile plots
@findex qqnorm
@findex qqline

@example
par(pty="s")       # arrange for a square figure region
qqnorm(long); qqline(long)
@end example

@noindent
which shows a reasonable fit but a shorter right tail than one would
expect from a normal distribution.  Let us compare this with some
simulated data from a @math{t} distribution

@iftex
@c @image{images/QQ,7cm} @c deleted by Chel Hee Lee 
@end iftex

@example
x <- rt(250, df = 5)
qqnorm(x); qqline(x)
@end example

@noindent
which will usually (if it is a random sample) show longer tails than
expected for a normal.  We can make a Q-Q plot against the generating
distribution by

@example
qqplot(qt(ppoints(250), df = 5), x, xlab = "Q-Q plot for t dsn")
qqline(x)
@end example

Finally, we might want a more formal test of agreement with normality
(or not).  @R{} provides the Shapiro-Wilk test
@cindex Shapiro-Wilk test
@findex shapiro.test

@example
> shapiro.test(long)

         Shapiro-Wilk normality test

data:  long
W = 0.9793, p-value = 0.01052
@end example

@noindent
and the Kolmogorov-Smirnov test
@cindex Kolmogorov-Smirnov test
@findex ks.test

@example
> ks.test(long, "pnorm", mean = mean(long), sd = sqrt(var(long)))

         One-sample Kolmogorov-Smirnov test

data:  long
D = 0.0661, p-value = 0.4284
alternative hypothesis: two.sided
@end example

@noindent
(Note that the distribution theory is not valid here as we
have estimated the parameters of the normal distribution from the same
sample.)

@node One- and two-sample tests,  , Examining the distribution of a set of data, Probability distributions
@section One- and two-sample tests
@cindex One- and two-sample tests

So far we have compared a single sample to a normal distribution.  A
much more common operation is to compare aspects of two samples.  Note
that in @R{}, all ``classical'' tests including the ones used below are
in package @pkg{stats} which is normally loaded.

Consider the following sets of data on the latent heat of the fusion of
ice (@emph{cal/gm}) from Rice (1995, p.490)

@example
Method A: 79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97
          80.05 80.03 80.02 80.00 80.02
Method B: 80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97
@end example

@noindent
Boxplots provide a simple graphical comparison of the two samples.

@c NOTE scan() from stdin is not parse()able, hence not source()able
@c Hence ./R-intro.R uses c(..)
@example
A <- scan()
79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97
80.05 80.03 80.02 80.00 80.02

B <- scan()
80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97

boxplot(A, B)
@end example
@findex boxplot
@cindex Box plots

@noindent
which indicates that the first group tends to give higher results than
the second.

@iftex
@c @image{images/ice,7cm} @c deleted by Chel Hee Lee
@end iftex

To test for the equality of the means of the two examples, we can use
an @emph{unpaired} @math{t}-test by
@cindex Student's @math{t} test
@findex t.test

@example
> t.test(A, B)

         Welch Two Sample t-test

data:  A and B
t = 3.2499, df = 12.027, p-value = 0.00694
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 0.01385526 0.07018320
sample estimates:
mean of x mean of y
 80.02077  79.97875
@end example

@noindent
which does indicate a significant difference, assuming normality.  By
default the @R{} function does not assume equality of variances in the
two samples (in contrast to the similar @SPLUS{} @code{t.test}
function).  We can use the F test to test for equality in the variances,
provided that the two samples are from normal populations.

@example
> var.test(A, B)

         F test to compare two variances

data:  A and B
F = 0.5837, num df = 12, denom df =  7, p-value = 0.3938
alternative hypothesis: true ratio of variances is not equal to 1
95 percent confidence interval:
 0.1251097 2.1052687
sample estimates:
ratio of variances
         0.5837405
@end example
@findex var.test

@noindent
which shows no evidence of a significant difference, and so we can use
the classical @math{t}-test that assumes equality of the variances.

@example
> t.test(A, B, var.equal=TRUE)

         Two Sample t-test

data:  A and B
t = 3.4722, df = 19, p-value = 0.002551
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 0.01669058 0.06734788
sample estimates:
mean of x mean of y
 80.02077  79.97875
@end example

All these tests assume normality of the two samples.  The two-sample
Wilcoxon (or Mann-Whitney) test only assumes a common continuous
distribution under the null hypothesis.

@cindex Wilcoxon test
@findex wilcox.test
@example
> wilcox.test(A, B)

         Wilcoxon rank sum test with continuity correction

data:  A and B
W = 89, p-value = 0.007497
alternative hypothesis: true location shift is not equal to 0

Warning message:
Cannot compute exact p-value with ties in: wilcox.test(A, B)
@end example

@noindent
Note the warning: there are several ties in each sample, which suggests
strongly that these data are from a discrete distribution (probably due
to rounding).

There are several ways to compare graphically the two samples.  We have
already seen a pair of boxplots.  The following

@example
> plot(ecdf(A), do.points=FALSE, verticals=TRUE, xlim=range(A, B))
> plot(ecdf(B), do.points=FALSE, verticals=TRUE, add=TRUE)
@end example

@noindent
will show the two empirical CDFs, and @code{qqplot} will perform a Q-Q
plot of the two samples.  The Kolmogorov-Smirnov test is of the maximal
vertical distance between the two ecdf's, assuming a common continuous
distribution:

@example
> ks.test(A, B)

         Two-sample Kolmogorov-Smirnov test

data:  A and B
D = 0.5962, p-value = 0.05919
alternative hypothesis: two-sided

Warning message:
cannot compute correct p-values with ties in: ks.test(A, B)
@end example

@node Loops and conditional execution, Writing your own functions, Probability distributions, Top
@chapter Grouping, loops and conditional execution
@cindex Loops and conditional execution

@menu
* Grouped expressions::         
* Control statements::          
@end menu

@node Grouped expressions, Control statements, Loops and conditional execution, Loops and conditional execution
@section Grouped expressions
@cindex Grouped expressions

@R{} is an expression language in the sense that its only command type
is a function or expression which returns a result.  Even an assignment
is an expression whose result is the value assigned, and it may be used
wherever any expression may be used; in particular multiple assignments
are possible.

Commands may be grouped together in braces, @code{@{@var{expr_1};
@var{@dots{}}; @var{expr_m}@}}, in which case the value of the group
is the result of the last expression in the group evaluated.  Since such
a group is also an expression it may, for example, be itself included in
parentheses and used a part of an even larger expression, and so on.

@node Control statements,  , Grouped expressions, Loops and conditional execution
@section Control statements
@cindex Control statements

@menu
* Conditional execution::       
* Repetitive execution::        
@end menu

@node Conditional execution, Repetitive execution, Control statements, Control statements
@subsection Conditional execution: @code{if} statements
@findex if

The language has available a conditional construction of the form

@example
> if (@var{expr_1}) @var{expr_2} else @var{expr_3}
@end example
@findex if
@findex else

@noindent
where @var{expr_1} must evaluate to a single logical value and the
result of the entire expression is then evident.

@findex &&
@findex ||
The ``short-circuit'' operators @code{&&} and @code{||} are often used
as part of the condition in an @code{if} statement.  Whereas @code{&}
and @code{|} apply element-wise to vectors, @code{&&} and @code{||}
apply to vectors of length one, and only evaluate their second argument
if necessary.

@findex ifelse
There is a vectorized version of the @code{if}/@code{else} construct,
the @code{ifelse} function.  This has the form @code{ifelse(condition, a,
b)} and returns a vector of the length of its longest argument, with
elements @code{a[i]} if @code{condition[i]} is true, otherwise
@code{b[i]}.


@node Repetitive execution,  , Conditional execution, Control statements
@subsection Repetitive execution: @code{for} loops, @code{repeat} and @code{while}
@findex for

There is also a @code{for} loop construction which has the form

@example
> for (@code{@var{name}} in @var{expr_1}) @var{expr_2}
@end example

@noindent
where @code{@var{name}} is the loop variable.  @var{expr_1} is a
vector expression, (often a sequence like @code{1:20}), and
@var{expr_2} is often a grouped expression with its sub-expressions
written in terms of the dummy @emph{name}.  @var{expr_2} is repeatedly
evaluated as @var{name} ranges through the values in the vector result
of @var{expr_1}.

As an example, suppose @code{ind} is a vector of class indicators and we
wish to produce separate plots of @code{y} versus @code{x} within
classes.  One possibility here is to use @code{coplot()},@footnote{to be
discussed later, or use @code{xyplot} from package @CRANpkg{lattice}.}
which will produce an array of plots corresponding to each level of the
factor.  Another way to do this, now putting all plots on the one
display, is as follows:

@example
> xc <- split(x, ind)
> yc <- split(y, ind)
> for (i in 1:length(yc)) @{
    plot(xc[[i]], yc[[i]])
    abline(lsfit(xc[[i]], yc[[i]]))
  @}
@end example

@findex split

(Note the function @code{split()} which produces a list of vectors
obtained by splitting a larger vector according to the classes specified
by a factor.  This is a useful function, mostly used in connection
with boxplots.  See the @code{help} facility for further details.)

@quotation
@strong{Warning}: @code{for()} loops are used in @R{} code much less
often than in compiled languages.  Code that takes a `whole object' view
is likely to be both clearer and faster in @R{}.
@end quotation

Other looping facilities include the

@example
> repeat @var{expr}
@end example
@findex repeat

@noindent
statement and the

@example
> while (@var{condition}) @var{expr}
@end example
@findex while

@noindent
statement.

The @code{break} statement can be used to terminate any loop, possibly
abnormally.  This is the only way to terminate @code{repeat} loops.
@findex break

The @code{next} statement can be used to discontinue one particular
cycle and skip to the ``next''.
@findex next

Control statements are most often used in connection with
@emph{functions} which are discussed in @ref{Writing your own
functions}, and where more examples will emerge.


@node Writing your own functions, Statistical models in R, Loops and conditional execution, Top
@chapter Writing your own functions
@cindex Writing functions

As we have seen informally along the way, the @R{} language allows the
user to create objects of mode @emph{function}.  These are true @R{}
functions that are stored in a special internal form and may be used in
further expressions and so on.  In the process, the language gains
enormously in power, convenience and elegance, and learning to write
useful functions is one of the main ways to make your use of @R{}
comfortable and productive.

It should be emphasized that most of the functions supplied as part of
the @R{} system, such as @code{mean()}, @code{var()},
@code{postscript()} and so on, are themselves written in @R{} and thus
do not differ materially from user written functions.

A function is defined by an assignment of the form

@example
> @var{name} <- function(@var{arg_1}, @var{arg_2}, @dots{}) @var{expression}
@end example
@findex function

@noindent
The @var{expression} is an @R{} expression, (usually a grouped
expression), that uses the arguments, @var{arg_i}, to calculate a value.
The value of the expression is the value returned for the function.

A call to the function then usually takes the form
@code{@var{name}(@var{expr_1}, @var{expr_2}, @dots{})} and may occur
anywhere a function call is legitimate.

@menu
* Simple examples::             
* Defining new binary operators::  
* Named arguments and defaults::  
* The three dots argument::     
* Assignment within functions::  
* More advanced examples::      
* Scope::                       
* Customizing the environment::  
* Object orientation::          
@end menu

@node Simple examples, Defining new binary operators, Writing your own functions, Writing your own functions
@section Simple examples

As a first example, consider a function to calculate the two sample
@math{t}-statistic, showing ``all the steps''.  This is an artificial
example, of course, since there are other, simpler ways of achieving the
same end.

The function is defined as follows:

@example
> twosam <- function(y1, y2) @{
    n1  <- length(y1); n2  <- length(y2)
    yb1 <- mean(y1);   yb2 <- mean(y2)
    s1  <- var(y1);    s2  <- var(y2)
    s <- ((n1-1)*s1 + (n2-1)*s2)/(n1+n2-2)
    tst <- (yb1 - yb2)/sqrt(s*(1/n1 + 1/n2))
    tst
  @}
@end example

With this function defined, you could perform two sample @math{t}-tests
using a call such as

@example
> tstat <- twosam(data$male, data$female); tstat
@end example

As a second example, consider a function to emulate directly the
@sc{Matlab} backslash command, which returns the coefficients of the
orthogonal projection of the vector @math{y} onto the column space of
the matrix, @math{X}.  (This is ordinarily called the least squares
estimate of the regression coefficients.)  This would ordinarily be
done with the @code{qr()} function; however this is sometimes a bit
tricky to use directly and it pays to have a simple function such as the
following to use it safely.

Thus given a @math{n} by @math{1} vector @math{y} and an @math{n} by
@math{p} matrix @math{X} then @math{X \ y} is defined as
@ifnottex
(X'X)^@{-@}X'y, where (X'X)^@{-@}
@end ifnottex
@tex
$(X^T X)^{-}X^T y$, where $(X^T X)^{-}$
@end tex
is a generalized inverse of @math{X'X}.

@example
> bslash <- function(X, y) @{
  X <- qr(X)
  qr.coef(X, y)
@}
@end example

After this object is created it may be used in statements such as

@example
> regcoeff <- bslash(Xmat, yvar)
@end example

@noindent
and so on.

The classical @R{} function @code{lsfit()} does this job quite well, and
more@footnote{See also the methods described in @ref{Statistical models
in R}}.  It in turn uses the functions @code{qr()} and @code{qr.coef()}
in the slightly counterintuitive way above to do this part of the
calculation.  Hence there is probably some value in having just this
part isolated in a simple to use function if it is going to be in
frequent use.  If so, we may wish to make it a matrix binary operator
for even more convenient use.

@node Defining new binary operators, Named arguments and defaults, Simple examples, Writing your own functions
@section Defining new binary operators
@cindex Binary operators

Had we given the @code{bslash()} function a different name, namely one of
the form

@example
%@var{anything}%
@end example

@noindent
it could have been used as a @emph{binary operator} in expressions
rather than in function form.  Suppose, for example, we choose @code{!}
for the internal character.  The function definition would then start as

@example
> "%!%" <- function(X, y) @{ @dots{} @}
@end example

@noindent
(Note the use of quote marks.)  The function could then be used as
@code{X %!% y}.  (The backslash symbol itself is not a convenient choice
as it presents special problems in this context.)

The matrix multiplication operator, @code{%*%}, and the outer product
matrix operator @code{%o%} are other examples of binary operators
defined in this way.

@node Named arguments and defaults, The three dots argument, Defining new binary operators, Writing your own functions
@section Named arguments and defaults
@cindex Named arguments
@cindex Default values

As first noted in @ref{Generating regular sequences}, if arguments to
called functions are given in the ``@code{@var{name}=@var{object}}''
form, they may be given in any order.  Furthermore the argument sequence
may begin in the unnamed, positional form, and specify named arguments
after the positional arguments.

Thus if there is a function @code{fun1} defined by

@example
> fun1 <- function(data, data.frame, graph, limit) @{
    @r{[function body omitted]}
  @}
@end example

@noindent
then the function may be invoked in several ways, for example

@example
> ans <- fun1(d, df, TRUE, 20)
> ans <- fun1(d, df, graph=TRUE, limit=20)
> ans <- fun1(data=d, limit=20, graph=TRUE, data.frame=df)
@end example

@noindent
are all equivalent.

In many cases arguments can be given commonly appropriate default
values, in which case they may be omitted altogether from the call when
the defaults are appropriate.  For example, if @code{fun1} were defined
as

@example
> fun1 <- function(data, data.frame, graph=TRUE, limit=20) @{ @dots{} @}
@end example

@noindent
it could be called as

@example
> ans <- fun1(d, df)
@end example

@noindent
which is now equivalent to the three cases above, or as

@example
> ans <- fun1(d, df, limit=10)
@end example

@noindent
which changes one of the defaults.

It is important to note that defaults may be arbitrary expressions, even
involving other arguments to the same function; they are not restricted
to be constants as in our simple example here.

@node The three dots argument, Assignment within functions, Named arguments and defaults, Writing your own functions
@section The @samp{@dots{}} argument

@c The ?Reserved topic links here, so please update it
@c if changing the node name.

Another frequent requirement is to allow one function to pass on
argument settings to another.  For example many graphics functions use
the function @code{par()} and functions like @code{plot()} allow the
user to pass on graphical parameters to @code{par()} to control the
graphical output.  (@xref{The par() function}, for more details on the
@code{par()} function.)  This can be done by including an extra
argument, literally @samp{@dots{}}, of the function, which may then be
passed on.  An outline example is given below.

@example
fun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) @{
  @r{[omitted statements]}
  if (graph)
    par(pch="*", ...)
  @r{[more omissions]}
@}
@end example

Less frequently, a function will need to refer to components of
@samp{@dots{}}.  The expression @code{list(...)} evaluates all such
arguments and returns them in a named list, while @code{..1},
@code{..2}, etc. evaluate them one at a time, with @samp{..n}
returning the n'th unmatched argument.

@node Assignment within functions, More advanced examples, The three dots argument, Writing your own functions
@section Assignments within functions

Note that @emph{any ordinary assignments done within the function are
local and temporary and are lost after exit from the function}.  Thus
the assignment @code{X <- qr(X)} does not affect the value of the
argument in the calling program.

To understand completely the rules governing the scope of @R{} assignments
the reader needs to be familiar with the notion of an evaluation
@emph{frame}.  This is a somewhat advanced, though hardly difficult,
topic and is not covered further here.

If global and permanent assignments are intended within a function, then
either the ``superassignment'' operator, @code{<<-} or the function
@code{assign()} can be used.  See the @code{help} document for details.
@SPLUS{} users should be aware that @code{<<-} has different semantics
in @R{}.  These are discussed further in @ref{Scope}.

@node More advanced examples, Scope, Assignment within functions, Writing your own functions
@section More advanced examples

@menu
* Efficiency factors in block designs::  
* Dropping all names in a printed array::  
* Recursive numerical integration::  
@end menu

@node Efficiency factors in block designs, Dropping all names in a printed array, More advanced examples, More advanced examples
@subsection Efficiency factors in block designs

As a more complete, if a little pedestrian, example of a function,
consider finding the efficiency factors for a block design.  (Some
aspects of this problem have already been discussed in @ref{Index
matrices}.)

A block design is defined by two factors, say @code{blocks} (@code{b}
levels) and @code{varieties} (@code{v} levels).  If @math{R} and
@math{K} are the @math{v} by @math{v} and @math{b} by @math{b}
@emph{replications} and @emph{block size} matrices, respectively, and
@math{N} is the @math{b} by @math{v} incidence matrix, then the
efficiency factors are defined as the eigenvalues of the matrix
@ifnottex
E = I_v - R^@{-1/2@}N'K^@{-1@}NR^@{-1/2@} = I_v - A'A, where
A = K^@{-1/2@}NR^@{-1/2@}.
@end ifnottex
@tex
$$E = I_v - R^{-1/2}N^T K^{-1}NR^{-1/2} = I_v - A^T A,$$
where $A = K^{-1/2}NR^{-1/2}$.
@end tex
One way to write the function is given below.

@example
> bdeff <- function(blocks, varieties) @{
    blocks <- as.factor(blocks)             # @r{minor safety move}
    b <- length(levels(blocks))
    varieties <- as.factor(varieties)       # @r{minor safety move}
    v <- length(levels(varieties))
    K <- as.vector(table(blocks))           # @r{remove dim attr}
    R <- as.vector(table(varieties))        # @r{remove dim attr}
    N <- table(blocks, varieties)
    A <- 1/sqrt(K) * N * rep(1/sqrt(R), rep(b, v))
    sv <- svd(A)
    list(eff=1 - sv$d^2, blockcv=sv$u, varietycv=sv$v)
@}
@end example

It is numerically slightly better to work with the singular value
decomposition on this occasion rather than the eigenvalue routines.

The result of the function is a list giving not only the efficiency
factors as the first component, but also the block and variety canonical
contrasts, since sometimes these give additional useful qualitative
information.

@node Dropping all names in a printed array, Recursive numerical integration, Efficiency factors in block designs, More advanced examples
@subsection Dropping all names in a printed array

For printing purposes with large matrices or arrays, it is often useful
to print them in close block form without the array names or numbers.
Removing the @code{dimnames} attribute will not achieve this effect, but
rather the array must be given a @code{dimnames} attribute consisting of
empty strings.  For example to print a matrix, @code{X}

@example
> temp <- X
> dimnames(temp) <- list(rep("", nrow(X)), rep("", ncol(X)))
> temp; rm(temp)
@end example

This can be much more conveniently done using a function,
@code{no.dimnames()}, shown below, as a ``wrap around'' to achieve the
same result.  It also illustrates how some effective and useful user
functions can be quite short.

@example
no.dimnames <- function(a) @{
  ## @r{Remove all dimension names from an array for compact printing.}
  d <- list()
  l <- 0
  for(i in dim(a)) @{
    d[[l <- l + 1]] <- rep("", i)
  @}
  dimnames(a) <- d
  a
@}
@end example

With this function defined, an array may be printed in close format
using

@example
> no.dimnames(X)
@end example

This is particularly useful for large integer arrays, where patterns are
the real interest rather than the values.

@node Recursive numerical integration,  , Dropping all names in a printed array, More advanced examples
@subsection Recursive numerical integration

Functions may be recursive, and may themselves define functions within
themselves.  Note, however, that such functions, or indeed variables,
are not inherited by called functions in higher evaluation frames as
they would be if they were on the search path.

The example below shows a naive way of performing one-dimensional
numerical integration.  The integrand is evaluated at the end points of
the range and in the middle.  If the one-panel trapezium rule answer is
close enough to the two panel, then the latter is returned as the value.
Otherwise the same process is recursively applied to each panel.  The
result is an adaptive integration process that concentrates function
evaluations in regions where the integrand is farthest from linear.
There is, however, a heavy overhead, and the function is only
competitive with other algorithms when the integrand is both smooth and
very difficult to evaluate.

The example is also given partly as a little puzzle in @R{} programming.

@example
area <- function(f, a, b, eps = 1.0e-06, lim = 10) @{
  fun1 <- function(f, a, b, fa, fb, a0, eps, lim, fun) @{
    ## @r{function `fun1' is only visible inside `area'}
    d <- (a + b)/2
    h <- (b - a)/4
    fd <- f(d)
    a1 <- h * (fa + fd)
    a2 <- h * (fd + fb)
    if(abs(a0 - a1 - a2) < eps || lim == 0)
      return(a1 + a2)
    else @{
      return(fun(f, a, d, fa, fd, a1, eps, lim - 1, fun) +
             fun(f, d, b, fd, fb, a2, eps, lim - 1, fun))
    @}
  @}
  fa <- f(a)
  fb <- f(b)
  a0 <- ((fa + fb) * (b - a))/2
  fun1(f, a, b, fa, fb, a0, eps, lim, fun1)
@}
@end example

@menu
* Scope::
* Object orientation::
@end menu

@node Scope, Customizing the environment, More advanced examples, Writing your own functions
@section Scope
@cindex Scope

The discussion in this section is somewhat more technical than in other
parts of this document.  However, it details one of the major differences
between @SPLUS{} and @R{}.

The symbols which occur in the body of a function can be divided into
three classes; formal parameters, local variables and free variables.
The formal parameters of a function are those occurring in the argument
list of the function.  Their values are determined by the process of
@emph{binding} the actual function arguments to the formal parameters.
Local variables are those whose values are determined by the evaluation
of expressions in the body of the functions.  Variables which are not
formal parameters or local variables are called free variables.  Free
variables become local variables if they are assigned to.  Consider the
following function definition.

@example
f <- function(x) @{
  y <- 2*x
  print(x)
  print(y)
  print(z)
@}
@end example

In this function, @code{x} is a formal parameter, @code{y} is a local
variable and @code{z} is a free variable.

In @R{} the free variable bindings are resolved by first looking in the
environment in which the function was created.  This is called
@emph{lexical scope}.  First we define a function called @code{cube}.

@example
cube <- function(n) @{
  sq <- function() n*n
  n*sq()
@}
@end example

The variable @code{n} in the function @code{sq} is not an argument to that
function.  Therefore it is a free variable and the scoping rules must be
used to ascertain the value that is to be associated with it.  Under static
scope (@SPLUS{}) the value is that associated with a global variable named
@code{n}.  Under lexical scope (@R{}) it is the parameter to the function
@code{cube} since that is the active binding for the variable @code{n} at
the time the function @code{sq} was defined.  The difference between
evaluation in @R{} and evaluation in @SPLUS{} is that @SPLUS{} looks for a
global variable called @code{n} while @R{} first looks for a variable
called @code{n} in the environment created when @code{cube} was invoked.

@example
## @r{first evaluation in S}
S> cube(2)
Error in sq(): Object "n" not found
Dumped
S> n <- 3
S> cube(2)
[1] 18
## @r{then the same function evaluated in R}
R> cube(2)
[1] 8
@end example

Lexical scope can also be used to give functions @emph{mutable state}.
In the following example we show how @R{} can be used to mimic a bank
account.  A functioning bank account needs to have a balance or total, a
function for making withdrawals, a function for making deposits and a
function for stating the current balance.  We achieve this by creating
the three functions within @code{account} and then returning a list
containing them.  When @code{account} is invoked it takes a numerical
argument @code{total} and returns a list containing the three functions.
Because these functions are defined in an environment which contains
@code{total}, they will have access to its value.

The special assignment operator, @code{<<-},
@findex <<-
is used to change the value associated with @code{total}.  This operator
looks back in enclosing environments for an environment that contains
the symbol @code{total} and when it finds such an environment it
replaces the value, in that environment, with the value of right hand
side.  If the global or top-level environment is reached without finding
the symbol @code{total} then that variable is created and assigned to
there.  For most users @code{<<-} creates a global variable and assigns
the value of the right hand side to it@footnote{In some sense this
mimics the behavior in @SPLUS{} since in @SPLUS{} this operator always
creates or assigns to a global variable.}.  Only when @code{<<-} has
been used in a function that was returned as the value of another
function will the special behavior described here occur.

@example
open.account <- function(total) @{
  list(
    deposit = function(amount) @{
      if(amount <= 0)
        stop("Deposits must be positive!\n")
      total <<- total + amount
      cat(amount, "deposited.  Your balance is", total, "\n\n")
    @},
    withdraw = function(amount) @{
      if(amount > total)
        stop("You don't have that much money!\n")
      total <<- total - amount
      cat(amount, "withdrawn.  Your balance is", total, "\n\n")
    @},
    balance = function() @{
      cat("Your balance is", total, "\n\n")
    @}
  )
@}

ross <- open.account(100)
robert <- open.account(200)

ross$withdraw(30)
ross$balance()
robert$balance()

ross$deposit(50)
ross$balance()
ross$withdraw(500)
@end example

@node Customizing the environment, Object orientation, Scope, Writing your own functions
@section Customizing the environment
@cindex Customizing the environment

Users can customize their environment in several different ways.  There
is a site initialization file and every directory can have its own
special initialization file.  Finally, the special functions
@code{.First} and @code{.Last} can be used.

The location of the site initialization file is taken from the value of
the @env{R_PROFILE} environment variable.  If that variable is unset,
the file @file{Rprofile.site} in the @R{} home subdirectory @file{etc} is
used.  This file should contain the commands that you want to execute
every time @R{} is started under your system.  A second, personal,
profile file named @file{.Rprofile}@footnote{So it is hidden under
UNIX.} can be placed in any directory.  If @R{} is invoked in that
directory then that file will be sourced.  This file gives individual
users control over their workspace and allows for different startup
procedures in different working directories.  If no @file{.Rprofile}
file is found in the startup directory, then @R{} looks for a
@file{.Rprofile} file in the user's home directory and uses that (if it
exists).  If the environment variable @env{R_PROFILE_USER} is set, the
file it points to is used instead of the @file{.Rprofile} files.

Any function named @code{.First()} in either of the two profile files or
in the @file{.RData} image has a special status.  It is automatically
performed at the beginning of an @R{} session and may be used to
initialize the environment.  For example, the definition in the example
below alters the prompt to @code{$} and sets up various other useful
things that can then be taken for granted in the rest of the session.

Thus, the sequence in which files are executed is, @file{Rprofile.site},
the user profile, @file{.RData} and then @code{.First()}.  A definition
in later files will mask definitions in earlier files.

@example
> .First <- function() @{
  options(prompt="$ ", continue="+\t")  # @r{@code{$} is the prompt}
  options(digits=5, length=999)         # @r{custom numbers and printout}
  x11()                                 # @r{for graphics}
  par(pch = "+")                        # @r{plotting character}
  source(file.path(Sys.getenv("HOME"), "R", "mystuff.R"))
                                        # @r{my personal functions}
  library(MASS)                         # @r{attach a package}
@}
@end example
@findex .First

Similarly a function @code{.Last()}, if defined, is (normally) executed
at the very end of the session.  An example is given below.

@example
> .Last <- function() @{
  graphics.off()                        # @r{a small safety measure.}
  cat(paste(date(),"\nAdios\n"))        # @r{Is it time for lunch?}
@}
@end example
@findex .Last

@node Object orientation,  , Customizing the environment, Writing your own functions
@section Classes, generic functions and object orientation
@cindex Classes
@cindex Generic functions
@cindex Object orientation

The class of an object determines how it will be treated by what are
known as @emph{generic} functions.  Put the other way round, a generic
function performs a task or action on its arguments @emph{specific to
the class of the argument itself}.  If the argument lacks any @code{class}
attribute, or has a class not catered for specifically by the generic
function in question, there is always a @emph{default action} provided.

An example makes things clearer.  The class mechanism offers the user
the facility of designing and writing generic functions for special
purposes.  Among the other generic functions are @code{plot()} for
displaying objects graphically, @code{summary()} for summarizing
analyses of various types, and @code{anova()} for comparing statistical
models.

The number of generic functions that can treat a class in a specific way
can be quite large.  For example, the functions that can accommodate in
some fashion objects of class @code{"data.frame"} include

@example
[     [[<-    any    as.matrix
[<-   mean    plot   summary
@end example

@findex methods
A currently complete list can be got by using the @code{methods()}
function:

@example
> methods(class="data.frame")
@end example

Conversely the number of classes a generic function can handle can also
be quite large.  For example the @code{plot()} function has a default
method and variants for objects of classes @code{"data.frame"},
@code{"density"}, @code{"factor"}, and more.  A complete list can be got
again by using the @code{methods()} function:

@example
> methods(plot)
@end example

For many generic functions the function body is quite short, for example

@example
> coef
function (object, ...)
UseMethod("coef")
@end example

@noindent
The presence of @code{UseMethod} indicates this is a generic function.
To see what methods are available we can use @code{methods()}

@example
> methods(coef)
[1] coef.aov*         coef.Arima*       coef.default*     coef.listof*
[5] coef.nls*         coef.summary.nls*

   Non-visible functions are asterisked
@end example

@noindent
In this example there are six methods, none of which can be seen by
typing its name.  We can read these by either of

@findex getAnywhere
@findex getS3method
@example
> getAnywhere("coef.aov")
A single object matching 'coef.aov' was found
It was found in the following places
  registered S3 method for coef from namespace stats
  namespace:stats
with value

function (object, ...)
@{
    z <- object$coef
    z[!is.na(z)]
@}

> getS3method("coef", "aov")
function (object, ...)
@{
    z <- object$coef
    z[!is.na(z)]
@}
@end example


The reader is referred to the @emph{R Language Definition} for a more
complete discussion of this mechanism.


@node Statistical models in R, Graphics, Writing your own functions, Top
@chapter Statistical models in R
@cindex Statistical models

This section presumes the reader has some familiarity with statistical
methodology, in particular with regression analysis and the analysis of
variance.  Later we make some rather more ambitious presumptions, namely
that something is known about generalized linear models and nonlinear
regression.

The requirements for fitting statistical models are sufficiently well
defined to make it possible to construct general tools that apply in a
broad spectrum of problems.

@R{} provides an interlocking suite of facilities that make fitting
statistical models very simple.  As we mention in the introduction, the
basic output is minimal, and one needs to ask for the details by calling
extractor functions.

@menu
* Formulae for statistical models::  
* Linear models::               
* Generic functions for extracting model information::  
* Analysis of variance and model comparison::  
* Updating fitted models::      
* Generalized linear models::   
* Nonlinear least squares and maximum likelihood models::  
* Some non-standard models::    
@end menu

@node Formulae for statistical models, Linear models, Statistical models in R, Statistical models in R
@section Defining statistical models; formulae
@cindex Formulae

The template for a statistical model is a linear regression model with
independent, homoscedastic errors

@ifnottex
@display
y_i = sum_@{j=0@}^p beta_j x_@{ij@} + e_i, @ @ @ @ i = 1, @dots{}, n,
@end display
@noindent
where the e_i are NID(0, sigma^2).
@end ifnottex
@tex
$$ y_i = \sum_{j=0}^p \beta_j x_{ij} + e_i,
   \qquad e_i \sim {\rm NID}(0,\sigma^2),
   \qquad i = 1, @dots{}, n
$$
@end tex
In matrix terms this would be written

@ifnottex
@display
y = X @ beta + e
@end display
@end ifnottex
@tex
$$ y = X \beta + e $$
@end tex

@noindent
where the @math{y} is the response vector, @math{X} is the @emph{model
matrix} or @emph{design matrix} and has columns
@math{x_0, x_1, @dots{}, x_p},
the determining variables.  Very often @math{x_0}
will be a column of ones defining an @emph{intercept} term.

@subsubheading Examples

Before giving a formal specification, a few examples may usefully set
the picture.

Suppose @code{y}, @code{x}, @code{x0}, @code{x1}, @code{x2}, @dots{} are
numeric variables, @code{X} is a matrix and @code{A}, @code{B},
@code{C}, @dots{} are factors.  The following formulae on the left
side below specify statistical models as described on the right.

@table @code
@item y ~ x
@itemx y ~ 1 + x
Both imply the same simple linear regression model of @math{y} on
@math{x}.  The first has an implicit intercept term, and the second an
explicit one.

@item y ~ 0 + x
@itemx y ~ -1 + x
@itemx y ~ x - 1
Simple linear regression of @math{y} on @math{x} through the origin
(that is, without an intercept term).

@item log(y) ~ x1 + x2
Multiple regression of the transformed variable,
@ifnottex
log(y),
@end ifnottex
@tex
$\log(y)$,
@end tex
on @math{x1} and @math{x2} (with an implicit intercept term).

@item y ~ poly(x,2)
@itemx y ~ 1 + x + I(x^2)
Polynomial regression of @math{y} on @math{x} of degree 2.  The first
form uses orthogonal polynomials, and the second uses explicit powers,
as basis.

@item y ~ X + poly(x,2)
Multiple regression @math{y} with model matrix consisting of the matrix
@math{X} as well as polynomial terms in @math{x} to degree 2.

@item y ~ A
Single classification analysis of variance model of @math{y}, with
classes determined by @math{A}.

@item y ~ A + x
Single classification analysis of covariance model of @math{y}, with
classes determined by @math{A}, and with covariate @math{x}.

@item y ~ A*B
@itemx y ~ A + B + A:B
@itemx y ~ B %in% A
@itemx y ~ A/B
Two factor non-additive model of @math{y} on @math{A} and @math{B}.  The
first two specify the same crossed classification and the second two
specify the same nested classification.  In abstract terms all four
specify the same model subspace.

@item y ~ (A + B + C)^2
@itemx y ~ A*B*C - A:B:C
Three factor experiment but with a model containing main effects and two
factor interactions only.  Both formulae specify the same model.

@item y ~ A * x
@itemx y ~ A/x
@itemx y ~ A/(1 + x) - 1
Separate simple linear regression models of @math{y} on @math{x} within
the levels of @math{A}, with different codings.  The last form produces
explicit estimates of as many different intercepts and slopes as there
are levels in @math{A}.

@item y ~ A*B + Error(C)
An experiment with two treatment factors, @math{A} and @math{B}, and
error strata determined by factor @math{C}.  For example a split plot
experiment, with whole plots (and hence also subplots), determined by
factor @math{C}.
@end table

@findex ~
The operator @code{~} is used to define a @emph{model formula} in @R{}.
The form, for an ordinary linear model, is

@example
@var{response} ~ @var{op_1} @var{term_1} @var{op_2} @var{term_2} @var{op_3} @var{term_3} @var{@dots{}}
@end example

@noindent
where

@table @var
@item response
is a vector or matrix, (or expression evaluating to a vector or matrix)
defining the response variable(s).
@item op_i
is an operator, either @code{+} or @code{-}, implying the inclusion or
exclusion of a term in the model, (the first is optional).
@item term_i
is either
@itemize @bullet
@item
a vector or matrix expression, or @code{1},
@item
a factor, or
@item
a @emph{formula expression} consisting of factors, vectors or matrices
connected by @emph{formula operators}.
@end itemize
In all cases each term defines a collection of columns either to be
added to or removed from the model matrix.  A @code{1} stands for an
intercept column and is by default included in the model matrix unless
explicitly removed.

@end table

The @emph{formula operators} are similar in effect to the Wilkinson and
Rogers notation used by such programs as Glim and Genstat.  One
inevitable change is that the operator @samp{@code{.}} becomes
@samp{@code{:}} since the period is a valid name character in @R{}.

The notation is summarized below (based on Chambers & Hastie, 1992,
p.29):

@table @code
@item @var{Y} ~ @var{M}
@var{Y} is modeled as @var{M}.

@item @var{M_1} + @var{M_2}
Include @var{M_1} and @var{M_2}.

@item @var{M_1} - @var{M_2}
Include @var{M_1} leaving out terms of @var{M_2}.

@item @var{M_1} : @var{M_2}
The tensor product of @var{M_1} and @var{M_2}.  If both terms are
factors, then the ``subclasses'' factor.

@item @var{M_1} %in% @var{M_2}
Similar to @code{@var{M_1}:@var{M_2}}, but with a different coding.

@item @var{M_1} * @var{M_2}
@code{@var{M_1} + @var{M_2} + @var{M_1}:@var{M_2}}.

@item @var{M_1} / @var{M_2}
@code{@var{M_1} + @var{M_2} %in% @var{M_1}}.

@item @var{M}^@var{n}
All terms in @var{M} together with ``interactions'' up to order @var{n}

@item I(@var{M})
Insulate @var{M}.  Inside @var{M} all operators have their normal
arithmetic meaning, and that term appears in the model matrix.
@end table

Note that inside the parentheses that usually enclose function arguments
all operators have their normal arithmetic meaning.  The function
@code{I()} is an identity function used to allow terms in model formulae
to be defined using arithmetic operators.

Note particularly that the model formulae specify the @emph{columns
of the model matrix}, the specification of the parameters being
implicit.  This is not the case in other contexts, for example in
specifying nonlinear models.

@menu
* Contrasts::                   
@end menu

@node Contrasts,  , Formulae for statistical models, Formulae for statistical models
@subsection Contrasts
@cindex Contrasts

We need at least some idea how the model formulae specify the columns of
the model matrix.  This is easy if we have continuous variables, as each
provides one column of the model matrix (and the intercept will provide
a column of ones if included in the model).

@cindex Factors
@cindex Ordered factors
What about a @math{k}-level factor @code{A}?  The answer differs for
unordered and ordered factors.  For @emph{unordered} factors @math{k -
1} columns are generated for the indicators of the second, @dots{},
@math{k}th levels of the factor. (Thus the implicit parameterization is
to contrast the response at each level with that at the first.)  For
@emph{ordered} factors the @math{k - 1} columns are the orthogonal
polynomials on @math{1, @dots{}, k}, omitting the constant term.

Although the answer is already complicated, it is not the whole story.
First, if the intercept is omitted in a model that contains a factor
term, the first such term is encoded into @math{k} columns giving the
indicators for all the levels.  Second, the whole behavior can be
changed by the @code{options} setting for @code{contrasts}.  The default
setting in @R{} is

@example
options(contrasts = c("contr.treatment", "contr.poly"))
@end example

@noindent
The main reason for mentioning this is that @R{} and @Sl{} have
different defaults for unordered factors, @Sl{} using Helmert
contrasts.  So if you need to compare your results to those of a textbook
or paper which used @SPLUS{}, you will need to set

@example
options(contrasts = c("contr.helmert", "contr.poly"))
@end example

@noindent
This is a deliberate difference, as treatment contrasts (@R{}'s default)
are thought easier for newcomers to interpret.

We have still not finished, as the contrast scheme to be used can be set
for each term in the model using the functions @code{contrasts} and
@code{C}.
@findex contrasts
@findex C

We have not yet considered interaction terms: these generate the
products of the columns introduced for their component terms.

Although the details are complicated, model formulae in @R{} will
normally generate the models that an expert statistician would expect,
provided that marginality is preserved.  Fitting, for example, a model
with an interaction but not the corresponding main effects will in
general lead to surprising results, and is for experts only.


@node Linear models, Generic functions for extracting model information, Formulae for statistical models, Statistical models in R
@section Linear models
@cindex Linear models

The basic function for fitting ordinary multiple models is @code{lm()},
and a streamlined version of the call is as follows:
@findex lm

@example
> @var{fitted.model} <- lm(@var{formula}, data = @var{data.frame})
@end example

For example

@example
> fm2 <- lm(y ~ x1 + x2, data = production)
@end example

@noindent
would fit a multiple regression model of @math{y} on @math{x1} and
@math{x2} (with implicit intercept term).

The important (but technically optional) parameter @code{data =
production} specifies that any variables needed to construct the model
should come first from the @code{production} @emph{data frame}.
@emph{This is the case regardless of whether data frame
@code{production} has been attached on the search path or not}.

@node Generic functions for extracting model information, Analysis of variance and model comparison, Linear models, Statistical models in R
@section Generic functions for extracting model information

The value of @code{lm()} is a fitted model object; technically a list of
results of class @code{"lm"}.  Information about the fitted model can
then be displayed, extracted, plotted and so on by using generic
functions that orient themselves to objects of class @code{"lm"}.  These
include

@example
add1    deviance   formula      predict  step
alias   drop1      kappa        print    summary
anova   effects    labels       proj     vcov
coef    family     plot         residuals
@end example

A brief description of the most commonly used ones is given below.

@table @code
@findex anova
@item anova(@var{object_1}, @var{object_2})
Compare a submodel with an outer model and produce an analysis of
variance table.

@findex coefficients
@findex coef
@item coef(@var{object})
Extract the regression coefficient (matrix).

Long form: @code{coefficients(@var{object})}.

@findex deviance
@item deviance(@var{object})
Residual sum of squares, weighted if appropriate.

@findex formula
@item formula(@var{object})
Extract the model formula.

@findex plot
@item plot(@var{object})
Produce four plots, showing residuals, fitted values and some
diagnostics.

@findex predict
@item predict(@var{object}, newdata=@var{data.frame})
The data frame supplied must have variables specified with the same
labels as the original.  The value is a vector or matrix of predicted
values corresponding to the determining variable values in
@var{data.frame}.

@c  @item @code{predict.gam(@var{object},}
@c  @item @w{@ @ @ @code{newdata=@var{data.frame})}}
@c  @tab @code{predict.gam()} is a safe alternative to @code{predict()} that
@c  can be used for @code{lm}, @code{glm} and @code{gam} fitted objects.  It
@c  must be used, for example, in cases where orthogonal polynomials are
@c  used as the original basis functions, and the addition of new data
@c  implies different basis functions to the original.

@findex print
@item print(@var{object})
Print a concise version of the object.  Most often used implicitly.

@findex residuals
@findex resid
@item residuals(@var{object})
Extract the (matrix of) residuals, weighted as appropriate.

Short form: @code{resid(@var{object})}.

@findex step
@item step(@var{object})
Select a suitable model by adding or dropping terms and preserving
hierarchies.  The model with the smallest value of AIC (Akaike's An
Information Criterion) discovered in the stepwise search is returned.

@findex summary
@item summary(@var{object})
Print a comprehensive summary of the results of the regression analysis.

@findex vcov
@item vcov(@var{object})
Returns the variance-covariance matrix of the main parameters of a
fitted model object.
@end table

@node Analysis of variance and model comparison, Updating fitted models, Generic functions for extracting model information, Statistical models in R
@section Analysis of variance and model comparison
@cindex Analysis of variance

The model fitting function @code{aov(@code{formula},
data=@var{data.frame})}
@findex aov
operates at the simplest level in a very similar way to the function
@code{lm()}, and most of the generic functions listed in the table in
@ref{Generic functions for extracting model information} apply.

It should be noted that in addition @code{aov()} allows an analysis of
models with multiple error strata such as split plot experiments, or
balanced incomplete block designs with recovery of inter-block
information.  The model formula

@example
@var{response} ~ @var{mean.formula} + Error(@var{strata.formula})
@end example
@findex Error

@noindent
specifies a multi-stratum experiment with error strata defined by the
@var{strata.formula}.  In the simplest case, @var{strata.formula} is
simply a factor, when it defines a two strata experiment, namely between
and within the levels of the factor.

For example, with all determining variables factors, a model formula such
as that in:

@example
> fm <- aov(yield ~ v + n*p*k + Error(farms/blocks), data=farm.data)
@end example

@noindent
would typically be used to describe an experiment with mean model
@code{v + n*p*k} and three error strata, namely ``between farms'',
``within farms, between blocks'' and ``within blocks''.

@menu
* ANOVA tables::                
@end menu

@node ANOVA tables,  , Analysis of variance and model comparison, Analysis of variance and model comparison
@subsection ANOVA tables

Note also that the analysis of variance table (or tables) are for a
sequence of fitted models.  The sums of squares shown are the decrease
in the residual sums of squares resulting from an inclusion of
@emph{that term} in the model at @emph{that place} in the sequence.
Hence only for orthogonal experiments will the order of inclusion be
inconsequential.

For multistratum experiments the procedure is first to project the
response onto the error strata, again in sequence, and to fit the mean
model to each projection.  For further details, see Chambers & Hastie
(1992).

A more flexible alternative to the default full ANOVA table is to
compare two or more models directly using the @code{anova()} function.
@findex anova

@example
> anova(@var{fitted.model.1}, @var{fitted.model.2}, @dots{})
@end example

The display is then an ANOVA table showing the differences between the
fitted models when fitted in sequence.  The fitted models being compared
would usually be an hierarchical sequence, of course.  This does not
give different information to the default, but rather makes it easier to
comprehend and control.

@node Updating fitted models, Generalized linear models, Analysis of variance and model comparison, Statistical models in R
@section Updating fitted models
@cindex Updating fitted models

The @code{update()} function is largely a convenience function that
allows a model to be fitted that differs from one previously fitted
usually by just a few additional or removed terms.  Its form is
@findex update

@example
> @var{new.model} <- update(@var{old.model}, @var{new.formula})
@end example

In the @var{new.formula} the special name consisting of a period,
@samp{@code{.}},
@findex .
only, can be used to stand for ``the corresponding part of the old model
formula''.  For example,

@example
> fm05 <- lm(y ~ x1 + x2 + x3 + x4 + x5, data = production)
> fm6  <- update(fm05, . ~ . + x6)
> smf6 <- update(fm6, sqrt(.) ~ .)
@end example

@noindent
would fit a five variate multiple regression with variables (presumably)
from the data frame @code{production}, fit an additional model including
a sixth regressor variable, and fit a variant on the model where the
response had a square root transform applied.

Note especially that if the @code{data=} argument is specified on the
original call to the model fitting function, this information is passed on
through the fitted model object to @code{update()} and its allies.

The name @samp{.} can also be used in other contexts, but with slightly
different meaning.  For example

@example
> fmfull <- lm(y ~ . , data = production)
@end example

@noindent
would fit a model with response @code{y} and regressor variables
@emph{all other variables in the data frame @code{production}}.

Other functions for exploring incremental sequences of models are
@code{add1()}, @code{drop1()} and @code{step()}.
@findex add1
@findex drop1
@findex step
The names of these give a good clue to their purpose, but for full
details see the on-line help.

@node Generalized linear models, Nonlinear least squares and maximum likelihood models, Updating fitted models, Statistical models in R
@section Generalized linear models
@cindex Generalized linear models

Generalized linear modeling is a development of linear models to
accommodate both non-normal response distributions and transformations
to linearity in a clean and straightforward way.  A generalized linear
model may be described in terms of the following sequence of
assumptions:

@itemize @bullet
@item
There is a response, @math{y}, of interest and stimulus variables
@ifnottex
x_1, x_2, @dots{},
@end ifnottex
@tex
$x_1$, $x_2$, @dots{},
@end tex
whose values influence the distribution of the response.

@item
The stimulus variables influence the distribution of @math{y} through
@emph{a single linear function, only}.  This linear function is called
the @emph{linear predictor}, and is usually written
@ifnottex
@display
eta = beta_1 x_1 + beta_2 x_2 + @dots{} + beta_p x_p,
@end display
hence x_i has no influence on the distribution of @math{y} if and only if
beta_i is zero.
@end ifnottex
@tex
$$ \eta = \beta_1 x_1 + \beta_2 x_2 + \cdots + \beta_p x_p, $$
hence $x_i$ has no influence on the distribution of @math{y} if and only
if $\beta_i=0$.
@end tex

@item
The distribution of @math{y} is of the form
@ifnottex
@display
f_Y(y; mu, phi)
  = exp((A/phi) * (y lambda(mu) - gamma(lambda(mu))) + tau(y, phi))
@end display
where phi is a @emph{scale parameter} (possibly known), and is constant
for all observations, @math{A} represents a prior weight, assumed known
but possibly varying with the observations, and $\mu$ is the mean of
@math{y}.
@end ifnottex
@tex
$$
f_Y(y;\mu,\varphi)
= \exp\left[{A \over \varphi}\left\{y\lambda(\mu) -
\gamma\left(\lambda(\mu)\right)\right\} + \tau(y,\varphi)\right]
$$
where $\varphi$ is a @emph{scale parameter} (possibly known), and is
constant for all observations, $A$ represents a prior weight, assumed
known but possibly varying with the observations, and $\mu$ is the mean
of $y$.
@end tex
So it is assumed that the distribution of @math{y} is determined by its
mean and possibly a scale parameter as well.

@item
@ifnottex
The mean, mu, is a smooth invertible function of the linear predictor:
@display
mu = m(eta),    eta = m^@{-1@}(mu) = ell(mu)
@end display
and this inverse function, ell(), is called the @emph{link function}.
@end ifnottex
@tex
The mean, $\mu$, is a smooth invertible function of the linear predictor:
$$ \mu = m(\eta),\qquad \eta = m^{-1}(\mu) = \ell(\mu) $$
and this inverse function, $\ell()$, is called the @emph{link function}.
@end tex

@end itemize

These assumptions are loose enough to encompass a wide class of models
useful in statistical practice, but tight enough to allow the
development of a unified methodology of estimation and inference, at
least approximately.  The reader is referred to any of the current
reference works on the subject for full details, such as McCullagh &
Nelder (1989) or Dobson (1990).

@menu
* Families::                    
* The glm() function::          
@end menu

@node Families, The glm() function, Generalized linear models, Generalized linear models
@subsection Families
@cindex Families

The class of generalized linear models handled by facilities supplied in
@R{} includes @emph{gaussian}, @emph{binomial}, @emph{poisson},
@emph{inverse gaussian} and @emph{gamma} response distributions and also
@emph{quasi-likelihood} models where the response distribution is not
explicitly specified.  In the latter case the @emph{variance function}
must be specified as a function of the mean, but in other cases this
function is implied by the response distribution.

Each response distribution admits a variety of link functions to connect
the mean with the linear predictor.  Those automatically available are
shown in the following table:

@quotation
@multitable @columnfractions 0.25 0.55
@headitem Family name @tab Link functions
@item @code{binomial} @tab @code{logit}, @code{probit}, @code{log}, @code{cloglog}
@item @code{gaussian} @tab @code{identity}, @code{log}, @code{inverse}
@item @code{Gamma} @tab @code{identity}, @code{inverse}, @code{log}
@item @code{inverse.gaussian} @tab @code{1/mu^2}, @code{identity}, @code{inverse}, @code{log}
@item @code{poisson} @tab @code{identity}, @code{log}, @code{sqrt}
@item @code{quasi} @tab @code{logit}, @code{probit}, @code{cloglog},
@code{identity}, @code{inverse}, @code{log}, @code{1/mu^2}, @code{sqrt}
@end multitable
@end quotation

The combination of a response distribution, a link function and various
other pieces of information that are needed to carry out the modeling
exercise is called the @emph{family} of the generalized linear model.

@node The glm() function,  , Families, Generalized linear models
@subsection The @code{glm()} function
@findex glm

Since the distribution of the response depends on the stimulus variables
through a single linear function @emph{only}, the same mechanism as was
used for linear models can still be used to specify the linear part of a
generalized model.  The family has to be specified in a different way.

The @R{} function to fit a generalized linear model is @code{glm()}
which uses the form

@example
> @var{fitted.model} <- glm(@var{formula}, family=@var{family.generator}, data=@var{data.frame})
@end example

The only new feature is the @var{family.generator}, which is the
instrument by which the family is described.  It is the name of a
function that generates a list of functions and expressions that
together define and control the model and estimation process.  Although
this may seem a little complicated at first sight, its use is quite
simple.

The names of the standard, supplied family generators are given under
``Family Name'' in the table in @ref{Families}.  Where there is a choice
of links, the name of the link may also be supplied with the family
name, in parentheses as a parameter.  In the case of the @code{quasi}
family, the variance function may also be specified in this way.

Some examples make the process clear.

@subsubheading The @code{gaussian} family

A call such as

@example
> fm <- glm(y ~ x1 + x2, family = gaussian, data = sales)
@end example

@noindent
achieves the same result as

@example
> fm <- lm(y ~ x1+x2, data=sales)
@end example

@noindent
but much less efficiently.  Note how the gaussian family is not
automatically provided with a choice of links, so no parameter is
allowed.  If a problem requires a gaussian family with a nonstandard
link, this can usually be achieved through the @code{quasi} family, as
we shall see later.

@subsubheading The @code{binomial} family

Consider a small, artificial example, from Silvey (1970).

On the Aegean island of Kalythos the male inhabitants suffer from a
congenital eye disease, the effects of which become more marked with
increasing age.  Samples of islander males of various ages were tested
for blindness and the results recorded.  The data is shown below:

@iftex
@quotation
@multitable {No.@: tested::} {50} {50} {50} {50} {50}
@item Age:          @tab  20 @tab  35 @tab  45 @tab  55 @tab  70
@item No.@: tested: @tab  50 @tab  50 @tab  50 @tab  50 @tab  50
@item No.@: blind:  @tab  @w{ 6} @tab  17 @tab  26 @tab  37 @tab  44
@end multitable
@end quotation
@end iftex
@ifnottex
@multitable {No.@: tested::} {50} {50} {50} {50} {50}
@item Age:          @tab  20 @tab  35 @tab  45 @tab  55 @tab  70
@item No.@: tested: @tab  50 @tab  50 @tab  50 @tab  50 @tab  50
@item No.@: blind:  @tab  @w{ 6} @tab  17 @tab  26 @tab  37 @tab  44
@end multitable
@end ifnottex

The problem we consider is to fit both logistic and probit models to
this data, and to estimate for each model the LD50, that is the age at
which the chance of blindness for a male inhabitant is 50%.

If @math{y} is the number of blind at age @math{x} and @math{n} the
number tested, both models have the form
@ifnottex
y ~ B(n, F(beta_0 + beta_1 x))
@end ifnottex
@tex
$$ y \sim {\rm B}(n, F(\beta_0 + \beta_1 x)) $$
@end tex
where for the probit case,
@eqn{F(z) = \Phi(z), F(z) = Phi(z)}
is the standard normal distribution function, and in the logit case
(the default),
@eqn{F(z) = e^z/(1+e^z),F(z) = e^z/(1+e^z)}.
In both cases the LD50 is
@ifnottex
LD50 = - beta_0/beta_1
@end ifnottex
@tex
$$ \hbox{LD50} = -\beta_0/\beta_1 $$
@end tex
that is, the point at which the argument of the distribution function is
zero.

The first step is to set the data up as a data frame

@example
> kalythos <- data.frame(x = c(20,35,45,55,70), n = rep(50,5),
                         y = c(6,17,26,37,44))
@end example

To fit a binomial model using @code{glm()} there are three possibilities
for the response:

@itemize @bullet
@item
If the response is a @emph{vector} it is assumed to hold @emph{binary}
data, and so must be a @math{0/1} vector.

@item
If the response is a @emph{two-column matrix} it is assumed that the
first column holds the number of successes for the trial and the second
holds the number of failures.

@item
If the response is a @emph{factor}, its first level is taken as failure
(0) and all other levels as `success' (1).
@end itemize

Here we need the second of these conventions, so we add a matrix to our
data frame:

@example
> kalythos$Ymat <- cbind(kalythos$y, kalythos$n - kalythos$y)
@end example

To fit the models we use

@example
> fmp <- glm(Ymat ~ x, family = binomial(link=probit), data = kalythos)
> fml <- glm(Ymat ~ x, family = binomial, data = kalythos)
@end example

Since the logit link is the default the parameter may be omitted on the
second call.  To see the results of each fit we could use

@example
> summary(fmp)
> summary(fml)
@end example

Both models fit (all too) well.  To find the LD50 estimate we can use a
simple function:

@example
> ld50 <- function(b) -b[1]/b[2]
> ldp <- ld50(coef(fmp)); ldl <- ld50(coef(fml)); c(ldp, ldl)
@end example

The actual estimates from this data are 43.663 years and 43.601 years
respectively.

@subsubheading Poisson models

With the Poisson family the default link is the @code{log}, and in
practice the major use of this family is to fit surrogate Poisson
log-linear models to frequency data, whose actual distribution is often
multinomial.  This is a large and important subject we will not discuss
further here.  It even forms a major part of the use of non-gaussian
generalized models overall.

Occasionally genuinely Poisson data arises in practice and in the past
it was often analyzed as gaussian data after either a log or a
square-root transformation.  As a graceful alternative to the latter, a
Poisson generalized linear model may be fitted as in the following
example:

@example
> fmod <- glm(y ~ A + B + x, family = poisson(link=sqrt),
              data = worm.counts)
@end example

@subsubheading Quasi-likelihood models

For all families the variance of the response will depend on the mean
and will have the scale parameter as a multiplier.  The form of
dependence of the variance on the mean is a characteristic of the
response distribution; for example for the poisson distribution
@eqn{\hbox{Var}[y] = \mu,Var(y) = mu}.

For quasi-likelihood estimation and inference the precise response
distribution is not specified, but rather only a link function and the
form of the variance function as it depends on the mean.  Since
quasi-likelihood estimation uses formally identical techniques to those
for the gaussian distribution, this family provides a way of fitting
gaussian models with non-standard link functions or variance functions,
incidentally.

For example, consider fitting the non-linear regression
@ifnottex
y = theta_1 z_1 / (z_2 - theta_2) + e
@end ifnottex
@tex
$$ y = {\theta_1z_1 \over z_2 - \theta_2} + e $$
@end tex
which may be written alternatively as
@ifnottex
y = 1 / (beta_1 x_1 + beta_2 x_2) + e
@end ifnottex
@tex
$$ y = {1 \over \beta_1x_1 + \beta_2x_2} + e $$
@end tex
where
@ifnottex
x_1 = z_2/z_1, x_2 = -1/z_1, beta_1 = 1/theta_1, and beta_2 =
theta_2/theta_1.
@end ifnottex
@tex
$x_1 = z_2/z_1$, $x_2=-1/z_1$, $\beta_1=1/\theta_1$ and
$\beta_2=\theta_2/\theta_1$.
@end tex
Supposing a suitable data frame to be set up we could fit this
non-linear regression as

@example
> nlfit <- glm(y ~ x1 + x2 - 1,
               family = quasi(link=inverse, variance=constant),
               data = biochem)
@end example

The reader is referred to the manual and the help document for further
information, as needed.

@node Nonlinear least squares and maximum likelihood models, Some non-standard models, Generalized linear models, Statistical models in R
@section Nonlinear least squares and maximum likelihood models
@cindex Nonlinear least squares

Certain forms of nonlinear model can be fitted by Generalized Linear
Models (@code{glm()}).  But in the majority of cases we have to approach
the nonlinear curve fitting problem as one of nonlinear optimization.
@R{}'s nonlinear optimization routines are @code{optim()}, @code{nlm()}
and (from @R{} 2.2.0) @code{nlminb()},
@findex nlm
@findex optim
@findex nlminb
which provide the functionality (and more) of @SPLUS{}'s @code{ms()} and
@code{nlminb()}.  We seek the parameter values that minimize some index
of lack-of-fit, and they do this by trying out various parameter values
iteratively.  Unlike linear regression for example, there is no
guarantee that the procedure will converge on satisfactory estimates.
All the methods require initial guesses about what parameter values to
try, and convergence may depend critically upon the quality of the
starting values.

@menu
* Least squares::               
* Maximum likelihood::          
@end menu

@node Least squares, Maximum likelihood, Nonlinear least squares and maximum likelihood models, Nonlinear least squares and maximum likelihood models
@subsection Least squares

One way to fit a nonlinear model is by minimizing the sum of the squared
errors (SSE) or residuals.  This method makes sense if the observed
errors could have plausibly arisen from a normal distribution.

Here is an example from Bates & Watts (1988), page 51.  The data are:

@example
> x <- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56,
         1.10, 1.10)
> y <- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)
@end example

The fit criterion to be minimized is:

@example
> fn <- function(p) sum((y - (p[1] * x)/(p[2] + x))^2)
@end example

In order to do the fit we need initial estimates of the parameters.  One
way to find sensible starting values is to plot the data, guess some
parameter values, and superimpose the model curve using those values.

@example
> plot(x, y)
> xfit <- seq(.02, 1.1, .05)
> yfit <- 200 * xfit/(0.1 + xfit)
> lines(spline(xfit, yfit))
@end example

We could do better, but these starting values of 200 and 0.1 seem
adequate.  Now do the fit:

@example
> out <- nlm(fn, p = c(200, 0.1), hessian = TRUE)
@end example
@findex nlm

After the fitting, @code{out$minimum} is the SSE, and
@code{out$estimate} are the least squares estimates of the parameters.
To obtain the approximate standard errors (SE) of the estimates we do:

@example
> sqrt(diag(2*out$minimum/(length(y) - 2) * solve(out$hessian)))
@end example

The 2 in the line above represents the number of parameters.  A 95%
confidence interval would be the parameter estimate @eqn{\pm, +/-} 1.96
SE.  We can superimpose the least squares fit on a new plot:

@example
> plot(x, y)
> xfit <- seq(.02, 1.1, .05)
> yfit <- 212.68384222 * xfit/(0.06412146 + xfit)
> lines(spline(xfit, yfit))
@end example

The standard package @pkg{stats} provides much more extensive facilities
for fitting non-linear models by least squares.  The model we have just
fitted is the Michaelis-Menten model, so we can use

@example
> df <- data.frame(x=x, y=y)
> fit <- nls(y ~ SSmicmen(x, Vm, K), df)
> fit
Nonlinear regression model
  model:  y ~ SSmicmen(x, Vm, K)
   data:  df
          Vm            K
212.68370711   0.06412123
 residual sum-of-squares:  1195.449
> summary(fit)

Formula: y ~ SSmicmen(x, Vm, K)

Parameters:
    Estimate Std. Error t value Pr(>|t|)
Vm 2.127e+02  6.947e+00  30.615 3.24e-11
K  6.412e-02  8.281e-03   7.743 1.57e-05

Residual standard error: 10.93 on 10 degrees of freedom

Correlation of Parameter Estimates:
      Vm
K 0.7651
@end example

@node Maximum likelihood,  , Least squares, Nonlinear least squares and maximum likelihood models
@subsection Maximum likelihood
@cindex Maximum likelihood

Maximum likelihood is a method of nonlinear model fitting that applies
even if the errors are not normal.  The method finds the parameter values
which maximize the log likelihood, or equivalently which minimize the
negative log-likelihood.  Here is an example from Dobson (1990), pp.@:
108--111.  This example fits a logistic model to dose-response data,
which clearly could also be fit by @code{glm()}.  The data are:

@example
> x <- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113,
         1.8369, 1.8610, 1.8839)
> y <- c( 6, 13, 18, 28, 52, 53, 61, 60)
> n <- c(59, 60, 62, 56, 63, 59, 62, 60)
@end example

The negative log-likelihood to minimize is:

@example
> fn <- function(p)
   sum( - (y*(p[1]+p[2]*x) - n*log(1+exp(p[1]+p[2]*x))
           + log(choose(n, y)) ))
@end example

@noindent
We pick sensible starting values and do the fit:

@example
> out <- nlm(fn, p = c(-50,20), hessian = TRUE)
@end example
@findex nlm

@noindent
After the fitting, @code{out$minimum} is the negative log-likelihood,
and @code{out$estimate} are the maximum likelihood estimates of the
parameters.  To obtain the approximate SEs of the estimates we do:

@example
> sqrt(diag(solve(out$hessian)))
@end example

A 95% confidence interval would be the parameter estimate @eqn{\pm, +/-}
1.96 SE.

@node Some non-standard models,  , Nonlinear least squares and maximum likelihood models, Statistical models in R
@section Some non-standard models

We conclude this chapter with just a brief mention of some of the other
facilities available in @R{} for special regression and data analysis
problems.

@itemize @bullet
@item
@cindex Mixed models
@strong{Mixed models.}  The recommended @CRANpkg{nlme} package provides
functions @code{lme()} and @code{nlme()}
@findex lme
@findex nlme
for linear and non-linear mixed-effects models, that is linear and
non-linear regressions in which some of the coefficients correspond to
random effects.  These functions make heavy use of formulae to specify
the models.

@item
@cindex Local approximating regressions
@strong{Local approximating regressions.}  The @code{loess()}
@findex loess
function fits a nonparametric regression by using a locally weighted
regression.  Such regressions are useful for highlighting a trend in
messy data or for data reduction to give some insight into a large data
set.

Function @code{loess} is in the standard package @pkg{stats}, together
with code for projection pursuit regression.
@findex loess

@item
@cindex Robust regression
@strong{Robust regression.} There are several functions available for
fitting regression models in a way resistant to the influence of extreme
outliers in the data.  Function @code{lqs}
@findex lqs
in the recommended package @CRANpkg{MASS} provides state-of-art algorithms
for highly-resistant fits.  Less resistant but statistically more
efficient methods are available in packages, for example function
@code{rlm}
@findex rlm
in package @CRANpkg{MASS}.

@item
@cindex Additive models
@strong{Additive models.} This technique aims to construct a regression
function from smooth additive functions of the determining variables,
usually one for each determining variable.  Functions @code{avas} and
@code{ace}
@findex avas
@findex ace
in package @CRANpkg{acepack} and functions @code{bruto} and @code{mars}
@findex bruto
@findex mars
in package @CRANpkg{mda} provide some examples of these techniques in
user-contributed packages to @R{}.  An extension is @strong{Generalized
Additive Models}, implemented in user-contributed packages @CRANpkg{gam} and
@CRANpkg{mgcv}.

@item
@cindex Tree-based models
@strong{Tree-based models.} Rather than seek an explicit global linear
model for prediction or interpretation, tree-based models seek to
bifurcate the data, recursively, at critical points of the determining
variables in order to partition the data ultimately into groups that are
as homogeneous as possible within, and as heterogeneous as possible
between.  The results often lead to insights that other data analysis
methods tend not to yield.

Models are again specified in the ordinary linear model form.  The model
fitting function is @code{tree()},
@findex tree
but many other generic functions such as @code{plot()} and @code{text()}
are well adapted to displaying the results of a tree-based model fit in
a graphical way.

Tree models are available in @R{} @emph{via} the user-contributed
packages @CRANpkg{rpart} and @CRANpkg{tree}.

@end itemize

@node Graphics, Packages, Statistical models in R, Top
@chapter Graphical procedures

@c Graphical facilities are an important and extremely versatile component
@c of the @R{} environment.  It is possible to use the facilities to
@c display a wide variety of statistical graphs and also to build entirely
@c new types of graph.

@R{}(개발)환경의 중요하고도 매우 다양한 역할을 수행하는 요소는 바로 그래픽 기능입니다. 
이를 통해 다양한 종류의 통계 그래프를 보여줄 수 있으며, 완전히 새로운 종류의 그래프를 만들어 낼 수도 있습니다.

@c The graphics facilities can be used in both interactive and batch modes, but in
@c most cases, interactive use is more productive.  Interactive use is also
@c easy because at startup time @R{} initiates a graphics @emph{device
@c driver} which opens a special @emph{graphics window} for the display of
@c interactive graphics.  Although this is done automatically, it is useful
@c to know that the command used is @code{X11()} under UNIX,
@c @code{windows()} under Windows and @code{quartz()} under Mac OS X.

그래픽 기능들은 대화식(interactive)처리방식과 배치(batch)처리방식이 있습니다.
대부분의 경우에는 대화식 처리방식을 이용하는 것이 더욱 효과적이며 사용하기 쉽습니다.
그 이유는 @R{}이 시작할때 대화식 그래픽처리를 위한 특수한 @emph{graphics window}(그래픽 윈도우)를 열어주는 @emph{device driver}(장치드라이버)를 자동으로 초기화 시켜주기 때문입니다.  
물론 그래픽 장치드라이버가 자동 초기화되기는 하지만, 이러한 기능을 수행하는 명령어를 알아두면 더욱 편리한 사용을 할 수 있습니다.
UNIX에서는 @code{X11()}, 윈도우즈에서는 @code{windows()}, 그리고 Mac OS X에서는 @code{quartz()}입니다.

@c Once the device driver is running, @R{} plotting commands can be used to
@c produce a variety of graphical displays and to create entirely new kinds
@c of display.

장치드라이버가 실행이 되면, @R{} 플랏팅 명령어들은 다양한 종류의 그래픽처리 및 새로운 종류의 그래프를 생성하기 위해서 사용될 수 있습니다.

@c Plotting commands are divided into three basic groups:
플랏팅 명령어들은 다음과 같이 크게 세 영역으로 나뉘어 집니다:

@itemize @bullet
@item
@c @strong{High-level} plotting functions create a new plot on the graphics
@c device, possibly with axes, labels, titles and so on.
@strong{High-level}(하이레벨) 플랏팅 함수들은 그래픽 장치에 축, 라벨, 제목등과 함께 새로운 플랏을 생성합니다. 
@item
@c @strong{Low-level} plotting functions add more information to an
@c existing plot, such as extra points, lines and labels.
@strong{Low-level}(로우레벨) 플랏팅 함수들은 이미 존재하는 플랏에 점, 선, 라벨들을 추가하여 좀 더 많은 정보들을 표현할 수 있도록 합니다. 
@item
@c @strong{Interactive} graphics functions allow you interactively add
@c information to, or extract information from, an existing plot, using a
@c pointing device such as a mouse.
@strong{Interactive}(대화형) 그래픽 함수들은 마우스와 같은 포인팅 장치(pointing device)를 이용하여 이미 생성된 플랏에 정보를 추가하거나 또는 추출해 냅니다.
@end itemize

@c In addition, @R{} maintains a list of @emph{graphical parameters} which
@c can be manipulated to customize your plots.

또한, @R{}은 사용자가 원하는대로 플랏을 수정 및 변경할 수 있도록 @emph{graphical parameters}(그래픽 파라미터)들의 목록을 제공해주고 있습니다.

@c This manual only describes what are known as `base' graphics.  A
@c separate graphics sub-system in package @pkg{grid} coexists with base --
@c it is more powerful but harder to use.  There is a recommended package
@c @CRANpkg{lattice} which builds on @pkg{grid} and provides ways to produce
@c multi-panel plots akin to those in the @emph{Trellis} system in @Sl{}.

이 안내서에서는 `base' 그래픽이라고 알려진 것들에 대해서만 다룹니다.
base 그래픽와는 별개로 @pkg{grid} 패키지 내에 있는 별도의 그래픽 서브-시스템이 존재합니다. 
이 시스템은 좀 더 강력한 그래픽 기능들을 제공하지만, 사용에 다소 어려움이 있습니다.
또한, @pkg{grid}를 기반으로 하는 @CRANpkg{lattice}라는 추천패키지도 있는데, 이는 @Sl{}에서 @emph{Trellis}(트렐리스)라는 시스템이 제공하는 다중패널 플랏과 같은 고급 그래픽처리가 가능한 함수들을 포함하고 있습니다.


@menu
* High-level plotting commands::  
* Low-level plotting commands::  
* Interacting with graphics::   
* Using graphics parameters::   
* Graphics parameters::         
* Device drivers::              
* Dynamic graphics::            
@end menu

@node High-level plotting commands, Low-level plotting commands, Graphics, Graphics
@section High-level plotting commands

High-level plotting functions are designed to generate a complete plot
of the data passed as arguments to the function.  Where appropriate,
axes, labels and titles are automatically generated (unless you request
otherwise.) High-level plotting commands always start a new plot,
erasing the current plot if necessary.

@menu
* The plot() function::         
* Displaying multivariate data::  
* Display graphics::            
* Arguments to high-level plotting functions::  
@end menu

@node The plot() function, Displaying multivariate data, High-level plotting commands, High-level plotting commands
@subsection The @code{plot()} function
@findex plot

One of the most frequently used plotting functions in @R{} is the
@code{plot()} function.  This is a @emph{generic} function: the type of
plot produced is dependent on the type or @emph{class} of the first
argument.

@table @code

@item plot(@var{x}, @var{y})
@itemx plot(@var{xy})
If @var{x} and @var{y} are vectors, @code{plot(@var{x}, @var{y})}
produces a scatterplot of @var{y} against @var{x}.  The same effect can
be produced by supplying one argument (second form) as either a list
containing two elements @var{x} and @var{y} or a two-column matrix.

@item plot(@var{x})
If @var{x} is a time series, this produces a time-series plot. If
@var{x} is a numeric vector, it produces a plot of the values in the
vector against their index in the vector.  If @var{x} is a complex
vector, it produces a plot of imaginary versus real parts of the vector
elements.

@item plot(@var{f})
@itemx plot(@var{f}, @var{y})
@var{f} is a factor object, @var{y} is a numeric vector.  The first form
generates a bar plot of @var{f}; the second form produces boxplots of
@var{y} for each level of @var{f}.

@item plot(@var{df})
@itemx plot(~ @var{expr})
@itemx plot(@var{y} ~ @var{expr})
@var{df} is a data frame, @var{y} is any object, @var{expr} is a list
of object names separated by `@code{+}' (e.g., @code{a + b + c}).  The
first two forms produce distributional plots of the variables in a data
frame (first form) or of a number of named objects (second form).  The
third form plots @var{y} against every object named in @var{expr}.
@end table

@node Displaying multivariate data, Display graphics, The plot() function, High-level plotting commands
@subsection Displaying multivariate data

@R{} provides two very useful functions for representing multivariate
data.  If @code{X} is a numeric matrix or data frame, the command

@example
> pairs(X)
@end example
@findex pairs

@noindent
produces a pairwise scatterplot matrix of the variables defined by the
columns of @code{X}, that is, every column of @code{X} is plotted
against every other column of @code{X} and the resulting @math{n(n-1)}
plots are arranged in a matrix with plot scales constant over the rows
and columns of the matrix.

When three or four variables are involved a @emph{coplot} may be more
enlightening.  If @code{a} and @code{b} are numeric vectors and @code{c}
is a numeric vector or factor object (all of the same length), then
the command

@example
> coplot(a ~ b | c)
@end example
@findex coplot

@noindent
produces a number of scatterplots of @code{a} against @code{b} for given
values of @code{c}.  If @code{c} is a factor, this simply means that
@code{a} is plotted against @code{b} for every level of @code{c}.  When
@code{c} is numeric, it is divided into a number of @emph{conditioning
intervals} and for each interval @code{a} is plotted against @code{b}
for values of @code{c} within the interval.  The number and position of
intervals can be controlled with @code{given.values=} argument to
@code{coplot()}---the function @code{co.intervals()} is useful for
selecting intervals.  You can also use two @emph{given} variables with a
command like

@example
> coplot(a ~ b | c + d)
@end example

@noindent
which produces scatterplots of @code{a} against @code{b} for every joint
conditioning interval of @code{c} and @code{d}.

The @code{coplot()} and @code{pairs()} function both take an argument
@code{panel=} which can be used to customize the type of plot which
appears in each panel.  The default is @code{points()} to produce a
scatterplot but by supplying some other low-level graphics function of
two vectors @code{x} and @code{y} as the value of @code{panel=} you can
produce any type of plot you wish.  An example panel function useful for
coplots is @code{panel.smooth()}.

@node Display graphics, Arguments to high-level plotting functions, Displaying multivariate data, High-level plotting commands
@subsection Display graphics

Other high-level graphics functions produce different types of plots.
Some examples are:

@table @code
@c  @item tsplot(x_1, x_2, @dots{})
@c  @findex tsplot
@c  Plots any number of time series on the same scale.  This automatic
@c  simultaneous scaling feature is also useful when the @code{x@var{_i}}'s
@c  are ordinary numeric vectors, in which case they are plotted against the
@c  numbers @math{1, 2, 3, @dots{}}.

@item qqnorm(x)
@itemx qqline(x)
@itemx qqplot(x, y)
@findex qqnorm
@findex qqline
@findex qqplot
Distribution-comparison plots.  The first form plots the numeric vector
@code{x} against the expected Normal order scores (a normal scores plot)
and the second adds a straight line to such a plot by drawing a line
through the distribution and data quartiles.  The third form plots the
quantiles of @code{x} against those of @code{y} to compare their
respective distributions.

@item hist(x)
@itemx hist(x, nclass=@var{n})
@itemx hist(x, breaks=@var{b}, @dots{})
@findex hist
Produces a histogram of the numeric vector @code{x}.  A sensible number
of classes is usually chosen, but a recommendation can be given with the
@code{nclass=} argument.  Alternatively, the breakpoints can be
specified exactly with the @code{breaks=} argument.  If the
@code{probability=TRUE} argument is given, the bars represent relative
frequencies divided by bin width instead of counts.

@item dotchart(x, @dots{})
@findex dotchart
Constructs a dotchart of the data in @code{x}.  In a dotchart the
@math{y}-axis gives a labelling of the data in @code{x} and the
@math{x}-axis gives its value.  For example it allows easy visual
selection of all data entries with values lying in specified ranges.

@item image(x, y, z, @dots{})
@itemx contour(x, y, z, @dots{})
@itemx persp(x, y, z, @dots{})
@findex image
@findex contour
@findex persp
Plots of three variables.  The @code{image} plot draws a grid of rectangles
using different colours to represent the value of @code{z}, the @code{contour}
plot draws contour lines to represent the value of @code{z}, and the
@code{persp} plot draws a 3D surface.
@end table

@node Arguments to high-level plotting functions,  , Display graphics, High-level plotting commands
@subsection Arguments to high-level plotting functions

There are a number of arguments which may be passed to high-level
graphics functions, as follows:

@table @code
@item add=TRUE
Forces the function to act as a low-level graphics function,
superimposing the plot on the current plot (some functions only).

@item axes=FALSE
Suppresses generation of axes---useful for adding your own custom axes
with the @code{axis()} function.  The default, @code{axes=TRUE}, means
include axes.

@item log="x"
@itemx log="y"
@itemx log="xy"
Causes the @math{x}, @math{y} or both axes to be logarithmic.  This will
work for many, but not all, types of plot.

@item type=
The @code{type=} argument controls the type of plot produced, as
follows:

@table @code
@item type="p"
Plot individual points (the default)
@item type="l"
Plot lines
@item type="b"
Plot points connected by lines (@emph{both})
@item type="o"
Plot points overlaid by lines
@item type="h"
Plot vertical lines from points to the zero axis (@emph{high-density})
@item type="s"
@itemx type="S"
Step-function plots.  In the first form, the top of the vertical defines
the point; in the second, the bottom.
@item type="n"
No plotting at all.  However axes are still drawn (by default) and the
coordinate system is set up according to the data.  Ideal for creating
plots with subsequent low-level graphics functions.
@end table

@item xlab=@var{string}
@itemx ylab=@var{string}
Axis labels for the @math{x} and @math{y} axes.  Use these arguments to
change the default labels, usually the names of the objects used in the
call to the high-level plotting function.

@item main=@var{string}
Figure title, placed at the top of the plot in a large font.

@item sub=@var{string}
Sub-title, placed just below the @math{x}-axis in a smaller font.
@end table

@node Low-level plotting commands, Interacting with graphics, High-level plotting commands, Graphics
@section Low-level plotting commands

Sometimes the high-level plotting functions don't produce exactly the
kind of plot you desire.  In this case, low-level plotting commands can
be used to add extra information (such as points, lines or text) to the
current plot.

Some of the more useful low-level plotting functions are:

@table @code
@item points(x, y)
@itemx lines(x, y)
@findex points
@findex lines
Adds points or connected lines to the current plot.  @code{plot()}'s
@code{type=} argument can also be passed to these functions (and
defaults to @code{"p"} for @code{points()} and @code{"l"} for
@code{lines()}.)

@item text(x, y, labels, @dots{})
@findex text
Add text to a plot at points given by @code{x, y}.  Normally
@code{labels} is an integer or character vector in which case
@code{labels[i]} is plotted at point @code{(x[i], y[i])}.  The default
is @code{1:length(x)}.

@strong{Note}: This function is often used in the sequence

@example
> plot(x, y, type="n"); text(x, y, names)
@end example

@noindent
The graphics parameter @code{type="n"} suppresses the points but sets up
the axes, and the @code{text()} function supplies special characters, as
specified by the character vector @code{names} for the points.

@item abline(a, b)
@itemx abline(h=@var{y})
@itemx abline(v=@var{x})
@itemx abline(@var{lm.obj})
@findex abline
Adds a line of slope @code{b} and intercept @code{a} to the current
plot.  @code{h=@var{y}} may be used to specify @math{y}-coordinates for
the heights of horizontal lines to go across a plot, and
@code{v=@var{x}} similarly for the @math{x}-coordinates for vertical
lines.  Also @var{lm.obj} may be list with a @code{coefficients}
component of length 2 (such as the result of model-fitting functions,)
which are taken as an intercept and slope, in that order.

@item polygon(x, y, @dots{})
@findex polygon
Draws a polygon defined by the ordered vertices in (@code{x}, @code{y})
and (optionally) shade it in with hatch lines, or fill it if the
graphics device allows the filling of figures.

@item legend(x, y, legend, @dots{})
@findex legend
Adds a legend to the current plot at the specified position.  Plotting
characters, line styles, colors etc., are identified with the labels in
the character vector @code{legend}.  At least one other argument @var{v}
(a vector the same length as @code{legend}) with the corresponding
values of the plotting unit must also be given, as follows:

@table @code
@item legend( , fill=@var{v})
Colors for filled boxes
@item legend( , col=@var{v})
Colors in which points or lines will be drawn
@item legend( , lty=@var{v})
Line styles
@item legend( , lwd=@var{v})
Line widths
@item legend( , pch=@var{v})
Plotting characters (character vector)
@end table

@item title(main, sub)
@findex title
Adds a title @code{main} to the top of the current plot in a large font
and (optionally) a sub-title @code{sub} at the bottom in a smaller font.

@item axis(side, @dots{})
@findex axis
Adds an axis to the current plot on the side given by the first argument
(1 to 4, counting clockwise from the bottom.)  Other arguments control
the positioning of the axis within or beside the plot, and tick
positions and labels.  Useful for adding custom axes after calling
@code{plot()} with the @code{axes=FALSE} argument.
@end table

Low-level plotting functions usually require some positioning
information (e.g., @math{x} and @math{y} coordinates) to determine where
to place the new plot elements.  Coordinates are given in terms of
@emph{user coordinates} which are defined by the previous high-level
graphics command and are chosen based on the supplied data.

Where @code{x} and @code{y} arguments are required, it is also
sufficient to supply a single argument being a list with elements named
@code{x} and @code{y}.  Similarly a matrix with two columns is also
valid input.  In this way functions such as @code{locator()} (see below)
may be used to specify positions on a plot interactively.

@menu
* Mathematical annotation::     
* Hershey vector fonts::        
@end menu

@node Mathematical annotation, Hershey vector fonts, Low-level plotting commands, Low-level plotting commands
@subsection Mathematical annotation

In some cases, it is useful to add mathematical symbols and formulae to a
plot.  This can be achieved in @R{} by specifying an @emph{expression} rather
than a character string in any one of @code{text}, @code{mtext}, @code{axis},
or @code{title}.   For example, the following code draws the formula for
the Binomial probability function:

@example
> text(x, y, expression(paste(bgroup("(", atop(n, x), ")"), p^x, q^@{n-x@})))
@end example

More information, including a full listing of the features available can
obtained from within @R{} using the commands:

@example
> help(plotmath)
> example(plotmath)
> demo(plotmath)
@end example

@node Hershey vector fonts,  , Mathematical annotation, Low-level plotting commands
@subsection Hershey vector fonts

It is possible to specify Hershey vector fonts for rendering text when using
the @code{text} and @code{contour} functions.  There are three reasons for
using the Hershey fonts:
@itemize @bullet
@item
Hershey fonts can produce better
output, especially on a computer screen, for rotated and/or small text.
@item
Hershey fonts
provide certain symbols that may not be available
in the standard fonts.  In particular, there are zodiac signs, cartographic
symbols and astronomical symbols.
@item
Hershey fonts provide cyrillic and japanese (Kana and Kanji) characters.
@end itemize

More information, including tables of Hershey characters can be obtained from
within @R{} using the commands:

@example
> help(Hershey)
> demo(Hershey)
> help(Japanese)
> demo(Japanese)
@end example

@node Interacting with graphics, Using graphics parameters, Low-level plotting commands, Graphics
@section Interacting with graphics

@R{} also provides functions which allow users to extract or add
information to a plot using a mouse.  The simplest of these is the
@code{locator()} function:

@table @code
@item locator(n, type)
@findex locator
Waits for the user to select locations on the current plot using the
left mouse button.  This continues until @code{n} (default 512) points
have been selected, or another mouse button is pressed.  The
@code{type} argument allows for plotting at the selected points and has
the same effect as for high-level graphics commands; the default is no
plotting.  @code{locator()} returns the locations of the points selected
as a list with two components @code{x} and @code{y}.
@end table

@code{locator()} is usually called with no arguments.  It is
particularly useful for interactively selecting positions for graphic
elements such as legends or labels when it is difficult to calculate in
advance where the graphic should be placed.  For example, to place some
informative text near an outlying point, the command

@example
> text(locator(1), "Outlier", adj=0)
@end example

@noindent
may be useful.  (@code{locator()} will be ignored if the current device,
such as @code{postscript} does not support interactive pointing.)

@table @code
@item identify(x, y, labels)
@findex identify
Allow the user to highlight any of the points defined by @code{x} and
@code{y} (using the left mouse button) by plotting the corresponding
component of @code{labels} nearby (or the index number of the point if
@code{labels} is absent).  Returns the indices of the selected points
when another button is pressed.
@end table

Sometimes we want to identify particular @emph{points} on a plot, rather
than their positions.  For example, we may wish the user to select some
observation of interest from a graphical display and then manipulate
that observation in some way.  Given a number of @math{(x, y)}
coordinates in two numeric vectors @code{x} and @code{y}, we could use
the @code{identify()} function as follows:

@example
> plot(x, y)
> identify(x, y)
@end example

The @code{identify()} functions performs no plotting itself, but simply
allows the user to move the mouse pointer and click the left mouse
button near a point.  If there is a point near the mouse pointer it will
be marked with its index number (that is, its position in the
@code{x}/@code{y} vectors) plotted nearby.  Alternatively, you could use
some informative string (such as a case name) as a highlight by using
the @code{labels} argument to @code{identify()}, or disable marking
altogether with the @code{plot = FALSE} argument.  When the process is
terminated (see above), @code{identify()} returns the indices of the
selected points; you can use these indices to extract the selected
points from the original vectors @code{x} and @code{y}.

@node Using graphics parameters, Graphics parameters, Interacting with graphics, Graphics
@section Using graphics parameters

When creating graphics, particularly for presentation or publication
purposes, @R{}'s defaults do not always produce exactly that which is
required.  You can, however, customize almost every aspect of the
display using @emph{graphics parameters}.  @R{} maintains a list of a
large number of graphics parameters which control things such as line
style, colors, figure arrangement and text justification among many
others.  Every graphics parameter has a name (such as `@code{col}',
which controls colors,) and a value (a color number, for example.)

A separate list of graphics parameters is maintained for each active
device, and each device has a default set of parameters when
initialized.  Graphics parameters can be set in two ways: either
permanently, affecting all graphics functions which access the current
device; or temporarily, affecting only a single graphics function call.

@menu
* The par() function::          
* Arguments to graphics functions::  
@end menu

@node The par() function, Arguments to graphics functions, Using graphics parameters, Using graphics parameters
@subsection Permanent changes: The @code{par()} function
@findex par
@cindex Graphics parameters

The @code{par()} function is used to access and modify the list of
graphics parameters for the current graphics device.

@table @code
@item par()
Without arguments, returns a list of all graphics parameters and their
values for the current device.
@item par(c("col", "lty"))
With a character vector argument, returns only the named graphics
parameters (again, as a list.)
@item par(col=4, lty=2)
With named arguments (or a single list argument), sets the values of
the named graphics parameters, and returns the original values of the
parameters as a list.
@end table

Setting graphics parameters with the @code{par()} function changes the
value of the parameters @emph{permanently}, in the sense that all future
calls to graphics functions (on the current device) will be affected by
the new value.  You can think of setting graphics parameters in this way
as setting ``default'' values for the parameters, which will be used by
all graphics functions unless an alternative value is given.

Note that calls to @code{par()} @emph{always} affect the global values
of graphics parameters, even when @code{par()} is called from within a
function.  This is often undesirable behavior---usually we want to set
some graphics parameters, do some plotting, and then restore the
original values so as not to affect the user's @R{} session.  You can
restore the initial values by saving the result of @code{par()} when
making changes, and restoring the initial values when plotting is
complete.

@example
> oldpar <- par(col=4, lty=2)
  @r{@dots{} plotting commands @dots{}}
> par(oldpar)
@end example

@noindent
To save and restore @emph{all} settable@footnote{Some graphics
parameters such as the size of the current device are for information
only.} graphical parameters use

@example
> oldpar <- par(no.readonly=TRUE)
  @r{@dots{} plotting commands @dots{}}
> par(oldpar)
@end example


@node Arguments to graphics functions,  , The par() function, Using graphics parameters
@subsection Temporary changes: Arguments to graphics functions

Graphics parameters may also be passed to (almost) any graphics function
as named arguments.  This has the same effect as passing the arguments
to the @code{par()} function, except that the changes only last for the
duration of the function call.  For example:

@example
> plot(x, y, pch="+")
@end example

@noindent
produces a scatterplot using a plus sign as the plotting character,
without changing the default plotting character for future plots.

Unfortunately, this is not implemented entirely consistently and it is
sometimes necessary to set and reset graphics parameters using
@code{par()}.


@node Graphics parameters, Device drivers, Using graphics parameters, Graphics
@section Graphics parameters list

The following sections detail many of the commonly-used graphical
parameters.  The @R{} help documentation for the @code{par()} function
provides a more concise summary; this is provided as a somewhat more
detailed alternative.

Graphics parameters will be presented in the following form:

@table @code
@item @var{name}=@var{value}
A description of the parameter's effect.  @var{name} is the name of the
parameter, that is, the argument name to use in calls to @code{par()} or
a graphics function.  @var{value} is a typical value you might use when
setting the parameter.
@end table

Note that @code{axes} is @strong{not} a graphics parameter but an
argument to a few @code{plot} methods: see @code{xaxt} and @code{yaxt}.

@menu
* Graphical elements::          
* Axes and tick marks::         
* Figure margins::              
* Multiple figure environment::  
@end menu

@node Graphical elements, Axes and tick marks, Graphics parameters, Graphics parameters
@subsection Graphical elements

@R{} plots are made up of points, lines, text and polygons (filled
regions.) Graphical parameters exist which control how these
@emph{graphical elements} are drawn, as follows:

@table @code
@item pch="+"
Character to be used for plotting points.  The default varies with
graphics drivers, but it is usually
@ifnottex
a circle.
@end ifnottex
@tex
`$\circ$'.
@end tex
Plotted points tend to appear slightly above or below the appropriate
position unless you use @code{"."} as the plotting character, which
produces centered points.

@item pch=4
When @code{pch} is given as an integer between 0 and 25 inclusive, a
specialized plotting symbol is produced.  To see what the symbols are,
use the command

@example
> legend(locator(1), as.character(0:25), pch = 0:25)
@end example

@noindent
Those from 21 to 25 may appear to duplicate earlier symbols, but can be
coloured in different ways: see the help on @code{points} and its
examples.

In addition, @code{pch} can be a character or a number in the range
@code{32:255} representing a character in the current font.

@item lty=2
Line types.  Alternative line styles are not supported on all graphics
devices (and vary on those that do) but line type 1 is always a solid
line, line type 0 is always invisible, and line types 2 and onwards are
dotted or dashed lines, or some combination of both.

@item lwd=2
Line widths.  Desired width of lines, in multiples of the ``standard''
line width.  Affects axis lines as well as lines drawn with
@code{lines()}, etc.  Not all devices support this, and some have
restrictions on the widths that can be used.

@item col=2
Colors to be used for points, lines, text, filled regions and images.
A number from the current palette (see @code{?palette}) or a named colour.

@item col.axis
@itemx col.lab
@itemx col.main
@itemx col.sub
The color to be used for axis annotation, @math{x} and @math{y} labels,
main and sub-titles, respectively.

@item font=2
An integer which specifies which font to use for text.  If possible,
device drivers arrange so that @code{1} corresponds to plain text,
@code{2} to bold face, @code{3} to italic, @code{4} to bold italic
and @code{5} to a symbol font (which include Greek letters).

@item font.axis
@itemx font.lab
@itemx font.main
@itemx font.sub
The font to be used for axis annotation, @math{x} and @math{y} labels,
main and sub-titles, respectively.

@item adj=-0.1
Justification of text relative to the plotting position.  @code{0} means
left justify, @code{1} means right justify and @code{0.5} means to
center horizontally about the plotting position.  The actual value is
the proportion of text that appears to the left of the plotting
position, so a value of @code{-0.1} leaves a gap of 10% of the text width
between the text and the plotting position.

@item cex=1.5
Character expansion.  The value is the desired size of text characters
(including plotting characters) relative to the default text size.

@item cex.axis
@itemx cex.lab
@itemx cex.main
@itemx cex.sub
The character expansion to be used for axis annotation, @math{x} and
@math{y} labels, main and sub-titles, respectively.
@end table

@node Axes and tick marks, Figure margins, Graphical elements, Graphics parameters
@subsection Axes and tick marks

Many of @R{}'s high-level plots have axes, and you can construct axes
yourself with the low-level @code{axis()} graphics function.  Axes have
three main components: the @emph{axis line} (line style controlled by the
@code{lty} graphics parameter), the @emph{tick marks} (which mark off unit
divisions along the axis line) and the @emph{tick labels} (which mark the
units.) These components can be customized with the following graphics
parameters.

@table @code
@item lab=c(5, 7, 12)
The first two numbers are the desired number of tick intervals on the
@math{x} and @math{y} axes respectively.  The third number is the
desired length of axis labels, in characters (including the decimal
point.)  Choosing a too-small value for this parameter may result in all
tick labels being rounded to the same number!

@item las=1
Orientation of axis labels.  @code{0} means always parallel to axis,
@code{1} means always horizontal, and @code{2} means always
perpendicular to the axis.

@item mgp=c(3, 1, 0)
Positions of axis components.  The first component is the distance from
the axis label to the axis position, in text lines.  The second
component is the distance to the tick labels, and the final component is
the distance from the axis position to the axis line (usually zero).
Positive numbers measure outside the plot region, negative numbers
inside.

@item tck=0.01
Length of tick marks, as a fraction of the size of the plotting region.
When @code{tck} is small (less than 0.5) the tick marks on the @math{x}
and @math{y} axes are forced to be the same size.  A value of 1 gives
grid lines.  Negative values give tick marks outside the plotting
region.  Use @code{tck=0.01} and @code{mgp=c(1,-1.5,0)} for internal
tick marks.

@item xaxs="r"
@itemx yaxs="i"
Axis styles for the @math{x} and @math{y} axes, respectively.   With
styles @code{"i"} (internal) and @code{"r"} (the default) tick marks
always fall within the range of the data, however style @code{"r"}
leaves a small amount of space at the edges.  (@Sl{} has other styles
not implemented in @R{}.)

@c Setting this parameter to @code{"d"} (direct axis) @emph{locks in} the
@c current axis and uses it for all future plots (or until the parameter is
@c set to one of the other values above, at least.) Useful for generating
@c series of fixed-scale plots.
@end table

@node Figure margins, Multiple figure environment, Axes and tick marks, Graphics parameters
@subsection Figure margins


A single plot in @R{} is known as a @code{figure} and comprises a
@emph{plot region} surrounded by margins (possibly containing axis
labels, titles, etc.) and (usually) bounded by the axes themselves.

@iftex
A typical figure is

@c @image{images/fig11,7cm} @c deleted by Chel Hee Lee
@end iftex

Graphics parameters controlling figure layout include:

@table @code
@item mai=c(1, 0.5, 0.5, 0)
Widths of the bottom, left, top and right margins, respectively,
measured in inches.

@item mar=c(4, 2, 2, 1)
Similar to @code{mai}, except the measurement unit is text lines.
@end table

@code{mar} and @code{mai} are equivalent in the sense that setting one
changes the value of the other.  The default values chosen for this
parameter are often too large; the right-hand margin is rarely needed,
and neither is the top margin if no title is being used.  The bottom and
left margins must be large enough to accommodate the axis and tick
labels.  Furthermore, the default is chosen without regard to the size
of the device surface: for example, using the @code{postscript()} driver
with the @code{height=4} argument will result in a plot which is about
50% margin unless @code{mar} or @code{mai} are set explicitly.  When
multiple figures are in use (see below) the margins are reduced, however
this may not be enough when many figures share the same page.

@node Multiple figure environment,  , Figure margins, Graphics parameters
@subsection Multiple figure environment

@R{} allows you to create an @math{n} by @math{m} array of figures on a
single page.  Each figure has its own margins, and the array of figures
is optionally surrounded by an @emph{outer margin}, as shown in the
following figure.

@iftex
@c @image{images/fig12,6cm} @c deleted by Chel Hee Lee 
@end iftex

The graphical parameters relating to multiple figures are as follows:

@table @code
@item mfcol=c(3, 2)
@itemx mfrow=c(2, 4)
Set the size of a multiple figure array.  The first value is the number of
rows; the second is the number of columns.  The only difference between
these two parameters is that setting @code{mfcol} causes figures to be
filled by column; @code{mfrow} fills by rows.

The layout in the Figure could have been created by setting
@code{mfrow=c(3,2)}; the figure shows the page after four plots have
been drawn.

Setting either of these can reduce the base size of symbols and text
(controlled by @code{par("cex")} and the pointsize of the device).  In a
layout with exactly two rows and columns the base size is reduced by a
factor of 0.83: if there are three or more of either rows or columns,
the reduction factor is 0.66.

@item mfg=c(2, 2, 3, 2)
Position of the current figure in a multiple figure environment.  The first
two numbers are the row and column of the current figure; the last two
are the number of rows and columns in the multiple figure array.  Set
this parameter to jump between figures in the array.  You can even use
different values for the last two numbers than the @emph{true} values
for unequally-sized figures on the same page.

@item fig=c(4, 9, 1, 4)/10
Position of the current figure on the page.  Values are the positions of
the left, right, bottom and top edges respectively, as a percentage of
the page measured from the bottom left corner.  The example value would
be for a figure in the bottom right of the page.  Set this parameter for
arbitrary positioning of figures within a page.  If you want to add a
figure to a current page, use @code{new=TRUE} as well (unlike S).

@item oma=c(2, 0, 3, 0)
@itemx omi=c(0, 0, 0.8, 0)
Size of outer margins.  Like @code{mar} and @code{mai}, the first
measures in text lines and the second in inches, starting with the
bottom margin and working clockwise.

@end table

Outer margins are particularly useful for page-wise titles, etc.  Text
can be added to the outer margins with the @code{mtext()} function with
argument @code{outer=TRUE}.  There are no outer margins by default,
however, so you must create them explicitly using @code{oma} or
@code{omi}.

More complicated arrangements of multiple figures can be produced by the
@code{split.screen()} and @code{layout()} functions, as well as by the
@pkg{grid} and @CRANpkg{lattice} packages.

@node Device drivers, Dynamic graphics, Graphics parameters, Graphics
@section Device drivers
@cindex Graphics device drivers

@R{} can generate graphics (of varying levels of quality) on almost any
type of display or printing device.  Before this can begin, however,
@R{} needs to be informed what type of device it is dealing with.  This
is done by starting a @emph{device driver}.  The purpose of a device
driver is to convert graphical instructions from @R{} (``draw a line,''
for example) into a form that the particular device can understand.

Device drivers are started by calling a device driver function.  There
is one such function for every device driver: type @code{help(Devices)}
for a list of them all.  For example, issuing the command

@example
> postscript()
@end example

@noindent
causes all future graphics output to be sent to the printer in
PostScript format.  Some commonly-used device drivers are:

@table @code
@item X11()
@findex X11
For use with the X11 window system on Unix-alikes
@item windows()
@findex windows
For use on Windows
@item quartz()
@findex quartz
For use on Mac OS X
@item postscript()
@findex postscript
For printing on PostScript printers, or creating PostScript graphics
files.
@item pdf()
@findex pdf
Produces a PDF file, which can also be included into PDF files.
@item png()
@findex png
Produces a bitmap PNG file. (Not always available: see its help page.)
@item jpeg()
@findex jpeg
Produces a bitmap JPEG file, best used for @code{image} plots.
(Not always available: see its help page.)
@end table

When you have finished with a device, be sure to terminate the device
driver by issuing the command

@example
> dev.off()
@end example

This ensures that the device finishes cleanly; for example in the case
of hardcopy devices this ensures that every page is completed and has
been sent to the printer.  (This will happen automatically at the normal
end of a session.)

@menu
* PostScript diagrams for typeset documents::  
* Multiple graphics devices::   
@end menu

@node PostScript diagrams for typeset documents, Multiple graphics devices, Device drivers, Device drivers
@subsection PostScript diagrams for typeset documents

By passing the @code{file} argument to the @code{postscript()} device
driver function, you may store the graphics in PostScript format in a
file of your choice.  The plot will be in landscape orientation unless
the @code{horizontal=FALSE} argument is given, and you can control the
size of the graphic with the @code{width} and @code{height} arguments
(the plot will be scaled as appropriate to fit these dimensions.) For
example, the command

@example
> postscript("file.ps", horizontal=FALSE, height=5, pointsize=10)
@end example

@noindent
will produce a file containing PostScript code for a figure five inches
high, perhaps for inclusion in a document.  It is important to note that
if the file named in the command already exists, it will be overwritten.
This is the case even if the file was only created earlier in the same
@R{} session.

Many usages of PostScript output will be to incorporate the figure in
another document.  This works best when @emph{encapsulated} PostScript
is produced: @R{} always produces conformant output, but only marks the
output as such when the @code{onefile=FALSE} argument is supplied.  This
unusual notation stems from @Sl{}-compatibility: it really means that
the output will be a single page (which is part of the EPSF
specification).  Thus to produce a plot for inclusion use something like

@example
> postscript("plot1.eps", horizontal=FALSE, onefile=FALSE,
             height=8, width=6, pointsize=10)
@end example


@node Multiple graphics devices,  , PostScript diagrams for typeset documents, Device drivers
@subsection Multiple graphics devices

In advanced use of @R{} it is often useful to have several graphics
devices in use at the same time.  Of course only one graphics device can
accept graphics commands at any one time, and this is known as the
@emph{current device}.  When multiple devices are open, they form a
numbered sequence with names giving the kind of device at any position.

The main commands used for operating with multiple devices, and their
meanings are as follows:

@table @code
@item X11()
[UNIX]
@item windows()
@itemx win.printer()
@itemx win.metafile()
[Windows]
@item quartz()
[Mac OS X]
@item postscript()
@itemx pdf()
@item png()
@item jpeg()
@item tiff()
@item bitmap()
@itemx @dots{}
Each new call to a device driver function opens a new graphics device,
thus extending by one the device list.  This device becomes the current
device, to which graphics output will be sent.

@item dev.list()
@findex dev.list
Returns the number and name of all active devices.  The device at
position 1 on the list is always the @emph{null device} which does not
accept graphics commands at all.

@item dev.next()
@itemx dev.prev()
@findex dev.next
@findex dev.prev
Returns the number and name of the graphics device next to, or previous
to the current device, respectively.

@item dev.set(which=@var{k})
@findex dev.set
Can be used to change the current graphics device to the one at position
@var{k} of the device list.  Returns the number and label of the device.

@item dev.off(@var{k})
@findex dev.off
Terminate the graphics device at point @var{k} of the device list.  For
some devices, such as @code{postscript} devices, this will either print
the file immediately or correctly complete the file for later printing,
depending on how the device was initiated.

@item dev.copy(device, @dots{}, which=@var{k})
@itemx dev.print(device, @dots{}, which=@var{k})
Make a copy of the device @var{k}.  Here @code{device} is a device
function, such as @code{postscript}, with extra arguments, if needed,
specified by @samp{@dots{}}.  @code{dev.print} is similar, but the
copied device is immediately closed, so that end actions, such as
printing hardcopies, are immediately performed.

@item graphics.off()
Terminate all graphics devices on the list, except the null device.
@end table

@node Dynamic graphics,  , Device drivers, Graphics
@section Dynamic graphics
@cindex Dynamic graphics

@R{} does not have builtin capabilities for dynamic or
interactive graphics, e.g.@ rotating point clouds or to ``brushing''
(interactively highlighting) points. However, extensive dynamic graphics
facilities are available in the system GGobi by Swayne, Cook and Buja
available from

@quotation
@uref{http://www.ggobi.org/}
@end quotation

@noindent
and these can be accessed from @R{} via the package @CRANpkg{rggobi}, described at
@uref{http://www.ggobi.org/rggobi}.

Also, package @CRANpkg{rgl} provides ways to interact with 3D plots, for example
of surfaces.

@node Packages, A sample session, Graphics, Top
@chapter Packages
@cindex Packages

@c All @R{} functions and datasets are stored in @emph{packages}.  Only
@c when a package is loaded are its contents available.  This is done both
@c for efficiency (the full list would take more memory and would take
@c longer to search than a subset), and to aid package developers, who are
@c protected from name clashes with other code.  The process of developing
@c packages is described in @ref{Creating R packages, , Creating R
@c packages, R-exts, Writing R Extensions}.  Here, we will describe them
@c from a user's point of view.

모든 @R{} 함수들과 데이터셋들은 @emph{packages}(패키지)안에 저장되어 있습니다. 
따라서, 패키지가 로드되었을때만 패키지 안의 내용들을 사용할 수 있습니다.
이러한 패키지 시스템은 전체리스트를 사용하지 않으므로 메모리의 사용량이 적고 필요시 검색에도 훨씬 적은 시간이 걸리므로 메모리사용에서 효율적이라고 할 수 있습니다. 
또한, 이러한 시스템은 다른 코드들과 이름이 충돌이 나는 것을 자연스레 방지해 줌으로서 패키지 개발자의 편의를 고려했다고 볼 수 있습니다. 
패키지를 개발하는 과정에 대해서는 @ref{Creating R packages, , Creating R packages, R-exts, Writing R Extensions}를 살펴보시길 바랍니다.
여기에서 우리는 사용자 측면에 대해서만 이야기 할 것입니다.

@c To see which packages are installed at your site, issue the command
어떤 패키지들이 사용자의 사이트(site)에 설치되어 있는지 알고 싶다면 다음의 명령어를 아무런 인자없이 입력해보세요.

@example
> library()
@end example

@noindent
@c with no arguments.  To load a particular package (e.g., the @CRANpkg{boot}
@c package containing functions from Davison & Hinkley (1997)), use a
@c command like

Davison & Hinkley (1997)가 작성한 함수들을 포함하고 있는 @CRANpkg{boot}와 같은 어떤 특정한 패키지를 설치하고자 한다면, 아래와 같이 명령어를 입력하면 됩니다. 
@example
> library(boot)
@end example

@c Users connected to the Internet can use the @code{install.packages()}
@c and @code{update.packages()} functions (available through the
@c @code{Packages} menu in the Windows and RAqua GUIs, @pxref{Installing
@c packages, , , R-admin, R Installation and Administration}) to install and
@c update packages.

인터넷에 연결되어 있는 사용자라면 @code{install.packages()}와 @code{update.packages()} 함수들을 이용하여 패키지를 설치하거나 업데이트 할 수 있습니다. 
윈도우즈와 RAqua GUI에서는 @code{Packages} 메뉴를 통하여 위의 기능들을 이용할 수 있습니다. 
@pxref{Installing packages, , , R-admin, R Installation and Administration})를 참고하시길 바랍니다.

@c To see which packages are currently loaded, use
현재 로드되어 있는 패키지들을 확인하고 싶다면 아래의 명령어를 이용해보세요.

@example
> search()
@end example

@noindent
@c to display the search list.  Some packages may be loaded but not
@c available on the search list (@pxref{Namespaces}): these will be
@c included in the list given by

이것은 검색리스트(search list)를 보여줄 것입니다.
일부 패키지들은 아마도 로드되었지만 검색리스트에서 보여지지 않을 수 도 있습니다.
이에 대해서는 @pxref{Namespaces}를 참고하시길 바랍니다.
이들은 다음의 명령어를 통해서 확인이 가능합니다.

@example
> loadedNamespaces()
@end example

@c To see a list of all available help topics in an installed package,
@c use

설치된 패키지에 있는 이용이 가능한 모든 도움말 주제들의 목록을 확인해 보고 싶다면 아래의 명령어를 이용하세요.

@example
> help.start()
@end example

@noindent
@c to start the @HTML{} help system, and then navigate to the package
@c listing in the @code{Reference} section.

이 명령어는 @HTML{} 도움말 시스템을 시작할 것이고, @code{Reference}섹션에서 패키지 목록들을 탐색하시면 됩니다.

@menu
* Standard packages::           
* Contributed packages and CRAN::  
* Namespaces::                  
@end menu

@node Standard packages, Contributed packages and CRAN, Packages, Packages
@section Standard packages

@c The standard (or @emph{base}) packages are considered part of the @R{}
@c source code.  They contain the basic functions that allow @R{} to work,
@c and the datasets and standard statistical and graphical functions that
@c are described in this manual.  They should be automatically available in
@c any @R{} installation.  @xref{Which add-on packages exist for R?, , R
@c packages, R-FAQ, R FAQ}, for a complete list.

표준 (또는 @emph{base}) 패키지들은 @R{} 소스코드의 중요한 부분입니다.
이들은 @R{}이 작업을 할 수 있도록 해주는 기본 함수들과 데이터셋, 그리고 표준 통계분석 및 이 문서에서 설명된 그래픽 함수들이 포함되어 있습니다.
이러한 표준 패키지들은 @R{} 설치시에 자동으로 사용이 가능합니다.
모든 표준패키지 목록을 알고 싶으시다면 다음을 참조하세요 @xref{Which add-on packages exist for R?, , R packages, R-FAQ, R FAQ}.

@node Contributed packages and CRAN, Namespaces, Standard packages, Packages
@section Contributed packages and @acronym{CRAN}
@cindex CRAN

@c There are thousands of contributed packages for @R{}, written by many
@c different authors.  Some of these packages implement specialized
@c statistical methods, others give access to data or hardware, and others
@c are designed to complement textbooks.  Some (the @emph{recommended}
@c packages) are distributed with every binary distribution of @R{}.  Most
@c are available for download from @acronym{CRAN}
@c (@uref{http://CRAN.R-project.org/} and its mirrors) and other
@c repositories such as Bioconductor (@uref{http://www.bioconductor.org/})
@c and Omegahat (@uref{http://www.omegahat.org/}).  The @emph{R FAQ}
@c contains a list of CRAN packages current at the time of release, but the
@c collection of available packages changes very frequently.

@R{}은 무수히 많은 개발자들에 의해 작성된 매우 방대한 양의 기여된 패키지(contributed package)들이 있습니다. 
이들 중 일부는 특수한 통계방법들을 구현하였고, 또다른 일부는 데이터 또는 하드웨어에 대한 접근과 관련이 있으며, 그 외의 다른 패키지들은 어떤 참고서 혹은 교과서의 부록이기도 합니다.
일부 @emph{recommended} (권장)패키지들은 @R{}의 바이너리 배포판과 함께 배포됩니다.
대부분은 @acronym{CRAN}(@uref{http://CRAN.R-project.org/}과 미러)와 Bioconductor (@uref{http://www.bioconductor.org/}) 그리고 Omegahat (@uref{http://www.omegahat.org/})과 같은 저장소들을 통해서 얻을 수 있습니다.
@emph{R FAQ}는 가장 최근에 릴리즈된 CRAN 패키지들의 목록을 포함하고 있지만, 이용가능한 패키지들의 목록이 매우 자주 변경됩니다.

@node Namespaces,  , Contributed packages and CRAN, Packages
@section Namespaces
@cindex Namespace
@findex ::
@findex :::

@c Packages can have @emph{namespaces}, and currently all of the base and
@c recommended packages do except the @code{datasets} package.  Namespaces
@c do three things: they allow the package writer to hide functions and
@c data that are meant only for internal use, they prevent functions from
@c breaking when a user (or other package writer) picks a name that clashes
@c with one in the package, and they provide a way to refer to an object
@c within a particular package.

패키지들은 @emph{namespaces}(네임스페이스)를 가질 수 있으며, 현재 @code{datasets} 패키지를 제외한 base와 권장 패키지들 모두가 네임스페이스를 가지고 있습니다. 
네임스페이스는 주로 다음의 세가지 역할을 수행합니다.
첫째는 패키지 작성자가 내부적 사용만을 목적으로 개발하고자 하는 함수들과 데이터들을 숨길 수 있도록 합니다. 
둘째는 사용자 혹은 다른 패키지 작성자가 @R{}의 함수명과 동일한 이름을 가지는 함수명을 사용하고자 할때 동일한 함수명으로 인한 충돌로 인하여 사용자가 사용하고자 하는 함수의 작동이 중단되는 것을 방지할 수 있도록 해줍니다.
마지막으로 특정패키지 내의 객체를 지칭하는데 사용될 수 있습니다.

@c For example, @code{t()} is the transpose function in @R{}, but users
@c might define their own function named @code{t}.  Namespaces prevent
@c the user's definition from taking precedence, and breaking every
@c function that tries to transpose a matrix.

예를 들면, @code{t()}라는 함수는 @R{}에서 행렬을 전치하는데 사용되어 집니다.  
그러나, 사용자는 아마도 @code{t}라는 동일한 이름을 가진 자신만의 고유한 함수를 만들었을수도 있습니다.
네임스페이스는 사용자가 작성한 함수가 우선권을 가지는 것을 막아주고, 행렬을 전치하고자 하는 모든 함수를 중단하게 합니다.

@c There are two operators that work with namespaces.  The double-colon
@c operator @code{::} selects definitions from a particular namespace.
@c In the example above, the transpose function will always be available
@c as @code{base::t}, because it is defined in the @code{base} package.
@c Only functions that are exported from the package can be retrieved in
@c this way.

네임스페이스와 함께 사용되는 두개의 연산자들이 있습니다. 
하나는 더블콜론(double-colon) 연산자 @code{::}이며, 이는 특정한 네임스페이스로부터 정의되어 있는 함수를 불러옵니다.
위의 예제를 다시 살펴보면, 전치함수는 @code{base}패키지 안에 정의되어 있기 때문에 항상 @code{base::t}를 이용하여 사용이 가능합니다.
용할 수 있습니다.
패키지에서 내보내어진 함수들만이 이러한 방법으로 검색되어 질 수 있습니다.

@c The triple-colon operator @code{:::} may be seen in a few places in R
@c code: it acts like the double-colon operator but also allows access to
@c hidden objects.  Users are more likely to use the @code{getAnywhere()}
@c function, which searches multiple packages.

트리플-콜론(triple-colon) 연산자 @code{:::}가 @R 코드내에서 여러 곳에서 사용된 것을 보았을 것입니다.
이것은 더블-콜론 연산자와 비슷하게 기능을 수행하며 또한 숨겨진 객체에 대한 접근을 허락합니다.
그퍼나, 여러개의 패키지들을 검색할 수 있는 특징때문에 사용자는 @code{getAnywhere()} 함수를 더 자주 이용할 것입니다.

@c Packages are often inter-dependent, and loading one may cause others to
@c be automatically loaded.  The colon operators described above will also
@c cause automatic loading of the associated package.  When packages with
@c namespaces are loaded automatically they are not added to the search
@c list.

패키지들은 서로 상호의존적(inter-dependent)이며, 하나를 로딩할 때 자동으로 다른 것들을 함께 로딩될 수 있습니다.
위에서 설명한 콜론연산자들은 또한 연관된 자동패키지들을 로딩하기도 합니다.
네임스페이스가 있는 패키지들이 자동으로 로드될때 이들은 검색목록에 추가되지 않습니다.

@node A sample session, Invoking R, Packages, Top
@c @appendix A sample session
@appendix A 샘플 세션 

@c The following session is intended to introduce to you some features of
@c the @R{} environment by using them.  Many features of the system will be
@c unfamiliar and puzzling at first, but this puzzlement will soon
@c disappear.

다음 세션은 @R{} (개발)환경의 일부 기능을 독자가 따라해 봄으로서 쉽게 알 수 있도록 준비한 섹션입니다.
시스템의 많은 기능들이 처음에는 익숙하지 않고 혼잡스러울 수 있으나, 이러한 어려움들은 차차 사라지게 될 것입니다.
@c This is written for the UNIX user.  Those using Windows will
@c need to adapt the discussion slightly.

@table @code
@item
@c Start @R{} appropriately for your platform (@pxref{Invoking R}).
@R{}을 실행시켜보세요 (사용자의 플랫폼별로 다를 수 있으니 @pxref{Invoking R}를 참조하시길 바랍니다).

@c The @R{} program begins, with a banner.
@R{} 프로그램이 시작되면 배너가 보일 것입니다.

@c (Within @R{} code, the prompt on the left hand side will not be shown to
@c avoid confusion.)
@R{} 코드를 표시할 때는 독자들의 혼돈을 피하기 위해서 왼쪽에 있는 프롬프트는 표시하지 않습니다.

@item help.start()
@c Start the @HTML{} interface to on-line help (using a web browser
@c available at your machine).  You should briefly explore the features of
@c this facility with the mouse.

이 명령어를 치면 온라인 도움말을 사용자의 환경에서 사용이 가능한 인터넷 브라우저를 이용하여 @HTML{}인터페이스를 시작하게 됩니다. 
마우스를 이용하여 단순히 어떻게 운영하는 것인지 간단히 살펴보시길 바랍니다.

@c Iconify the help window and move on to the next part.
다음으로 넘어가기 위해서 도움말 창을 작게 만듭니다.

@item x <- rnorm(50)
@itemx y <- rnorm(x)
@c Generate two pseudo-random normal vectors of @math{x}- and
@c @math{y}-coordinates.
이것은 @math{x}와 @math{y}라는 두개의 벡터를 생성하는 것을 의미하는데, 이것은 추후에 플랏을 그리는데 사용할 좌표의 정보입니다. 
@math{x}는 표준정규분포로부터 발생시킨 50개의 난수들을 열벡터의 형식으로 가지고 있으며, @math{y} 역시 @math{x}와 같은 길이만큼의 난수를 표준정규분포로부터 가지게 됩니다.

@item plot(x, y)
@c Plot the points in the plane.  A graphics window will appear automatically.
@math{x}와 @math{y}로 이루어진 좌표들을 평면공간에 플랏하도록 합니다.
그래픽 창이 자동으로 보여질 것입니다.

@item ls()
@c See which @R{} objects are now in the @R{} workspace.
@R{} 워크스페이스 (즉, 작업공간)에 어떠한 @R{} 객체들이 있는지 확인해 보도록 합니다.

@item rm(x, y)
@c Remove objects no longer needed. (Clean up).
더 이상 필요가 없는 객체들을 삭제하도록 합니다.

@item x <- 1:20
@c Make @math{x = (1, 2, @dots{}, 20)}.
@math{x = (1, 2, @dots{}, 20)}를 생성합니다.

@item w <- 1 + sqrt(x)/2
@c A `weight' vector of standard deviations.
표준편차를 이용한 `가중치'벡터를 생성합니다.

@item dummy <- data.frame(x=x, y= x + rnorm(x)*w)
@itemx dummy
@c Make a @emph{data frame} of two columns, @math{x} and @math{y}, and look
@c at it.
@math{x}와 @math{y}의 두개의 열로 이루어진 @emph{data frame}(데이터프레임)을 생성합니다.
그리고 나서 이를 살펴볼 수 있습니다.

@item fm <- lm(y ~ x, data=dummy)
@itemx summary(fm)
@c Fit a simple linear regression and look at the
@c analysis.  With @code{y} to the left of the tilde,
@c we are modelling @math{y} dependent on @math{x}.

단순선형회귀분석을 실행하고 그 분석결과를 살펴봅니다.
틸데표시 좌측에 있는 @code{y}를 우리는 @math{x}를 이용하여 모델한 것입니다.
 
@item fm1 <- lm(y ~ x, data=dummy, weight=1/w^2)
@itemx summary(fm1)
@c Since we know the standard deviations, we can do a weighted regression.
우리는 표준편차를 알고 있기 때문에, 가중회귀분석을 수행합니다.
그리고 그 결과를 봅니다

@item attach(dummy)
@c Make the columns in the data frame visible as variables.
데이터프레임내에 있는 열들을 일반적인 변수와 같이 접근할 수 있도록 해줍니다.

@item lrf <- lowess(x, y)
@c Make a nonparametric local regression function.
비모수 국지회귀함수를 수행합니다.

@item plot(x, y)
@c Standard point plot.
표준적 방법으로 @math{x}와 @math{y} 포인트들을 플랏합니다.

@item lines(x, lrf$y)
@c Add in the local regression.
포인트를 플랏한 그래픽에 회귀분석으로부터 나온 결과를 이용하여 회귀곡선을 그립니다.

@item abline(0, 1, lty=3)
@c The true regression line: (intercept 0, slope 1).
그래픽에 기울기가 1이고 절편이 0인 실제 회귀분석곡선을 추가적으로 그려넣습니다.

@item abline(coef(fm))
@c Unweighted regression line.
위에서 단순선형회귀분석을 한 결과가 저장된 @math{fm}로부터 기울기와 절편에 해당하는 회귀계수들을 이용하여 회귀곡선을 그리도록 합니다.

@item abline(coef(fm1), col = "red")
@c Weighted regression line.
위에서 가중회귀분석을 한 결과가 저장된 @math{fm1}로부터 기울기와 절편에 해당하는 회귀계수들을 이용하여 회귀곡선을 빨간색으로 그려넣습니다.

@item detach()
@c Remove data frame from the search path.
검색경로(search path)로부터 데이터프레임을 제거합니다.

@item plot(fitted(fm), resid(fm),
@itemx @w{@ @ @ @ @ xlab="Fitted values"},
@itemx @w{@ @ @ @ @ ylab="Residuals"},
@itemx @w{@ @ @ @ @ main="Residuals vs Fitted")}
@c A standard regression diagnostic plot to check for heteroscedasticity.
@c Can you see it?
이분산성(heteroscedasticity)을 확인하기 위해서 표준회귀 진단플랏을 그립니다.
보입니까? 

@item qqnorm(resid(fm), main="Residuals Rankit Plot")
@c A normal scores plot to check for skewness, kurtosis and outliers.  (Not
@c very useful here.)
비대칭도(skewness), 첨도(kurtosis), 그리고 이상치(outliers)를 찾기 위해서 정규스코어플랏(normal score plot)을 생성합니다.
(실제로 여기에서는 별로 유용하지 않습니다).

@item rm(fm, fm1, lrf, x, dummy)
@c Clean up again.
다시 불필요한 객체들을 삭제합니다.
@end table

@c The next section will look at data from the classical experiment of
@c Michelson to measure the speed of light.  This dataset is available in
@c the @code{morley} object, but we will read it to illustrate the
@c @code{read.table} function.

다음 섹션에서는 Michelson이 빛의 속도를 측정하기 위해서 사용했던 실험으로부터 모은 데이터를 살펴보도록 하겠습니다.
이 데이터셋은 @code{morley} 객체에서 이용이 가능하지만, 여기에서는 @code{read.table}함수를 어떻게 사용하는가를 보여주기 위해서 데이터를 불러 오도록 해보겠습니다.

@table @code
@item filepath <- system.file("data", "morley.tab" , package="datasets")
@itemx filepath

데이터 파일이 들어있는 경로에 대한 정보를 먼저 얻습니다.

@item file.show(filepath)
@c Optional.  Look at the file.
(선택적 사항) 파일의 내용을 봅니다

@item mm <- read.table(filepath)
@itemx mm
@c Read in the Michelson data as a data frame, and look at it.
@c There are five experiments (column @code{Expt}) and each has 20 runs
@c (column @code{Run}) and @code{sl} is the recorded speed of light,
@c suitably coded.

Michelson의 데이터를 데이터프레임으로서 읽어들이고, 이를 확인해 봅니다.
이 데이터셋은 @code{Expt}라는 열로부터 5번의 실험들이 있었으며, @code{Run}이라는 열로부터 각각 20번씩 수행되었음을 알 수 있습니다.
그리고 @code{sl}에는 빛의 속도가 입력되어 있습니다.

@item mm$Expt <- factor(mm$Expt)
@itemx mm$Run <- factor(mm$Run)
@c Change @code{Expt} and @code{Run} into factors.
@code{Expt}와 @code{Run}에 있는 데이터의 종류를 요인(factor)으로 변경합니다.

@item attach(mm)
@c Make the data frame visible at position 3 (the default).
데이터프레임을 포지션 3 (기본값)에서 볼 수 있도록 합니다. 

@item plot(Expt, Speed, main="Speed of Light Data", xlab="Experiment No.")
@c Compare the five experiments with simple boxplots.
박스플랏(boxplot)을 이용하여 5개의 실험들을 비교해보도록 합니다.

@item fm <- aov(Speed ~ Run + Expt, data=mm)
@itemx summary(fm)
@c Analyze as a randomized block, with `runs' and `experiments' as factors.
`runs'와 `experiments'를 요인으로 놓은 상태에서 랜덤마이즈된 블락(randomized block)으로서 분석을 합니다.

@item fm0 <- update(fm, . ~ . - Run)
@itemx anova(fm0, fm)
@c Fit the sub-model omitting `runs', and compare using a formal analysis
@c of variance.
`runs'를 삭제한 서브모델을 적합한 다음에 이전의 분산분석(analysis of variance)와 비교를 해봅니다.

@item detach()
@itemx rm(fm, fm0)
@c Clean up before moving on.
다음 분석으로 넘어가기 전에 불필요한 객체들을 삭제합니다.

@end table

@c We now look at some more graphical features: contour and image plots.
우리는 이제 contour(컨투어 또는 등고선)와 image(이미지) 플랏이라는 그래픽 기능에 대해서 좀 더 알아보도록 할 것입니다.

@table @code
@item x <- seq(-pi, pi, len=50)
@itemx y <- x
@c @math{x} is a vector of 50 equally spaced values in
@math{x}는 

@ifnottex
@c the interval [-pi\, pi].
[-pi\, pi] 구간을 50등분한 값을 가지고 있는 벡터입니다.
@end ifnottex
@iftex
@tex
$-\pi\leq x \leq \pi$ 구간을 50등분한 값을 가지고 있는 벡터입니다.
@end tex
@end iftex

@c @math{y} is the same.
@math{y}는 @math{x}와 동일한 벡터입니다.

@item f <- outer(x, y, function(x, y) cos(y)/(1 + x^2))
@c @math{f} is a square matrix, with rows and columns indexed by @math{x}
@c and @math{y} respectively, of values of the function
@c @eqn{\cos(y)/(1 + x^2),cos(y)/(1 + x^2)}.
@math{f}는 @math{x}와 @math{y}를 각각 행과 열로 가지는 정방행렬이며, 이 행렬의 원소는 @math{x}의 원소와 @math{y}의 원소의 쌍을 이용하여 함수 @eqn{\cos(y)/(1 + x^2),cos(y)/(1 + x^2)}를 통해 얻어집니다.

@item oldpar <- par(no.readonly = TRUE)
@itemx par(pty="s")
@c Save the plotting parameters and set the plotting region to ``square''.
현재의 플랏팅 파라미터들을 저장하고 플랏팅지역 (plotting region)을 ``square''로 정합니다.

@item contour(x, y, f)
@itemx contour(x, y, f, nlevels=15, add=TRUE)
@c Make a contour map of @math{f}; add in more lines for more detail.
@math{f}의 컨투어 맵(contour map)을 생성하고, 15개의 컨투어 레벨을 보여지도록 합니다.

@item fa <- (f-t(f))/2
@c @code{fa} is the ``asymmetric part'' of @math{f}.  (@code{t()} is
@c transpose).
@code{fa}는 @math{f}의 ``asymmetric part''(비대칭 부분)입니다 (여기에서 @code{t()}는 행렬의 전치를 의미합니다).

@item contour(x, y, fa, nlevels=15)
@c Make a contour plot, @dots{}
컨투어 플랏을 생성합니다.

@item par(oldpar)
@c @dots{} and restore the old graphics parameters.
이전의 그래픽 파라미터들을 원상태로 되돌립니다.

@item image(x, y, f)
@itemx image(x, y, fa)
@c Make some high density image plots, (of which you can get
@c hardcopies if you wish), @dots{}

이미지 플랏을 생성합니다.

@item objects(); rm(x, y, f, fa)
@c @dots{} and clean up before moving on.
어떤 객체들이 워크스페이스에 있는지 확인한 뒤, 다음 분석을 수행하기 전에 불필요한 객체들을 제거합니다.

@end table

@c @R{} can do complex arithmetic, also.
@R{}은 또한 복소수 연산을 수행할 수 있습니다.

@table @code
@item th <- seq(-pi, pi, len=100)
@itemx z <- exp(1i*th)
@c @code{1i} is used for the complex number @math{i}.
@code{1i}는 복소수 @math{i}를 나타내는데 사용됩니다.

@item par(pty="s")
@itemx plot(z, type="l")
@c Plotting complex arguments means plot imaginary versus real parts.  This
@c should be a circle.

허수와 실수부분을 플랏하도록 합니다.  
이것은 반드시 원의 모양이 나와야 합니다.

@item w <- rnorm(100) + rnorm(100)*1i
@c Suppose we want to sample points within the unit circle.  One method
@c would be to take complex numbers with standard normal real and imaginary
@c parts @dots{}
단위 원(unit circle)내에서 어떤 포인트들을 샘플링해야 한다고 가정해 봅니다. 
이를 위한 한 가지 방법은 아마도 실수와 허수부분에 각각 표준정규분포로부터 난수를 생성하는 것입니다.

@item w <- ifelse(Mod(w) > 1, 1/w, w)
@c @dots{} and to map any outside the circle onto their reciprocal.
원 밖에 놓인 값들만을 골라 그들의 역수에 맵핑시키도록 합니다.

@item plot(w, xlim=c(-1,1), ylim=c(-1,1), pch="+",xlab="x", ylab="y")
@itemx lines(z)
@itemx
@c All points are inside the unit circle, but the distribution is not
@c uniform.
단위원(unit circle)내에 모든 점들이 있지만, 균일분포(uniform distribution)가 아님을 알 수 있습니다.

@item w <- sqrt(runif(100))*exp(2*pi*runif(100)*1i)
@itemx plot(w, xlim=c(-1,1), ylim=c(-1,1), pch="+", xlab="x", ylab="y")
@itemx lines(z)
@itemx
@c The second method uses the uniform distribution.  The points should now
@c look more evenly spaced over the disc.
두번째 방법으로는 균일분포를 이용하는 것입니다.
이 점들은 반드시 디스크에 균등하게 퍼져 있어 보여야 합니다.

@item rm(th, w, z)
@c Clean up again.
다시 불필요한 객체들을 제거 하도록 합니다.

@item q()
@c Quit the @R{} program.  You will be asked if you want to save the @R{}
@c workspace, and for an exploratory session like this, you probably do not
@c want to save it.
@R{} 프로그램을 종료합니다.
이때,  @R{} 작업공간 (또는 워크스페이스)를 저장하고 싶은지에 대해서 물어보게 될 것입니다.
그리고, 기초사용에 대한 설명을 목적으로 하는 세션이므로 꼭 저장하실 필요는 없습니다.
@end table

@node Invoking R, The command-line editor, A sample session, Top
@appendix Invoking R

@c Users of @R{} on Windows or Mac OS X should read the OS-specific section
@c first, but command-line use is also supported.

윈도우즈와 Mac OS X에서 @R{}을 사용하는 유저들은 반드시 운영체제와 관련된 설명부분을 먼저 읽어보시길 바랍니다. 
명령어라인 (command-line)사용 역시 지원됩니다.

@menu
* Invoking R from the command line::  
* Invoking R under Windows::    
* Invoking R under Mac OS X::   
* Scripting with R::            
@end menu

@node Invoking R from the command line, Invoking R under Windows, Invoking R, Invoking R
@appendixsec Invoking R from the command line

When working at a command line on UNIX or Windows, the command @samp{R}
can be used both for starting the main @R{} program in the form



@display
@code{R} [@var{options}] [@code{<}@var{infile}] [@code{>}@var{outfile}],
@end display

@noindent
or, via the @code{R CMD} interface, as a wrapper to various @R{} tools
(e.g., for processing files in @R{} documentation format or manipulating
add-on packages) which are not intended to be called ``directly''.

At the Windows command-line, @command{Rterm.exe} is preferred to
@command{R}.

You need to ensure that either the environment variable @env{TMPDIR} is
unset or it points to a valid place to create temporary files and
directories.

Most options control what happens at the beginning and at the end of an
@R{} session.  The startup mechanism is as follows (see also the on-line
help for topic @samp{Startup} for more information, and the section below
for some Windows-specific details).

@itemize @bullet
@item
Unless @option{--no-environ} was given, @R{} searches for user and site
files to process for setting environment variables.  The name of the
site file is the one pointed to by the environment variable
@env{R_ENVIRON}; if this is unset, @file{@var{R_HOME}/etc/Renviron.site}
is used (if it exists).  The user file is the one pointed to by the
environment variable @env{R_ENVIRON_USER} if this is set; otherwise,
files @file{.Renviron} in the current or in the user's home directory
(in that order) are searched for.  These files should contain lines of
the form @samp{@var{name}=@var{value}}.  (See @code{help("Startup")} for
a precise description.)  Variables you might want to set include
@env{R_PAPERSIZE} (the default paper size), @env{R_PRINTCMD} (the
default print command) and @env{R_LIBS} (specifies the list of @R{}
library trees searched for add-on packages).

@item
Then @R{} searches for the site-wide startup profile unless the command
line option @option{--no-site-file} was given.  The name of this file is
taken from the value of the @env{R_PROFILE} environment variable.  If
that variable is unset, the default
@file{@var{R_HOME}/etc/Rprofile.site} is used if this exists.

@item
Then, unless @option{--no-init-file} was given, @R{} searches for a user
profile and sources it.  The name of this file is taken from the
environment variable @env{R_PROFILE_USER}; if unset, a file called
@file{.Rprofile} in the current directory or in the user's home
directory (in that order) is searched for.

@item
It also loads a saved workspace from file @file{.RData} in the current
directory if there is one (unless @option{--no-restore} or
@option{--no-restore-data} was specified).

@item
Finally, if a function @code{.First()} exists, it is executed.  This
function (as well as @code{.Last()} which is executed at the end of the
@R{} session) can be defined in the appropriate startup profiles, or
reside in @file{.RData}.
@end itemize

In addition, there are options for controlling the memory available to
the @R{} process (see the on-line help for topic @samp{Memory} for more
information).  Users will not normally need to use these unless they
are trying to limit the amount of memory used by @R{}.

@R{} accepts the following command-line options.

@table @option
@item --help
@itemx -h
Print short help message to standard output and exit successfully.

@item --version
Print version information to standard output and exit successfully.

@item --encoding=@var{enc}
Specify the encoding to be assumed for input from the console or
@code{stdin}.  This needs to be an encoding known to @code{iconv}: see
its help page.  (@code{--encoding @var{enc}} is also accepted.)

@item RHOME
Print the path to the @R{} ``home directory'' to standard output and
exit successfully.  Apart from the front-end shell script and the man
page, @R{} installation puts everything (executables, packages, etc.)
into this directory.

@item --save
@itemx --no-save
Control whether data sets should be saved or not at the end of the @R{}
session.  If neither is given in an interactive session, the user is
asked for the desired behavior when ending the session with @kbd{q()};
in non-interactive use one of these must be specified or implied by some
other option (see below).

@item --no-environ
Do not read any user file to set environment variables.

@item --no-site-file
Do not read the site-wide profile at startup.

@item --no-init-file
Do not read the user's profile at startup.

@item --restore
@itemx --no-restore
@itemx --no-restore-data
Control whether saved images (file @file{.RData} in the directory where
@R{} was started) should be restored at startup or not.  The default is
to restore. (@option{--no-restore} implies all the specific
@option{--no-restore-*} options.)

@item --no-restore-history
Control whether the history file (normally file @file{.Rhistory} in the
directory where @R{} was started, but can be set by the environment
variable @env{R_HISTFILE}) should be restored at startup or not.  The
default is to restore.

@item --no-Rconsole
(Windows only) Prevent loading the @file{Rconsole} file at startup.

@item --vanilla
Combine @option{--no-save}, @option{--no-environ},
@option{--no-site-file}, @option{--no-init-file} and
@option{--no-restore}.  Under Windows, this also includes
@option{--no-Rconsole}.

@item -f @var{file}
@itemx --file=@var{file}
(not @command{Rgui.exe}) Take input from @var{file}: @samp{-} means
@code{stdin}.  Implies @option{--no-save} unless @option{--save} has
been set.  On a Unix-alike, shell metacharacters should be avoided in
@var{file} (but as from @R{} 2.14.0 spaces are allowed).

@item -e @var{expression}
(not @command{Rgui.exe}) Use @var{expression} as an input line.  One or
more @option{-e} options can be used, but not together with @option{-f}
or @option{--file}.  Implies @option{--no-save} unless @option{--save}
has been set.  (There is a limit of 10,000 bytes on the total length of
expressions used in this way.  Expressions containing spaces or shell
metacharacters will need to be quoted.)

@item --no-readline
(UNIX only) Turn off command-line editing via @strong{readline}.  This
is useful when running @R{} from within Emacs using the @acronym{ESS}
(``Emacs Speaks Statistics'') package.  @xref{The command-line editor},
for more information.  Command-line editing is enabled by default
interactive use (see @option{--interactive}).  This option also affects
tilde-expansion: see the help for @code{path.expand}.

@item --min-vsize=@var{N}
@itemx --min-nsize=@var{N}
For expert use only: set the initial trigger sizes for garbage
collection of vector heap (in bytes) and @emph{cons cells} (number)
respectively.  Suffix @samp{M} specifies megabytes or millions of cells
respectively.  The defaults are 6Mb and 350k respectively.

@item --max-ppsize=@var{N}
Specify the maximum size of the pointer protection stack as @var{N}
locations.  This defaults to 10000, but can be increased to allow
large and complicated calculations to be done.  Currently the maximum
value accepted is 100000.

@item --max-mem-size=@var{N}
(Windows only) Specify a limit for the amount of memory to be used both
for @R{} objects and working areas.  This is set by default to the
smaller of the amount of physical RAM in the machine and for 32-bit
@R{}, 1.5Gb@footnote{2.5Gb on versions of Windows that support 3Gb per
process and have the support enabled: see the @file{rw-FAQ} Q2.9; 3.5Gb
on some 64-bit versions of Windows.}, and must be between 32Mb and the
maximum allowed on that version of Windows.

@item --quiet
@itemx --silent
@itemx -q
Do not print out the initial copyright and welcome messages.

@item --slave
Make @R{} run as quietly as possible.  This option is intended to
support programs which use @R{} to compute results for them.  It implies
@option{--quiet} and @option{--no-save}.

@item --interactive
(UNIX only) Assert that @R{} really is being run interactively even if
input has been redirected: use if input is from a FIFO or pipe and fed
from an interactive program.  (The default is to deduce that @R{} is
being run interactively if and only if @file{stdin} is connected to a
terminal or @code{pty}.)  Using @option{-e}, @option{-f} or
@option{--file} asserts non-interactive use even if
@option{--interactive} is given.

@item --ess
(Windows only) Set @code{Rterm} up for use by @code{R-inferior-mode} in
@acronym{ESS}, including asserting interactive use without the
command-line editor.

@item --verbose
Print more information about progress, and in particular set @R{}'s
option @code{verbose} to @code{TRUE}.  @R{} code uses this option to
control the printing of diagnostic messages.

@item --debugger=@var{name}
@itemx -d @var{name}
(UNIX only) Run @R{} through debugger @var{name}.  For most debuggers
(the exceptions are @command{valgrind} and recent versions of
@command{gdb}), further command line options are disregarded, and should
instead be given when starting the @R{} executable from inside the
debugger.

@item --gui=@var{type}
@itemx -g @var{type}
(UNIX only) Use @var{type} as graphical user interface (note that this
also includes interactive graphics).  Currently, possible values for
@var{type} are @samp{X11} (the default) and, provided that @samp{Tcl/Tk}
support is available, @samp{Tk}. (For back-compatibility, @samp{x11} and
@samp{tk} are accepted.)

@item --arch=@var{name}
(UNIX only) Run the specified sub-architecture.  Most commonly used on
Mac OS X, where the possible values are @samp{i386}, @samp{x86_64} and
@samp{ppc}.

@item --args
This flag does nothing except cause the rest of the command line to be
skipped: this can be useful to retrieve values from it with
@code{commandArgs(TRUE)}.
@end table

Note that input and output can be redirected in the usual way (using
@samp{<} and @samp{>}), but the line length limit of 4095 bytes still
applies.  Warning and error messages are sent to the error channel
(@code{stderr}).

The command @code{R CMD} allows the invocation of various tools which
are useful in conjunction with @R{}, but not intended to be called
``directly''.  The general form is

@example
R CMD @var{command} @var{args}
@end example

@noindent
where @var{command} is the name of the tool and @var{args} the arguments
passed on to it.

Currently, the following tools are available.

@table @code
@item BATCH
Run @R{} in batch mode.  Runs @command{R --restore --save} with possibly
further options (see @code{?BATCH}).
@item COMPILE
(UNIX only) Compile C, C++, Fortran @dots{} files for use with @R{}.
@item SHLIB
Build shared library for dynamic loading.
@item INSTALL
Install add-on packages.
@item REMOVE
Remove add-on packages.
@item build
Build (that is, package) add-on packages.
@item check
Check add-on packages.
@item LINK
(UNIX only) Front-end for creating executable programs.
@item Rprof
Post-process @R{} profiling files.
@item Rdconv
@itemx Rd2txt
Convert Rd format to various other formats, including @HTML{}, @LaTeX{},
plain text, and extracting the examples.  @code{Rd2txt} can be used as
shorthand for @code{Rd2conv -t txt}.
@itemx Rd2pdf
Convert Rd format to PDF.
@item Stangle
Extract S/R code from Sweave documentation
@item Sweave
Process Sweave documentation
@item Rdiff
Diff @R{} output ignoring headers etc
@item config
Obtain configuration information
@item javareconf
(Unix only) Update the Java configuration variables
@item rtags
(Unix only) Create Emacs-style tag files from C, R, and Rd files
@item open
(Windows only) Open a file via Windows' file associations
@item texify
(Windows only) Process (La)TeX files with R's style files
@end table

Use

@example
R CMD @var{command} --help
@end example

@noindent
to obtain usage information for each of the tools accessible via the
@code{R CMD} interface.

In addition, you can use@footnote{as from @R{} 2.13.0.}  options
@option{--arch=}, @option{--no-environ}, @option{--no-init-file},
@option{--no-site-file} and @option{--vanilla} between @command{R} and
@command{CMD}: these affect any @R{} processes run by the tools.  (Here
@option{--vanilla} is equivalent to @option{--no-environ --no-site-file
--no-init-file}.)  However, note that @command{R CMD} does not of itself
use any @R{} startup files (in particular, neither user nor site
@file{Renviron} files), and all of the @R{} processes run by these tools
(except @command{BATCH}) use @option{--no-restore}.  Most use
@option{--vanilla} and so invoke no @R{} startup files: the current
exceptions are @command{INSTALL}, @command{REMOVE}, @command{Sweave} and
@command{SHLIB} (which uses @option{--no-site-file --no-init-file}).

@example
R CMD @var{cmd} @var{args}
@end example

@noindent
for any other executable @command{@var{cmd}} on the path or given by an
absolute filepath: this is useful to have the same environment as @R{}
or the specific commands run under, for example to run @command{ldd} or
@command{pdflatex}.  Under Windows @var{cmd} can be an executable or a
batch file, or if it has extension @code{.sh} or @code{.pl} the
appropriate interpreter (if available) is called to run it.


@node Invoking R under Windows, Invoking R under Mac OS X, Invoking R from the command line, Invoking R
@appendixsec Invoking R under Windows

There are two ways to run @R{} under Windows.  Within a terminal window
(e.g.@ @code{cmd.exe} or a more capable shell), the methods described in
the previous section may be used, invoking by @code{R.exe} or more
directly by @code{Rterm.exe}.  For interactive use, there is a
console-based GUI (@code{Rgui.exe}).

The startup procedure under Windows is very similar to that under
UNIX, but references to the `home directory' need to be clarified, as
this is not always defined on Windows.  If the environment variable
@env{R_USER} is defined, that gives the home directory.  Next, if the
environment variable @env{HOME} is defined, that gives the home
directory.  After those two user-controllable settings, @R{} tries to
find system defined home directories.  It first tries to use the
Windows "personal" directory (typically @code{C:\Documents and
Settings\username\My Documents} in Windows XP).  If that fails, and
environment variables @env{HOMEDRIVE} and @env{HOMEPATH} are defined
(and they normally are) these define the home directory.  Failing all
those, the home directory is taken to be the starting directory.

You need to ensure that either the environment variables @env{TMPDIR},
@env{TMP} and @env{TEMP} are either unset or one of them points to a
valid place to create temporary files and directories.

Environment variables can be supplied as @samp{@var{name}=@var{value}}
pairs on the command line.

If there is an argument ending @file{.RData} (in any case) it is
interpreted as the path to the workspace to be restored: it implies
@option{--restore} and sets the working directory to the parent of the
named file.  (This mechanism is used for drag-and-drop and file
association with @code{RGui.exe}, but also works for @code{Rterm.exe}.
If the named file does not exist it sets the working directory
if the parent directory exists.)

The following additional command-line options are available when
invoking @code{RGui.exe}.

@table @option
@item --mdi
@itemx --sdi
@itemx --no-mdi
Control whether @code{Rgui} will operate as an MDI program 
(with multiple child windows within one main window) or an SDI application
(with multiple top-level windows for the console, graphics and pager).  The 
command-line setting overrides the setting in the user's @file{Rconsole} file.

@item --debug
Enable the ``Break to debugger'' menu item in @code{Rgui}, and trigger
a break to the debugger during command line processing.
@end table

Under Windows with @code{R CMD} you may also specify your own
@file{.bat}, @file{.exe}, @file{.sh} or @file{.pl} file.  It will be run
under the appropriate interpreter (Perl for @file{.pl}) with several
environment variables set appropriately, including @env{R_HOME},
@env{R_OSTYPE}, @env{PATH}, @env{BSTINPUTS} and @env{TEXINPUTS}.  For
example, if you already have @file{latex.exe} on your path, then

@example
R CMD latex.exe mydoc
@end example
@noindent
will run @LaTeX{} on @file{mydoc.tex}, with the path to @R{}'s
@file{share/texmf} macros appended to @env{TEXINPUTS}.  (Unfortunately,
this does not help with the MiKTeX build of @LaTeX{}, but
@command{R CMD texify mydoc} will work in that case.)

@node Invoking R under Mac OS X, Scripting with R, Invoking R under Windows, Invoking R
@appendixsec Invoking R under Mac OS X

There are two ways to run @R{} under Mac OS X.  Within a @code{Terminal.app}
window by invoking @code{R}, the methods described in the first
subsection apply.  There is also console-based GUI (@code{R.app}) that by
default is installed in the @code{Applications} folder on your
system.  It is a standard double-clickable Mac OS X application.

The startup procedure under Mac OS X is very similar to that under UNIX.
The `home directory' is the one inside the R.framework, but the startup
and current working directory are set as the user's home directory
unless a different startup directory is given in the Preferences window
accessible from within the GUI.

@node Scripting with R,  , Invoking R under Mac OS X, Invoking R
@appendixsec Scripting with R

If you just want to run a file @file{foo.R} of @R{} commands, the
recommended way is to use @command{R CMD BATCH foo.R}.  If you want to
run this in the background or as a batch job use OS-specific facilities
to do so: for example in most shells on Unix-alike OSes @command{R CMD
BATCH foo.R &} runs a background job.

You can pass parameters to scripts via additional arguments on the
command line: for example (where the exact quoting needed will depend on
the shell in use)

@example
R CMD BATCH "--args arg1 arg2" foo.R &
@end example

@noindent
will pass arguments to a script which can be retrieved as a character
vector by

@example
args <- commandArgs(TRUE)
@end example

This is made simpler by the alternative front-end @command{Rscript},
which can be invoked by

@example
Rscript foo.R arg1 arg2
@end example

@noindent
and this can also be used to write executable script files like (at
least on Unix-alikes, and in some Windows shells)

@example
#! /path/to/Rscript
args <- commandArgs(TRUE)
...
q(status=<exit status code>)
@end example

@noindent
If this is entered into a text file @file{runfoo} and this is made
executable (by @command{chmod 755 runfoo}), it can be invoked for
different arguments by

@example
runfoo arg1 arg2
@end example

@noindent
For further options see @command{help("Rscript")}.  This writes @R{}
output to @file{stdout} and @file{stderr}, and this can be redirected in
the usual way for the shell running the command.

If you do not wish to hardcode the path to @command{Rscript} but have it
in your path (which is normally the case for an installed @R{} except on
Windows, but e.g.@: Mac OS X users may need to add @file{/usr/local/bin}
to their path), use

@example
#! /usr/bin/env Rscript
...
@end example

@noindent
At least in Bourne and bash shells, the @code{#!} mechanism does
@strong{not} allow extra arguments like 
@code{#! /usr/bin/env Rscript --vanilla}.

One thing to consider is what @code{stdin()} refers to.  It is
commonplace to write @R{} scripts with segments like

@example
chem <- scan(n=24)
2.90 3.10 3.40 3.40 3.70 3.70 2.80 2.50 2.40 2.40 2.70 2.20
5.28 3.37 3.03 3.03 28.95 3.77 3.40 2.20 3.50 3.60 3.70 3.70
@end example

@noindent
and @code{stdin()} refers to the script file to allow such traditional
usage.  If you want to refer to the process's @file{stdin}, use
@code{"stdin"} as a @code{file} connection, e.g.@: @code{scan("stdin", ...)}.

Another way to write executable script files (suggested by Fran@,{c}ois
Pinard) is to use a @emph{here document} like

@example
#!/bin/sh
[environment variables can be set here]
R --slave [other options] <<EOF

   R program goes here...

EOF
@end example

@noindent
but here @code{stdin()} refers to the program source and
@code{"stdin"} will not be usable.

Very short scripts can be passed to @command{Rscript} on the
command-line via the @option{-e} flag.

Note that on a Unix-alike the input filename (such as @file{foo.R})
should not contain spaces nor shell metacharacters.


@node The command-line editor, Function and variable index, Invoking R, Top
@appendix The command-line editor

@appendixsection Preliminaries

When the @acronym{GNU} @strong{readline} library is available at the
time @R{} is configured for compilation under UNIX, an inbuilt command
line editor allowing recall, editing and re-submission of prior commands
is used.  Note that other versions of @strong{readline} exist and may be
used by the inbuilt command line editor: this used to happen on Mac OS X.

It can be disabled (useful for usage with @acronym{ESS} @footnote{The
`Emacs Speaks Statistics' package; see the @acronym{URL}
@uref{http://ESS.R-project.org}}) using the startup option
@option{--no-readline}.

Windows versions of @R{} have somewhat simpler command-line editing: see
@samp{Console} under the @samp{Help} menu of the @acronym{GUI}, and the
file @file{README.Rterm} for command-line editing under
@code{Rterm.exe}.

When using @R{} with @strong{readline} capabilities, the functions
described below are available, as well as others (probably) documented
in @command{man readline} or @command{info readline} on your system.

Many of these use either Control or Meta characters.  Control
characters, such as @kbd{Control-m}, are obtained by holding the
@key{CTRL} down while you press the @key{m} key, and are written as
@kbd{C-m} below.  Meta characters, such as @kbd{Meta-b}, are typed by
holding down @key{META}@footnote{On a PC keyboard this is usually the
Alt key, occasionally the `Windows' key.  On a Mac keyboard normally no
meta key is available.} and pressing @key{b}, and written as @kbd{M-b}
in the following.  If your terminal does not have a @key{META} key
enabled, you can still type Meta characters using two-character
sequences starting with @kbd{ESC}.  Thus, to enter @kbd{M-b}, you could
type @key{ESC}@key{b}.  The @kbd{ESC} character sequences are also
allowed on terminals with real Meta keys.  Note that case is significant
for Meta characters.

@appendixsection Editing actions

The @R{} program keeps a history of the command lines you type,
including the erroneous lines, and commands in your history may be
recalled, changed if necessary, and re-submitted as new commands.  In
Emacs-style command-line editing any straight typing you do while in
this editing phase causes the characters to be inserted in the command
you are editing, displacing any characters to the right of the cursor.
In @emph{vi} mode character insertion mode is started by @kbd{M-i} or
@kbd{M-a}, characters are typed and insertion mode is finished by typing
a further @key{ESC}.  (The default is Emacs-style, and only that is
described here: for @emph{vi} mode see the @strong{readline}
documentation.)

Pressing the @key{RET} command at any time causes the command to be
re-submitted.

Other editing actions are summarized in the following table.

@appendixsection Command-line editor summary

@subheading Command recall and vertical motion

@table @kbd
@item C-p
Go to the previous command (backwards in the history).
@item C-n
Go to the next command (forwards in the history).
@item C-r @var{text}
Find the last command with the @var{text} string in it.
@end table

On most terminals, you can also use the up and down arrow keys instead
of @kbd{C-p} and @kbd{C-n}, respectively.

@subheading Horizontal motion of the cursor

@table @kbd
@item C-a
Go to the beginning of the command.
@item C-e
Go to the end of the line.
@item M-b
Go back one word.
@item M-f
Go forward one word.
@item C-b
Go back one character.
@item C-f
Go forward one character.
@end table

On most terminals, you can also use the left and right arrow keys
instead of @kbd{C-b} and @kbd{C-f}, respectively.

@subheading Editing and re-submission

@table @kbd
@item @var{text}
Insert @var{text} at the cursor.
@item C-f @var{text}
Append @var{text} after the cursor.
@item @key{DEL}
Delete the previous character (left of the cursor).
@item C-d
Delete the character under the cursor.
@item M-d
Delete the rest of the word under the cursor, and ``save'' it.
@item C-k
Delete from cursor to end of command, and ``save'' it.
@item C-y
Insert (yank) the last ``saved'' text here.
@item C-t
Transpose the character under the cursor with the next.
@item M-l
Change the rest of the word to lower case.
@item M-c
Change the rest of the word to upper case.
@item @key{RET}
Re-submit the command to @R{}.
@end table

The final @key{RET} terminates the command line editing sequence.

The @strong{readline} key bindings can be customized in the usual way
@emph{via} a @file{~/.inputrc} file.  As from @R{} 2.12.0, these
customizations can be conditioned on application @code{R}, that is
by including a section like

@example
$if R
  "\C-xd": "q('no')\n"
$endif
@end example

@node Function and variable index, Concept index, The command-line editor, Top
@appendix Function and variable index

@printindex vr

@node Concept index, References, Function and variable index, Top
@appendix Concept index

@printindex cp

@node References,  , Concept index, Top
@appendix References

D.@: M.@: Bates and  D.@: G.@: Watts (1988), @emph{Nonlinear Regression
Analysis and Its Applications.} John Wiley & Sons, New York.

@noindent
Richard A.@: Becker, John M.@: Chambers and Allan R.@: Wilks (1988),
@emph{The New S Language.} Chapman & Hall, New York.
This book is often called the ``@emph{Blue Book}''.

@noindent
John M.@: Chambers and Trevor J.@: Hastie eds. (1992),
@emph{Statistical Models in S.} Chapman & Hall, New York.
This is also called the ``@emph{White Book}''.

@noindent
John M.@: Chambers (1998)
@emph{Programming with Data}. Springer, New York.
This is also called the ``@emph{Green Book}''.

@noindent
A.@: C.@: Davison and D.@: V.@: Hinkley (1997), @emph{Bootstrap Methods
and Their Applications}, Cambridge University Press.

@noindent
Annette J.@: Dobson (1990), @emph{An Introduction to Generalized Linear
Models}, Chapman and Hall, London.

@noindent
Peter McCullagh and John A.@: Nelder (1989), @emph{Generalized Linear
Models.} Second edition, Chapman and Hall, London.

@noindent
John A.@ Rice (1995), @emph{Mathematical Statistics and Data Analysis.}
Second edition.  Duxbury Press, Belmont, CA.

@noindent
S.@: D.@: Silvey (1970), @emph{Statistical Inference.} Penguin, London.

@bye
