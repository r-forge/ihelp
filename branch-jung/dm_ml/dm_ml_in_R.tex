### statistical computing, data mining, machine learning in R ###

R은 통계적 분석을 실행하고 그래프를 생성할 수 있는 환경(environment)을 제공합니다.

R은 일반적인 형태의 컴퓨터 언어에 기초하고 있어서 상당한 유연성을 제공합니다.

R 언어를 사용함에 있어 기본적으로 알아두어야 할 개념들과 팁(tip)은 다음과 같습니다.

# 표현과 객체(expressions and objects): 모든 R 표현(expressions)은 어떤 값을 반환(return) 합니다. NULL 객체도 마찬가지 이지만 어떤 경우에는 보여지지(출력되지) 않을 수 있습니다. 또한 표현(expressions)은 객체(objects)에 대해 적용되는 것입니다. 

# 함수와 인자(또는 인수: arguments): 

# 연산(인덱싱 연산)
# 할당
# 벡터 연산
# 다음과 같은 데이터를 만들어 봅니다.
# > weight <- c(60, 72, 57, 90, 95, 72)
# > height <- c(1.75, 1.80, 1.65, 1.90, 1.74, 1.91)
# 이를 이용하여 몸무게의 표준편차(standard deviation)은 다음과 같이 구할 수 있습니다.
# > sqrt(sum((weight - xbar)^2)/(length(weight) - 1))
# 이를 연산하는데 소요되는 시간은 다음과 같이 구할 수 있습니다.
# > system.time(sqrt(sum((weight - xbar)^2)/(length(weight) - 1)))
# 그런데 다음과 같이 객체를 벡터화하여 벡터연산을 해 보도록 합니다. 그리고 이의 연산시간을 비교해 보도록 하게습니다.
# > 

# 인자(argument)의 순서는 함수를 사용하는데 무관합니다. 이러한 인자의 순서는 다음과 같은 경우까지를 포함합니다.
# plot(y=weight,x=height)
# plot(x=height,y=weight)
# 함수 인자의 기본값(default)를 알고 싶다면 formals(function name)를 사용하시기 바랍니다.
# 예를 들어, 
# > formals(ls)
# > formals(summary)
# > args(summary.default)
# 와 같습니다. 하지만 함수의 구조를 파악하기 위해서,
# > ls
# 를 사용하여도 됩니다.
# 추가적으로, 함수명.default()도 실행해 보시기 바랍니다. - class and method
# 예를 들어, 
# summary.dafault()
# 와 같습니다.




운영체제가 Unix가 아니라면 특히 윈도우의 경우 먼저 윈도우 환경에 대한 정보를 필요로 합니다. 
이러한 정보는 최소한 특정 파일의 경로에 접근하는데에도 사용될 것이기 때문입니다.

> .Platform
> do.call(rbind, .Platform)

객체의 이름이 .(dot)으로 시작하면 이것은 숨겨진 객체를 말합니다.
객체를 조회하는 함수는 다음과 같은데 all.names=TRUE를 사용하면 숨겨진 객체도 조회가 가능합니다.

> objects(all.names=TRUE)

두 가지 코드를 실행하고 난 출력 결과를 비교해 보시기 바랍니다.

### Environment ###




객체 생성

객체를 생성하는 방법은 이후에 할당연산자를 이용하는 방법이 지속적으로 사용될 것이나 여기에서는 다른 방법으로 생성하는 방법을  소개할 것입니다.

assign() 함수: 첫 번째 인자 x는 이름을 지정하고 두 번째 인자 value는 할당할 값을 지정합니다. 

- Usage:
	> assign(x, value, pos = -1, envir = as.environment(pos),
       inherits = FALSE, immediate = TRUE)

그런데 assign() 함수는 특정 값을 벡터의 원소에 할당할 수 없습니다.

> assign("a", value=1:5))
> assign("a[1]", value=6)

ls() 함수로 생성된 객체를 확인해 보면 a[1]이라는 객체가 생성된 것을 확인할 수 있습니다. 즉 a라는 객체의 a[1] 원소에 6을 할당하는 것이 아니라 a[1]이라는 새로운 객체가 생성되는 것입니다. 

다음과 같은 코드를 고려해 보시기 바랍니다.

> repr.env <- new.env(parent = baseenv())
> assign("repr.obj", "Sweave", envir=repr.env)
> repr.obj
> get("repr.obj", repr.env)

객체의 이름이 정해진 것이 아니라 연산과정에서 인자 등으로 전달 받아서 생성할 경우 assign() 함수는 유용하게 사용될 수 있습니다. 아래의 코드를 살펴봐 주시기 바랍니다.

> for(i in 1:5) { #-- Create objects  'r.1', 'r.2', ... 'r.6' --
  +  name <- paste("r", i, sep = ".")
  +  assign(name, 1:i)
	}
> ls(pattern = "^r..$")

이와는 약간 다르게 global environment인 .GlobalENV에 객체를 생성하는 예제도 가능합니다.

> myf <- function(x) {
  +  innerf <- function(x) assign("Global.res", x^2, envir = .GlobalEnv)
  +  innerf(x+1)
	}
> myf(3)
> Global.res

위의 코드에서 envir=.GlobalEnv를 사용하여 Global.res 객체가 base environment에 생성되었습니다. 그렇지 않았다면 Global.res 객체가 함수 내부에 생성되어 마지막 줄의 Global.res에서 에러가 발생하였을 것입니다.

Class와 Methods

S언어는 S3와 S4라는 두 개의 공식적 객체 시스템이 있습니다. 다음의 에ㅖ를 살펴보시기 바랍니다.

> x <- smaple(1:5, 50, replace=T)
> y <- as.factor(x)
> class(x); class(y)
> summary(x); summmary(y)

객체 x와 y의 클래스가 각각 integer와 factor로 서로 다르며 같은 summary() 함수를 사용해도 반환되는 결과의 구조가 다릅니다. 왜 이러한 현상이 나타나는지 확인하기 위하여 summary() 함수의 내용을 살펴보고자 합니다.

> summary

summary() 함수내에 UseMethod() 함수를 이용하여 summary라는 generic 함수를 이용한 것을 알 수 있을 것입니다. 이를 다시 자새히 확인해 보기 위해 summary.dafault() 함수를 내용을 살펴보고자 합니다.

> summary.default

반환되는 결과를 살펴보면 summary() 함수를 실행하는데 있어 대상 객체가 integer인지 factor인지에 따라 계산되는 과정이 다름을 알 수 있을 것입니다. 그렇다면 summary() 함수를 generic 함수를 사용하는 함수의 종류를 검색해 보겠습니다.

> methods(summary)

methods() 함수는 위와 같이 generic 함수명 이외의 아래와 같이 class 이름으로도 method 함수를 검색할 수 있습니다.

> methods(class="aov") 

이러한 generic 함수는 사용자 정의를 이용해서도 만들 수 있습니다.

> my.generic <- function(x) UseMethod("my.generic")
> my.generic.matrix <- function(x){
+ cat("This is test matrix\n")
+ cat("Number of Rows is: ", nrow(x), "\n")
+ cat("Number of Columns is: ", ncol(x), "\n")
+ x
+ }
> my.generic.class <- function(x){
+ cat("This is test class\n")
+ x
+ }
> my.generic.default <- function(x){
+ cat("This is dafault\n")
+ x
+ }
> test.mat <- matrix(1:10, ncol=2))
> my.generic(test.mat)

추가적으로, inherits() 함수는 특정 class의 속성을 상속했는지의 여부를 검증하는 함수이고, unclass() 함수는 객체에서 calss 속성을 제거하는 함수입니다. 이에 대한 보다 자세한 도움말은 help() 함수를 이용하여 직접 찾아 보시기 바랍니다. 또한 getS3method() 함수는 S3 시스템의 method 함수의 내용을 조회하는 함수입니다. 이 함수는 패키지에서 숨김 객체로 있는 method 함수의 내용을 조회할 때 유용하게 사용될 수 있습니다. 

S4의 객체와 method는 S3 보다 좀더 형식적이고 엄격하지만 프로그래밍을 위한 보다 많은 도구를 제공합니다. S4 시스템에서 class는 setClass() 함수로 만듭니다. # 참고로, S4에서는 멤버변수를 슬롯(slot)이라 칭합니다. S4 시스템에서 class는 setClass() 함수로 만들고 representation 인자로 slot과 데이터형을 정합니다.

## do.call(): 
## Usage:
## do.call(what, args, quote = FALSE, envir = parent.frame())
## 기본적 설명: 

이 문서에서 필요한 패키지들은 아래와 같습니다. 먼저 패키지들을 설치해 주시기 바랍니다.

이름 출처 개발자명 설명
arm
ggplot2
glmnet
igraph
lme4
lubridate
RCurl
reshape
RJSONIO
tm
XML

본 문서에서 사용된 ufo_awesome.tsv 파일을 획득하기 위해서는 아래의 링크를 참고하사기 바랍니다.

http://www.infochimps.com/datasets/60000-documented-ufo-sightings-with-text-descriptions-and-metada

이 외에도 다양한 데이터가 많이 공객되어 있습니다.

http://thedatahub.kr/

> ufo <- read.delim("ufo_awesome.tsv", sep="\t", stringsAsFactors=FALSE, header=FALSE, na.strings="")
> str(ufo)
'data.frame':   61870 obs. of  6 variables:
 $ V1: chr  "19951009" "19951010" "19950101" "19950510" ...
 $ V2: chr  "19951009" "19951011" "19950103" "19950510" ...
 $ V3: chr  " Iowa City, IA" " Milwaukee, WI" " Shelton, WA" " Columbia, MO" ...
 $ V4: chr  NA NA NA NA ...
 $ V5: chr  NA "2 min." NA "2 min." ...
 $ V6: chr  "Man repts. witnessing &quot;flash, followed by a classic UFO, w/ a tailfin at back.&quot

stringsAsFacors 인자의 기본값은 TRUE 입니다.
 
> ufo1 <- read.delim("ufo_awesome.tsv", sep="\t", header=FALSE, na.strings="")

> str(ufo1)
'data.frame':   61870 obs. of  6 variables:
 $ DateOccurred    : Factor w/ 9608 levels "-0.4","-1.6",..: 4015 4016 3747 3869 3900 4031 3852 3988 3761 3992 ...
 $ DateReported    : Factor w/ 5567 levels "- thank you for reading",..: 304 306 63 176 207 315 161 276 101 280 ...
 $ Location        : Factor w/ 22120 levels "-1.2","-1.4",..: 9212 12592 17908 4170 17680 2543 6282 10654 12971 16343 ...
 $ ShortDescription: Factor w/ 192 levels " ","      445",..: NA NA NA NA NA NA NA NA NA NA ...
 $ Duration        : Factor w/ 9637 levels "-","--","-------------------------",..: NA 2967 NA 2967 NA 4443 2967 NA NA 6116 ...
 $ LongDescription : Factor w/ 61470 levels "-----Mensagem Original----- De: Flavio Mori Para: felicio-sp Enviada em: domingo,

> ufo2 <- read.delim(file="C:\\Users\\Eugene\\Documents\\testdatasets\\ufo_awesome.tsv", 
+ sep="\t", header=FALSE, na.strings="", stringsAsFactors=FALSE)

read.delim에 대한 도움말은 

> ?read.delim
> ??read.delim

으로 찾을 수 있습니다.

불러들여온 데이터의 개략적인 형태를 확인하기 위해 head()와 tail() 함수를 이용해 봅니다.

> head(ufo); tail(ufo)

확인해 보니 데이터셋에 변수명이 없습니다. 데이터세트에 변수명을 부여하기 위해 다음과 같은 명령어를 이용합니다.

> names(ufo)<-c("DateOccurred","DateReported","Location","ShortDescription",
+ "Duration","LongDescription")

날짜의 경우 다른 프로그램과 마찬가지로 특별한 유형으로 저장해 놓는 것이 좋습니다.

> ufo$DateOccurred <- as.Date(ufo$DateOccurred, format="%Y%m%d")
> ufo$DateReported <- as.Date(ufo$DateReported, format="%Y%m%d")

위와 같은 명령어는 일반적으로 사용되고 있으나 이 경우에는 다음과 같은 에러가 나타날 것입니다.

"다음에 오류가 있습니다strptime(x, format, tz = "GMT") : 입력문자열이 너무 깁니다."

head() 이용하여 파악한 결과 DateOccurred는 8자리 YYYYMMDD의 형태를 가지고 있습니다. DateOccurred와 DateReported에서 문자열이 몇 자리인지 그리고 이들이 어디에 위치하는지를 알고 싶을 것입니다. 왜냐하면 8자리가 아니어서 "입력문자열이 너무 깁니다."라는 에러 메세지가 나타났기 때문입니다. 

> good.rows <- ifelse(nchar(ufo$DateOccurred)>=8 & nchar(ufo$DateOccurred)!= 8 | nchar(ufo$DateReported)!=8,FALSE,TRUE)
> length(which(!good.rows))
[1] 454
> ufo <- ufo[good.rows,]

## ifelse(): 
## Usage: ifelse(test, yes, no)
## 기본적 설명: ifelse 함수의 test 인자는 논리벡터나 논리벡터로 강제 변환될 수 있는 표현식을 사용하고 yes 인자와 no 인자는 벡터나 연산의 결과가 벡터인 표현식을 사용합니다. ifelse 함수는 test 인자의 결과가 같은 길이의 벡터를 반환합니다. 반환하는 값은 논리벡터에서 원소의 값이 TRUE이면 yes 벡터에서 같은 인덱스(위치)를 갖는 값을, FALSE이면 no 벡터에서 같은 인테스를 갖는 값을 반환합니다.

## nchar(): 
기본적 설명: 문자벡터의 각 원소가 몇 개의 문자열로 구성되어 있는지 알 수 있습니다. 이것은 다른 의미로 문자벡터의 원소가 non-empty strings인지를 발견해 내는데 가장 빠른 방법을 제공합니다.

## which(): 
기본적 설명: 특정 조건을 만족하는 원소의 index를 구할 수 있습니다.

> ufo$DateOccurred <- as.Date(ufo$DateOccurred, format="%Y%m%d")
> ufo$DateReported <- as.Date(ufo$DateReported, format="%Y%m%d")

############################
## location 데이터 다루기 ##
############################

location 데이터를 다루기 위해 다음과 같이 get.location() 함수를 스스로 만들어 봅니다.

get.location <- function(l) {
	split.location <- tryCatch(strsplit(l,",")[[1]], error=function(e) return(c(NA, NA)))
	clean.location <- gsub("^ ","",split.location)
	if (length(clean.location) > 2) {
		return(c(NA,NA))
	}
	else {
		return(clean.location)
	}
}

## function(): 
## 기본적 설명: 사용자 함수를 정의합니다.
## Usage:
## function( arglist ) expr
## return(value)
## Arguments:
## arglist - Empty or one or more name or name=expression terms.
## expr - An expression.
## value - An expression.

## 정규표현식(regular expression):
## 기본적 설명: R의 확장 정규표현식은 POSIX 1003.2 표준을 기반으로 이식되었습니다. grep(), regexpr(), gregexpr(), sub(), gsub(), strsplit() 등의 함수의 기본 모드에서 허용하는 정규표현식은 확장 정규표현식을 따릅니다. 정규표현식은 작은 단위의 표현식을 결합하는 다양한 연산자를 사용하는 산술 연산과 비슥하고 이 표현식은 0개 또는 하나 이상의 문자와 매치됩니다.

## gsub():
## 기본적 설명: 패턴 매치된 모든 문자를 치환합니다.

## grep(): 

## agrep():

## grepRaw(): 

## strsplit():
## 기본적 설명: 문자열의 요소를 문자열 내의 하위 문자열로 분할합니다.
## Usage:
## strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)
## Arguments:
## x - 분할될 문자 벡터, 다른 형태의 입력은 에러가 발생합니다.
## split - character vector (or object which can be coerced to such) containing regular expression(s) (unless fixed = TRUE) to use for splitting. If empty matches occur, in particular if split has length 0, x is split into single characters. If split has length greater than 1, it is re-cycled along x. 
## fixed - logical. If TRUE match split exactly, otherwise use regular expressions. Has priority over perl. 
## perl - logical. Should perl-compatible regexps be used?
## useBytes - logical. If TRUE the matching is done byte-by-byte rather than character-by-character, and inputs with marked encodings are not converted. This is forced (with a warning) if any input is found which is marked as "bytes".


## tryCatch(): 
## 기본적 설명: 예외처리 구문으로서 예기치 않은 오류가 발생하였을 때, 프로그램이 강제 종료되지 않고 안전하게 종료시킬 수 있습니다. 일반적으로 stop() 함수나 warning() 함수는 사용자가 에러나 논리적 오류가 발생하는 사례를 알고 작성하지만 tryCatch() 함수는 이것이 불명확할 경우에 사용하는 것입니다. 또한 이 함수는 다른 사람이 만들어 놓은 함수를 사용자 정의함수로 사용할 때 사용됩니다.

## apply() 함수군: 데이터 객체의 각 차원에 대해서 함수를 적용한 후 이의 결과를 집계하여 반환하는 기능을 가집니다.
## apply(): 
## 기본적 설명: 행렬이나 배열의 주변값에 특정 함수를 적용하여 그 적용결과를 반환하는 함수입니다.
## Usage:
## apply(X, MARGIN, FUN, ...)
## Arguments:
## X - an array, including a matrix.
## MARGIN - a vector giving the subscripts which the function will be applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows and columns. Where X has named dimnames, it can be a character vector selecting dimension names.
## FUN - the function to be applied: see ‘Details’. In the case of functions like +, %*%, etc., the function name must be backquoted or quoted.
## ... - optional arguments to FUN.
## Example:
## mat <- matrix(1:15, nrow=5)
## mat_na <- mat
## mat_na[5, 3] <- NA
## apply(mat_na, 1, sum)
## apply(mat_na, 1, sum, na.rm=TRUE)
## sum() 대신 sort() 그리고 sort()의 인자(arguements)를 활용하여 사용해 보시기 바랍니다. FUN 인자에 함수가 아닌 연산자를 사용하는 경우 연산자를 " "(따옴표: quotation) 안에 넣어 기술해야 합니다. 단항연산자(예를 들어, "!")와는 달리 다항연산자("/": 나누기)를 사용하는 경우에는 두 번째 피연산자를 FUN 인자값 뒤에 기술해야 합니다.

## eapply():

## lapplu():

## mapply():

## rapply():

## tapply():
  
> city.state <- lapply(ufo$Location, get.location)
> head(city.state)

리스트를 이용해 매트릭스를 만들기 위해 do.call() 함수를 사용해 봅니다. apply() 함수와 같이, do.call() 함수는 리스트에 대해 함수 호출을 실행합니다.

> location.matrix <- do.call(rbind, city.state)
> ufo <- transform(ufo, USCity=location.matrix[,1], USState=tolower(location.matrix[,2]), stringsAsFactors=FALSE)

## transform():
## Usage:
## transform(`_data`, ...)
## 기본적 설명: 데이터 프레임을 변형시키는 함수입니다. '_data' 인자는 변형할 대상의 데이터 객체를 지정하고 두 번째 인자 ...는 tag=value의 형태로 사용하는데 tag는 새롭게 추가될 변수명을 지정하고 value는 변경할 변수의 표현식을 지정합니다.
## Examples:
## transform(airquality, Ozone = -Ozone)
## transform(airquality, new = -Ozone, Temp = (Temp-32)/1.8)

## tolower(): 
## Usage
## chartr(old, new, x)
## tolower(x)
## toupper(x)
## casefold(x, upper = FALSE)
## 기본적 설명: tolower and toupper 인자는 문자 벡터에서 대품자로 표기되어 있는 문자를 소문자로 변환하거나 그 반대로 변화시킵니다. 알파벳이 아닌 문자는 변경되지 않은 채로 남겨둡니다. 

ufo 데이터 객체에는 미국과 캐나다의 지역이 같이 포함되어 있는 것을 알 수 있습니다. 이 중 미국의 데이터만 선택하여 분석하고자 합니다. 데이터를 선택 분할 하기 위해 다음과 같은 코드를 사용해 봅니다. 여기에서는 NA가 어디에 위치하는 지가 관심 대상입니다.

> us.states <- c("ak","al","ar","az","ca","co","ct","de","fl","ga","hi","ia","id","il", "in","ks","ky","la","ma","md","me",
+ "mi","mn","mo","ms","mt","nc","nd","ne","nh", "nj","nm","nv","ny","oh","ok","or","pa","ri","sc","sd","tn","tx","ut","va",
+ "vt", "wa","wi","wv","wy")
> ufo$USState <- us.states[match(ufo$USState,us.states)]
> ufo$USCity[is.na(ufo$USState)] <- NA
> ufo.us <- subset(ufo, !is.na(USState))
> head(ufo.us)

## match():
## Usage:
## match(x, table, nomatch = NA_integer_, incomparables = NULL)
## 기본적 설명: match() 함수는 첫 번째 인자의 원소가 두 번째 인자에 있는지를 비교하여 두 번째 인자에서 해당 위치의 index 값을 반환하고 매치되는 것이 없으면 nomatch 인자에서 지정한 값을 반환합니다.

> summary(ufo.us$DateOccurred)

> quick.hist <- ggplot(ufo.us, aes(x=DateOccurred)) + geom_histogram() ## 이거 넣으면 에러남: + scale_x_date(major="50 years")
> ggsave(plot=quick.hist, filename="quick_hist.png", height=6, width=8)

## ggolot2:::ggplot()

## geom_histogram()

## scale_date()

## scale_x_date()

그림에서 보는 바와 같이 거의 모든 관측치가 1990년 이후에 발생했습니다. 따라서 시간 상 1990년 이전의 데이터는 제거하고 이후의 데이터로만 분석을 하고자 합니다. 따라서 다음과 같은 코드를 생각해 볼 수 있습니다.

> ufo.us <- subset(ufo.us, DateOccurred >= as.Date("1990-01-01"))
> nrow(ufo.us)
> ufo.us$YearMonth <- strftime(ufo.us$DateOccurred, format="%Y-%m")

여기에서 transform() 함수가 아니라 strftime() 함수를 사용한 점을 한 번 살펴보시기 바랍니다. 

## strftime():
## Usage:
## S3 method for class 'POSIXct'
## format(x, format = "", tz = "", usetz = FALSE, ...)
## S3 method for class 'POSIXlt'
## format(x, format = "", usetz = FALSE, ...)
## S3 method for class 'POSIXt'
## as.character(x, ...)
## strftime(x, format = "", tz = "", usetz = FALSE, ...)
## strptime(x, format, tz = "")





