<html lang="ko">
<head>
<title>R Data Import/Export (한국어 - 2013.07.09, ver.0.00 초기셋팅완료)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="R Data Import/Export (한국어 - 2013.07.09, ver.0.00 초기셋팅완료)">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body {margin-left: 5%; margin-right: 5%;}

H1 {             
    background: white;
    color: rgb(25%, 25%, 25%);
    font-family: monospace;
    font-size: xx-large;
    text-align: center
}

H2 {
    background: white;
    color: rgb(40%, 40%, 40%);
    font-family: monospace;
    font-size: x-large;
    text-align: center
}

H3 {
    background: white;
    color: rgb(40%, 40%, 40%);
    font-family: monospace;
    font-size: large
}

H4 {
    background: white;
    color: rgb(40%, 40%, 40%);
    font-family: monospace
}

span.samp{font-family: monospace}
span.command{font-family: monospace}
span.option{font-family: monospace}
span.file{font-family: monospace}
span.env{font-family: monospace}

ul {
    margin-top: 0.25ex;
    margin-bottom: 0.25ex;
}
li {
    margin-top: 0.25ex;
    margin-bottom: 0.25ex;
}
p {
    margin-top: 0.6ex;
    margin-bottom: 1.2ex;
}
--></style>
</head>
<body>
<h1 class="settitle">R Data Import/Export (한국어 - 2013.07.09, ver.0.00 초기셋팅완료)</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Acknowledgements">Acknowledgements</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">R Data Import/Export</h2>

<!-- This is a guide to importing and exporting data to and from R. -->
<!-- The current version of this document is @value{VERSION}. -->
<p>이 문서는 데이터를 R로 불러들이거나 R에서 내보내는 안내입니다. 이 문서의 현재 버전은 3.0.0 Under development (2013-02-11)입니다.

   <p>ISBN 3-900051-10-0

   <p>Copyright &copy; 2000&ndash;2012 R Core Team<br>
Korean translation copyright &copy; 2008&ndash;2013 Korean R Translation Team (정우준, 이철희).

   <p>Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   <p>Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   <p>Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the R Core Team. 
<!--  ^- read that -->

<ul class="menu">
<li><a accesskey="1" href="#Acknowledgements">Acknowledgements</a>
<li><a accesskey="2" href="#Introduction">Introduction</a>
<li><a accesskey="3" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>
<li><a accesskey="4" href="#Importing-from-other-statistical-systems">Importing from other statistical systems</a>
<li><a accesskey="5" href="#Relational-databases">Relational databases</a>
<li><a accesskey="6" href="#Binary-files">Binary files</a>
<li><a accesskey="7" href="#Image-files">Image files</a>
<li><a accesskey="8" href="#Connections">Connections</a>
<li><a accesskey="9" href="#Network-interfaces">Network interfaces</a>
<li><a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a>
<li><a href="#References">References</a>
<li><a href="#Function-and-variable-index">Function and variable index</a>
<li><a href="#Concept-index">Concept index</a>
</ul>

<div class="node">
<a name="Acknowledgements"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Acknowledgements</h2>

<p><em>이 매뉴얼은 Korean R Translation Team의 정우준님에 의해서 번역되었습니다</em>. 
<!-- The relational databases part of this manual is based in part on an -->
<!-- earlier manual by Douglas Bates and Saikat DebRoy.  The principal author -->
<!-- of this manual was Brian Ripley. -->

   <p>이 매뉴얼의 관계형데이터베이스 부분은 부분적으로 Douglas Bates와 Saikat DebRoy의 이전 버전에 기초하고 있습니다. 이 매뉴얼의 주저자는 Brian Ripley입니다.

<!-- Many volunteers have contributed to the packages used here.  The -->
<!-- principal authors of the packages mentioned are -->
   <p>많은 자원자들이 여기에 사용된 팩키지에 공헌하였습니다. 여기에 언급된 팩키지들의 주요 저자는 아래와 같습니다.

   <blockquote>
   <p><table summary=""><tr align="left"><td valign="top"><strong>CORBA</strong> </td><td valign="top">Duncan Temple Lang
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=DBI"><strong>DBI</strong></a> </td><td valign="top">David A. James
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=dataframes2xls"><strong>dataframes2xls</strong></a> </td><td valign="top">Guido van Steen
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=foreign"><strong>foreign</strong></a> </td><td valign="top">Thomas Lumley, Saikat DebRoy, Douglas Bates, Duncan Murdoch and Roger Bivand
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=gdata"><strong>gdata</strong></a> </td><td valign="top">Gregory R. Warnes
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=hdf5"><strong>hdf5</strong></a> </td><td valign="top">Marcus Daniels
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=ncdf"><strong>ncdf</strong></a>, <a href="http://CRAN.R-project.org/package=ncdf4"><strong>ncdf4</strong></a> </td><td valign="top">David Pierce
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=rJava"><strong>rJava</strong></a> </td><td valign="top">Simon Urbanek
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=RJDBC"><strong>RJDBC</strong></a> </td><td valign="top">Simon Urbanek
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=RMySQL"><strong>RMySQL</strong></a> </td><td valign="top">David James and Saikat DebRoy
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=RNetCDF"><strong>RNetCDF</strong></a> </td><td valign="top">Pavel Michna
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=RODBC"><strong>RODBC</strong></a> </td><td valign="top">Michael Lapsley and Brian Ripley
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=ROracle"><strong>ROracle</strong></a> </td><td valign="top">David A, James
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=RPostgreSQL"><strong>RPostgreSQL</strong></a> </td><td valign="top">Sameer Kumar Prayaga and Tomoaki Nishiyama
<br></td></tr><tr align="left"><td valign="top"><strong>RSPerl</strong> </td><td valign="top">Duncan Temple Lang
<br></td></tr><tr align="left"><td valign="top"><strong>RSPython</strong> </td><td valign="top">Duncan Temple Lang
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=RSQLite"><strong>RSQLite</strong></a> </td><td valign="top">David A, James
<br></td></tr><tr align="left"><td valign="top"><strong>SJava</strong> </td><td valign="top">John Chambers and Duncan Temple Lang
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=WriteXLS"><strong>WriteXLS</strong></a> </td><td valign="top">Marc Schwartz
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=XLConnect"><strong>XLConnect</strong></a> </td><td valign="top">Mirai Solutions GmbH
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=xlsReadWrite"><strong>xlsReadWrite</strong></a> </td><td valign="top">Hans-Peter Suter
<br></td></tr><tr align="left"><td valign="top"><a href="http://CRAN.R-project.org/package=XML"><strong>XML</strong></a> </td><td valign="top">Duncan Temple Lang
   <br></td></tr></table>
</blockquote>

<!-- Brian Ripley is the author of the support for connections. -->
   <p>Brian Ripley는 connection 지원의 저자입니다.

<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Acknowledgements">Acknowledgements</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction</h2>

<!-- Reading data into a statistical system for analysis and exporting the -->
<!-- results to some other system for report writing can be frustrating tasks -->
<!-- that can take far more time than the statistical analysis itself, even -->
<!-- though most readers will find the latter far more appealing. -->
<p>분석을 위해 통계 시스템으로 데이터를 불러들이는 것(Importing)과 보고서 작성을 위해 다른 시스템으로 결과들을 내보내는 것(Exporting)은 대부분의 독자들에게 훨씬 더 흥미로운 부분이지만 통계적 분석 그 자체 보다 더 많은 시간이 걸릴 수도 있는 매우 지루한 과정이기도 합니다.

<!-- This manual describes the import and export facilities available either -->
<!-- in @R{} itself or via packages which are available from @acronym{CRAN} -->
<!-- or elsewhere. -->
   <p>이 매뉴얼에서는 R에 내장되어 있거나 CRAN에서 구할 수 있는 다양한 패키지들(packages)을 통한 데이터의 입력 및 결과 출력 장치들(facilities)에 대해 기술할 것입니다. 기술된 패키지들 중 일부는 계속 개발 중이지만, 이미 충분히 유용한 기능을 제공합니다.

<!-- Unless otherwise stated, everything described in this manual is (at -->
<!-- least in principle) available on all platforms running @R{}. -->
   <p>따로 언급하지 않는 한, 이 매뉴얼에 기술된 모든 장치들(facilities)은 R을 구현하는 모든 플랫폼(platform)에서 사용 가능합니다.

<!-- In general, statistical systems like @R{} are not particularly well -->
<!-- suited to manipulations of large-scale data.  Some other systems are -->
<!-- better than @R{} at this, and part of the thrust of this manual is to -->
<!-- suggest that rather than duplicating functionality in @R{} we can make -->
<!-- another system do the work!  (For example Therneau & Grambsch (2000) -->
<!-- commented that they preferred to do data manipulation in SAS and then -->
<!-- use package @CRANpkg{survival} in @Sl{} for the analysis.)  Database -->
<!-- manipulation systems are often very suitable for manipulating and -->
<!-- extracting data: several packages to interact with DBMSs are discussed -->
<!-- here. -->
   <p>일반적으로 R과 같은 통계 시스템들은 특히 대용량 데이터(large-scale data)의 조작에 적절하지 않습니다. 이 점에 있어서는 다른 시스템들이 R 보다 더 나을 수 있기 때문에, 이 매뉴얼 주제의 일부문은 R 안에서 그 같은 기능을 반복하기 보다는 우리가 다른 시스템을 사용해서 이 작업을 할 수 있다는 것을 보여주는 데 있습니다(예를 들면, Therneau &amp; Grambsch (2000)의 저서에서 그들은 데이터 조작은 SAS로 그리고 생존분석<a href="http://CRAN.R-project.org/package=survival"><strong>survival</strong></a> in S로 하는 것을 선호한다고 말했습니다). 데이터베이스 조작 시스템은 종종 데이터의 조작과 추출에 보다 적합하고 DBMSs와 상호작용하는 여러 팩키지들이 여기에서 논의됩니다.

<!-- There are packages to allow functionality developed in languages such as -->
<!-- @code{Java}, @code{perl} and @code{python} to be directly integrated -->
<!-- with @R{} code, making the use of facilities in these languages even -->
<!-- more appropriate.(See the @CRANpkg{rJava} package from @acronym{CRAN} and -->
<!-- the @pkg{SJava}, @pkg{RSPerl} and @pkg{RSPython} packages from the -->
<!-- Omegahat project, @uref{http://www.omegahat.org}.) -->
   <p>직접적으로 R 코드와 통합하기 위한 <code>Java</code>, <code>perl</code> 그리고 <code>python</code>과 같은 언어에서 개발된 기능을 허용하는 팩키지들이 있는데 보다 더 적절하게 이들 언어에서 도구들을 사용할 수 있도록 합니다(<acronym>CRAN</acronym>로부터 팩키지 <a href="http://CRAN.R-project.org/package=rJava"><strong>rJava</strong></a>와 Omegahat 프로젝트 <a href="http://www.omegahat.org">http://www.omegahat.org</a>로부터  팩키지 <strong>SJava</strong>, <strong>RSPerl</strong> 그리고 <strong>RSPython</strong> 참고하십시오.)

<!-- index Unix tools -->
<!-- index AWK -->
<!-- index perl -->
<!-- It is also worth remembering that @R{} like @Sl{} comes from the Unix -->
<!-- tradition of small re-usable tools, and it can be rewarding to use tools -->
<!-- such as @code{awk} and @code{perl} to manipulate data before import or -->
<!-- after export.  The case study in Becker, Chambers & Wilks (1988, Chapter -->
<!-- 9) is an example of this, where Unix tools were used to check and -->
<!-- manipulate the data before input to @Sl{}. The traditional Unix tools -->
<!-- are now much more widely available, including for Windows. -->
   <p>또한, R도 S처럼 작지만 재사용 가능한 여러 개의 도구(tools)를 이용하는 Unix 전통에서 출발했다는 점을 상기해 보았을 때, 데이터를 불러오기 하기 전이나 내보내기 한 후에 데이터를 조작하기 위하여 <code>awk</code>과 <code>perl</code> 같은 도구들을 사용해 볼만 합니다. Becker, Chambers &amp; Wilks (1988, Chapter 9)에 있는 사례 연구에서 S에 데이터를 입력하기 전에 여러 Unix 도구(tool)들을 데이터를 검증하고 조작하는 데 사용한 것이 그 예가 될 수 있을 것입니다. 전통적인 Unix 도구(tool)들이 이제는 Windows를 포함한 다양한 시스템에서 더욱 많이 사용되고 있습니다.

<ul class="menu">
<li><a accesskey="1" href="#Imports">Imports</a>
<li><a accesskey="2" href="#Export-to-text-files">Export to text files</a>
<li><a accesskey="3" href="#XML">XML</a>
</ul>

<div class="node">
<a name="Imports"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Export-to-text-files">Export to text files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<h3 class="section">1.1 Imports</h3>

<p><a name="index-scan-1"></a>

<ul class="menu">
<li><a accesskey="1" href="#Encodings">Encodings</a>
</ul>

<!-- The easiest form of data to import into @R{} is a simple text file, and -->
<!-- this will often be acceptable for problems of small or medium scale. -->
<!-- The primary function to import from a text file is @code{scan}, and this -->
<!-- underlies most of the more convenient functions discussed in -->
<!-- @ref{Spreadsheet-like data}. -->
   <p>R 에 입력하기 가장 쉬운 파일형태는 단순한 text 파일인데 이것은 주로 작거나 중간 정도 크기의
문제를 해결하는데 적합합니다. Text 파일을 읽어 들이기 위해 가장 많이 사용하는 기능은
<code>scan</code> 이며, 이것은 <a href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>에 설명되어 있는 더욱 편리한 대부분의
함수(functions)의 기초가 됩니다.

<!-- However, all statistical consultants are familiar with being presented -->
<!-- by a client with a memory stick (formerly, a floppy disc or CD-R) of -->
<!-- data in some proprietary binary format, for example `an Excel -->
<!-- spreadsheet' or `an SPSS file'.  Often the simplest thing to do is to -->
<!-- use the originating application to export the data as a text file (and -->
<!-- statistical consultants will have copies of the most common applications -->
<!-- on their computers for that purpose).  However, this is not always -->
<!-- possible, and @ref{Importing from other statistical systems} discusses -->
<!-- what facilities are available to access such files directly from @R{}. -->
   <p>하지만, 모든 통계 컨설턴트들은 의뢰인이 Excel 스프레드 시트나 SPSS 파일처럼 특정 binary
포맷을 가진 데이터를 플로피 디스크나 CD 에 저장한 것을 받는 경우가 대부분입니다. 일을
하는데 있어서 흔히 가장 쉬운 경우가 데이터를 text 파일 형태로 내보내는 application 을 사용해서
그 결과물을 출력하는 것입니다(그리고 통계 컨설턴트들은 이러한 작업을 하기 위해 널리
통용되고 있는 여러 개의 application 들을 그들의 컴퓨터 안에 두고 사용하기도 합니다). 그렇지만,
이렇게 application 을 이용하는 것이 언제나 가능한 것은 아니며, <a href="#Importing-from-other-statistical-systems">Importing from other statistical systems</a> 에서 어떠한 장치들이 R 에서 이러한 파일들을 직접 사용하는 것이
가능한지 설명하고 있습니다.

<!-- For Excel spreadsheets, the available methods are summarized in -->
<!-- @ref{Reading Excel spreadsheets}.  For ODS spreadsheets from Open -->
<!-- Office, see the Omegahat package@footnote{Currently not available from -->
<!-- that repository but as a source package for download from -->
<!-- @url{http://www.omegahat.org/ROpenOffice/}.} @pkg{ROpenOffice}. -->
   <p>Excel 스프레드 시트(spreadsheet)를 이용하기 위해 사용 가능한
방법들은 <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a>에 요약되어 있습니다. 오픈오피스의 ODS 스프레드시트의 경우에는 the Omegahat package<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a> <strong>ROpenOffice</strong>를 참고하시기 바랍니다.

<!-- In a few cases, data have been stored in a binary form for compactness -->
<!-- and speed of access.  One application of this that we have seen several -->
<!-- times is imaging data, which is normally stored as a stream of bytes as -->
<!-- represented in memory, possibly preceded by a header.  Such data formats -->
<!-- are discussed in @ref{Binary files} and @ref{Binary connections}. -->
   <p>적지 않은 경우 데이터는 그 크기를 줄이고(compactness) 접근 속도를 높이기 위해(speed of access) binary 포맷으로 저장됩니다. 여기에 대한 한 가지 사례는 이미지 데이터(imaging data)를 저장하는 데서 찾을 수 있는데, 보통 엄청난 사이즈의 메모리를 차지하기 때문에 헤더(header)를 앞에 붙이기도 합니다. 이러한 형태의 데이터 포맷에 대해서는 <a href="#Binary-files">Binary files</a>와 <a href="#Binary-connections">Binary connections</a>에서 더 찾아볼 수 있습니다.

<!-- For much larger databases it is common to handle the data using a -->
<!-- database management system (DBMS).  There is once again the option of -->
<!-- using the DBMS to extract a plain file, but for many such DBMSs the -->
<!-- extraction operation can be done directly from an @R{} package: -->
<!-- @xref{Relational databases}.  Importing data via network connections is -->
<!-- discussed in @ref{Network interfaces}. -->
   <p>좀 더 큰 데이터베이스에 대해서는 database management system (DBMS)을 사용해서 데이터를 처리하는 것이 일반적입니다. 또한, DBMS를 사용해서 특정한 포맷이 없는(plain) 파일을 추출해내는 것도 가능합니다. 그렇지만 DBMS와 같은 시스템들을 이용한 결과 추출 작업을 R 패키지를 사용해서 직접하는 것도 가능합니다. 이에 관하여는 <a href="#Relational-databases">Relational databases</a>를 참고하십시오. 네트워크 연결을 통해 데이터를 입력하는 방법은 <a href="#Network-interfaces">Network interfaces</a>에서 찾을 수 있습니다.

<div class="node">
<a name="Encodings"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Imports">Imports</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Imports">Imports</a>

</div>

<h4 class="subsection">1.1.1 Encodings</h4>

<p><a name="index-Encodings-2"></a>
Unless the file to be imported from is entirely in ASCII, it is usually
necessary to know how it was encoded.  For text files, a good way to
find out something about its structure is the <samp><span class="command">file</span></samp>
command-line tool (for Windows, included in <code>Rtools</code>).  This
reports something like

<pre class="example">     text.Rd: UTF-8 Unicode English text
     text2.dat: ISO-8859 English text
     text3.dat: Little-endian UTF-16 Unicode English character data,
        with CRLF line terminators
     intro.dat: UTF-8 Unicode text
     intro.dat: UTF-8 Unicode (with BOM) text
</pre>
   <p class="noindent">Modern Unix-alike systems, including Mac OS X, are likely to produce
UTF-8 files.  Windows may produce what it calls `Unicode' files
(<code>UCS-2LE</code> or just possibly <code>UTF-16LE</code><a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>).  Otherwise most files will be in a
8-bit encoding unless from a Chinese/Japanese/Korean locale (which have
a wide range of encodings in common use).  It is not possible to
automatically detect with certainty which 8-bit encoding (although
guesses may be possible and <samp><span class="command">file</span></samp> may guess as it did in the
example above), so you may simply have to ask the originator for some
clues (e.g. `Russian on Windows').

   <p>`BOMs' (Byte Order Marks,
<a href="http://en.wikipedia.org/wiki/Byte_order_mark">http://en.wikipedia.org/wiki/Byte_order_mark</a>) cause problems for
Unicode files.  In the Unix world BOMs are rarely used, whereas in the
Windows world they almost always are for UCS-2/UTF-16 files, and often
are for UTF-8 files.  The <samp><span class="command">file</span></samp> utility will not even recognize
UCS-2 files without a BOM, but many other utilities will refuse to read
files with a BOM and the <acronym>IANA</acronym> standards for <code>UTF-16LE</code>
and <code>UTF-16BE</code> prohibit it.  We have too often been reduced to
looking at the file with the command-line utility <samp><span class="command">od</span></samp> or a hex
editor to work out its encoding.

<div class="node">
<a name="Export-to-text-files"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#XML">XML</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Imports">Imports</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<h3 class="section">1.2 Export to text files</h3>

<p><a name="index-Exporting-to-a-text-file-3"></a>
<!-- Exporting results from @R{} is usually a less contentious task, but -->
<!-- there are still a number of pitfalls.  There will be a target -->
<!-- application in mind, and normally a text file will be the most -->
<!-- convenient interchange vehicle.  (If a binary file is required, see -->
<!-- @ref{Binary files}.) -->

   <p>R에서 결과를 내보내는 과정은 대체로 다소 단순한 작업이지만, 여전히 많은 문제점을 안고 있습니다. 아무래도 이 작업에 사용하고자 하는 특정 어플리케이션이 있기 마련이고, 보통의 경우 text 파일이 가장 편리하게 변환할 수 있는 수단이라고 할 수 있습니다(만약 binary 파일이 필요하면, <a href="#Binary-files">Binary files</a>을 참조하십시오).

   <p><a name="index-cat-4"></a><!-- Function @code{cat} underlies the functions for exporting data.  It -->
<!-- takes a @code{file} argument, and the @code{append} argument allows a -->
<!-- text file to be written via successive calls to @code{cat}.  Better, -->
<!-- especially if this is to be done many times, is to open a @code{file} -->
<!-- connection for writing or appending, and @code{cat} to that connection, -->
<!-- then @code{close} it. -->

   <p>함수 cat은 데이터를 추출해내는 여러 함수들 중 가장 기본이 됩니다. 이것은 하나의 파일을 인자(argument)로 하며, 인자 append는 cat 어떤 텍스트 파일이 연속적인 호출(call)을 통해 cat에 쓰여질 수 있도록 해줍니다. 만약 이런 작업이 여러 번에 걸쳐 발생한다면, file connection을 열어서 쓰기(writing), 첨가하기(appending), 그리고 cat을 connection에 연결하고 close로 file을 종료하면 됩니다.

   <p><a name="index-write-5"></a><a name="index-write_002etable-6"></a><!-- The most common task is to write a matrix or data frame to file as a -->
<!-- rectangular grid of numbers, possibly with row and column labels.  This -->
<!-- can be done by the functions @code{write.table} and @code{write}. -->
<!-- Function @code{write} just writes out a matrix or vector in a specified -->
<!-- number of columns (and transposes a matrix).  Function -->
<!-- @code{write.table} is more convenient, and writes out a data frame (or -->
<!-- an object that can be coerced to a data frame) with row and column -->
<!-- labels. -->

   <p>가장 흔히 하는 작업은 하나의 행렬 혹은 데이터 프레임을 숫자들의 열이나 행에 label을 붙인 사각형의 격자(grid) 형태로 입력하는 것입니다. 이 작업은 <code>write.table</code>과 <code>write</code> 함수로 실행될 수 있습니다. 함수 <code>write</code>은 단순히 정해진 숫자의 열들로 하나의 행렬이나 벡터(그리고 전치 행렬(transpose) 까지도)를 표현할 수 있습니다. 함수 <code>write.table</code>은 더욱 사용하기 편리하며, 행과 열의 이름과 함께 데이터 프레임(혹은 데이터 프레임이라고 정의할 수 있는 하나의 객체)을 정의할 수 있습니다.

<!-- There are a number of issues that need to be considered in writing out a -->
<!-- data frame to a text file. -->
   <p>하나의 데이터 프레임을 하나의 text 파일로 정의하기 위해서는 많은 부분에서 고민해 볼 필요가 있습니다.

     <ol type=1 start=1>
<a name="index-format-7"></a><li><strong>Precision</strong>

     <!-- Most of the conversions of real/complex numbers done by these functions -->
     <!-- is to full precision, but those by @code{write} are governed by the -->
     <!-- current setting of @code{options(digits)}.  For more control, use -->
     <!-- @code{format} on a data frame, possibly column-by-column. -->
     <p>이러한 함수들에 의한 대부분의 실수/복소수 간 전환(conversion)은 가능한 모든 자릿수를 다 이용하지만(full precision), <code>write</code>에 의한 그러한 결과는 <code>options(digits)</code>에 의해 현재 세팅 된 자릿수(digits option)에 의해 결정됩니다. 그 이상의 컨트롤은 데이터 프레임에 <code>format)을 이용하여 열(column-by-column) 별로도 가능합니다.

     <li></code><strong>Header line</strong><code>

     <!-- @R{} prefers the header line to have no entry for the row names, so the -->
     <!-- file looks like -->
     <!-- R은 행 이름을 입력하지 않아도 되도록 header line을 사용하는 방식을 택하며, 그렇기 때문에 파일의 형태는 @c 다음과 같습니다. -->
     <pre class="example">                          dist    climb   time
          Greenmantle     2.5     650     16.083
             ...
</pre>
     <p class="noindent"><!-- Some other systems require a (possibly empty) entry for the row names, which -->
<!-- is what @code{write.table} will provide if argument @code{col.names = NA} -->
<!-- is specified.  Excel is one such system. -->

     <p>몇몇 다른 시스템들은 (입력하지 않아도 되긴 하지만) 행 이름을 입력하도록 하며, 이것은 인자가 col.names = NA라고 지정되어 있을 때, write.table이 보여주는 결과와 같습니다. 엑셀이 그러한 시스템 중 하나입니다.

     <li></code><strong>Separator</strong><code>
<a name="index-CSV-files-8"></a><a name="index-comma-separated-values-9"></a><a name="index-write_002ecsv-10"></a><a name="index-write_002ecsv2-11"></a>
<!-- A common field separator to use in the file is a comma, as that is -->
<!-- unlikely to appear in any of the fields in English-speaking countries. -->
<!-- Such files are known as CSV (comma separated values) files, and wrapper -->
<!-- function @code{write.csv} provides appropriate defaults.  In some -->
<!-- locales the comma is used as the decimal point (set this in -->
<!-- @code{write.table} by @code{dec = ","}) and there CSV files use the -->
<!-- semicolon as the field separator: use @code{write.csv2} for appropriate -->
<!-- defaults.  There is an IETF standard for CSV files (which mandates -->
<!-- commas and CRLF line endings, for which use @code{eol = "\r\n"}), RFC4180 -->
<!-- (see @uref{http://tools.ietf.org/html/rfc4180}), but what is more -->
<!-- important in practice is that the file is readable by the application it -->
<!-- is targeted at. -->

     <p>가장 많이 사용되는 필드 구분자 중 하나는 쉼표(comma)이며, 그래서 영어를 사용하는 국가에서는 필드 안에서 입력된 값에서 쉼표를 발견하는 일이 그리 흔하지는 않습니다. 이러한 형태의 파일들을 CSV (comma separated values)라고 하며, wrapper 함수인 write.csv가 적당한 기본값을 제공합니다. 몇몇 지역에서는, 쉼표가 소수점(decimal point)으로 사용되고 있으므로(이 경우는 write.table에서 {dec = ","</code>을 지정하는 것과 같습니다) CSV 파일 중에 세미콜론이 필드 구분자로 사용되는 것도 있습니다. 이 경우 적절한 기본값을 사용하기 위해 <code>write.csv2</code>을 사용해야 합니다. CSV에 대한 IETF 표준이 있습니다. IETF에서는 <code>eol = "\r\n"</code>), RFC4180 (see <a href="http://tools.ietf.org/html/rfc4180">http://tools.ietf.org/html/rfc4180</a>) 를 사용하는 것에 대해콤마와 CRLF 라인 인코딩을 권장합니다. 그러나 실제에서 더욱 중요한 것은 목표로 하고 있는 어플리케이션에 의해 읽혀들여 질 수 있는가 입니다.

     <!-- Using a semicolon or tab (@code{sep = "\t"}) are probably the safest -->
     <!-- options. -->
     <p>따라서, 세미콜론을 사용하거나 탭(<code>sep = "\t"</code>)을 사용하는 것이 가장 안전한 선택이 될 수 있습니다.

     <li><strong>Missing values</strong>
<a name="index-Missing-values-12"></a>
<!-- By default missing values are output as @code{NA}, but this may be -->
<!-- changed by argument @code{na}.  Note that @code{NaN}s are treated as -->
<!-- @code{NA} by @code{write.table}, but not by @code{cat} nor @code{write}. -->

     <p>디폴트로 결측값들을 NA로 출력(output)되게 지정한다고 해도, 이것은 인수 na에 의해 달라질 수 있습니다. NaN는 write.table에서는 NA와 똑같이 취급되지만, cat이나 write에서는 그렇지 않다는 점을 주의해야 합니다.

     <li><strong>Quoting strings</strong>
<a name="index-Quoting-strings-13"></a>
<!-- By default strings are quoted (including the row and column names). -->
<!-- Argument @code{quote} controls if  character and factor variables are -->
<!-- quoted: some programs, for example @pkg{Mondrian}, do not accept quoted -->
<!-- strings (which are the default). -->

     <p>문자열(string, 그것이 행 이름이던 열 이름이던)은 기본값으로 인용(quote)됩니다. 문자(character)와 요인(factor) 변수들이 인용된다면 인자 <code>quote</code>가 제어합니다. 예를 들어 <strong>Mondrian</strong> 같은 어떤 프로그램들은 인용된 문자열을 받아들이지 않고 기본값을 적용합니다.

     <!-- Some care is needed if the strings contain embedded quotes.  Three -->
     <!-- useful forms are -->
     <p>만약에 문자열(strings)이 임베디드 인용문(embedded quotes)을 포함하고 있다면 특별히 더 조심해야 합니다. 유용한 세 가지 형태는 다음과 같습니다.

     <pre class="example">          &gt; df &lt;- data.frame(a = I("a \" quote"))
          &gt; write.table(df)
          "a"
          "1" "a \" quote"
          &gt; write.table(df, qmethod = "double")
          "a"
          "1" "a "" quote"
          &gt; write.table(df, quote = FALSE, sep = ",")
          a
          1,a " quote
</pre>
     <!-- @noindent -->
     <!-- The second is the form of escape commonly used by spreadsheets. -->
     <p>두번째 방법은 명령을 중단(escape)하기 위한 형태인데 주로 스프레드 시트 형태 에서 많이 사용됩니다.

     <li><strong>Encodings</strong>
<a name="index-Encodings-14"></a>
Text files do not contain metadata on their encodings, so for non-ASCII
data the file needs to be targetted to the application intended to read
it.  All of these functions can write to a <em>connection</em> which
allows an encoding to be specified for the file, and <code>write.table</code>
has a <code>fileEncoding</code> argument to make this easier.

     <p>The hard part is to know what file encoding to use.  For use on Windows,
it is best to use what Windows calls `Unicode'<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>, that is <code>"UTF-16LE"</code>.  Using UTF-8 is a good way
to make portable files that will not easily be confused with any other
encoding, but even Mac OS X applications (where UTF-8 is the system
encoding) may not recognize them, and Windows applications are most
unlikely to.  Apparently Excel:mac 2004/8 expects <code>.csv</code> files in
<code>"macroman"</code> encoding (the encoding used in much earlier versions
of Mac OS).

        </ol>

   <p><a name="index-write_002ematrix-15"></a>Function <code>write.matrix</code> in package <a href="http://CRAN.R-project.org/package=MASS"><strong>MASS</strong></a> provides a
specialized interface for writing matrices, with the option of writing
them in blocks and thereby reducing memory usage.

   <p><a name="index-sink-16"></a>It is possible to use <code>sink</code> to divert the standard R output to
a file, and thereby capture the output of (possibly implicit)
<code>print</code> statements.  This is not usually the most efficient route,
and the <code>options(width)</code> setting may need to be increased.

   <p><a name="index-write_002eforeign-17"></a>Function <code>write.foreign</code> in package <a href="http://CRAN.R-project.org/package=foreign"><strong>foreign</strong></a> uses
<code>write.table</code> to produce a text file and also writes a code file
that will read this text file into another statistical package. There is
currently support for export to <code>SAS</code>, <code>SPSS</code> and <code>Stata</code>.

<div class="node">
<a name="XML"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Export-to-text-files">Export to text files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<h3 class="section">1.3 XML</h3>

<p><a name="index-XML-18"></a>
<!-- When reading data from text files, it is the responsibility of the user -->
<!-- to know and to specify the conventions used to create that file, -->
<!-- e.g. the comment character, whether a header line is present, the value -->
<!-- separator, the representation for missing values (and so on) described -->
<!-- in @ref{Export to text files}.  A markup language which can be used to -->
<!-- describe not only content but also the structure of the content can -->
<!-- make a file self-describing, so that one need not provide these details -->
<!-- to the software reading the data. -->

   <p>text 파일들에서 데이터를 읽어 들일 때, 그 파일을 생성하는 데 사용한 규정(convention)들을 알고 표기하는 것은 사용자의 책임입니다. 예를 들어, 주석문자(comment character)나 헤더의 존재 여부, 값 구분자(the value separator), 결측치의 재표현 등은 <a href="#Export-to-text-files">Export to text files</a>에 기술되어 있습니다.  데이터의 내용뿐 아니라 그 내용의 구조까지 기록하는 마크업 언어(markup language)는 하나의 파일이 그 안에서 완전히 설명 가능하도록(self-describing) 해주며, 그렇기 때문에 누군가가 데이터를 읽을 때 소프트웨어에 이러한 세부 사항들을 알려줄 필요가 없습니다.

<!-- The eXtensible Markup Language - more commonly known simply as -->
<!-- @acronym{XML} - can be used to provide such structure, not only for -->
<!-- standard datasets but also more complex data structures. -->
<!-- @acronym{XML} is becoming extremely popular and is emerging as a -->
<!-- standard for general data markup and exchange.  It is being used by -->
<!-- different communities to describe geographical data such as maps, -->
<!-- graphical displays, mathematics and so on. -->
   <p>확장형 마크업 언어(좀 더 일반적으로는 <acronym>XML</acronym>로 알려져 있는 eXtensible Markup Language)는 표준 형태의 데이터 세트뿐 아니라 좀 더 복잡한 형태의 데이터 구조까지도 표현이 가능합니다. <acronym>XML</acronym>은 점점 더 엄청난 인기를 얻고 있으며, 모든 형태의 데이터 마크업과 그 교환에 대한 하나의 기준이 되어가고 있습니다. XML은 서로 다른 커뮤니티들에서 지도, 그래픽, 수학식 등의 지리학적 데이터를 묘사하는데 사용되고 있습니다.

<!-- XML provides a way to specify the file's encoding, e.g.@: -->
   <p><acronym>XML</acronym>은 비록 요구되지 않더라도 다음과 같이 파일의 인코딩을 특정하는 방법을 제공하고 있습니다.

<pre class="example">     &lt;?xml version="1.0" encoding="UTF-8"?&gt;
</pre>
   <!-- @noindent -->
<!-- although it does not require it. -->
<!-- The @CRANpkg{XML} package provides general facilities for reading and -->
<!-- writing @acronym{XML} documents within @R{}.  A description of the -->
<!-- facilities of the @CRANpkg{XML} package is outside the scope of this -->
<!-- document: see the package's Web page at -->
<!-- @uref{http://www.omegahat.org/RSXML} for details and examples.  Package -->
<!-- @CRANpkg{StatDataML} on @acronym{CRAN} is one example building on -->
<!-- @CRANpkg{XML}. -->
   <p>패키지  <a href="http://CRAN.R-project.org/package=XML"><strong>XML</strong></a>은 R에서 <acronym>XML</acronym> 문서를 읽고 쓸 수 있도록 다양한 기능을 제공합니다. 팩키지  <a href="http://CRAN.R-project.org/package=XML"><strong>XML</strong></a>의 기능에 대한 설명서는 이 문서의 범위를 벗어나므로 세부적 사항들과 예제에 대하여는 웹페이지(<a href="http://www.omegahat.org/RSXML">http://www.omegahat.org/RSXML</a>)를 참고하기 바랍니다. <acronym>CRAN</acronym>에서 패키지 <a href="http://CRAN.R-project.org/package=StatDataML"><strong>StatDataML</strong></a>은  <a href="http://CRAN.R-project.org/package=XML"><strong>XML</strong></a>에서 구축된 하나의 사례입니다.

   <p>%NB가 'nota bene' 이거 맞나?

   <p>NB: <a href="http://CRAN.R-project.org/package=XML"><strong>XML</strong></a> is available as a binary package for Windows, normally
from the `CRAN extras' repository (which is selected by default on
Windows).

   <p>주의: <a href="http://CRAN.R-project.org/package=XML"><strong>XML</strong></a>은 일반적으로 'CRAN extras' 저장소(리포지토리: repository)로부터 윈도우즈 운영체제에 바이너리 패키지 형태(윈도우즈에 기본값으로 선택되어 지게 되어있습니다)로 사용가능합니다.

<div class="node">
<a name="Spreadsheet-like-data"></a>
<a name="Spreadsheet_002dlike-data"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Importing-from-other-statistical-systems">Importing from other statistical systems</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Spreadsheet-like data</h2>

<p><a name="index-Spreadsheet_002dlike-data-19"></a>

<ul class="menu">
<li><a accesskey="1" href="#Variations-on-read_002etable">Variations on read.table</a>
<li><a accesskey="2" href="#Fixed_002dwidth_002dformat-files">Fixed-width-format files</a>
<li><a accesskey="3" href="#Data-Interchange-Format-_0028DIF_0029">Data Interchange Format (DIF)</a>
<li><a accesskey="4" href="#Using-scan-directly">Using scan directly</a>
<li><a accesskey="5" href="#Re_002dshaping-data">Re-shaping data</a>
<li><a accesskey="6" href="#Flat-contingency-tables">Flat contingency tables</a>
</ul>

<!-- In @ref{Export to text files} we saw a number of variations on the -->
<!-- format of a spreadsheet-like text file, in which the data are presented -->
<!-- in a rectangular grid, possibly with row and column labels.  In this -->
<!-- section we consider importing such files into @R{}. -->
   <p><a href="#Export-to-text-files">Export to text files</a>에서 우리는 행과 열 이름이 달려 있고 사각의 격자 형태로 표현된 다양한 스프레드 시트 형태의 text 파일 포맷을 확인할 수 있었습니다. 이번에는 이와 같은 형태의 파일들을 R로 읽어 들이는 방법을 다룹니다.

<div class="node">
<a name="Variations-on-read.table"></a>
<a name="Variations-on-read_002etable"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Fixed_002dwidth_002dformat-files">Fixed-width-format files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>

</div>

<h3 class="section">2.1 Variations on <code>read.table</code></h3>

<p><a name="index-read_002etable-20"></a>
<!-- The function @code{read.table} is the most convenient way to read in a -->
<!-- rectangular grid of data.  Because of the many possibilities, there are -->
<!-- several other functions that call @code{read.table} but change a group -->
<!-- of default arguments. -->

   <p><code>read.table</code>은 사각형 격자 형태의 데이터를 읽기 위한 가장 편리한 방법입니다. 다양한 가능성 때문에, <code>read.table</code>을 호출하는 다른 다양한 함수들이 존재하지만, 이러한 함수들은 단지 몇 개의 디폴트 지정만 달리한 것입니다.

<!-- Beware that @code{read.table} is an inefficient way to read in -->
<!-- very large numerical matrices: see @code{scan} below. -->
   <p>주의할 점은 read.table은 대용량 수치 행렬을 읽기에는 비효율적인 방법이라는 점입니다. 보다 자세한 내용은 다음에 나올 <code>scan</code>을 참고하십시오.

<!-- Some of the issues to consider are: -->
   <p>몇 개의 중요한 사항은 다음과 같습니다.

     <ol type=1 start=1>
<li><strong>Encoding</strong>

     <!-- If the file contains non-ASCII character fields, ensure that it is read -->
     <!-- in the correct encoding.  This is mainly an issue for reading Latin-1 -->
     <!-- files in a UTF-8 locale, which can be done by something like -->
     <p>만약 파일에 ASCII 형태가 아닌 문자 변수들이 포함되어 있다면, 그것이 제대로 부호화 되어 읽어졌는지 반드시 확인해야 합니다. 이것은 주로 UTF-8 locale에서 Latin-1 파일을 읽는 것과 관련된 문제인데, 이것은 아래와 같은 방법으로 해결할 수 있습니다.

     <pre class="example">          read.table("file.dat", fileEncoding="latin1")
</pre>
     <p class="noindent"><!-- Note that this will work in any locale which can represent Latin-1 -->
<!-- strings, but not many Greek/Russian/Chinese/Japanese @dots{} locales. -->

     <p>중요한 것은 그리스/러시아/중국/일본 <small class="dots">...</small> locales를 제외하고 Latin-1으로 표현된 모든 locale에 대해 이 방법을 사용할 수 있다는 점입니다.

     <li><strong>Header line</strong>

     <!-- We recommend that you specify the @code{header} argument explicitly, -->
     <!-- Conventionally the header line has entries only for the columns and not -->
     <!-- for the row labels, so is one field shorter than the remaining lines. -->
     <!-- (If @R{} sees this, it sets @code{header = TRUE}.)  If presented with a -->
     <!-- file that has a (possibly empty) header field for the row labels, read -->
     <!-- it in by something like -->
     <p>우리는 여러분들에게 헤더를 분명하게 표기하라고 권하고 싶습니다. 전통적으로 헤더에는 행 이름 대신 열 이름들만 들어가 있었는데, 그래서 하나의 변수가 다른 것들에 비해 길이가 짧습니다(만약 R이 이것을 판단할 수 있으면, header = TRUE로 세팅 할 것입니다). 만약에, 어떤 파일이 행 이름에 대한(입력이 되지 않았을 수 있는) 헤더 변수를 포함한다면, 아래와 같은 방법으로 이 파일을 읽을 수 있습니다.

     <pre class="example">          read.table("file.dat", header = TRUE, row.names = 1)
</pre>
     <!-- Column names can be given explicitly via the @code{col.names}; explicit -->
     <!-- names override the header line (if present). -->
     <p>열 이름들은 <code>col.names</code>을 사용해서 따로 정의될 수 있으며, 따로 정의된 이름은 헤더(만약 존재한다면)에 대해 우선합니다.

     <li><strong>Separator</strong>

     <!-- Normally looking at the file will determine the field separator to be -->
     <!-- used, but with white-space separated files there may be a choice between -->
     <!-- the default @code{sep = ""} which uses any white space (spaces, tabs or -->
     <!-- newlines) as a separator, @code{sep = " "} and @code{sep = "\t"}.  Note -->
     <!-- that the choice of separator affects the input of quoted strings. -->
     <p>보통은 파일을 보면 파일에 사용된 변수 구분자가 무엇인지 알 수 있지만, 공백으로 파일이 구분된 경우, 우리는 구분자로 어떤 종류의 공백이든(단순 여백, 탭, 혹은 새로운 행) 다 사용할 수 있는 디폴트 <code>sep = ""</code>과 <code>sep = " "</code>, <code>sep = "＼t"</code> 중에서 하나를 구분자로 선택할 수 있습니다. 구분자의 선택이 인용된 문자열의 입력에 영향을 줄 수도 있다는 점을 주의해야 합니다.

     <!-- If you have a tab-delimited file containing empty fields be sure to use -->
     <!-- @code{sep = "\t"}. -->
     <p>만약 여러분이 여백을 포함하고 있는 탭을 구분자로 지정한(tab-delimited) 파일을 가지고 있다면, <code>sep = "＼t"</code>을 사용해야만 합니다.

     <li><strong>Quoting</strong>
<a name="index-Quoting-strings-21"></a>
<!-- By default character strings can be quoted by either @samp{"} or -->
<!-- @samp{'}, and in each case all the characters up to a matching quote are -->
<!-- taken as part of the character string.  The set of valid quoting -->
<!-- characters (which might be none) is controlled by the @code{quote} -->
<!-- argument.  For @code{sep = "\n"} the default is changed to @code{quote = -->
<!-- ""}. -->

     <p>디폴트에 의해 문자형 문자열이 &lsquo;<samp><span class="samp">"</span></samp>&rsquo; 또는 &lsquo;<samp><span class="samp">'</span></samp>&rsquo;에 의해 인용되면, 각각의 경우에 그 인용부호(quote)가 나타나기 전의 모든 문자들이 문자형 문자열의 한 덩어리로 간주됩니다. 유효한 인용부호 문자들의 조합(만약 인용부호 지정이 없다면)은 <code>quote</code> 인수(argument)로 통제할 수 있습니다. <code>sep ="＼n"</code>에 대해서, 디폴트는 <code>quote = ""</code>로 변경되어야 합니다.

     <!-- If no separator character is specified, quotes can be escaped within -->
     <!-- quoted strings by immediately preceding them by @samp{\}, C-style. -->
     <p>아무런 구분자가 지정되지 않은 경우, C에서 그런 것처럼, 인용된 문자열 안에 든 인접한 바로 앞의 „＼‟에 의해 인용 작업이 중단될 수 있습니다.

     <!-- If a separator character is specified, quotes can be escaped within -->
     <!-- quoted strings by doubling them as is conventional in spreadsheets.  For -->
     <!-- example -->
     <p>특정 구분 문자가 지정된 경우에는 인용된 문자열 내에서 중복된 구분 문자에 의한 인용 작업의 중단이 발생할 수도 있습니다. 예를 들면,

     <pre class="example">          'One string isn''t two',"one more"
</pre>
     <p>을 읽어 들일 때는

     <p class="noindent"><!-- can be read by -->

     <pre class="example">          read.table("testfile", sep = ",")
</pre>
     <p>read.table("testfile", sep = ",")을 사용해야 합니다.

     <p class="noindent"><!-- This does not work with the default separator. -->

     <p>이렇게 하면 디폴트 구분자에 대해 작동하지 않습니다

     <li><strong>Missing values</strong>
<a name="index-Missing-values-22"></a>
<!-- By default the file is assumed to contain the character string @code{NA} -->
<!-- to represent missing values, but this can be changed by the argument -->
<!-- @code{na.strings}, which is a vector of one or more character -->
<!-- representations of missing values. -->

     <p>파일 안에 든 결측값들을 표기하기 위해 문자열 <code>NA</code>를 사용하도록 디폴트가 지정되어 있지만, 결측값을 표현하기 위한 한 개 이상의 문자 벡터를 지정하는 <code>na.strings</code>에 의해 이 표현은 달라질 수 있습니다.

     <!-- Empty fields in numeric columns are also regarded as missing values. -->
     <p>또한 수치화된 열들 중에서 비워진 열들도 결측치로 간주됩니다.

     <!-- In numeric columns, the values @code{NaN}, @code{Inf} and @code{-Inf} are -->
     <!-- accepted. -->
     <p>숫자로 된 열에서는 <code>NaN</code>과 <code>Inf</code>, <code>-Inf</code>이 채워진 것으로 인정됩니다.

     <li><strong>Unfilled lines</strong>

     <!-- It is quite common for a file exported from a spreadsheet to have all -->
     <!-- trailing empty fields (and their separators) omitted.  To read such -->
     <!-- files set @code{fill = TRUE}. -->
     <p>스프레드 시트로부터 나온 파일이 줄줄 이어지는 빈 칸이 있는 열 들을 포함했거나 구분자가 빠져있는 경우는 매우 흔합니다. 이러한 파일을 읽기 위해서는 <code>fill = TRUE</code> 옵션을 사용합니다.

     <li><strong>White space in character fields</strong>

     <!-- If a separator is specified, leading and trailing white space in -->
     <!-- character fields is regarded as part of the field.  To strip the space, -->
     <!-- use argument @code{strip.white = TRUE}. -->
     <p>구분자가 지정되어 있는 경우에는, 문자열들 앞에 연속된 여백이 그 열의 일부로 인식됩니다. 그 여백을 제거하기 위해서는, <code>strip.white = TRUE</code> 옵션을 사용합니다.

     <li><strong>Blank lines</strong>

     <!-- By default, @code{read.table} ignores empty lines.  This can be changed -->
     <!-- by setting @code{blank.lines.skip = FALSE}, which will only be useful in -->
     <!-- conjunction with @code{fill = TRUE}, perhaps to use blank rows to -->
     <!-- indicate missing cases in a regular layout. -->
     <p>기본적으로 <code>read.table</code>는 빈 행들을 무시합니다. 이것은 <code>blank.lines.skip = FALSE</code> 세팅으로  바꿀 수 있는데, 이 옵션은 <code>fill = TRUE</code>와 함께 사용될 때만 작동합니다. 이것은 일반적으로 비어 있는 행들이 결측된 개체들을 나타내는데 사용되기 때문입니다.

     <li><strong>Classes for the variables</strong>

     <!-- Unless you take any special action, @code{read.table} reads all the -->
     <!-- columns as character vectors and then tries to select a suitable class -->
     <!-- for each variable in the data frame.  It tries in turn @code{logical}, -->
     <!-- @code{integer}, @code{numeric} and @code{complex}, moving on if any -->
     <!-- entry is not missing and cannot be converted.@footnote{This is normally -->
     <!-- fast as looking at the first entry rules out most of the possibilities.} -->
     <!-- If all of these fail, the variable is converted to a factor. -->
     <p>특별한 조치를 따로 하지 않는다면, <code>read.table</code>은 모든 열을 문자 벡터로 읽은 후 데이터 프레임 내에 포함된 각각의 변수들에 적당한 클래스(class)를 선택하려 합니다. 어떤 입력 값이 결측치가 아니고 특별히 해당 class로 전환 될 수 없다면, 이 문장은 차례로 logical, integer, numeric 그리고 complex로 움직여가며 class 할당을 시도합니다.1 만약 이러한 시도가 모두 실패하면, 그 변수는 factor 변수로 변환됩니다.

     <!-- Arguments @code{colClasses} and @code{as.is} provide greater control. -->
     <!-- Specifying @code{as.is = TRUE} suppresses conversion of character -->
     <!-- vectors to factors (only).  Using @code{colClasses} allows the desired -->
     <!-- class to be set for each column in the input: it will be faster and use -->
     <!-- less memory. -->
     <p>인자(argument) <code>colClasses</code>와 <code>as.is</code>는 더 많은 것을 통제할 수 있게 합니다. <code>as.is = TRUE</code>로 설정하는 것은 문자열들이 factor로 전환되는 일이 없도록 합니다(주로 이 용도로만 쓰입니다). <code>colClasses</code>를 사용하는 것은 원하는 클래스(class)가 입력할 때 각각의 열에 할당하도록 합니다. 그리고 이러한 방법은 보다 빠르고 메모리를 적게 차지합니다.

     <!-- Note that @code{colClasses} and @code{as.is} are specified @emph{per} -->
     <!-- column, not @emph{per} variable, and so include the column of row names -->
     <!-- (if any). -->
     <p>중요한 것은 <code>colClasses</code>와 <code>as.is</code>이 <em>각각의</em> 변수가 아니라, <em>각각의</em> 열에 대해 기술한다는 것입니다. 그래서 이들은 행 이름들이 포함된 열도 (만약 그런 열이 있다면) 포함합니다.

     <li><strong>Comments</strong>

     <!-- By default, @code{read.table} uses @samp{#} as a comment character, -->
     <!-- and if this is encountered (except in quoted strings) the rest of the -->
     <!-- line is ignored. Lines containing only white space and a comment are -->
     <!-- treated as blank lines. -->
     <p><code>read.table</code>은 기본값으로 &lsquo;<samp><span class="samp">#</span></samp>&rsquo;을 주석 문자로 사용하고 있습니다. 만약, 이 문자가 나타난다면 (인용되고 있는 부분에서 나타난 것이 아니라면) 그 줄의 나머지 부분은 무시됩니다. 즉, 오직 여백(white space)과 주석을 포함한 줄들 만이 공백(blank line)으로 처리됩니다.

     <!-- If it is known that there will be no comments in the data file, it is -->
     <!-- safer (and may be faster) to use @code{comment.char = ""}. -->
     <p>만약 데이터 파일 안에 주석이 없는 것이 확실하다면, <code>comment.char = ""</code>을 사용하는 편이 더 안전할 것입니다(어쩌면 처리도 더 빠를 것입니다.)

     <li><strong>Escapes</strong>

     <!-- Many OSes have conventions for using backslash as an escape character in -->
     <!-- text files, but Windows does not (and uses backslash in path names). -->
     <!-- It is optional in @R{} whether such conventions are applied to data files. -->
     <p>많은 OS들은 관습적으로 text 파일에서 역슬래쉬(＼)를 마침(또는 종료: escape) 문자로 사용하고 있지만, Windows에서는 그렇지 않습니다(역슬래쉬(＼)를 경로 이름을 표시하는 데 사용하고 있습니다). R에서 이 문제는 데이터 파일에 적용하는데 있어 관습을 따를 것인지 아닌지의 선택의 문제입니다.

     <!-- Both @code{read.table} and @code{scan} have a logical argument -->
     <!-- @code{allowEscapes}.  This is false by default, and backslashes are then -->
     <!-- only interpreted as (under circumstances described above) escaping -->
     <!-- quotes.  If this set to be true, C-style escapes are interpreted, namely -->
     <!-- the control characters @code{\a, \b, \f, \n, \r, \t, \v} and octal and -->
     <!-- hexadecimal representations like @code{\040} and @code{\0x2A}.  Any -->
     <!-- other escaped character is treated as itself, including backslash.  Note -->
     <!-- that Unicode escapes such as @code{\u@var{xxxx}} are never interpreted. -->
     <p><code>read.table</code>과 <code>scan</code> 모두 <code>allowEscapes</code>라는 "논리 인자(logical argument)"를 사용합니다. false가 기본값으로 설정되어 있으며, 그래서 (앞서 설명한 환경에서는) 역슬래쉬(＼)들은 오직 "마침(또는 종료: escaping)"으로 해석됩니다. 만약 이것이 true로 설정되어 있다면, C-스타일 <code>＼a, ＼b, ＼f, ＼n, ＼r, ＼t, ＼v</code>와 <code>\040</code> 및 <code>\0x2A</code>와 같이 표현된 8진수나 16진수 통제 문자가 종료로 인식됩니다. 역슬래쉬(＼)를 포함한 어떤 다른 종료 문자도 그것과 같이 다루어 집니다. <code>\u</code><var>xxx</var>와 같은 유니코드 종료문자(Unicode escapes)는 인식되지 않는 점에 유의하십시오.

     <li><strong>Encoding</strong>

     <p>This can be specified by the <code>fileEncoding</code> argument, for example

     <p>이것은 다음의 예와 같이 <code>fileEncoding</code> 인자로 설정할 수 있습니다.

     <!-- @example -->
     <!-- fileEncoding = "UCS-2LE"    # Windows 'Unicode' files -->
     <!-- fileEncoding = "UTF-8" -->
     <!-- @end example -->
     <pre class="example">          fileEncoding = "UCS-2LE"    # 윈도우즈 유니코드 파일
          fileEncoding = "UTF-8"
</pre>
     <p class="noindent"><!-- If you know (correctly) the file's encoding this will almost always -->
<!-- work.  However, we know of one exception, UTF-8 files with a BOM.  Some -->
<!-- people claim that UTF-8 files should never have a BOM, but some software -->
<!-- (apparently including Excel:mac) uses them, and many Unix-alike OSes do -->
<!-- not accept them.  So faced with a file which @command{file} reports as -->

     <p>여러분이 (올바로) 파일의 인코딩을 알고 있다면 이것은 거의 항상 작동합니다. 그러나 우리는 한 가지 예외를 알고 있는데 그것은 BOM 있는 UTF-8 파일입니다. 어떤 사람들은 UTF-8 파일이 BOM을 가지면 안된다고 주장하지만 (명백하게 엑셀:mac은 포함하는) 어떤 소프트웨어는 그것을 사용하고 많은 유닉스 계열의 OS들은 그것을 허용하지 않습니다. 그래서 다음과 같은 <samp><span class="command">file</span></samp> 보고를 하는 파일을 보게 됩니다.

     <pre class="example">          intro.dat: UTF-8 Unicode (with BOM) text
</pre>
     <p class="noindent"><!-- it can be read on Windows by -->

     <p>이것은 윈도우즈에서 다음과 같이 읽힐 수 있습니다.

     <pre class="example">          read.table("intro.dat", fileEncoding = "UTF-8")
</pre>
     <p class="noindent"><!-- but in a UTF-8 locale on a Unix-alike is likely to need -->

     <p>그러나 유닉스 계열의 UTF-8 locale은 다음이 필요할 것입니다.

     <pre class="example">          con &lt;- file("intro.dat", "r")
          seek(con, 3)  # step over the 3 initial bytes, the BOM
          foo &lt;- read.table(con)
          close(con)
</pre>
     <p class="noindent">Another problem with this (real-life) example is that whereas
<samp><span class="command">file-5.03</span></samp> reported the BOM, <samp><span class="command">file-4.17</span></samp> found on Mac
OS 10.5 (Leopard) did not.
        </ol>

   <p>이러한 (실제의) 사례에 따른 또 다른 문제는 <samp><span class="command">file-5.03</span></samp>은 BOM을 보고하는 반면에 MAC OS 10.5(레오파드) 에서 <samp><span class="command">file-4.17</span></samp>는 그렇지 않다는 점입니다.

   <p><a name="index-read_002ecsv-23"></a><a name="index-read_002ecsv2-24"></a><a name="index-read_002edelim-25"></a><a name="index-read_002edelim2-26"></a><a name="index-CSV-files-27"></a><a name="index-Sys_002elocaleconv-28"></a><a name="index-locales-29"></a><!-- Convenience functions @code{read.csv} and @code{read.delim} provide -->
<!-- arguments to @code{read.table} appropriate for CSV and tab-delimited -->
<!-- files exported from spreadsheets in English-speaking locales.  The -->
<!-- variations @code{read.csv2} and @code{read.delim2} are appropriate for -->
<!-- use in those locales where the comma is used for the decimal point and -->
<!-- (for @code{read.csv2}) for spreadsheets which use semicolons to separate -->
<!-- fields. -->

   <p>편리한 함수인 <code>read.csv</code>와 <code>read.table</code>은 영어권에서 스프레드시트로부터 추출된 CSV와 탭으로 구분된 파일들에 적절한 <code>read.table</code>의 인자(arguments)를 제공합니다. <code>read.csv2</code> 와 <code>read.delim2</code>와 같은 변형은 구분자로 콤마(,)를 사용하거나 (<code>read.csv2</code>의 경우) 세미콜론이 스프레트시트의 필드구분자로 사용되는 지역에 적절합니다.

<!-- If the options to @code{read.table} are specified incorrectly, the error -->
<!-- message will usually be of the form -->
   <p>read.table에 옵션을 부적절하게 지정하면, 보통 다음과 같은 형태의 에러 메시지가 나타납니다.

<pre class="example">     Error in scan(file = file, what = what, sep = sep, :
             line 1 did not have 5 elements
</pre>
   <p class="noindent"><!-- or -->

   <p>또는

<pre class="example">     Error in read.table("files.dat", header = TRUE) :
             more columns than column names
</pre>
   <p><a name="index-count_002efields-30"></a>
<!-- This may give enough information to find the problem, but the auxiliary -->
<!-- function @code{count.fields} can be useful to investigate further. -->

   <p>이 메세지가 무엇이 문제인지 충분한 정보를 제공하지 못한다면 보조적으로 <code>count.fields</code>가 문제를 보다 더 자세하게 찾아내는데 유용하게 사용될 수 있습니다.

<!-- Efficiency can be important when reading large data grids.  It will help -->
<!-- to specify @code{comment.char = ""}, @code{colClasses} as one of the -->
<!-- atomic vector types (logical, integer, numeric, complex, character or -->
<!-- perhaps raw) for each column, and to give @code{nrows}, the number of -->
<!-- rows to be read (and a mild over-estimate is better than not specifying -->
<!-- this at all).  See the examples in later sections. -->
   <p>효율성은 큰 데이터 그리드(grid)를 읽는데 중요합니다. 각 열에 대하여 (논리, 정수, 분수, 복소수, 문자 또는 미가공 된) atomic 벡터 유형들 중 하나인 <code>colClasses</code>인 <code>comment.char = ""</code>를 특정하고 읽어야 할 행의 수인 <code>nrows</code>를 (다소 과대 추정하는 것이 특정하지 않는 것보다 더 좋습니다) 부여하는 것이 도움이 될 것입니다. 아래의 예제들을 참조하십시오.

<div class="node">
<a name="Fixed-width-format-files"></a>
<a name="Fixed_002dwidth_002dformat-files"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Data-Interchange-Format-_0028DIF_0029">Data Interchange Format (DIF)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variations-on-read_002etable">Variations on read.table</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>

</div>

<h3 class="section">2.2 Fixed-width-format files</h3>

<p><a name="index-Fixed_002dwidth_002dformat-files-31"></a>
<!-- Sometimes data files have no field delimiters but have fields in -->
<!-- pre-specified columns.  This was very common in the days of punched -->
<!-- cards, and is still sometimes used to save file space. -->

   <p>종종 데이터 파일은 필드 구분자가 없이 사전에 정해진 열에 필드를 가집니다. 이것은 천공카드가 사용되던 때에 매우 일반적이었고 파일 공간을 절약하는데 여전히 종종 쓰입니다.

   <p><a name="index-read_002efwf-32"></a><!-- Function @code{read.fwf} provides a simple way to read such files, -->
<!-- specifying a vector of field widths.  The function reads the file into -->
<!-- memory as whole lines, splits the resulting character strings, writes -->
<!-- out a temporary tab-separated file and then calls @code{read.table}. -->
<!-- This is adequate for small files, but for anything more complicated we -->
<!-- recommend using the facilities of a language like @code{perl} to -->
<!-- pre-process the file. -->
<a name="index-perl-33"></a>
함수 <code>read.fwf</code>는 필드 넓이의 벡터를 특정지음으로써, 그러한 파일들을 읽는데 단순한 방법을 제공합니다. <code>read.fwf</code> 함수는 파일의 전체 줄을 메모리로 읽고, 결과 문자열을 분할하고, 탭으로 분리된 임시 파일을 작성하여 <code>read.table</code>을 호출(call)합니다. 이것은 작은 파일에 적당하지만 어떤 더 복잡한 것에 대해서는 파일 전처리를 위해 <code>perl</code>과 같은 언어의 도구를 사용하는 것을 권장합니다.

   <p><a name="index-read_002efortran-34"></a><!-- Function @code{read.fortran} is a similar function for fixed-format files, -->
<!-- using Fortran-style column specifications. -->

   <p>함수 <code>read.fortran</code>은 포트란(Fortran) 유형의 열을 지정함으로써 고정된 포맷 파일에 대해 유사한 함수입니다.

<div class="node">
<a name="Data-Interchange-Format-(DIF)"></a>
<a name="Data-Interchange-Format-_0028DIF_0029"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-scan-directly">Using scan directly</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Fixed_002dwidth_002dformat-files">Fixed-width-format files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>

</div>

<h3 class="section">2.3 Data Interchange Format (DIF)</h3>

<p><a name="index-Data-Interchange-Format-_0028DIF_0029-35"></a>
An old format sometimes used for spreadsheet-like data is DIF, or Data Interchange
format.

   <p><a name="index-read_002eDIF-36"></a>Function <code>read.DIF</code> provides a simple way to read such files.  It takes
arguments similar to <code>read.table</code> for assigning types to each of the columns.

   <p>On Windows, spreadsheet programs often store spreadsheet data copied to
the clipboard in this format; <code>read.DIF("clipboard")</code> can read it
from there directly.  It is slightly more robust than
<code>read.table("clipboard")</code> in handling spreadsheets with empty
cells.

<div class="node">
<a name="Using-scan-directly"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Re_002dshaping-data">Re-shaping data</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Data-Interchange-Format-_0028DIF_0029">Data Interchange Format (DIF)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>

</div>

<h3 class="section">2.4 Using <code>scan</code> directly</h3>

<p><a name="index-scan-37"></a>
Both <code>read.table</code> and <code>read.fwf</code> use <code>scan</code> to read the
file, and then process the results of <code>scan</code>.  They are very
convenient, but sometimes it is better to use <code>scan</code> directly.

   <p>Function <code>scan</code> has many arguments, most of which we have already
covered under <code>read.table</code>.  The most crucial argument is
<code>what</code>, which specifies a list of modes of variables to be read
from the file.  If the list is named, the names are used for the
components of the returned list.  Modes can be numeric, character or
complex, and are usually specified by an example, e.g. <code>0</code>,
<code>""</code> or <code>0i</code>.  For example

<pre class="example">     cat("2 3 5 7", "11 13 17 19", file="ex.dat", sep="\n")
     scan(file="ex.dat", what=list(x=0, y="", z=0), flush=TRUE)
</pre>
   <p class="noindent">returns a list with three components and discards the fourth column in
the file.

   <p><a name="index-readLines-38"></a>There is a function <code>readLines</code> which will be more convenient if
all you want is to read whole lines into R for further processing.

   <p>One common use of <code>scan</code> is to read in a large matrix.  Suppose
file <samp><span class="file">matrix.dat</span></samp> just contains the numbers for a 200 x 2000
matrix. Then we can use
<!-- write.table(matrix(rnorm(200*2000), 200), "matrix.dat", row.names=F, col.names=F) -->

<pre class="example">     A &lt;- matrix(scan("matrix.dat", n = 200*2000), 200, 2000, byrow = TRUE)
</pre>
   <p class="noindent">On one test this took 1 second (under Linux, 3 seconds under Windows on
the same machine) whereas

<pre class="example">     A &lt;- as.matrix(read.table("matrix.dat"))
</pre>
   <p class="noindent">took 10 seconds (and more memory), and

<pre class="example">     A &lt;- as.matrix(read.table("matrix.dat", header = FALSE, nrows = 200,
                               comment.char = "", colClasses = "numeric"))
</pre>
   <p class="noindent">took 7 seconds.  The difference is almost entirely due to the overhead
of reading 2000 separate short columns: were they of length 2000,
<code>scan</code> took 9 seconds whereas <code>read.table</code> took 18 if used
efficiently (in particular, specifying <code>colClasses</code>) and 125 if
used naively.

   <p>Note that timings can depend on the type read and the data. 
Consider reading a million distinct integers:
<pre class="example">     writeLines(as.character((1+1e6):2e6), "ints.dat")
     xi &lt;- scan("ints.dat", what=integer(0), n=1e6)   # 0.77s
     xn &lt;- scan("ints.dat", what=numeric(0), n=1e6)   # 0.93s
     xc &lt;- scan("ints.dat", what=character(0), n=1e6) # 0.85s
     xf &lt;- as.factor(xc)                              # 2.2s
     DF &lt;- read.table("ints.dat")                     # 4.5s
</pre>
   <p class="noindent">and a million examples of a small set of codes:
<pre class="example">     code &lt;- c("LMH", "SJC", "CHCH", "SPC", "SOM")
     writeLines(sample(code, 1e6, replace=TRUE), "code.dat")
     y &lt;- scan("code.dat", what=character(0), n=1e6)  # 0.44s
     yf &lt;- as.factor(y)                               # 0.21s
     DF &lt;- read.table("code.dat")                     # 4.9s
     DF &lt;- read.table("code.dat", nrows=1e6)          # 3.6s
</pre>
   <p>Note that these timings depend heavily on the operating system (the
basic reads in Windows take at least as twice as long as these Linux
times) and on the precise state of the garbage collector.

<div class="node">
<a name="Re-shaping-data"></a>
<a name="Re_002dshaping-data"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Flat-contingency-tables">Flat contingency tables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-scan-directly">Using scan directly</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>

</div>

<h3 class="section">2.5 Re-shaping data</h3>

<p><a name="index-Re_002dshaping-data-39"></a>
Sometimes spreadsheet data is in a compact format that gives the
covariates for each subject followed by all the observations on that
subject.  R's modelling functions need observations in a single
column.  Consider the following sample of data from repeated MRI brain
measurements

<pre class="example">      Status   Age    V1     V2     V3    V4
           P 23646 45190  50333  55166 56271
          CC 26174 35535  38227  37911 41184
          CC 27723 25691  25712  26144 26398
          CC 27193 30949  29693  29754 30772
          CC 24370 50542  51966  54341 54273
          CC 28359 58591  58803  59435 61292
          CC 25136 45801  45389  47197 47126
</pre>
   <p class="noindent">There are two covariates and up to four measurements on each subject. 
The data were exported from Excel as a file <samp><span class="file">mr.csv</span></samp>.

   <p><a name="index-stack-40"></a>We can use <code>stack</code> to help manipulate these data to give a single
response.

<pre class="example">     zz &lt;- read.csv("mr.csv", strip.white = TRUE)
     zzz &lt;- cbind(zz[gl(nrow(zz), 1, 4*nrow(zz)), 1:2], stack(zz[, 3:6]))
</pre>
   <p class="noindent">with result

<pre class="example">           Status   Age values ind
     X1         P 23646  45190  V1
     X2        CC 26174  35535  V1
     X3        CC 27723  25691  V1
     X4        CC 27193  30949  V1
     X5        CC 24370  50542  V1
     X6        CC 28359  58591  V1
     X7        CC 25136  45801  V1
     X11        P 23646  50333  V2
     ...
</pre>
   <p><a name="index-unstack_002e-41"></a>Function <code>unstack</code> goes in the opposite direction, and may be
useful for exporting data.

   <p><a name="index-reshape-42"></a>Another way to do this is to use the function
<code>reshape</code>, by

<pre class="example">     &gt; reshape(zz, idvar="id",timevar="var",
       varying=list(c("V1","V2","V3","V4")),direction="long")
         Status   Age var    V1 id
     1.1      P 23646   1 45190  1
     2.1     CC 26174   1 35535  2
     3.1     CC 27723   1 25691  3
     4.1     CC 27193   1 30949  4
     5.1     CC 24370   1 50542  5
     6.1     CC 28359   1 58591  6
     7.1     CC 25136   1 45801  7
     1.2      P 23646   2 50333  1
     2.2     CC 26174   2 38227  2
     ...
</pre>
   <p>The <code>reshape</code> function has a more complicated syntax than
<code>stack</code> but can be used for data where the `long' form has more
than the one column in this example. With <code>direction="wide"</code>,
<code>reshape</code> can also perform the opposite transformation.

   <p>Some people prefer the tools in packages <a href="http://CRAN.R-project.org/package=reshape"><strong>reshape</strong></a>,
<a href="http://CRAN.R-project.org/package=reshape2"><strong>reshape2</strong></a> and <a href="http://CRAN.R-project.org/package=plyr"><strong>plyr</strong></a>.

<div class="node">
<a name="Flat-contingency-tables"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Re_002dshaping-data">Re-shaping data</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>

</div>

<h3 class="section">2.6 Flat contingency tables</h3>

<p><a name="index-Flat-contingency-tables-43"></a>
Displaying higher-dimensional contingency tables in array form typically
is rather inconvenient.  In categorical data analysis, such information
is often represented in the form of bordered two-dimensional arrays with
leading rows and columns specifying the combination of factor levels
corresponding to the cell counts.  These rows and columns are typically
&ldquo;ragged&rdquo; in the sense that labels are only displayed when they change,
with the obvious convention that rows are read from top to bottom and
columns are read from left to right.  In R, such &ldquo;flat&rdquo; contingency
tables can be created using <code>ftable</code>,
<a name="index-ftable-44"></a>which creates objects of class <code>"ftable"</code> with an appropriate print
method.

   <p>As a simple example, consider the R standard data set
<code>UCBAdmissions</code> which is a 3-dimensional contingency table
resulting from classifying applicants to graduate school at UC Berkeley
for the six largest departments in 1973 classified by admission and sex.

<pre class="example">     &gt; data(UCBAdmissions)
     &gt; ftable(UCBAdmissions)
                     Dept   A   B   C   D   E   F
     Admit    Gender
     Admitted Male        512 353 120 138  53  22
              Female       89  17 202 131  94  24
     Rejected Male        313 207 205 279 138 351
              Female       19   8 391 244 299 317
</pre>
   <p class="noindent">The printed representation is clearly more useful than displaying the
data as a 3-dimensional array.

   <p>There is also a function <code>read.ftable</code> for reading in flat-like
contingency tables from files. 
<a name="index-read_002eftable-45"></a>This has additional arguments for dealing with variants on how exactly
the information on row and column variables names and levels is
represented.  The help page for <code>read.ftable</code> has some useful
examples.  The flat tables can be converted to standard contingency
tables in array form using <code>as.table</code>.

   <p>Note that flat tables are characterized by their &ldquo;ragged&rdquo; display of
row (and maybe also column) labels.  If the full grid of levels of the
row variables is given, one should instead use <code>read.table</code> to read
in the data, and create the contingency table from this using
<code>xtabs</code>.

<div class="node">
<a name="Importing-from-other-statistical-systems"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Relational-databases">Relational databases</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Importing from other statistical systems</h2>

<p><a name="index-Importing-from-other-statistical-systems-46"></a>
In this chapter we consider the problem of reading a binary data file
written by another statistical system.  This is often best avoided, but
may be unavoidable if the originating system is not available.

   <p>In all cases the facilities described were written for data files from
specific versions of the other system (often in the early 2000s), and
have not necessarily been updated for the most recent versions of the
other system.

<ul class="menu">
<li><a accesskey="1" href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a>
<li><a accesskey="2" href="#Octave">Octave</a>
</ul>

<div class="node">
<a name="EpiInfo-Minitab-SAS-S-PLUS-SPSS-Stata-Systat"></a>
<a name="EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Octave">Octave</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Importing-from-other-statistical-systems">Importing from other statistical systems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Importing-from-other-statistical-systems">Importing from other statistical systems</a>

</div>

<h3 class="section">3.1 EpiInfo, Minitab, S-PLUS, SAS, SPSS, Stata, Systat</h3>

<p>The recommended package <a href="http://CRAN.R-project.org/package=foreign"><strong>foreign</strong></a> provides import facilities for
files produced by these statistical systems, and for export to Stata. In
some cases these functions may require substantially less memory than
<code>read.table</code> would. <code>write.foreign</code> (See <a href="#Export-to-text-files">Export to text files</a>) provides an export mechanism with support currently for
<code>SAS</code>, <code>SPSS</code> and <code>Stata</code>.

   <p><a name="index-EpiInfo-47"></a><a name="index-EpiData-48"></a><a name="index-read_002eepiinfo-49"></a>EpiInfo versions 5 and 6 stored data in a  self-describing fixed-width
text format. <code>read.epiinfo</code> will read these <samp><span class="file">.REC</span></samp> files into
an R data frame. EpiData also produces data in this format.

   <p><a name="index-Minitab-50"></a><a name="index-read_002emtp-51"></a>Function <code>read.mtp</code> imports a `Minitab Portable Worksheet'.  This
returns the components of the worksheet as an R list.

   <p><a name="index-SAS-52"></a><a name="index-read_002export-53"></a>Function <code>read.xport</code> reads a file in SAS Transport (XPORT) format
and return a list of data frames.  If SAS is available on your system,
function <code>read.ssd</code> can be used to create and run a SAS script that
saves a SAS permanent dataset (<samp><span class="file">.ssd</span></samp> or <samp><span class="file">.sas7bdat</span></samp>) in
Transport format.  It then calls <code>read.xport</code> to read the resulting
file.  (Package <a href="http://CRAN.R-project.org/package=Hmisc"><strong>Hmisc</strong></a> has a similar function <code>sas.get</code>, also
running SAS.)  For those without access to SAS but running on Windows,
the SAS System Viewer (a zero-cost download) can be used to open SAS
datasets and export them to e.g. <samp><span class="file">.csv</span></samp> format.

   <p><a name="index-S_002dPLUS-54"></a><a name="index-read_002eS-55"></a><a name="index-data_002erestore-56"></a>
Function <code>read.S</code> which can read binary objects produced by S-PLUS
3.x, 4.x or 2000 on (32-bit) Unix or Windows (and can read them on a
different OS).  This is able to read many but not all S objects: in
particular it can read vectors, matrices and data frames and lists
containing those.

   <p>Function <code>data.restore</code> reads S-PLUS data dumps (created by
<code>data.dump</code>) with the same restrictions (except that dumps from the
Alpha platform can also be read).  It should be possible to read data
dumps from S-PLUS 5.x and later written with <code>data.dump(oldStyle=T)</code>.

   <p>If you have access to S-PLUS, it is usually more reliable to <code>dump</code>
the object(s) in S-PLUS and <code>source</code> the dump file in R.  For
S-PLUS 5.x and later you may need to use <code>dump(..., oldStyle=T)</code>,
and to read in very large objects it may be preferable to use the dump
file as a batch script rather than use the <code>source</code> function.

   <p><a name="index-SPSS-57"></a><a name="index-SPSS-Data-Entry-58"></a><a name="index-read_002espss-59"></a>Function <code>read.spss</code> can read files created by the `save' and
`export' commands in <acronym>SPSS</acronym>.  It returns a list with one
component for each variable in the saved data set. <acronym>SPSS</acronym>
variables with value labels are optionally converted to R factors.

   <p><acronym>SPSS</acronym> Data Entry is an application for creating data entry
forms.  By default it creates data files with extra formatting
information that <code>read.spss</code> cannot handle, but it is possible to
export the data in an ordinary <acronym>SPSS</acronym> format.

   <p>Some third-party applications claim to produce data `in SPSS format' but
with differences in the formats: <code>read.spss</code> may or may not be able
to handle these.

   <p><a name="index-Stata-60"></a><a name="index-read_002edta-61"></a><a name="index-write_002edta-62"></a>Stata <samp><span class="file">.dta</span></samp> files are a binary file format. Files from versions 5
up to 11 of Stata can be read and written by functions <code>read.dta</code>
and <code>write.dta</code>.  Stata variables with value labels are optionally
converted to (and from) R factors.  Stata version 12 by default
writes `format-115 datasets': <code>read.dta</code> currently may not be able
to read those.

   <p><a name="index-Systat-63"></a><a name="index-read_002esystat-64"></a><code>read.systat</code> reads those Systat <code>SAVE</code> files that are
rectangular data files (<code>mtype = 1</code>) written on little-endian
machines (such as from Windows).  These have extension <samp><span class="file">.sys</span></samp>
or (more recently) <samp><span class="file">.syd</span></samp>.

<div class="node">
<a name="Octave"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Importing-from-other-statistical-systems">Importing from other statistical systems</a>

</div>

<h3 class="section">3.2 Octave</h3>

<p><a name="index-Octave-65"></a><a name="index-read_002eoctave-66"></a>
Octave is a numerical linear algebra system
(<a href="http://www.octave.org">http://www.octave.org</a>), and function <code>read.octave</code> in
package <a href="http://CRAN.R-project.org/package=foreign"><strong>foreign</strong></a> can read in files in Octave text data format
created using the Octave command <samp><span class="command">save -ascii</span></samp>, with support for
most of the common types of variables, including the standard atomic
(real and complex scalars, matrices, and N-d arrays, strings,
ranges, and boolean scalars and matrices) and recursive (structs, cells,
and lists) ones.

<div class="node">
<a name="Relational-databases"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Binary-files">Binary files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Importing-from-other-statistical-systems">Importing from other statistical systems</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Relational databases</h2>

<p><a name="index-Relational-databases-67"></a><a name="index-DBMS-68"></a>

<ul class="menu">
<li><a accesskey="1" href="#Why-use-a-database_003f">Why use a database?</a>
<li><a accesskey="2" href="#Overview-of-RDBMSs">Overview of RDBMSs</a>
<li><a accesskey="3" href="#R-interface-packages">R interface packages</a>
</ul>

<div class="node">
<a name="Why-use-a-database%3f"></a>
<a name="Why-use-a-database_003f"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Overview-of-RDBMSs">Overview of RDBMSs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Relational-databases">Relational databases</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Relational-databases">Relational databases</a>

</div>

<h3 class="section">4.1 Why use a database?</h3>

<p>There are limitations on the types of data that R handles well. 
Since all data being manipulated by R are resident in memory, and
several copies of the data can be created during execution of a
function, R is not well suited to extremely large data sets.  Data
objects that are more than a (few) hundred megabytes in size can cause
R to run out of memory, particularly on a 32-bit operating system.

   <p>R does not easily support concurrent access to data.  That is, if
more than one user is accessing, and perhaps updating, the same data,
the changes made by one user will not be visible to the others.

   <p>R does support persistence of data, in that you can save a data
object or an entire worksheet from one session and restore it at the
subsequent session, but the format of the stored data is specific to
R and not easily manipulated by other systems.

   <p>Database management systems (DBMSs) and, in particular, relational
DBMSs (RDBMSs) <em>are</em> designed to do all of these things well. 
Their strengths are

     <ol type=1 start=1>
<li>To provide fast access to selected parts of large databases.

     <li>Powerful ways to summarize and cross-tabulate columns in databases.

     <li>Store data in more organized ways than the rectangular grid model of
spreadsheets and R data frames.

     <li>Concurrent access from multiple clients running on multiple hosts while
enforcing security constraints on access to the data.

     <li>Ability to act as a server to a wide range of clients.
        </ol>

   <p>The sort of statistical applications for which DBMS might be used are to
extract a 10% sample of the data, to cross-tabulate data to produce a
multi-dimensional contingency table, and to extract data group by group
from a database for separate analysis.

   <p>Increasingly OSes are themselves making use of DBMSs for these reasons,
so it is nowadays likely that one will be already installed on your
(non-Windows) OS.  <a href="http://en.wikipedia.org/wiki/Akonadi">Akonadi</a>
is used by KDE4 to store personal information and uses MySQL.  Several
Mac OS X applications, including Mail and Address Book, use SQLite. 
<!-- http://www.actualtechnologies.com/sqlite_applications.php -->

<div class="node">
<a name="Overview-of-RDBMSs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#R-interface-packages">R interface packages</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Why-use-a-database_003f">Why use a database?</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Relational-databases">Relational databases</a>

</div>

<h3 class="section">4.2 Overview of RDBMSs</h3>

<p>Traditionally there had been large (and expensive) commercial RDBMSs
(<a href="http://www.informix.com">Informix</a>; <a href="http://www.oracle.com">Oracle</a>; <a href="http://www.sybase.com">Sybase</a>;
<a href="http://www.ibm.com/db2">IBM's DB2</a>;
<a href="http://www.microsoft.com/SQL/default.mspx">Microsoft <acronym>SQL</acronym> Server</a> on Windows) and academic and small-system databases (such as
MySQL, PostgreSQL, Microsoft Access, <small class="dots">...</small>), the former marked out by
much greater emphasis on data security features.  The line is blurring,
with the Open Source MySQL and PostgreSQL having more and more high-end
features, and free `express' versions being made available for the
commercial DBMSs.

   <p><a name="index-ODBC-69"></a><a name="index-Open-Database-Connectivity-70"></a>There are other commonly used data sources, including spreadsheets,
non-relational databases and even text files (possibly compressed). 
Open Database Connectivity (<acronym>ODBC</acronym>) is a standard to use all of
these data sources.  It originated on Windows (see
<a href="http://www.microsoft.com/data/odbc/">http://www.microsoft.com/data/odbc/</a>) but is also implemented on
Linux/Unix/Mac OS X.

   <p>All of the packages described later in this chapter provide clients to
client/server databases.  The database can reside on the same machine or
(more often) remotely.  There is an <acronym>ISO</acronym> standard (in fact
several: <acronym>SQL</acronym>92 is <acronym>ISO</acronym>/IEC 9075, also known as
<acronym>ANSI</acronym> X3.135-1992, and <acronym>SQL</acronym>99 is coming into use) for
an interface language called <acronym>SQL</acronym> (Structured Query Language,
sometimes pronounced `sequel': see Bowman <em>et al.</em> 1996 and Kline
and Kline 2001) which these DBMSs support to varying degrees.

<ul class="menu">
<li><a accesskey="1" href="#SQL-queries">SQL queries</a>
<li><a accesskey="2" href="#Data-types">Data types</a>
</ul>

<div class="node">
<a name="SQL-queries"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Data-types">Data types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overview-of-RDBMSs">Overview of RDBMSs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Overview-of-RDBMSs">Overview of RDBMSs</a>

</div>

<h4 class="subsection">4.2.1 <acronym>SQL</acronym> queries</h4>

<p><a name="index-SQL-queries-71"></a>
The more comprehensive R interfaces generate <acronym>SQL</acronym> behind the
scenes for common operations, but direct use of <acronym>SQL</acronym> is needed
for complex operations in all.  Conventionally <acronym>SQL</acronym> is written
in upper case, but many users will find it more convenient to use lower
case in the R interface functions.

   <p>A relational DBMS stores data as a database of <em>tables</em> (or
<em>relations</em>) which are rather similar to R data frames, in that
they are made up of <em>columns</em> or <em>fields</em> of one type
(numeric, character, date, currency, <small class="dots">...</small>) and <em>rows</em> or
<em>records</em> containing the observations for one entity.

   <p><acronym>SQL</acronym> `queries' are quite general operations on a relational
database.  The classical query is a SELECT statement of the type

<pre class="example">     SELECT State, Murder FROM USArrests WHERE Rape &gt; 30 ORDER BY Murder
     
     SELECT t.sch, c.meanses, t.sex, t.achieve
       FROM student as t, school as c WHERE t.sch = c.id
     
     SELECT sex, COUNT(*) FROM student GROUP BY sex
     
     SELECT sch, AVG(sestat) FROM student GROUP BY sch LIMIT 10
</pre>
   <p class="noindent">The first of these selects two columns from the R data frame
<code>USArrests</code> that has been copied across to a database table,
subsets on a third column and asks the results be sorted.  The second
performs a database <em>join</em> on two tables <code>student</code> and
<code>school</code> and returns four columns.  The third and fourth queries do
some cross-tabulation and return counts or averages.  (The five
aggregation functions are COUNT(*) and SUM, MAX, MIN and AVG, each
applied to a single column.)

   <p>SELECT queries use FROM to select the table, WHERE to specify a
condition for inclusion (or more than one condition separated by AND or
OR), and ORDER BY to sort the result.  Unlike data frames, rows in RDBMS
tables are best thought of as unordered, and without an ORDER BY
statement the ordering is indeterminate.  You can sort (in
lexicographical order) on more than one column by separating them by
commas.  Placing DESC after an ORDER BY puts the sort in descending
order.

   <p>SELECT DISTINCT queries will only return one copy of each distinct row
in the selected table.

   <p>The GROUP BY clause selects subgroups of the rows according to the
criterion.  If more than one column is specified (separated by commas)
then multi-way cross-classifications can be summarized by one of the
five aggregation functions.  A HAVING clause allows the select to
include or exclude groups depending on the aggregated value.

   <p>If the SELECT statement contains an ORDER BY statement that produces a
unique ordering, a LIMIT clause can be added to select (by number) a
contiguous block of output rows.  This can be useful to retrieve rows a
block at a time.  (It may not be reliable unless the ordering is unique,
as the LIMIT clause can be used to optimize the query.)

   <p>There are queries to create a table (CREATE TABLE, but usually one
copies a data frame to the database in these interfaces), INSERT or
DELETE or UPDATE data.  A table is destroyed by a DROP TABLE `query'.

   <p>Kline and Kline (2001) discuss the details of the implementation of SQL
in Microsoft SQL Server 2000, Oracle, MySQL and PostgreSQL.

<div class="node">
<a name="Data-types"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#SQL-queries">SQL queries</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Overview-of-RDBMSs">Overview of RDBMSs</a>

</div>

<h4 class="subsection">4.2.2 Data types</h4>

<p>Data can be stored in a database in various data types.  The range of
data types is DBMS-specific, but the <acronym>SQL</acronym> standard defines many
types, including the following that are widely implemented (often not by
the <acronym>SQL</acronym> name).

     <dl>
<dt><code>float(</code><var>p</var><code>)</code><dd>Real number, with optional precision.  Often called <code>real</code> or
<code>double</code> or <code>double precision</code>. 
<br><dt><code>integer</code><dd>32-bit integer.  Often called <code>int</code>. 
<br><dt><code>smallint</code><dd>16-bit integer
<br><dt><code>character(</code><var>n</var><code>)</code><dd>fixed-length character string.  Often called <code>char</code>. 
<br><dt><code>character varying(</code><var>n</var><code>)</code><dd>variable-length character string.  Often called <code>varchar</code>.  Almost
always has a limit of 255 chars. 
<br><dt><code>boolean</code><dd>true or false.  Sometimes called <code>bool</code> or <code>bit</code>. 
<br><dt><code>date</code><dd>calendar date
<br><dt><code>time</code><dd>time of day
<br><dt><code>timestamp</code><dd>date and time
</dl>

<p class="noindent">There are variants on <code>time</code> and <code>timestamp</code>, <code>with
timezone</code>.  Other types widely implemented are <code>text</code> and
<code>blob</code>, for large blocks of text and binary data, respectively.

   <p>The more comprehensive of the R interface packages hide the type
conversion issues from the user.

<div class="node">
<a name="R-interface-packages"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Overview-of-RDBMSs">Overview of RDBMSs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Relational-databases">Relational databases</a>

</div>

<h3 class="section">4.3 R interface packages</h3>

<p>There are several packages available on <acronym>CRAN</acronym> to help R
communicate with DBMSs.  They provide different levels of abstraction. 
Some provide means to copy whole data frames to and from databases.  All
have functions to select data within the database via <acronym>SQL</acronym>
queries, and to retrieve the result as a whole as a
data frame or in pieces (usually as groups of rows).

   <p>All except <a href="http://CRAN.R-project.org/package=RODBC"><strong>RODBC</strong></a> are tied to one DBMS, but there has been a
proposal for a unified `front-end' package <a href="http://CRAN.R-project.org/package=DBI"><strong>DBI</strong></a>
(<a href="http://developer.r-project.org/db">http://developer.r-project.org/db</a>) in conjunction with a
`back-end', the most developed of which is <a href="http://CRAN.R-project.org/package=RMySQL"><strong>RMySQL</strong></a>.  Also on
<acronym>CRAN</acronym> are the back-ends <a href="http://CRAN.R-project.org/package=ROracle"><strong>ROracle</strong></a>, <a href="http://CRAN.R-project.org/package=RPostgreSQL"><strong>RPostgreSQL</strong></a> and
<a href="http://CRAN.R-project.org/package=RSQLite"><strong>RSQLite</strong></a> (which works with the bundled DBMS <code>SQLite</code>,
<a href="http://www.sqlite.org">http://www.sqlite.org</a>),  <a href="http://CRAN.R-project.org/package=RJDBC"><strong>RJDBC</strong></a> (which uses Java and can
connect to any DBMS that has a JDBC driver) and <a href="http://CRAN.R-project.org/package=RpgSQL"><strong>RpgSQL</strong></a> (a
specialist interface to PostgreSQL built on top of <a href="http://CRAN.R-project.org/package=RJBDC"><strong>RJBDC</strong></a>).

   <p>The BioConductor project has updated <strong>RdbiPgSQL</strong> (formerly on
<acronym>CRAN</acronym> ca 2000), a first-generation interface to PostgreSQL.

   <p><strong>PL/R</strong> (<a href="http://www.joeconway.com/plr/"><code>http://www.joeconway.com/plr/</code></a>) is a project to embed R into
PostgreSQL.

   <p>Package <a href="http://CRAN.R-project.org/package=RMongo"><strong>RMongo</strong></a> provides an R interface to a Java client for
`MongoDB' (<a href="http://en.wikipedia.org/wiki/MongoDB">http://en.wikipedia.org/wiki/MongoDB</a>) databases, which
are queried using JavaScript rather than SQL.  Package <a href="http://CRAN.R-project.org/package=rmongodb"><strong>rmongodb</strong></a> is
another client using <strong>mongodb</strong>'s C driver.

<ul class="menu">
<li><a accesskey="1" href="#DBI">DBI</a>
<li><a accesskey="2" href="#RODBC">RODBC</a>
</ul>

<div class="node">
<a name="DBI"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#RODBC">RODBC</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#R-interface-packages">R interface packages</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-interface-packages">R interface packages</a>

</div>

<h4 class="subsection">4.3.1 Packages using DBI</h4>

<p><a name="index-MySQL-database-system-72"></a>
Package <a href="http://CRAN.R-project.org/package=RMySQL"><strong>RMySQL</strong></a> on <acronym>CRAN</acronym> provides an interface to the
MySQL database system (see <a href="http://www.mysql.com">http://www.mysql.com</a> and Dubois,
2000).  The description here applies to version <code>0.5-0</code>: earlier
versions had a substantially different interface.  The current version
requires the <a href="http://CRAN.R-project.org/package=DBI"><strong>DBI</strong></a> package, and this description will apply with
minor changes to all the other back-ends to <a href="http://CRAN.R-project.org/package=DBI"><strong>DBI</strong></a>.

   <p>MySQL exists on Unix/Linux/Mac OS X and Windows: there is a `Community
Edition' released under GPL but commercial licenses are also available. 
MySQL was originally a `light and lean' database.  (It preserves the
case of names where the operating file system is case-sensitive, so not
on Windows.)

   <p><a name="index-dbDriver-73"></a><a name="index-dbConnect-74"></a><a name="index-dbDisconnect-75"></a>The call <code>dbDriver("MySQL")</code> returns a database connection manager
object, and then a call to <code>dbConnect</code> opens a database connection
which can subsequently be closed by a call to the generic function
<code>dbDisconnect</code>.  Use <code>dbDriver("Oracle")</code>,
<code>dbDriver("PostgreSQL")</code> or <code>dbDriver("SQLite")</code> with those
DBMSs and packages <a href="http://CRAN.R-project.org/package=ROracle"><strong>ROracle</strong></a>, <a href="http://CRAN.R-project.org/package=RPostgreSQL"><strong>RPostgreSQL</strong></a> or <a href="http://CRAN.R-project.org/package=RSQLite"><strong>RSQLite</strong></a>
respectively.

   <p><a name="index-dbSendQuery-76"></a><a name="index-dbClearResult-77"></a><a name="index-dbGetQuery-78"></a><acronym>SQL</acronym> queries can be sent by either <code>dbSendQuery</code> or
<code>dbGetQuery</code>.  <code>dbGetquery</code> sends the query and retrieves the
results as a data frame.  <code>dbSendQuery</code> sends the query and returns
an object of class inheriting from <code>"DBIResult"</code> which can be used
to retrieve the results, and subsequently used in a call to
<code>dbClearResult</code> to remove the result.

   <p><a name="index-fetch-79"></a>Function <code>fetch</code> is used to retrieve some or all of the rows in the
query result, as a list.  The function <code>dbHasCompleted</code> indicates if
all the rows have been fetched, and <code>dbGetRowCount</code> returns the
number of rows in the result.

   <p><a name="index-dbReadTable-80"></a><a name="index-dbWriteTable-81"></a><a name="index-dbExistsTable-82"></a><a name="index-dbRemoveTable-83"></a>These are convenient interfaces to read/write/test/delete tables in the
database.  <code>dbReadTable</code> and <code>dbWriteTable</code> copy to and from
an R data frame, mapping the row names of the data frame to the field
<code>row_names</code> in the <code>MySQL</code> table.

<pre class="smallexample">     &gt; library(RMySQL) # will load DBI as well
     ## open a connection to a MySQL database
     &gt; con &lt;- dbConnect(dbDriver("MySQL"), dbname = "test")
     ## list the tables in the database
     &gt; dbListTables(con)
     ## load a data frame into the database, deleting any existing copy
     &gt; data(USArrests)
     &gt; dbWriteTable(con, "arrests", USArrests, overwrite = TRUE)
     TRUE
     &gt; dbListTables(con)
     [1] "arrests"
     ## get the whole table
     &gt; dbReadTable(con, "arrests")
                    Murder Assault UrbanPop Rape
     Alabama          13.2     236       58 21.2
     Alaska           10.0     263       48 44.5
     Arizona           8.1     294       80 31.0
     Arkansas          8.8     190       50 19.5
     ...
     ## Select from the loaded table
     &gt; dbGetQuery(con, paste("select row_names, Murder from arrests",
                             "where Rape &gt; 30 order by Murder"))
        row_names Murder
     1   Colorado    7.9
     2    Arizona    8.1
     3 California    9.0
     4     Alaska   10.0
     5 New Mexico   11.4
     6   Michigan   12.1
     7     Nevada   12.2
     8    Florida   15.4
     &gt; dbRemoveTable(con, "arrests")
     &gt; dbDisconnect(con)
</pre>
   <div class="node">
<a name="RODBC"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#DBI">DBI</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#R-interface-packages">R interface packages</a>

</div>

<h4 class="subsection">4.3.2 Package RODBC</h4>

<p><a name="index-ODBC-84"></a><a name="index-Open-Database-Connectivity-85"></a>
Package <a href="http://CRAN.R-project.org/package=RODBC"><strong>RODBC</strong></a> on <acronym>CRAN</acronym> provides an interface to database
sources supporting an <acronym>ODBC</acronym> interface.  This is very widely
available, and allows the same R code to access different database
systems.  <a href="http://CRAN.R-project.org/package=RODBC"><strong>RODBC</strong></a> runs on Unix/Linux, Windows and Mac OS X, and
almost all database systems provide support for <acronym>ODBC</acronym>.  We have
tested Microsoft SQL Server, Access, MySQL, PostgreSQL, Oracle and IBM
DB2 on Windows and MySQL, Oracle, PostgreSQL and SQLite on Linux.

   <p>ODBC is a client-server system, and we have happily connected to a DBMS
running on a Unix server from a Windows client, and <em>vice versa</em>.

   <p>On Windows ODBC support is part of the OS.  On Unix/Linux you will need
an <acronym>ODBC</acronym> Driver Manager such as unixODBC
(<a href="http://www.unixODBC.org">http://www.unixODBC.org</a>) or iOBDC (<a href="http://www.iODBC.org">http://www.iODBC.org</a>:
this is pre-installed in Mac OS X) and an installed driver for your
database system.

   <p><a name="index-Excel-86"></a><a name="index-g_t_002exls-87"></a><a name="index-Dbase-88"></a><a name="index-g_t_002edbf-89"></a>Windows provides drivers not just for DBMSs but also for Excel
(<samp><span class="file">.xls</span></samp>) spreadsheets, DBase (<samp><span class="file">.dbf</span></samp>) files and even text
files.  (The named applications do <em>not</em> need to be
installed. Which file formats are supported depends on the the versions
of the drivers.)  There are versions for Excel and Access 2007/2010 (go
to <a href="http://download.microsoft.com">http://download.microsoft.com</a>, and search for `Office ODBC',
which will lead to <samp><span class="file">AccessDatabaseEngine.exe</span></samp>), the `2007 Office
System Driver' (the latter has a version for 64-bit Windows, and that
will also read earlier versions).

   <p>On Mac OS X the Actual Technologies
(<a href="http://www.actualtechnologies.com/product_access.php">http://www.actualtechnologies.com/product_access.php</a>) drivers
provide ODBC interfaces to Access databases (including Access 2007/2010)
and to Excel spreadsheets (not including Excel 2007/2010).

   <p><a name="index-odbcConnect-90"></a><a name="index-odbcDriverConnect-91"></a><a name="index-odbcGetInfo-92"></a>Many simultaneous connections are possible.  A connection is opened by a
call to <code>odbcConnect</code> or <code>odbcDriverConnect</code> (which on the
Windows GUI allows a database to be selected via dialog boxes) which
returns a handle used for subsequent access to the database.  Printing a
connection will provide some details of the ODBC connection, and calling
<code>odbcGetInfo</code> will give details on the client and server.

   <p><a name="index-odbcClose-93"></a><a name="index-close-94"></a>A connection is closed by a call to <code>close</code> or <code>odbcClose</code>,
and also (with a warning) when not R object refers to it and at the end
of an R session.

   <p><a name="index-sqlTables-95"></a>Details of the tables on a connection can be found using
<code>sqlTables</code>.

   <p><a name="index-sqlFetch-96"></a><a name="index-sqlSave-97"></a>Function <code>sqlSave</code> copies an R data frame to a table in the
database, and <code>sqlFetch</code> copies a table in the database to an R
data frame.

   <p><a name="index-sqlQuery-98"></a><a name="index-sqlCopy-99"></a><a name="index-odbcQuery-100"></a><a name="index-sqlGetResults-101"></a><a name="index-sqlFetchMore-102"></a>An <acronym>SQL</acronym> query can be sent to the database by a call to
<code>sqlQuery</code>.  This returns the result in an R data frame. 
(<code>sqlCopy</code> sends a query to the database and saves the result as a
table in the database.)  A finer level of control is attained by first
calling <code>odbcQuery</code> and then <code>sqlGetResults</code> to fetch the
results.  The latter can be used within a loop to retrieve a limited
number of rows at a time, as can function <code>sqlFetchMore</code>.

   <p><a name="index-PostgreSQL-database-system-103"></a>Here is an example using PostgreSQL, for which the <acronym>ODBC</acronym> driver
maps column and data frame names to lower case.  We use a database
<code>testdb</code> we created earlier, and had the DSN (data source name) set
up in <samp><span class="file">~/.odbc.ini</span></samp> under <code>unixODBC</code>.  Exactly the same code
worked using MyODBC to access a MySQL database under Linux or Windows
(where MySQL also maps names to lowercase).  Under Windows,
<acronym>DSN</acronym>s are set up in the <acronym>ODBC</acronym> applet in the Control
Panel (`Data Sources (ODBC)' in the `Administrative Tools' section). 
<a name="index-MySQL-database-system-104"></a>
<pre class="smallexample">     &gt; library(RODBC)
     ## tell it to map names to l/case
     &gt; channel &lt;- odbcConnect("testdb", uid="ripley", case="tolower")
     ## load a data frame into the database
     &gt; data(USArrests)
     &gt; sqlSave(channel, USArrests, rownames = "state", addPK = TRUE)
     &gt; rm(USArrests)
     ## list the tables in the database
     &gt; sqlTables(channel)
       TABLE_QUALIFIER TABLE_OWNER TABLE_NAME TABLE_TYPE REMARKS
     1                              usarrests      TABLE
     ## list it
     &gt; sqlFetch(channel, "USArrests", rownames = "state")
                    murder assault urbanpop rape
     Alabama          13.2     236       58 21.2
     Alaska           10.0     263       48 44.5
         ...
     ## an SQL query, originally on one line
     &gt; sqlQuery(channel, "select state, murder from USArrests
                where rape &gt; 30 order by murder")
            state murder
     1 Colorado      7.9
     2 Arizona       8.1
     3 California    9.0
     4 Alaska       10.0
     5 New Mexico   11.4
     6 Michigan     12.1
     7 Nevada       12.2
     8 Florida      15.4
     ## remove the table
     &gt; sqlDrop(channel, "USArrests")
     ## close the connection
     &gt; odbcClose(channel)
</pre>
   <p><a name="index-Excel-105"></a><a name="index-g_t_002exls-106"></a><a name="index-odbcConnectExcel-107"></a>As a simple example of using <acronym>ODBC</acronym> under Windows with a Excel
spreadsheet, we can read from a spreadsheet by

<pre class="smallexample">     &gt; library(RODBC)
     &gt; channel &lt;- odbcConnectExcel("bdr.xls")
     ## list the spreadsheets
     &gt; sqlTables(channel)
       TABLE_CAT TABLE_SCHEM        TABLE_NAME   TABLE_TYPE REMARKS
     1 C:\\bdr            NA           Sheet1$ SYSTEM TABLE      NA
     2 C:\\bdr            NA           Sheet2$ SYSTEM TABLE      NA
     3 C:\\bdr            NA           Sheet3$ SYSTEM TABLE      NA
     4 C:\\bdr            NA Sheet1$Print_Area        TABLE      NA
     ## retrieve the contents of sheet 1, by either of
     &gt; sh1 &lt;- sqlFetch(channel, "Sheet1")
     &gt; sh1 &lt;- sqlQuery(channel, "select * from [Sheet1$]")
</pre>
   <p class="noindent">Notice that the specification of the table is different from the name
returned by <code>sqlTables</code>: <code>sqlFetch</code> is able to map the
differences.

<!-- @node RPgSQL,  , RODBC, R interface packages -->
<!-- @subsection Package RPgSQL -->
<!-- @cindex PostgreSQL database system -->
<!-- Package @pkg{RPgSQL} at @uref{http://rpgsql.sourceforge.net/} and in the -->
<!-- @code{Devel} area on @acronym{CRAN} provides an interface to -->
<!-- @uref{http://www.postgresql.org, PostgreSQL}.  Development appears to -->
<!-- have ceased. -->
<!-- PostgreSQL is described by its developers as `the most advanced open -->
<!-- source database server' (Momjian, 2000).  It would appear to be buildable -->
<!-- for most Unix-alike OSes and Windows (under Cygwin or U/Win). -->
<!-- PostgreSQL has most of the features of the commercial RDBMSs. -->
<!-- @findex db.connect -->
<!-- @findex db.read.table -->
<!-- @findex db.write.table -->
<!-- To make use of @pkg{RPgSQL}, first open a connection to a database using -->
<!-- @code{db.connect}.  (Currently only one connection can be open at a -->
<!-- time.)  Once a connection is open an @R{} data frame can be copied to a -->
<!-- PostgreSQL table by @code{db.write.table}, whereas @code{db.read.table} -->
<!-- copies a PostgreSQL table to an @R{} data frame. -->
<!-- @findex bind.db.proxy -->
<!-- @cindex proxy data frame -->
<!-- @pkg{RPgSQL} has the interesting concept of a @emph{proxy data frame}. -->
<!-- A data frame proxy is an @R{} object that inherits from the -->
<!-- @code{"data.frame"} class, but contains no data.  All accesses to the -->
<!-- proxy data frame generate the appropriate @acronym{SQL} query and -->
<!-- retrieve the resulting data from the database.  A proxy data frame is -->
<!-- set up by a call to @code{bind.db.proxy}.  To remove the proxy, just -->
<!-- remove the object which @code{bind.db.proxy} created. -->
<!-- @findex db.execute -->
<!-- @findex db.result.columns -->
<!-- @findex db.result.rows -->
<!-- @findex db.read.column -->
<!-- @findex db.fetch.result -->
<!-- @findex db.clear.result -->
<!-- @findex db.result.get.value -->
<!-- A finer level of control is available via sending @acronym{SQL} queries -->
<!-- to the PostgreSQL server via @code{db.execute}.  This leaves a result in -->
<!-- PostgreSQL's result cache, unless flushed by @code{clear = TRUE} (the -->
<!-- default).  Once a result is in the cache, @code{db.fetch.result} can be -->
<!-- used to fetch the whole result as a data frame.  Functions such as -->
<!-- @code{db.result.columns} and @code{db.result.rows} will report the -->
<!-- number of columns and rows in the cached table, and -->
<!-- @code{db.read.column} will fetch a single column (as a vector).  An -->
<!-- individual cell in the result can be read by @code{db.result.get.value}. -->
<!-- @code{db.clear.result} will clear the result cache. -->
<!-- @findex sql.insert -->
<!-- @findex sql.select -->
<!-- One disadvantage is that PostgreSQL maps all table and column names to -->
<!-- lower case, so for maximal flexibility, only use lower case in @R{} -->
<!-- names.  Functions @code{sql.insert} and @code{sql.select} provide -->
<!-- convenience wrappers for the INSERT and SELECT queries. -->
<!-- We can explore these functions in a simple example.  The database -->
<!-- @file{testdb} had already been set up, and as PostgreSQL was running on -->
<!-- a standalone machine no further authentication was required to connect. -->
<!-- @smallexample -->
<!-- > library(RPgSQL) -->
<!-- > db.connect(dbname="testdb")   # add authentication as needed -->
<!-- Connected to database "testdb" on "" -->
<!-- > data(USArrests) -->
<!-- > usarrests <- USArrests -->
<!-- > names(usarrests) <- tolower(names(USArrests)) -->
<!-- > db.write.table(USArrests, write.row.names = TRUE) -->
<!-- > db.write.table(usarrests, write.row.names = TRUE) -->
<!-- > rm(USArrests, usarrests) -->
<!-- ## db.ls lists tables in the database. -->
<!-- > db.ls() -->
<!-- [1] "USArrests"  "usarrests" -->
<!-- > db.read.table("USArrests") -->
<!-- Murder Assault UrbanPop Rape -->
<!-- Alabama          13.2     236       58 21.2 -->
<!-- Alaska           10.0     263       48 44.5 -->
<!-- ... -->
<!-- ## set up a proxy data frame.  Remember USArrests has been removed -->
<!-- > bind.db.proxy("USArrests") -->
<!-- ## USArrests is now a proxy, so all accesses are to the database -->
<!-- > USArrests[, "Rape"] -->
<!-- Rape -->
<!-- 1  21.2 -->
<!-- 2  44.5 -->
<!-- ... -->
<!-- > rm(USArrests) # remove proxy -->
<!-- > db.execute("SELECT rpgsql_row_names, murder FROM usarrests", -->
<!-- "WHERE rape > 30 ORDER BY murder", clear=FALSE) -->
<!-- > db.fetch.result() -->
<!-- murder -->
<!-- Colorado      7.9 -->
<!-- Arizona       8.1 -->
<!-- California    9.0 -->
<!-- Alaska       10.0 -->
<!-- New Mexico   11.4 -->
<!-- Michigan     12.1 -->
<!-- Nevada       12.2 -->
<!-- Florida      15.4 -->
<!-- > db.rm("USArrests", "usarrests") # use ask=FALSE to skip confirmation -->
<!-- Destroy table USArrests? y -->
<!-- Destroy table usarrests? y -->
<!-- > db.ls() -->
<!-- character(0) -->
<!-- > db.disconnect() -->
<!-- @end smallexample -->
<!-- @noindent -->
<!-- Notice how the row names are mapped if @code{write.row.names = TRUE} to -->
<!-- a field @code{rpgsql_row_names} in the database table and transparently -->
<!-- restored provided we preserve that field in the query. -->
<!-- @pkg{RPgSQL} provides means to extend its mapping between @R{} classes -->
<!-- within a data frame and PostgreSQL types. -->
<div class="node">
<a name="Binary-files"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Image-files">Image files</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Relational-databases">Relational databases</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Binary files</h2>

<p><a name="index-Binary-files-108"></a>

<ul class="menu">
<li><a accesskey="1" href="#Binary-data-formats">Binary data formats</a>
<li><a accesskey="2" href="#dBase-files-_0028DBF_0029">dBase files (DBF)</a>
</ul>

   <p>Binary connections (<a href="#Connections">Connections</a>) are now the preferred way to
handle binary files.

<div class="node">
<a name="Binary-data-formats"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#dBase-files-_0028DBF_0029">dBase files (DBF)</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Binary-files">Binary files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Binary-files">Binary files</a>

</div>

<h3 class="section">5.1 Binary data formats</h3>

<p><a name="index-hdf5-109"></a><a name="index-Hierarchical-Data-Format-110"></a>
<a name="index-netCDF-111"></a><a name="index-network-Common-Data-Form-112"></a>
Packages <a href="http://CRAN.R-project.org/package=hdf5"><strong>hdf5</strong></a>, <a href="http://CRAN.R-project.org/package=h5r"><strong>h5r</strong></a>, Bioconductor's <strong>rhdf5</strong>,
<a href="http://CRAN.R-project.org/package=RNetCDF"><strong>RNetCDF</strong></a>, <a href="http://CRAN.R-project.org/package=ncdf"><strong>ncdf</strong></a> and <a href="http://CRAN.R-project.org/package=ncdf4"><strong>ncdf4</strong></a> on <acronym>CRAN</acronym> provide
interfaces to <acronym>NASA</acronym>'s HDF5 (Hierarchical Data Format, see
<a href="http://hdf.ncsa.uiuc.edu/HDF5/">http://hdf.ncsa.uiuc.edu/HDF5/</a>) and to UCAR's netCDF data files
(network Common Data Form, see
<a href="http://www.unidata.ucar.edu/packages/netcdf/">http://www.unidata.ucar.edu/packages/netcdf/</a>).

   <p>Both of these are systems to store scientific data in array-oriented
ways, including descriptions, labels, formats, units, <small class="dots">...</small>.  HDF5 also
allows <em>groups</em> of arrays, and the R interface maps lists
to HDF5 groups, and can write numeric and character vectors and
matrices.

   <p>NetCDF's version 4 format (confusingly, implemented in netCDF 4.1.1 and
later, but not in 4.0.1) includes the use of various HDF5 formats.  This
is handled by package <a href="http://CRAN.R-project.org/package=ncdf4"><strong>ncdf4</strong></a> whereas <a href="http://CRAN.R-project.org/package=RNetCDF"><strong>RNetCDF</strong></a> and
<a href="http://CRAN.R-project.org/package=ncdf"><strong>ncdf</strong></a> handle version 3 files.

   <p>The availability of software to support these formats is somewhat
limited by platform, especially on Windows.

<div class="node">
<a name="dBase-files-(DBF)"></a>
<a name="dBase-files-_0028DBF_0029"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Binary-data-formats">Binary data formats</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Binary-files">Binary files</a>

</div>

<h3 class="section">5.2 dBase files (DBF)</h3>

<p><a name="index-dBase-113"></a><a name="index-DBF-files-114"></a><code>dBase</code> was a DOS program written by Ashton-Tate and later owned by
Borland which has a binary flat-file format that became popular, with
file extension <samp><span class="file">.dbf</span></samp>.  It has been adopted for the 'Xbase' family
of databases, covering dBase, Clipper, FoxPro and their Windows
equivalents Visual dBase, Visual Objects and Visual FoxPro (see
<a href="http://www.e-bachmann.dk/docs/xbase.htm">http://www.e-bachmann.dk/docs/xbase.htm</a>).  A dBase file contains
a header and then a series of fields and so is most similar to an R
data frame.  The data itself is stored in text format, and can include
character, logical and numeric fields, and other types in later versions
(see <a href="http://clicketyclick.dk/docs/data_types.html">http://clicketyclick.dk/docs/data_types.html</a>).

   <p><a name="index-read_002edbf-115"></a><a name="index-write_002edbf-116"></a>Functions <code>read.dbf</code> and <code>write.dbf</code> provide ways to read and
write basic DBF files on all R platforms.  For Windows users
<code>odbcConnectDbase</code> in package <a href="http://CRAN.R-project.org/package=RODBC"><strong>RODBC</strong></a> provides more
comprehensive facilities to read DBF files <em>via</em> Microsoft's dBase
ODBC driver (and the Visual FoxPro driver can also be used via
<code>odbcDriverConnect</code>). 
<a name="index-odbcConnectDbase-117"></a>
<div class="node">
<a name="Image-files"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Connections">Connections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Binary-files">Binary files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Image files</h2>

<p>A particular class of binary files are those representing images, and a
not uncommon request is to read such a file into R as a matrix.

   <p>There are many formats for image files (most with lots of variants), and
it may be necessary to use external conversion software to first convert
the image into one of the formats for which a package currently provides
an R reader.  A versatile example of such software is ImageMagick and
its fork GraphicsMagick.  These provide command-line programs
<samp><span class="command">convert</span></samp> and <samp><span class="command">gm convert</span></samp> to convert images from one
format to another: what formats they can input is determined when they
are compiled, and the supported formats can be listed by e.g. 
<samp><span class="command">convert -list format</span></samp>.

   <p>Package <a href="http://CRAN.R-project.org/package=pixmap"><strong>pixmap</strong></a> has a function <code>read.pnm</code> to read `portable
anymap' images in PBM (black/white), PGM (grey) and PPM (RGB colour)
formats.  These are also known as `netpbm' formats.

   <p>Packages <a href="http://CRAN.R-project.org/package=bmp"><strong>bmp</strong></a>, <a href="http://CRAN.R-project.org/package=jpeg"><strong>jpeg</strong></a> and <a href="http://CRAN.R-project.org/package=png"><strong>png</strong></a> read the
formats after which they are named.  See also packages <a href="http://CRAN.R-project.org/package=biOps"><strong>biOps</strong></a>
and <a href="http://CRAN.R-project.org/package=Momocs"><strong>Momocs</strong></a>, and Bioconductor package <strong>EBImage</strong>.

   <p>TIFF is more a meta-format, a wrapper within which a very large variety
of image formats can be embedded.  Packages <a href="http://CRAN.R-project.org/package=rtiff"><strong>rtiff</strong></a> and
<a href="http://CRAN.R-project.org/package=tiff"><strong>tiff</strong></a> can read some of the sub-formats (depending on the
external <code>libtiff</code> software against which they are compiled). 
There some facilities for specialized sub-formats, for example in
Bioconductor package <strong>beadarray</strong>.

   <p>Raster files are common in the geographical sciences, and package
<a href="http://CRAN.R-project.org/package=rgdal"><strong>rgdal</strong></a> provides an interface to GDAL which provides some
facilities of its own to read raster files and links to many others. 
Which formats it supports is determined when GDAL is compiled: use
<code>gdalDrivers()</code> to see what these are for the build you are using. 
It can be useful for uncommon formats such as JPEG 2000 (which is a
different format from JPEG, and not currently supported in the Mac OS X
nor Windows binary versions of <a href="http://CRAN.R-project.org/package=rgdal"><strong>rgdal</strong></a>).

<div class="node">
<a name="Connections"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Network-interfaces">Network interfaces</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Image-files">Image files</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Connections</h2>

<p><a name="index-Connections-118"></a><em>Connections</em> are used in R in the sense of Chambers (1998) and
Ripley (2001), a set of functions to replace the use of file names by a
flexible interface to file-like objects.

<ul class="menu">
<li><a accesskey="1" href="#Types-of-connections">Types of connections</a>
<li><a accesskey="2" href="#Output-to-connections">Output to connections</a>
<li><a accesskey="3" href="#Input-from-connections">Input from connections</a>
<li><a accesskey="4" href="#Listing-and-manipulating-connections">Listing and manipulating connections</a>
<li><a accesskey="5" href="#Binary-connections">Binary connections</a>
</ul>

<div class="node">
<a name="Types-of-connections"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Output-to-connections">Output to connections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Connections">Connections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Connections">Connections</a>

</div>

<h3 class="section">7.1 Types of connections</h3>

<p><a name="index-Connections-119"></a>
<a name="index-file-120"></a><a name="index-File-connections-121"></a>The most familiar type of connection will be a file, and file
connections are created by function <code>file</code>.  File connections can
(if the OS will allow it for the particular file) be opened for reading
or writing or appending, in text or binary mode.  In fact, files can be
opened for both reading and writing, and R keeps a separate file
position for reading and writing.

   <p><a name="index-open-122"></a><a name="index-close-123"></a>Note that by default a connection is not opened when it is created.  The
rule is that a function using a connection should open a connection
(needed) if the connection is not already open, and close a connection
after use if it opened it.  In brief, leave the connection in the state
you found it in.   There are generic functions <code>open</code> and
<code>close</code> with methods to explicitly open and close connections.

   <p><a name="index-gzfile-124"></a><a name="index-bzfile-125"></a><a name="index-Compressed-files-126"></a>Files compressed via the algorithm used by <code>gzip</code> can be used as
connections created by the function <code>gzfile</code>, whereas files
compressed by <code>bzip2</code> can be used via <code>bzfile</code>.

   <p><a name="index-Terminal-connections-127"></a><a name="index-stdin-128"></a><a name="index-stdout-129"></a><a name="index-stderr-130"></a>Unix programmers are used to dealing with special files <code>stdin</code>,
<code>stdout</code> and <code>stderr</code>.   These exist as <em>terminal
connections</em> in R.  They may be normal files, but they might also
refer to input from and output to a GUI console.  (Even with the standard
Unix R interface, <code>stdin</code> refers to the lines submitted from
<code>readline</code> rather than a file.)

   <p>The three terminal connections are always open, and cannot be opened or
closed.  <code>stdout</code> and <code>stderr</code> are conventionally used for
normal output and error messages respectively.  They may normally go to
the same place, but whereas normal output can be re-directed by a call
to <code>sink</code>, error output is sent to <code>stderr</code> unless re-directed
by <code>sink, type="message")</code>.  Note carefully the language used here:
the connections cannot be re-directed, but output can be sent to other
connections.

   <p><a name="index-Text-connections-131"></a><a name="index-textConnection-132"></a><em>Text connections</em> are another source of input.  They allow R
character vectors to be read as if the lines were being read from a text
file.  A text connection is created and opened by a call to
<code>textConnection</code>, which copies the current contents of the
character vector to an internal buffer at the time of creation.

   <p>Text connections can also be used to capture R output to a character
vector.  <code>textConnection</code> can be asked to create a new character
object or append to an existing one, in both cases in the user's
workspace.  The connection is opened by the call to
<code>textConnection</code>, and at all times the complete lines output to the
connection are available in the R object.  Closing the connection
writes any remaining output to a final element of the character vector.

   <p><a name="index-Pipe-connections-133"></a><a name="index-pipe-134"></a><em>Pipes</em> are a special form of file that connects to another
process, and pipe connections are created by the function <code>pipe</code>. 
Opening a pipe connection for writing (it makes no sense to append to a
pipe) runs an OS command, and connects its standard input to whatever
R then writes to that connection.  Conversely, opening a pipe
connection for input runs an OS command and makes its standard output
available for R input from that connection.

   <p><a name="index-URL-connections-135"></a><a name="index-url-136"></a><acronym>URL</acronym>s of types &lsquo;<samp><span class="samp">http://</span></samp>&rsquo;, &lsquo;<samp><span class="samp">ftp://</span></samp>&rsquo; and &lsquo;<samp><span class="samp">file://</span></samp>&rsquo;
can be read from using the function <code>url</code>.  For convenience,
<code>file</code> will also accept these as the file specification and call
<code>url</code>.

   <p><a name="index-Sockets-137"></a><a name="index-socketConnection-138"></a>Sockets can also be used as connections via function
<code>socketConnection</code> on platforms which support Berkeley-like sockets
(most Unix systems, Linux and Windows).  Sockets can be written to or
read from, and both client and server sockets can be used.

<div class="node">
<a name="Output-to-connections"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Input-from-connections">Input from connections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Types-of-connections">Types of connections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Connections">Connections</a>

</div>

<h3 class="section">7.2 Output to connections</h3>

<p><a name="index-Connections-139"></a>
<a name="index-cat-140"></a><a name="index-write-141"></a><a name="index-write_002etable-142"></a><a name="index-sink-143"></a>We have described functions <code>cat</code>, <code>write</code>, <code>write.table</code>
and <code>sink</code> as writing to a file, possibly appending to a file if
argument <code>append = TRUE</code>, and this is what they did prior to R
version 1.2.0.

   <p>The current behaviour is equivalent, but what actually happens is that
when the <code>file</code> argument is a character string, a file connection
is opened (for writing or appending) and closed again at the end of the
function call.  If we want to repeatedly write to the same file, it is
more efficient to explicitly declare and open the connection, and pass
the connection object to each call to an output function.  This also
makes it possible to write to pipes, which was implemented earlier in a
limited way via the syntax <code>file = "|cmd"</code> (which can still be
used).

   <p><a name="index-writeLines-144"></a>There is a function <code>writeLines</code> to write complete text lines
to a connection.

   <p>Some simple examples are

<pre class="example">     zz &lt;- file("ex.data", "w")  # open an output file connection
     cat("TITLE extra line", "2 3 5 7", "", "11 13 17",
         file = zz, sep = "\n")
     cat("One more line\n", file = zz)
     close(zz)
     
     ## convert decimal point to comma in output, using a pipe (Unix)
     ## both R strings and (probably) the shell need \ doubled
     zz &lt;- pipe(paste("sed s/\\\\./,/ &gt;", "outfile"), "w")
     cat(format(round(rnorm(100), 4)), sep = "\n", file = zz)
     close(zz)
     ## now look at the output file:
     file.show("outfile", delete.file = TRUE)
     
     ## capture R output: use examples from help(lm)
     zz &lt;- textConnection("ex.lm.out", "w")
     sink(zz)
     example(lm, prompt.echo = "&gt; ")
     sink()
     close(zz)
     ## now `ex.lm.out' contains the output for futher processing.
     ## Look at it by, e.g.,
     cat(ex.lm.out, sep = "\n")
</pre>
   <div class="node">
<a name="Input-from-connections"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Listing-and-manipulating-connections">Listing and manipulating connections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Output-to-connections">Output to connections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Connections">Connections</a>

</div>

<h3 class="section">7.3 Input from connections</h3>

<p><a name="index-scan-145"></a><a name="index-read_002etable-146"></a><a name="index-readLines-147"></a>The basic functions to read from connections are <code>scan</code> and
<code>readLines</code>.  These take a character string argument and open a
file connection for the duration of the function call, but explicitly
opening a file connection allows a file to be read sequentially in
different formats.

   <p>Other functions that call <code>scan</code> can also make use of connections,
in particular <code>read.table</code>.

   <p>Some simple examples are

<pre class="example">     ## read in file created in last examples
     readLines("ex.data")
     unlink("ex.data")
     
     ## read listing of current directory (Unix)
     readLines(pipe("ls -1"))
     
     # remove trailing commas from an input file.
     # Suppose we are given a file `data' containing
     450, 390, 467, 654,  30, 542, 334, 432, 421,
     357, 497, 493, 550, 549, 467, 575, 578, 342,
     446, 547, 534, 495, 979, 479
     # Then read this by
     scan(pipe("sed -e s/,$// data"), sep=",")
</pre>
   <p><a name="index-URL-connections-148"></a>For convenience, if the <code>file</code> argument specifies a FTP or HTTP
<acronym>URL</acronym>, the <acronym>URL</acronym> is opened for reading via <code>url</code>. 
Specifying files via &lsquo;<samp><span class="samp">file://foo.bar</span></samp>&rsquo; is also allowed.

<ul class="menu">
<li><a accesskey="1" href="#Pushback">Pushback</a>
</ul>

<div class="node">
<a name="Pushback"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Input-from-connections">Input from connections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Input-from-connections">Input from connections</a>

</div>

<h4 class="subsection">7.3.1 Pushback</h4>

<p><a name="index-pushBack_002e-149"></a><a name="index-Pushback-on-a-connection-150"></a>C programmers may be familiar with the <code>ungetc</code> function to push
back a character onto a text input stream.  R connections have the
same idea in a more powerful way, in that an (essentially) arbitrary
number of lines of text can be pushed back onto a connection via a call
to <code>pushBack</code>.

   <p>Pushbacks operate as a stack, so a read request first uses each line
from the most recently pushbacked text, then those from earlier
pushbacks and finally reads from the connection itself.  Once a
pushbacked line is read completely, it is cleared.  The number of
pending lines pushed back can be found via a call to
<code>pushBackLength</code>. 
<a name="index-pushBackLength-151"></a>
A simple example will show the idea.

<pre class="example">     &gt; zz &lt;- textConnection(LETTERS)
     &gt; readLines(zz, 2)
     [1] "A" "B"
     &gt; scan(zz, "", 4)
     Read 4 items
     [1] "C" "D" "E" "F"
     &gt; pushBack(c("aa", "bb"), zz)
     &gt; scan(zz, "", 4)
     Read 4 items
     [1] "aa" "bb" "G"  "H"
     &gt; close(zz)
</pre>
   <p>Pushback is only available for connections opened for input in text mode.

<div class="node">
<a name="Listing-and-manipulating-connections"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Binary-connections">Binary connections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Input-from-connections">Input from connections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Connections">Connections</a>

</div>

<h3 class="section">7.4 Listing and manipulating connections</h3>

<p><a name="index-Connections-152"></a>
<a name="index-showConnections-153"></a>A summary of all the connections currently opened by the user can be
found by <code>showConnections()</code>, and a summary of all connections,
including closed and terminal connections, by <code>showConnections(all
= TRUE)</code>

   <p><a name="index-seek-154"></a><a name="index-isSeekable-155"></a>The generic function <code>seek</code> can be used to read and (on some
connections) reset the current position for reading or writing. 
Unfortunately it depends on OS facilities which may be unreliable
(e.g. with text files under Windows).  Function <code>isSeekable</code>
reports if <code>seek</code> can change the position on the connection
given by its argument.

   <p><a name="index-truncate-156"></a>The function <code>truncate</code> can be used to truncate a file opened for
writing at its current position.  It works only for <code>file</code>
connections, and is not implemented on all platforms.

<div class="node">
<a name="Binary-connections"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Listing-and-manipulating-connections">Listing and manipulating connections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Connections">Connections</a>

</div>

<h3 class="section">7.5 Binary connections</h3>

<p><a name="index-Binary-files-157"></a>
<a name="index-readBin-158"></a><a name="index-writeBin-159"></a>Functions <code>readBin</code> and <code>writeBin</code> read to and write from
binary connections.  A connection is opened in binary mode by appending
<code>"b"</code> to the mode specification, that is using mode <code>"rb"</code> for
reading, and mode <code>"wb"</code> or <code>"ab"</code> (where appropriate) for
writing.  The functions have arguments

<pre class="example">     readBin(con, what, n = 1, size = NA, endian = .Platform$endian)
     writeBin(object, con, size = NA, endian = .Platform$endian)
</pre>
   <p>In each case <code>con</code> is a connection which will be opened if
necessary for the duration of the call, and if a character string is
given it is assumed to specify a file name.

   <p>It is slightly simpler to describe writing, so we will do that first. 
<code>object</code> should be an atomic vector object, that is a vector of
mode <code>numeric</code>, <code>integer</code>, <code>logical</code>, <code>character</code>,
<code>complex</code> or <code>raw</code>, without attributes.  By default this is
written to the file as a stream of bytes exactly as it is represented in
memory.

   <p><code>readBin</code> reads a stream of bytes from the file and interprets them
as a vector of mode given by <code>what</code>.  This can be either an object
of the appropriate mode (e.g. <code>what=integer()</code>) or a character
string describing the mode (one of the five given in the previous
paragraph or <code>"double"</code> or <code>"int"</code>).  Argument <code>n</code>
specifies the maximum number of vector elements to read from the
connection: if fewer are available a shorter vector will be returned. 
Argument <code>signed</code> allows 1-byte and 2-byte integers to be
read as signed (the default) or unsigned integers.

   <p>The remaining two arguments are used to write or read data for
interchange with another program or another platform.  By default binary
data is transferred directly from memory to the connection or <em>vice
versa</em>.  This will not suffice if the data are to be transferred to a
machine with a different architecture, but between almost all R
platforms the only change needed is that of byte-order.  Common PCs
(&lsquo;<samp><span class="samp">ix86</span></samp>&rsquo;-based and &lsquo;<samp><span class="samp">x86_64</span></samp>&rsquo;-based machines), Compaq Alpha
and Vaxen are <em>little-endian</em>, whereas Sun Sparc, mc680x0 series,
IBM R6000, SGI and most others are <em>big-endian</em>.  (Network
byte-order (as used by XDR, eXternal Data Representation) is
big-endian.)  To transfer to or from other programs we may need to do
more, for example to read 16-bit integers or write single-precision real
numbers.  This can be done using the <code>size</code> argument, which
(usually) allows sizes 1, 2, 4, 8 for integers and logicals, and sizes
4, 8 and perhaps 12 or 16 for reals.  Transferring at different sizes
can lose precision, and should not be attempted for vectors containing
<code>NA</code>'s.

   <p><a name="index-readChar-160"></a><a name="index-writeChar-161"></a>Character strings are read and written in C format, that is as a string
of bytes terminated by a zero byte.  Functions <code>readChar</code> and
<code>writeChar</code> provide greater flexibility.

<ul class="menu">
<li><a accesskey="1" href="#Special-values">Special values</a>
</ul>

<div class="node">
<a name="Special-values"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Binary-connections">Binary connections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Binary-connections">Binary connections</a>

</div>

<h4 class="subsection">7.5.1 Special values</h4>

<p>Functions <code>readBin</code> and <code>writeBin</code> will pass missing and
special values, although this should not be attempted if a size change
is involved.

   <p>The missing value for R logical and integer types is <code>INT_MIN</code>,
the smallest representable <code>int</code> defined in the C header
<samp><span class="file">limits.h</span></samp>, normally corresponding to the bit pattern
<code>0x80000000</code>.

   <p>The representation of the special values for R numeric and complex
types is machine-dependent, and possibly also compiler-dependent.  The
simplest way to make use of them is to link an external application
against the standalone <code>Rmath</code> library which exports double
constants <code>NA_REAL</code>, <code>R_PosInf</code> and <code>R_NegInf</code>, and
include the header <samp><span class="file">Rmath.h</span></samp> which defines the macros <code>ISNAN</code>
and <code>R_FINITE</code>.

   <p>If that is not possible, on all current platforms IEC 60559 (aka IEEE
754) arithmetic is used, so standard C facilities can be used to test
for or set <code>Inf</code>, <code>-Inf</code> and <code>NaN</code> values.  On such
platforms <code>NA</code> is represented by the <code>NaN</code> value with low-word
<code>0x7a2</code> (1954 in decimal).

   <p>Character missing values are written as <code>NA</code>, and there are no
provision to recognize character values as missing (as this can be done
by re-assigning them once read).

<div class="node">
<a name="Network-interfaces"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Connections">Connections</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Network interfaces</h2>

<ul class="menu">
<li><a accesskey="1" href="#Reading-from-sockets">Reading from sockets</a>
<li><a accesskey="2" href="#Using-download_002efile">Using download.file</a>
<li><a accesskey="3" href="#CORBA-interface">CORBA interface</a>
</ul>

<p>Some limited facilities are available to exchange data at a lower level
across network connections.

<div class="node">
<a name="Reading-from-sockets"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-download_002efile">Using download.file</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Network-interfaces">Network interfaces</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Network-interfaces">Network interfaces</a>

</div>

<h3 class="section">8.1 Reading from sockets</h3>

<p><a name="index-Sockets-162"></a>Base R comes with some facilities to communicate <em>via</em>
<acronym>BSD</acronym> sockets on systems that support them (including the common
Linux, Unix and Windows ports of R).  One potential problem with
using sockets is that these facilities are often blocked for security
reasons or to force the use of Web caches, so these functions may be
more useful on an intranet than externally.  For new projects it
is suggested that socket connections are used instead.

   <p><a name="index-make_002esocket-163"></a><a name="index-read_002esocket-164"></a><a name="index-write_002esocket-165"></a><a name="index-close_002esocket-166"></a>The earlier low-level interface is given by functions <code>make.socket</code>,
<code>read.socket</code>, <code>write.socket</code> and <code>close.socket</code>.

<div class="node">
<a name="Using-download.file"></a>
<a name="Using-download_002efile"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#CORBA-interface">CORBA interface</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reading-from-sockets">Reading from sockets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Network-interfaces">Network interfaces</a>

</div>

<h3 class="section">8.2 Using <code>download.file</code></h3>

<p>Function <code>download.file</code> is provided to read a file from a
Web resource via FTP or HTTP and write it to a file.  Often this can be
avoided, as functions such as <code>read.table</code> and <code>scan</code> can read
directly from a URL, either by explicitly using <code>url</code> to open a
connection, or implicitly using it by giving a URL as the <code>file</code>
argument.

<div class="node">
<a name="CORBA-interface"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-download_002efile">Using download.file</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Network-interfaces">Network interfaces</a>

</div>

<h3 class="section">8.3 <acronym>CORBA</acronym> interface</h3>

<p><a name="index-CORBA-167"></a>
<acronym>CORBA</acronym> (Common Object Request Broker Architecture) is similar
to <acronym>DCOM</acronym>, allowing applications to call methods, or operations,
in server objects running in other applications, potentially programmed
in different languages and running on different machines.  There is a
<strong>CORBA</strong> package available from the Omegahat project (at
<a href="http://www.omegahat.org/RSCORBA/">http://www.omegahat.org/RSCORBA/</a>), currently for Unix but a
Windows version looks to be possible.

   <p>This package allows R commands to be used to locate available
<acronym>CORBA</acronym> servers, query the methods they provide, and dynamically
invoke methods on these objects.  R values given as arguments in
these calls are exported in the call and made available to that
operation invocation.  Primitive data types (vectors and lists) are
exported by default, while more complex objects are exported by
reference.  Examples of using this include communicating with the
Gnumeric (<a href="http://www.gnumeric.org">http://www.gnumeric.org</a>) spreadsheet, and also
interacting with the data visualization system
<a href="http://www.ggobi.org">ggobi</a>.

   <p>One can also create <acronym>CORBA</acronym> servers within R, allowing other
applications to call these methods.  For example, one might offer access
to a particular dataset or to some of R's modelling software.  This
is done dynamically by combining R data objects and functions.  This
allows one to explicitly export data and functionality from R.

   <p>One can also use the <strong>CORBA</strong> package to achieve distributed,
parallel computing in R.  One R session acts as a manager and
dispatches tasks to different servers running in other R worker
sessions.  This uses the ability to invoke asynchronous or background
CORBA calls in R.  More information is available from the Omegahat
project at <a href="http://www.omegahat.org/RSCORBA/">http://www.omegahat.org/RSCORBA/</a>.

<div class="node">
<a name="Reading-Excel-spreadsheets"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#References">References</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Network-interfaces">Network interfaces</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Reading Excel spreadsheets</h2>

<p>The most common R data import/export question seems to be `how do I read
an Excel spreadsheet'.  This chapter collects together advice and
options given earlier.  Note that most of the advice is for pre-Excel
2007 spreadsheets and not the later <samp><span class="file">.xlsx</span></samp> format.

   <p><a name="index-read_002ecsv-168"></a><a name="index-read_002edelim-169"></a><a name="index-read_002eDIF-170"></a><a name="index-read_002etable-171"></a><a name="index-readClipboard-172"></a>The first piece of advice is to avoid doing so if possible!  If you have
access to Excel, export the data you want from Excel in tab-delimited or
comma-separated form, and use <code>read.delim</code> or <code>read.csv</code> to
import it into R.  (You may need to use <code>read.delim2</code> or
<code>read.csv2</code> in a locale that uses comma as the decimal point.) 
Exporting a DIF file and reading it using <code>read.DIF</code> is another
possibility.

   <p>If you do not have Excel, many other programs are able to read such
spreadsheets and export in a text format on both Windows and Unix, for
example Gnumeric (<a href="http://www.gnome.org/projects/gnumeric/">http://www.gnome.org/projects/gnumeric/</a>) and
OpenOffice (<a href="http://www.openoffice.org">http://www.openoffice.org</a>).  You can also
cut-and-paste between the display of a spreadsheet in such a program and
R: <code>read.table</code> will read from the R console or, under Windows,
from the clipboard (via <code>file = "clipboard"</code> or
<code>readClipboard</code>).  The <code>read.DIF</code> function can also read from
the clipboard.

   <p>Note that an Excel <samp><span class="file">.xls</span></samp> file is not just a spreadsheet: such
files can contain many sheets, and the sheets can contain formulae,
macros and so on.  Not all readers can read other than the first sheet,
and may be confused by other contents of the file.

   <p><a name="index-odbcConnectExcel-173"></a><a name="index-odbcConnectExcel2007-174"></a>Windows users (of 32-bit R) can use <code>odbcConnectExcel</code> in
package <a href="http://CRAN.R-project.org/package=RODBC"><strong>RODBC</strong></a>.  This can select rows and columns from any of the
sheets in an Excel spreadsheet file (at least from Excel 97&ndash;2003,
depending on your ODBC drivers: by calling <code>odbcConnect</code> directly
versions back to Excel 3.0 can be read).  The version
<code>odbcConnectExcel2007</code> will read the Excel 2007 formats as well as
earlier ones (provided the drivers are installed, including with 64-bit
Windows R: see <a href="#RODBC">RODBC</a>).  Mac users can also use <a href="http://CRAN.R-project.org/package=RODBC"><strong>RODBC</strong></a> if
they have a suitable driver (e.g. that from Actual Technologies).

   <p><a name="index-read_002exls-175"></a><code>Perl</code> users have contributed a module
<code>OLE::SpreadSheet::ParseExcel</code> and a program <code>xls2csv.pl</code> to
convert Excel 95&ndash;2003 spreadsheets to CSV files.  Package <a href="http://CRAN.R-project.org/package=gdata"><strong>gdata</strong></a>
provides a basic wrapper in its <code>read.xls</code> function.  With suitable
<code>Perl</code> modules installed this function can also read Excel 2007
spreadsheets.

   <p><a name="index-xlsReadWrite-176"></a>32-bit Windows package <a href="http://CRAN.R-project.org/package=xlsReadWrite"><strong>xlsReadWrite</strong></a> from
<a href="http://www.swissr.org/">http://www.swissr.org/</a> and CRAN has a function <code>read.xls</code> to
read <samp><span class="file">.xls</span></samp> files (based on a third-party non-Open-Source Delphi
component).

   <p><a name="index-dataframes2xls-177"></a><a name="index-WriteXLS-178"></a>Packages <a href="http://CRAN.R-project.org/package=dataframes2xls"><strong>dataframes2xls</strong></a> and <a href="http://CRAN.R-project.org/package=WriteXLS"><strong>WriteXLS</strong></a> each contain a function
to <em>write</em> one or more data frames to an <samp><span class="file">.xls</span></samp> file, using
Python and Perl respectively.  Another version of <code>write.xls</code> in
available in package <a href="http://CRAN.R-project.org/package=xlsReadWrite"><strong>xlsReadWrite</strong></a>.

   <p><a name="index-xlsx-179"></a><a name="index-RExcelXML-180"></a>Two packages which can read and and manipulate Excel 2007/10
spreadsheets but not earlier formats are <a href="http://CRAN.R-project.org/package=xlsx"><strong>xlsx</strong></a> (which requires
Java) and the Omegahat package <strong>RExcelXML</strong>.

   <p><a name="index-XLConnect-181"></a>Package <a href="http://CRAN.R-project.org/package=XLConnect"><strong>XLConnect</strong></a> can read, write and manipulate both Excel
97&ndash;2003 and Excel 2007/10 spreadsheets, requiring Java.

<div class="node">
<a name="References"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Function-and-variable-index">Function and variable index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix A References</h2>

<p class="noindent">R. A. Becker, J. M. Chambers and A. R. Wilks (1988)
<em>The New S Language.  A Programming Environment for Data Analysis
and Graphics.</em>  Wadsworth &amp; Brooks/Cole.

<p class="noindent">J. Bowman, S. Emberson and M. Darnovsky (1996) <em>The
Practical <acronym>SQL</acronym> Handbook.  Using Structured Query Language.</em>
Addison-Wesley.

<p class="noindent">J. M. Chambers (1998) <em>Programming with Data.  A Guide to the S
Language.</em> Springer-Verlag.

<p class="noindent">P. Dubois (2000) <em>MySQL.</em> New Riders.

<p class="noindent">M. Henning and S. Vinoski (1999) <em>Advanced CORBA Programming
with C++.</em> Addison-Wesley.

<p class="noindent">K. Kline and D. Kline (2001) <em>SQL in a Nutshell.</em> O'Reilly.

<p class="noindent">B. Momjian (2000) <em>PostgreSQL: Introduction and Concepts.</em>
Addison-Wesley. 
Also downloadable at <a href="http://www.postgresql.org/docs/awbook.html">http://www.postgresql.org/docs/awbook.html</a>.

<p class="noindent">B. D. Ripley (2001) Connections. \<em>R News</em>, <strong>1/1</strong>, 16&ndash;7. 
  \<a href="http://www.r-project.org/doc/Rnews/Rnews_2001-1.pdf">http://www.r-project.org/doc/Rnews/Rnews_2001-1.pdf</a>

<p class="noindent">T. M. Therneau and P. M. Grambsch (2000) <em>Modeling Survival
Data.  Extending the Cox Model.</em> Springer-Verlag.

<p class="noindent">E. J. Yarger, G. Reese and T. King (1999) <em>MySQL &amp; mSQL</em>. 
O'Reilly.

<div class="node">
<a name="Function-and-variable-index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Concept-index">Concept index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#References">References</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Function and variable index</h2>

<ul class="index-vr" compact>
<li><a href="#index-bzfile-125"><code>bzfile</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-cat-140"><code>cat</code></a>: <a href="#Output-to-connections">Output to connections</a></li>
<li><a href="#index-cat-4"><code>cat</code></a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-close-123"><code>close</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-close-94"><code>close</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-close_002esocket-166"><code>close.socket</code></a>: <a href="#Reading-from-sockets">Reading from sockets</a></li>
<li><a href="#index-count_002efields-30"><code>count.fields</code></a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-dataframes2xls-177"><code>dataframes2xls</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-data_002erestore-56"><code>data.restore</code></a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-dbClearResult-77"><code>dbClearResult</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-dbConnect-74"><code>dbConnect</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-dbDisconnect-75"><code>dbDisconnect</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-dbDriver-73"><code>dbDriver</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-dbExistsTable-82"><code>dbExistsTable</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-g_t_002edbf-89"><code>.dbf</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-dbGetQuery-78"><code>dbGetQuery</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-dbReadTable-80"><code>dbReadTable</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-dbRemoveTable-83"><code>dbRemoveTable</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-dbSendQuery-76"><code>dbSendQuery</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-dbWriteTable-81"><code>dbWriteTable</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-fetch-79"><code>fetch</code></a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-file-120"><code>file</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-format-7"><code>format</code></a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-ftable-44"><code>ftable</code></a>: <a href="#Flat-contingency-tables">Flat contingency tables</a></li>
<li><a href="#index-gzfile-124"><code>gzfile</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-hdf5-109"><code>hdf5</code></a>: <a href="#Binary-data-formats">Binary data formats</a></li>
<li><a href="#index-isSeekable-155"><code>isSeekable</code></a>: <a href="#Listing-and-manipulating-connections">Listing and manipulating connections</a></li>
<li><a href="#index-make_002esocket-163"><code>make.socket</code></a>: <a href="#Reading-from-sockets">Reading from sockets</a></li>
<li><a href="#index-netCDF-111"><code>netCDF</code></a>: <a href="#Binary-data-formats">Binary data formats</a></li>
<li><a href="#index-odbcClose-93"><code>odbcClose</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-odbcConnect-90"><code>odbcConnect</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-odbcConnectDbase-117"><code>odbcConnectDbase</code></a>: <a href="#dBase-files-_0028DBF_0029">dBase files (DBF)</a></li>
<li><a href="#index-odbcConnectExcel-173"><code>odbcConnectExcel</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-odbcConnectExcel-107"><code>odbcConnectExcel</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-odbcConnectExcel2007-174"><code>odbcConnectExcel2007</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-odbcDriverConnect-91"><code>odbcDriverConnect</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-odbcGetInfo-92"><code>odbcGetInfo</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-odbcQuery-100"><code>odbcQuery</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-open-122"><code>open</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-pipe-134"><code>pipe</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-pushBack_002e-149"><code>pushBack.</code></a>: <a href="#Pushback">Pushback</a></li>
<li><a href="#index-pushBackLength-151"><code>pushBackLength</code></a>: <a href="#Pushback">Pushback</a></li>
<li><a href="#index-readBin-158"><code>readBin</code></a>: <a href="#Binary-connections">Binary connections</a></li>
<li><a href="#index-readChar-160"><code>readChar</code></a>: <a href="#Binary-connections">Binary connections</a></li>
<li><a href="#index-readClipboard-172"><code>readClipboard</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-read_002ecsv-168"><code>read.csv</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-read_002ecsv-23"><code>read.csv</code></a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-read_002ecsv2-24"><code>read.csv2</code></a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-read_002edbf-115"><code>read.dbf</code></a>: <a href="#dBase-files-_0028DBF_0029">dBase files (DBF)</a></li>
<li><a href="#index-read_002edelim-169"><code>read.delim</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-read_002edelim-25"><code>read.delim</code></a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-read_002edelim2-26"><code>read.delim2</code></a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-read_002eDIF-170"><code>read.DIF</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-read_002eDIF-36"><code>read.DIF</code></a>: <a href="#Data-Interchange-Format-_0028DIF_0029">Data Interchange Format (DIF)</a></li>
<li><a href="#index-read_002edta-61"><code>read.dta</code></a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-read_002eepiinfo-49"><code>read.epiinfo</code></a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-read_002efortran-34"><code>read.fortran</code></a>: <a href="#Fixed_002dwidth_002dformat-files">Fixed-width-format files</a></li>
<li><a href="#index-read_002eftable-45"><code>read.ftable</code></a>: <a href="#Flat-contingency-tables">Flat contingency tables</a></li>
<li><a href="#index-read_002efwf-32"><code>read.fwf</code></a>: <a href="#Fixed_002dwidth_002dformat-files">Fixed-width-format files</a></li>
<li><a href="#index-readLines-147"><code>readLines</code></a>: <a href="#Input-from-connections">Input from connections</a></li>
<li><a href="#index-readLines-38"><code>readLines</code></a>: <a href="#Using-scan-directly">Using scan directly</a></li>
<li><a href="#index-read_002emtp-51"><code>read.mtp</code></a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-read_002eoctave-66"><code>read.octave</code></a>: <a href="#Octave">Octave</a></li>
<li><a href="#index-read_002eS-55"><code>read.S</code></a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-read_002esocket-164"><code>read.socket</code></a>: <a href="#Reading-from-sockets">Reading from sockets</a></li>
<li><a href="#index-read_002espss-59"><code>read.spss</code></a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-read_002esystat-64"><code>read.systat</code></a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-read_002etable-171"><code>read.table</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-read_002etable-146"><code>read.table</code></a>: <a href="#Input-from-connections">Input from connections</a></li>
<li><a href="#index-read_002etable-20"><code>read.table</code></a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-read_002exls-175"><code>read.xls</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-read_002export-53"><code>read.xport</code></a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-reshape-42"><code>reshape</code></a>: <a href="#Re_002dshaping-data">Re-shaping data</a></li>
<li><a href="#index-RExcelXML-180"><code>RExcelXML</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-scan-145"><code>scan</code></a>: <a href="#Input-from-connections">Input from connections</a></li>
<li><a href="#index-scan-37"><code>scan</code></a>: <a href="#Using-scan-directly">Using scan directly</a></li>
<li><a href="#index-scan-1"><code>scan</code></a>: <a href="#Imports">Imports</a></li>
<li><a href="#index-seek-154"><code>seek</code></a>: <a href="#Listing-and-manipulating-connections">Listing and manipulating connections</a></li>
<li><a href="#index-showConnections-153"><code>showConnections</code></a>: <a href="#Listing-and-manipulating-connections">Listing and manipulating connections</a></li>
<li><a href="#index-sink-143"><code>sink</code></a>: <a href="#Output-to-connections">Output to connections</a></li>
<li><a href="#index-sink-16"><code>sink</code></a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-socketConnection-138"><code>socketConnection</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-sqlCopy-99"><code>sqlCopy</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-sqlFetch-96"><code>sqlFetch</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-sqlFetchMore-102"><code>sqlFetchMore</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-sqlGetResults-101"><code>sqlGetResults</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-sqlQuery-98"><code>sqlQuery</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-sqlSave-97"><code>sqlSave</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-sqlTables-95"><code>sqlTables</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-stack-40"><code>stack</code></a>: <a href="#Re_002dshaping-data">Re-shaping data</a></li>
<li><a href="#index-stderr-130"><code>stderr</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-stdin-128"><code>stdin</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-stdout-129"><code>stdout</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-Sys_002elocaleconv-28"><code>Sys.localeconv</code></a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-textConnection-132"><code>textConnection</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-truncate-156"><code>truncate</code></a>: <a href="#Listing-and-manipulating-connections">Listing and manipulating connections</a></li>
<li><a href="#index-unstack_002e-41"><code>unstack.</code></a>: <a href="#Re_002dshaping-data">Re-shaping data</a></li>
<li><a href="#index-url-136"><code>url</code></a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-write-141"><code>write</code></a>: <a href="#Output-to-connections">Output to connections</a></li>
<li><a href="#index-write-5"><code>write</code></a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-writeBin-159"><code>writeBin</code></a>: <a href="#Binary-connections">Binary connections</a></li>
<li><a href="#index-writeChar-161"><code>writeChar</code></a>: <a href="#Binary-connections">Binary connections</a></li>
<li><a href="#index-write_002ecsv-10"><code>write.csv</code></a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-write_002ecsv2-11"><code>write.csv2</code></a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-write_002edbf-116"><code>write.dbf</code></a>: <a href="#dBase-files-_0028DBF_0029">dBase files (DBF)</a></li>
<li><a href="#index-write_002edta-62"><code>write.dta</code></a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-write_002eforeign-17"><code>write.foreign</code></a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-writeLines-144"><code>writeLines</code></a>: <a href="#Output-to-connections">Output to connections</a></li>
<li><a href="#index-write_002ematrix-15"><code>write.matrix</code></a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-write_002esocket-165"><code>write.socket</code></a>: <a href="#Reading-from-sockets">Reading from sockets</a></li>
<li><a href="#index-write_002etable-142"><code>write.table</code></a>: <a href="#Output-to-connections">Output to connections</a></li>
<li><a href="#index-write_002etable-6"><code>write.table</code></a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-WriteXLS-178"><code>WriteXLS</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-XLConnect-181"><code>XLConnect</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-g_t_002exls-87"><code>.xls</code></a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-xlsReadWrite-176"><code>xlsReadWrite</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
<li><a href="#index-xlsx-179"><code>xlsx</code></a>: <a href="#Reading-Excel-spreadsheets">Reading Excel spreadsheets</a></li>
   </ul><div class="node">
<a name="Concept-index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Function-and-variable-index">Function and variable index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Concept index</h2>



<ul class="index-cp" compact>
<li><a href="#index-Binary-files-157">Binary files</a>: <a href="#Binary-connections">Binary connections</a></li>
<li><a href="#index-Binary-files-108">Binary files</a>: <a href="#Binary-files">Binary files</a></li>
<li><a href="#index-comma-separated-values-9">comma separated values</a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-Compressed-files-126">Compressed files</a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-Connections-152">Connections</a>: <a href="#Listing-and-manipulating-connections">Listing and manipulating connections</a></li>
<li><a href="#index-Connections-139">Connections</a>: <a href="#Output-to-connections">Output to connections</a></li>
<li><a href="#index-Connections-119">Connections</a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-Connections-118">Connections</a>: <a href="#Connections">Connections</a></li>
<li><a href="#index-CORBA-167">CORBA</a>: <a href="#CORBA-interface">CORBA interface</a></li>
<li><a href="#index-CSV-files-27">CSV files</a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-CSV-files-8">CSV files</a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-Data-Interchange-Format-_0028DIF_0029-35">Data Interchange Format (DIF)</a>: <a href="#Data-Interchange-Format-_0028DIF_0029">Data Interchange Format (DIF)</a></li>
<li><a href="#index-Dbase-88">Dbase</a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-dBase-113">dBase</a>: <a href="#dBase-files-_0028DBF_0029">dBase files (DBF)</a></li>
<li><a href="#index-DBF-files-114">DBF files</a>: <a href="#dBase-files-_0028DBF_0029">dBase files (DBF)</a></li>
<li><a href="#index-DBMS-68">DBMS</a>: <a href="#Relational-databases">Relational databases</a></li>
<li><a href="#index-Encodings-14">Encodings</a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-Encodings-2">Encodings</a>: <a href="#Encodings">Encodings</a></li>
<li><a href="#index-EpiData-48">EpiData</a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-EpiInfo-47">EpiInfo</a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-Excel-86">Excel</a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-Exporting-to-a-text-file-3">Exporting to a text file</a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-File-connections-121">File connections</a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-Fixed_002dwidth_002dformat-files-31">Fixed-width-format files</a>: <a href="#Fixed_002dwidth_002dformat-files">Fixed-width-format files</a></li>
<li><a href="#index-Flat-contingency-tables-43">Flat contingency tables</a>: <a href="#Flat-contingency-tables">Flat contingency tables</a></li>
<li><a href="#index-Hierarchical-Data-Format-110">Hierarchical Data Format</a>: <a href="#Binary-data-formats">Binary data formats</a></li>
<li><a href="#index-Importing-from-other-statistical-systems-46">Importing from other statistical systems</a>: <a href="#Importing-from-other-statistical-systems">Importing from other statistical systems</a></li>
<li><a href="#index-locales-29">locales</a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-Minitab-50">Minitab</a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-Missing-values-22">Missing values</a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-Missing-values-12">Missing values</a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-MySQL-database-system-104">MySQL database system</a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-MySQL-database-system-72">MySQL database system</a>: <a href="#DBI">DBI</a></li>
<li><a href="#index-network-Common-Data-Form-112">network Common Data Form</a>: <a href="#Binary-data-formats">Binary data formats</a></li>
<li><a href="#index-Octave-65">Octave</a>: <a href="#Octave">Octave</a></li>
<li><a href="#index-ODBC-84">ODBC</a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-ODBC-69">ODBC</a>: <a href="#Overview-of-RDBMSs">Overview of RDBMSs</a></li>
<li><a href="#index-Open-Database-Connectivity-85">Open Database Connectivity</a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-Open-Database-Connectivity-70">Open Database Connectivity</a>: <a href="#Overview-of-RDBMSs">Overview of RDBMSs</a></li>
<li><a href="#index-perl-33">perl</a>: <a href="#Fixed_002dwidth_002dformat-files">Fixed-width-format files</a></li>
<li><a href="#index-Pipe-connections-133">Pipe connections</a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-PostgreSQL-database-system-103">PostgreSQL database system</a>: <a href="#RODBC">RODBC</a></li>
<li><a href="#index-Pushback-on-a-connection-150">Pushback on a connection</a>: <a href="#Pushback">Pushback</a></li>
<li><a href="#index-Quoting-strings-21">Quoting strings</a>: <a href="#Variations-on-read_002etable">Variations on read.table</a></li>
<li><a href="#index-Quoting-strings-13">Quoting strings</a>: <a href="#Export-to-text-files">Export to text files</a></li>
<li><a href="#index-Relational-databases-67">Relational databases</a>: <a href="#Relational-databases">Relational databases</a></li>
<li><a href="#index-Re_002dshaping-data-39">Re-shaping data</a>: <a href="#Re_002dshaping-data">Re-shaping data</a></li>
<li><a href="#index-SAS-52">SAS</a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-Sockets-162">Sockets</a>: <a href="#Reading-from-sockets">Reading from sockets</a></li>
<li><a href="#index-Sockets-137">Sockets</a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-S_002dPLUS-54">S-PLUS</a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-Spreadsheet_002dlike-data-19">Spreadsheet-like data</a>: <a href="#Spreadsheet_002dlike-data">Spreadsheet-like data</a></li>
<li><a href="#index-SPSS-57">SPSS</a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-SPSS-Data-Entry-58">SPSS Data Entry</a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-SQL-queries-71">SQL queries</a>: <a href="#SQL-queries">SQL queries</a></li>
<li><a href="#index-Stata-60">Stata</a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-Systat-63">Systat</a>: <a href="#EpiInfo-Minitab-SAS-S_002dPLUS-SPSS-Stata-Systat">EpiInfo Minitab SAS S-PLUS SPSS Stata Systat</a></li>
<li><a href="#index-Terminal-connections-127">Terminal connections</a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-Text-connections-131">Text connections</a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-URL-connections-148">URL connections</a>: <a href="#Input-from-connections">Input from connections</a></li>
<li><a href="#index-URL-connections-135">URL connections</a>: <a href="#Types-of-connections">Types of connections</a></li>
<li><a href="#index-XML-18">XML</a>: <a href="#XML">XML</a></li>
   </ul><div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Currently not available from
that repository but as a source package for download from
<a href="http://www.omegahat.org/ROpenOffice/">http://www.omegahat.org/ROpenOffice/</a>.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> the
distinction is subtle,
<a href="http://en.wikipedia.org/wiki/UTF-16/UCS-2">http://en.wikipedia.org/wiki/UTF-16/UCS-2</a>, and the use of
surrogate pairs is very rare.</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> Even then,
Windows applications may expect a Byte Order Mark which the
implementation of <code>iconv</code> used by R may or may not add depending
on the platform.</p>

   <hr></div>

</body></html>

<!--

Local Variables:
coding: utf-8
End:

-->
