@c 
@c Modified by Chel Hee Lee on 2013-JUL-10
@c 
@c 교정작업 실시: 2013-JUL-10 
@c 처음부터 up to chapter 1
@c 

\input texinfo
@c %**start of header
@setfilename R-FAQ.info
@settitle R FAQ (한국어 - 2013.07.09, ver.0.30, 오역 교정중)
@setchapternewpage on
@set FAQ_YEAR 2013
@set FAQ_DATE @value{FAQ_YEAR}-02-08
@set REL_YEAR 2013
@set REL_MAJOR 2
@set REL_MINOR 15
@set REL_PATCHLEVEL 3
@set REL_VERSION @value{REL_MAJOR}.@value{REL_MINOR}.@value{REL_PATCHLEVEL}
@set FAQ_VERSION @value{REL_MAJOR}.@value{REL_MINOR}.@value{FAQ_DATE}

@c <COMMENT>
@c ISBNs for R 1.x.
@c @set FAQ_ISBN 3-900051-01-1
@c @set R_ISBN 3-900051-00-3
@c </COMMENT>
@set FAQ_ISBN 3-900051-08-9
@set R_ISBN 3-900051-07-0
@c @documentlanguage en
@c @documentencoding ISO-8859-1
@c %**end of header
@c @documentlanguage utf-8

@dircategory Programming
@direntry
* R FAQ: (R-FAQ).               The R statistical system FAQ.
@end direntry

@finalout

@macro SPLUS{}
@sc{S-Plus}
@end macro

@macro CRAN{}
@acronym{CRAN}
@end macro

@macro HTML{}
@acronym{HTML}
@end macro

@macro FORTRAN{}
FORTRAN
@end macro

@macro XML{}
@acronym{XML}
@end macro

@macro XSL{}
@acronym{XSL}
@end macro

@macro pkg {p}
@strong{\p\}
@end macro

@macro CRANpkg {p}
@url{http://CRAN.R-project.org/package=\p\, @strong{\p\}}
@end macro

@titlepage
@title R @acronym{FAQ}
@subtitle Frequently Asked Questions on R
@subtitle Version @value{FAQ_VERSION}
@subtitle ISBN @value{FAQ_ISBN}
@author Kurt Hornik

@end titlepage

@ifinfo
@c We do not really see this in info, but in plain text output.
R FAQ                            @*
Frequently Asked Questions on R  @*
Version @value{FAQ_VERSION}      @*
ISBN @value{FAQ_ISBN}            @*
Kurt Hornik                      @*
@sp 2
@end ifinfo

@ifnothtml
@contents
@end ifnothtml

@ifnottex
@node Top, Introduction, (dir), (dir)
@top R FAQ
@ifhtml
@html
@c <h2>Frequently Asked Questions on R</h2>
<h2> R 에 관하여 자주 물어보는 질문들 </h2>
<h2>Version @value{FAQ_VERSION}</h2>
<h2>ISBN @value{FAQ_ISBN}</h2>
<address>Kurt Hornik</address>
<p><p><hr><p>
@end html
@end ifhtml
@end ifnottex

@menu
* Introduction::                
* R Basics::                    
* R and S::                     
* R Web Interfaces::            
* R Add-On Packages::           
* R and Emacs::                 
* R Miscellanea::               
* R Programming::               
* R Bugs::                      
* Acknowledgments::             
@end menu

@node Introduction, R Basics, Top, Top
@c @chapter Introduction
@chapter 소개

@c This document contains answers to some of the most frequently asked
@c questions about R.
이 문서는 R에 관하여 가장 많이 자주 물어보는 질문들에 대해서 정리한 문서입니다.

본 한국어 문서는 @strong{R Development Translation Teams} (@url{http://developer.r-project.org/TranslationTeams.html}) 에서 @strong{Korean} 섹션을 담당하는 @strong{Korean R Translation Team}에 의해서 관리되고 있습니다. 
문서의 수정과 재배포를 허락해 준 @strong{Kurt Hornik과 R Development Core Team}에게 감사를 드립니다.
@c 또한, 우리의 이러한 활동에 많은 관심과 아낌없는 지원을 해주는 Prof. Friedrich Leisch (Austria), Prof. Duncan Murdoch (Canada), Prof. Mikelis Bickis (Canada)에 깊은 감사의 뜻을 표현합니다.  

아래와 같은 분들에 의하여 이 문서는 2009년 이래로 여러차례의 교정과 수정이 이루어졌습니다.
의도하지 않게 관리부실로 인하여 성함이 누락되신 분이 있다면 꼭 @email{gnustats@@korea.gnu.org}로 연락을 부탁드립니다. 

@itemize @bullet
@item Chel Hee Lee, University of Saskatchewan, Saskatoon, Canada, 2009-2013
@item Heather Kim, University of Manitoba, Winnipeg, Canada, 2013
@end itemize

본 문서에 대한 참여 및 제안은 @email{ihelp-translators@@ihelp.r-forge.r-project.org} 메일링을 이용해 주시면 감사드리겠습니다. 


@menu
* Legalese::                    
* Obtaining this document::     
* Citing this document::        
* Notation::                    
* Feedback::                    
@end menu

@node Legalese, Obtaining this document, Introduction, Introduction
@c @section Legalese
@section Legalese

@c This document is copyright @copyright{} 1998--@value{FAQ_YEAR} by Kurt
@c Hornik.
이 문서의 영문본에 대한 저작권은 @copyright{} 1998--@value{FAQ_YEAR} Kurt Hornik에게 있으며, 한국어 번역본은 Chel Hee Lee @copyright{} 2009--@value{FAQ_YEAR}에 있습니다.

@c This document is free software; you can redistribute it and/or modify it
@c under the terms of the @acronym{GNU} General Public License as published
@c by the Free Software Foundation; either version 2, or (at your option)
@c any later version.
본 문서는 자유소프트웨어(free software)이므로, 자유소프트웨어 재단 (Free Software Foundation)에 의해서 배포되는 @acronym{GNU} 일반공중라이센스 (General Public License) 버전 2 또는 그 이후의 버전들을 통하여 수정 및 재배포를 할 수 있습니다. 

@c This document is distributed in the hope that it will be useful, but
@c WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@c @acronym{GNU} General Public License for more details.
이 문서가 사용자에게 유용하길 바라는 희망에서 배포되고 있습니다.
그러나, 어떤 상업적 형태(MERCHANTABILITY)로서의 보증 및 특수한 목적에 적합(FITNESS FOR A PARTICULAR PURPOSES)등 어떠한 형태의 보증을 하지 않습니다.
보다 자세한 사항들은 @acronym{GNU} 일반공증라이센스를 참조하시길 부탁드립니다. 

@c Copies of the @acronym{GNU} General Public License versions are
@c available at
@acronym{GNU} 일반공증라이센스의 사본들을 아래의 주소로부터 찾으실 수 있습니다.

@display
@url{http://www.R-project.org/Licenses/}
@end display

@node Obtaining this document, Citing this document, Legalese, Introduction
@c @section Obtaining this document
@section 이 문서를 얻는 방법

@c The latest version of this document is always available from
가장 최신 버전의 문서는 항상 아래의 주소에서 확인이 가능합니다.
@display
@url{http://CRAN.R-project.org/doc/FAQ/}
@end display

@c From there, you can obtain versions converted to
위의 주소로부터 
@url{http://CRAN.R-project.org/doc/FAQ/R-FAQ.txt,, plain
@acronym{ASCII} text},
@url{http://CRAN.R-project.org/doc/FAQ/R-FAQ.dvi.gz,, DVI},
@url{http://CRAN.R-project.org/doc/FAQ/R-FAQ.info.gz,, @acronym{GNU}
info}, @url{http://CRAN.R-project.org/doc/FAQ/R-FAQ.html,, @HTML{}},
@url{http://CRAN.R-project.org/doc/FAQ/R-FAQ.pdf,, PDF},
@url{http://CRAN.R-project.org/doc/FAQ/R-FAQ.ps.gz,, PostScript}
으로 변환되어진 문서형식을 가진 버전들을 얻을 수 있습니다.
@c as well as the 
또한, 이렇게 다양한 형식의 문서들을 생성하기 위해 사용된 
@url{http://CRAN.R-project.org/doc/FAQ/R-FAQ.texi,,Texinfo source} 
@c used for creating all these formats using the
를 얻을 수 있습니다.
@c @url{http://texinfo.org/, @acronym{GNU} Texinfo system}.

@c You can also obtain the R @acronym{FAQ} from the @file{doc/FAQ}
@c subdirectory of a @CRAN{} site (@pxref{What is CRAN?}).
그외에도 R @acronym{FAQ} 문서를 @CRAN{} 사이트 (@pxref{What is CRAN?} 참조)의 하위디렉토리 @file{doc/FAQ}에서 찾을 수 있습니다.

@node Citing this document, Notation, Obtaining this document, Introduction
@c @section Citing this document
@section 이 문서를 인용하는 방법

@c In publications, please refer to this @acronym{FAQ} as Hornik
@c (@value{FAQ_YEAR}), ``The R @acronym{FAQ}'', and give the above,
@c @emph{official} @acronym{URL} and the ISBN @value{FAQ_ISBN}:
퍼블리케이션 (publication)에서 본 @acronym{FAQ} 문서를 인용하고자 할 때에는 Hornik (@value{FAQ_YEAR}), ``The R @acronym{FAQ}'' 이라고 해주시고, 위에서 언급한 @emph{공식적인} @acronym{URL}과 ISBN @value{FAQ_ISBN}을 기재해 주세요.

@example
@group
@@Misc@{,
  author        = @{Kurt Hornik@},
  title         = @{The @{R@} @{FAQ@}@},
  year          = @{@value{REL_YEAR}@},
  note          = @{@{ISBN@} @value{FAQ_ISBN}@},
  url           = @{http://CRAN.R-project.org/doc/FAQ/R-FAQ.html@}
@}
@end group
@end example


@node Notation, Feedback, Citing this document, Introduction
@c @section Notation
@section 표기법

@c Everything should be pretty standard.  @samp{R>} is used for the R
@c prompt, and a @samp{$} for the shell prompt (where applicable).
이 문서에서는 거의 대부분이 표준에 가까운 표기법을 사용합니다.
예를들면, @samp{R>}은 R 프롬프트(prompt)를 나타내고, @samp{$}는 쉘프롬프트(shell prompt)를 의미합니다.

@node Feedback,  , Notation, Introduction
@c @section Feedback
@section 피드백 보내기 

@c Feedback via email to @email{Kurt.Hornik@@R-project.org} is of course
@c most welcome.
@c 피드백은 @email{Kurt.Hornik@@R-project.org}로 보내주시면 감사드리겠습니다. 
본 문서에 대한 피드백은 @email{gnustats@@korea.gnu.org} 또는 @email{ihelp-translators@@lists.r-forge.r-project.org}로 보내주시길 부탁드립니다.

@c In particular, note that I do not have access to Windows or Macintosh
@c systems.  Features specific to the Windows and Mac OS X ports of R are
@c described in the
@c @url{http://CRAN.R-project.org/bin/windows/base/rw-FAQ.html, ``R for
@c Windows @acronym{FAQ}''} and the
@c @url{http://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html, ``R for Mac
@c OS X @acronym{FAQ}''}.  If you have information on Macintosh or Windows
@c systems that you think should be added to this document, please let me
@c know.

특히, 다음의 내용에 대해서 알아주셨으면 합니다.  
이 문서의 작성자 (및 번역자 Chel Hee Lee)는 Windows 또는 Macintosh 시스템들을 가지고 있지 않습니다.
따라서, Windows와 Mac OS X와 관련된 특별한 내용들에 대해서는 
@url{http://CRAN.R-project.org/bin/windows/base/rw-FAQ.html, ``R for Windows @acronym{FAQ}''} 와
@url{http://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html, ``R for Mac OS X @acronym{FAQ}''}을 참고 해주세요.
만약 Macintosh와 Windows 시스템들에 관련된 정보라고 할지라도, 이 문서내에 곡 포함되어야 한다고 생각되시면 꼭 알려주시기를 부탁드립니다.

@c <FIXME>
@c Should we maybe have direct links inside the R tree to the various
@c rw-FAQ versions?
@c </FIXME>

@node R Basics, R and S, Introduction, Top
@c @chapter R Basics
@chapter R의 기본적인 사항들 

@menu
* What is R?::                  
* What machines does R run on?::  
* What is the current version of R?::  
* How can R be obtained?::      
* How can R be installed?::     
* Are there Unix-like binaries for R?::  
* What documentation exists for R?::  
* Citing R::                    
* What mailing lists exist for R?::  
* What is CRAN?::               
* Can I use R for commercial purposes?::  
* Why is R named R?::           
* What is the R Foundation?::   
* What is R-Forge?::            
@end menu

@node What is R?, What machines does R run on?, R Basics, R Basics
@c @section What is R?
@section R이란 무엇인가?

@c R is a system for statistical computation and graphics.  It consists of
@c a language plus a run-time environment with graphics, a debugger, access
@c to certain system functions, and the ability to run programs stored in
@c script files.
R은 통계 계산 (statistical computation)과 그래픽 (graphics)를 위한 시스템입니다.
이것은 언어(language), 그래픽을 사용하는 실행환경 (run-time environment), 디버거(debugger), 특정시스템 함수들에 대한 접근, 그리고 스크립트 파일들에 저장되어 있는 프로그램들을 실행시키는 요소들로 구성되어 있습니다.

@c The design of R has been heavily influenced by two existing languages:
@c Becker, Chambers & Wilks' S (@pxref{What is S?}) and Sussman's
@c @url{http://www.cs.indiana.edu/scheme-repository/home.html, Scheme}.
@c Whereas the resulting language is very similar in appearance to S, the
@c underlying implementation and semantics are derived from Scheme.
@c @xref{What are the differences between R and S?}, for further details.
R의 디자인은 Becker, Chambers & Wilks의 S (@pxref{What is S?})와 Sussman의 @url{http://www.cs.indiana.edu/scheme-repository/home.html,
Scheme}으로부터 크게 영향을 받았습니다. 
결과적으로 보이는 언어는 S의 외형과 매우 흡사하지만, 근본적인 구현방법과 시맨틱스(sematics)는 Scheme으로부터 유래되었습니다. 
더 많은 내용을 알고 싶으시다면 @ref{What are the differences between R and S?}를 참고하시길 바랍니다.

@c The core of R is an interpreted computer language which allows branching
@c and looping as well as modular programming using functions.  Most of the
@c user-visible functions in R are written in R.  It is possible for the
@c user to interface to procedures written in the C, C++, or FORTRAN
@c languages for efficiency.  The R distribution contains functionality for
@c a large number of statistical procedures.  Among these are: linear and
@c generalized linear models, nonlinear regression models, time series
@c analysis, classical parametric and nonparametric tests, clustering and
@c smoothing.  There is also a large set of functions which provide a
@c flexible graphical environment for creating various kinds of data
@c presentations.  Additional modules (``add-on packages'') are available
@c for a variety of specific purposes (@pxref{R Add-On Packages}).
R의 핵심은 인터프리트된 컴퓨터 언어 (interpreted computer language)입니다.
이것은 분기(branching), 루핑(Looping) 그리고 함수(functions)를 이용한 모듈(modular) 프로그래밍을 가능하게 합니다.
R에서 사용자가 사용하는 함수들의 대부분은 R로 작성되었습니다.
또한, 사용자가 효율성(efficiency)를 위한 목적으로 C, C++, 또는 FORTRAN과 같은 언어로 작성된 프로시져들에 인터페이싱(interface)하는 것이 가능합니다.
R 배포판 (distribution)은 방대한 양의 통계적 프로시져(statistical procedure)들을 위한 기능(functionalities)들을 포함하고 있습니다.
이들중에는 선형 및 일반화 선형 모델 (linear and generalized linear models), 비선형모델 (nonlinear regression model), 시계열분석 (time series analysis), 전통적인 모수 및 비모수 테스트 (classical parametric and nonparametric tests), 클러스터링 (clustering)과 평활화 (smoothing)이 있습니다. 
또한 매우 다양한 종류의 데이터 시각적 표현들을 생성할 수 있는 매우 유연한 그래픽 환경을 제공해주는 방대한 양의 함수들의 집합이 있습니다.
특수한 목적을 달성하기 위해서 개발된 애드온 패키지(``add-on packages'')로 알려져 있는 부가적인 모듈들 역시 이용이 가능합니다.
(이들에 대해서 더 알고 싶으시면 @ref{R Add-On Packages}를 참고해주세요).

@c R was initially written by @email{Ross.Ihaka@@R-project.org, Ross Ihaka}
@c and @email{Robert.Gentleman@@R-project.org, Robert Gentleman} at the
@c Department of Statistics of the University of Auckland in Auckland, New
@c Zealand.  In addition, a large group of individuals has contributed to R
@c by sending code and bug reports.

최초의 R은 @email{Ross.Ihaka@@R-project.org, Ross Ihaka}와 @email{Robert.Gentleman@@R-project.org, Robert Gentleman}가 New Zealand의 Auckland 에 있는 University of Auckland의 통계학과에 재직중일 당시 작성되었습니다.
그 이후, 많은 사용자들이 코드를 제공하고 버그를 리포팅 함으로서 R에 기여 해왔습니다. 

@c Since mid-1997 there has been a core group (the ``R Core Team'') who can
@c modify the R source code archive.  The group currently consists of Doug
@c Bates, John Chambers, Peter Dalgaard, Seth Falcon, Robert Gentleman,
@c Kurt Hornik, Stefano Iacus, Ross Ihaka, Friedrich Leisch, Uwe Ligges,
@c Thomas Lumley, Martin Maechler, Duncan Murdoch, Paul Murrell, Martyn
@c Plummer, Brian Ripley, Deepayan Sarkar, Duncan Temple Lang, Luke
@c Tierney, and Simon Urbanek.

1997년 중반 이래로 ``R Core Team''이라는 이름의 그룹에 의해서 R의 소스 코드 아카이브를 수정 및 관리되어지고 있습니다. 
이 그룹은 Doug Bates, John Chambers, Peter Dalgaard, Seth Falcon, Robert Gentleman, Kurt Hornik, Stefano Iacus, Ross Ihaka, Friedrich Leisch, Uwe Ligges, Thomas Lumley, Martin Maechler, Duncan Murdoch, Paul Murrell, Martyn Plummer, Brian Ripley, Deepayan Sarkar, Duncan Temple Lang, Luke Tierney, Simon Urbanek 으로 구성되어 있습니다. 

@c R has a home page at @url{http://www.R-project.org/}.  It is
@c @url{http://www.gnu.org/philosophy/free-sw.html, free software}
@c distributed under a @acronym{GNU}-style
@c @url{http://www.gnu.org/copyleft/copyleft.html, copyleft}, and an
@c official part of the @url{http://www.gnu.org/, @acronym{GNU}} project
@c (``@acronym{GNU} S'').

R은 홈페이지 @url{http://www.R-project.org/}를 가지고 있습니다.
@acronym{GNU} @url{http://www.gnu.org/copyleft/copyleft.html, copyleft}를 기반으로 배포되는 @url{http://www.gnu.org/philosophy/free-sw.html, free software}입니다.
이는 ``@acronym{GNU} S''라고 불리는 @url{http://www.gnu.org/, @acronym{GNU}} 공식 프로젝트의 일부입니다.

@node What machines does R run on?, What is the current version of R?, What is R?, R Basics
@c @section What machines does R run on?
@section R이 실행이 가능한 기계들

@c R is being developed for the Unix-like, Windows and Mac families of
@c operating systems.  Support for Mac OS Classic ended with R 1.7.1.
R은 Unix, Windows와 Mac 계열의 환경에서 개발되어져 왔습니다.
R 1.7.1 이후로는 Mac OS Classic 에 대한 지원이 종료되었습니다.

@c The current version of R will configure and build under a number of
@c common Unix-like (e.g., @uref{http://en.wikipedia.org/wiki/Unix-like})
@c platforms including @var{cpu}-linux-gnu for the i386, amd64, alpha,
@c arm/armel, hppa, ia64, m68k, mips/mipsel, powerpc, s390 and sparc 
@c @acronym{CPU}s (e.g., @url{http://buildd.debian.org/build.php?&pkg=r-base}),
@c i386-hurd-gnu, @var{cpu}-kfreebsd-gnu for i386 and amd64, 
@c powerpc-apple-darwin, mips-sgi-irix,

현 버전의 R은 보편적인 유닉스와 같은 (@uref{http://en.wikipedia.org/wiki/Unix-like}) 플랫폼을 기반으로 개발되고 설정됩니다.
@var{cpu}-linux-gnu for the i386, amd64, alpha, arm/armel, hppa, ia64, m68k, mips/mipsel, powerpc, s390 and sparc @acronym{CPU}s (e.g., @url{http://buildd.debian.org/build.php?&pkg=r-base}), i386-hurd-gnu, @var{cpu}-kfreebsd-gnu for i386 and amd64, powerpc-apple-darwin, mips-sgi-irix, rs6000-ibm-aix, 그리고 sparc-sun-solaris이 이에 해당합니다.

@c <FIXME>
@c Not sure anymore ...
@c alpha-dec-osf4,
@c <COMMENT>
@c i386-freebsd reported by B. Gian James" <gian.james@gmail.com> on
@c 2009-01-11
@c (Architecture: i386, OS: FreeBSD 7.1-PRERELEASE, Vendor: PC-BSD)
@c i386-freebsd,
@c </COMMENT>
@c i386-sun-solaris,
@c hppa-hp-hpux, 
@c </FIXME>

@c rs6000-ibm-aix, and sparc-sun-solaris.

@c and according to @email{jlindsey@@luc.ac.be, Jim Lindsey} also on
@c Mac, Amiga and Atari under m68k-linux.
@email{jlindsey@@luc.ac.be, Jim Lindsey}에 따르면 m68k-linux에 속하는 Mac, Amiga 그리고 Atari 에서도 가능합니다.

@c If you know about other platforms, please drop us a note.
만약, 다른 플랫폼에 대해서 알고 계신다면 저희에게 알려주시길 부탁드립니다.

@node What is the current version of R?, How can R be obtained?, What machines does R run on?, R Basics
@c @section What is the current version of R?
@section R의 현재 발표된 버전은 무엇인가요?
 
@c The current released version is @value{REL_VERSION}.  Based on this
@c `major.minor.patchlevel' numbering scheme, there are two development
@c versions of R, a patched version of the current release (`r-patched')
@c and one working towards the next minor or eventually major (`r-devel')
@c releases of R, respectively.  Version r-patched is for bug fixes mostly.
@c New features are typically introduced in r-devel.

현재 발표된 (released) 버전은 @value{REL_VERSION}입니다. 
`major.minor.patchlevel'의 형식을 가지는 번호체계(numbering scheme)에 기초하여, R은 두 개발버전 (development version)들과 현재 발표된 버전의 일부를 수정한 'r-patched'라는 이름의 패치된 버전이 있으며, 다음 단계의 마이너(minor) 버전 또는 결과적으로는 주버전(major)이 될 `r-devel'라는 이름으로 발표된 R이 있습니다.
패치 버전 (r-patched)은 대개 버그 수정을 한 것입니다.
새로운 기능 및 형상들은 일반적으로 r-devel 에서 소개됩니다. 

@node How can R be obtained?, How can R be installed?, What is the current version of R?, R Basics
@c @section How can R be obtained?
@section 어떻게 R을 얻을 수 있나요? 

@c Sources, binaries and documentation for R can be obtained via @CRAN{},
@c the ``Comprehensive R Archive Network'' (see @ref{What is CRAN?}).
R 원시코드 (sources), 바이너리 (binaries), 그리고 문서들(documentation)은 @CRAN{}(``Comprehensive R Archive Network'')을 통하여 얻을 수 있습니다. 
(@ref{What is CRAN?}을 살펴보세요).

@c Sources are also available via @url{https://svn.R-project.org/R/}, the
@c R Subversion repository, but currently not via anonymous rsync (nor
@c CVS).
원시코드 (sources)는 또한 R 서브버전 저장소 (subversion repository)인 @url{https://svn.R-project.org/R/}를 통하여 얻을 수 있습니다.
그러나, 익명 rsync (그리고 CVS)를 사용할 수 없습니다.

@c Tarballs with daily snapshots of the r-devel and r-patched development
@c versions of R can be found at
@c @url{ftp://ftp.stat.math.ethz.ch/Software/R}.
R의 r-devel와 r-patched 버전들에 대한 일일 스냅샷(daily snapshot)을 @url{ftp://ftp.stat.math.ethz.ch/Software/R}에서 타르볼(tarball)의 형태로 찾을 수 있습니다. 

@c Sources are also available via anonymous rsync.  Use

@c @example
@c rsync -rptC --delete rsync.R-project.org::@var{module} R
@c @end example

@c @noindent
@c to create a copy of the source tree specified by @var{module} in the
@c subdirectory @file{R} of the current directory, where @var{module}
@c specifies one of the three existing flavors of the R sources, and can be
@c one of @samp{r-release} (current released version), @samp{r-patched}
@c (patched released version), and @samp{r-devel} (development version).
@c The rsync trees are created directly from the master CVS archive and are
@c updated hourly.  The @option{-C} and in the @command{rsync} command
@c is to cause it to skip the CVS directories.  Further information on
@c @command{rsync} is available at @url{http://rsync.samba.org/rsync/}.

@c @c <NOTE>
@c @c Keep in sync with R-admin.
@c Note that the sources available via rsync do not include the recommended
@c packages, whereas these are included in the tarballs of released
@c versions.  To install the appropriate sources for the recommended
@c packages, run @command{./tools/rsync-recommended} from the top-level of
@c the R sources that you pulled by rsync.
@c @c </NOTE>

@c The sources of the development version are also available via anonymous
@c CVS.  See @url{http://anoncvs.R-project.org} for more information.

@node How can R be installed?, Are there Unix-like binaries for R?, How can R be obtained?, R Basics
@c @section How can R be installed?
@section 어떻게 R을 설치할 수 있나요?

@menu
* How can R be installed (Unix-like)::  
* How can R be installed (Windows)::  
* How can R be installed (Macintosh)::  
@end menu

@node How can R be installed (Unix-like), How can R be installed (Windows), How can R be installed?, How can R be installed?
@c @subsection How can R be installed (Unix-like)
@subsection Unix와 같은 환경에서 R을 어떻게 설치할 수 있나요?

@c If R is already installed, it can be started by typing @kbd{R} at the
@c shell prompt (of course, provided that the executable is in your path).
만약 R이 이미 설치되어 있다면, 쉘 프롬프트(shell prompt)에서 @kbd{R}이라고 입력을 함으로서 실행할 수 있습니다 (물론, 실행가능한 파일이 경로에 올바르게 위치해 있다는 가정하에서 입니다). 

@c If binaries are available for your platform (see @ref{Are there
@c Unix-like binaries for R?}), you can use these, following the
@c instructions that come with them.
만약 사용자의 플랫폼에 바이너리(binaries)가 사용가능하다면 (@ref{Are there Unix-like binaries for R?} 섹션을 살펴보세요), 이와 함께 제공되는 지시사항들을 따른다면 이들을 사용할 수 있습니다.

@c Otherwise, you can compile and install R yourself, which can be done
@c very easily under a number of common Unix-like platforms (see @ref{What
@c machines does R run on?}).  The file @file{INSTALL} that comes with the
@c R distribution contains a brief introduction, and the ``R Installation
@c and Administration'' guide (@pxref{What documentation exists for R?})
@c has full details.
그렇지 않다면, R을 직접 컴파일하여 설치하여야 합니다. 
일반적인 Unix와 같은 플랫폼(@ref{What machines does R run on?}를 참고해주세요)에서 이 과정을 수행하는 것은 매우 쉽쉽니다. 
R의 배포판과 함께 제공되는 @file{INSTALL} 파일은 간단한 설치지침을 포함하고 있으면 ``R Installation and Administration''라는 가이드는 설치와 관련한 자세한 내용들이 잘 문서화 되어 있습니다 (@ref{What documentation exists for R?}을 참고하세요).

@c Note that you need a @FORTRAN{} compiler or perhaps @command{f2c} in
@c addition to a C compiler to build R.
참고로 R을 빌드(build)하기 위해서는 C 컴파일러(compiler) 외에도 @FORTRAN{} 컴파일러 혹은 아마도 @command{f2c}라는 것이 필요할 수도 있습니다.

@c In the simplest case, untar the R source code, change to the directory
@c thus created, and issue the following commands (at the shell prompt):
가장 간단한 방법은 R 원시코드(source code)의 압축을 풀고, 압축이 풀어 생성된 디렉토리로 이동한 후, (쉘 프롬프트상에서) 다음과 같은 명령어를 입력하는 것입니다.

@example
$ ./configure
$ make
@end example

@c If these commands execute successfully, the R binary and a shell script
@c front-end called @file{R} are created and copied to the @file{bin}
@c directory.  You can copy the script to a place where users can invoke
@c it, for example to @file{/usr/local/bin}.  In addition, plain text help
@c pages as well as @HTML{} and @LaTeX{} versions of the documentation are
@c built.
만약 명령어들이 성공적으로 수행된다면, R 바이너리와 쉘 스크립트로 작성된 사용자가 이용이 가능한 @file{R}이라는 이름을 가진 파일이 생성되고, 이는 @file{bin} 디렉토리에 복사되어 질 것입니다. 
사용자는 이 스크립트를 실행시키고자 하는 위치로 스크립트를 복사해 넣기만 하면 됩니다.
예를들면, @file{/usr/local/bin} 디렉토리입니다. 
또한, 텍스트로만 구성된 도움말 페이지 뿐만아니라 @HTML{}, @LaTeX{} 버전의 문서들도 함께 설치됩니다. 

@c Use @kbd{make dvi} to create DVI versions of the R manuals, such as
@c @file{refman.dvi} (an R object reference index) and @file{R-exts.dvi},
@c the ``R Extension Writers Guide'', in the @file{doc/manual}
@c subdirectory.  These files can be previewed and printed using standard
@c programs such as @command{xdvi} and @command{dvips}.  You can also use
@c @kbd{make pdf} to build PDF (Portable Document Format) version of the
@c manuals, and view these using e.g.@: Acrobat.  Manuals written in the
@c @acronym{GNU} Texinfo system can also be converted to info files
@c suitable for reading online with Emacs or stand-alone @acronym{GNU}
@c Info; use @kbd{make info} to create these versions (note that this
@c requires Makeinfo version 4.5).
@file{doc/manual}에 놓여있는 @file{refman.dvi} (R object reference index) 혹은 @file{R-exts.dvi} (``R Extension Writers Guide'')와 같은 R 매뉴얼들의 DVI 버전을 생성하기 위해서는 @kbd{make dvi}를 이용해보세요.
이러한 파일들은 @command{xdvi} 또는 @command{dvips}와 같은 표준 프로그램들을 이용하여 미리 보거나 프린트를 할 수 있습니다. 
또한, @kbd{make pdf}의 사용은 매뉴얼들을 PDF (Portable Document Format)의 형식으로 생성하게 해줍니다. 
이들은 Arobat을 이용하여 볼 수 있습니다. 
@acronym{GNU} Texinfo 시스템에 의하여 작성된 매뉴얼들 (본 한국어 매뉴얼 역시 @acronym{GNU} Texinfo 시스템을 이용하여 작성되었습니다) 은 또한 Emacs 또는 독립적인 @acronym{GNU} Info 와 함께 온라인으로 읽을 수 읽을 수 있도록 info 파일들로 변환할 수 있습니다. 
이들을 생성하기 위해서는 @kbd{make info}를 이용하시길 바랍니다. 
(단, 이경우에는 Makeinfo 의 버전이 4.5 이상이 요구됩니다).


@c Finally, use @kbd{make check} to find out whether your R system works
@c correctly.
마지막으로 R 시스템이 정상적으로 작동하는지 확인하기 위해서 @kbd{make check}를 이용해 보세요.

@c You can also perform a ``system-wide'' installation using @kbd{make
@c install}.  By default, this will install to the following directories:
@kbd{make install}을 이용하여 ``system-wide''(시스템 전체에서 사용이 가능한) 설치를 수행할 수도 있습니다. 
기본적으로 이것은 다음의 디렉토리에 설치됩니다. 

@table @file
@item $@{prefix@}/bin
@c the front-end shell script
사용자가 직접 이용하는 쉘 스크립트 (front-end shell script)
@item $@{prefix@}/man/man1
@c the man page
도움말 페이지
@item $@{prefix@}/lib/R
@c all the rest (libraries, on-line help system, @dots{}).  This is the ``R
@c Home Directory'' (@env{R_HOME}) of the installed system.
위의 내용을 제외한 나머지 모두 (라이브러리, 온라인 도움말, @dots{})이 이곳에 설치됩니다. 
이것을 설치된 시스템의 ``R Home Directory''(R 홈디렉토리, @env{R_HOME})이라고 합니다. 
@end table

@noindent
@c In the above, @code{prefix} is determined during configuration
@c (typically @file{/usr/local}) and can be set by running
@c @command{configure} with the option
위에서 @code{prefix}는 환경설정을 하는 동안에 결정되어 지며 (일반적으로 @file{/usr/local/}입니다), 아래에 보이는 것과 같이 @command{configure}에 옵션을 이용하여 설치시에 정할 수도 있습니다.

@example
$ ./configure --prefix=/where/you/want/R/to/go
@end example

@noindent
@c (E.g., the R executable will then be installed into
@c @file{/where/you/want/R/to/go/bin}.)
(즉, R의 실행파일들은 @file{/where/you/want/R/to/go/bin}에 설치될 것입니다).

@c To install DVI, info and PDF versions of the manuals, use @kbd{make
@c install-dvi}, @kbd{make install-info} and @kbd{make install-pdf},
@c respectively.
DVI, info, PDF 버전의 매뉴얼들을 설치하기 위해서는 @kbd{make install-dvi}, @kbd{make install-info}, @kbd{make install-pdf}을 각각 실행시키세요.


@node How can R be installed (Windows), How can R be installed (Macintosh), How can R be installed (Unix-like), How can R be installed?
@c @subsection How can R be installed (Windows)
@subsection Windows 에서는 R을 어떻게 설치해야 하나요?

@c The @file{bin/windows} directory of a @CRAN{} site contains binaries for
@c a base distribution and a large number of add-on packages from @CRAN{}
@c to run on Windows 2000 and later (including 64-bit versions of Windows)
@c on ix86 and x86_64 chips. The Windows version of R was created by Robert
@c Gentleman and Guido Masarotto, and is now being developed and maintained
@c by @email{murdoch@@stats.uwo.ca, Duncan Murdoch} and
@c @email{Brian.Ripley@@R-project.org, Brian D. Ripley}.
@CRAN{} 사이트의 @file{bin/windows} 디렉토리는 ix86 과 x86_64 칩상에서 돌아가는 Windows 2000 과 그 이후
의 버전들 (64비트 포함)에서 돌아갈 수 있는 R base 배포판과 방대한 양의 애드온(add-on) 패키지들에 대한 바이너리들을 포함하고 있습니다. 
Windows 버전의 R은 Robert Gentleman과 Guido Masarotto에 의해서 만들어졌으며, 현재는 @email{murdoch@@stats.uwo.ca, Duncan Murdoch}와 @email{Brian.Ripley@@R-project.org, Brian D. Ripley}에 의해서 개발
및 유지보수가 되고 있습니다.

@c Note that when uncompressing the zip files, the pkunzip program needs to
@c be invoked with the @samp{-D} flag to create subdirectories.  Also, be
@c aware that some decompression programs do not preserve long file names
@c properly.

@c For most installations the Windows installer program will be the easiest
@c tool to use.
대부분의 경우, Windows 설치 프로그램 (installer)은 이용하기에 가장 쉬운 도구일 것입니다.

@c See the @url{http://CRAN.R-project.org/bin/windows/base/@/rw-FAQ.html,
@c ``R for Windows @acronym{FAQ}''} for more details.
보다 더 자세한 사항에 대해서는 @url{http://CRAN.R-project.org/bin/windows/base/@/rw-FAQ.html, ``R for Windows @acronym{FAQ}''}를 참고하세요.

@node How can R be installed (Macintosh),  , How can R be installed (Windows), How can R be installed?
@c @subsection How can R be installed (Macintosh)
@subsection Macintosh에서는 어떻게 R을 설치하나요? 

@c The @file{bin/macosx} directory of a @CRAN{} site contains a standard
@c Apple installer package inside a disk image named @file{R.dmg}.  Once
@c downloaded and executed, the installer will install the current
@c non-developer release of R.  RAqua is a native Mac OS X Darwin version
@c of R with a R.app Mac OS X @acronym{GUI}.  Inside
@c @file{bin/macosx/powerpc/contrib/@var{x}.@var{y}} there are prebuilt
@c binary packages (for powerpc version of Mac OS X) to be used with RAqua
@c corresponding to the ``@var{x}.@var{y}'' release of R. The installation
@c of these packages is available through the ``Package'' menu of the R.app
@c @acronym{GUI}.  This port of R for Mac OS X is maintained by
@c @email{Stefano.Iacus@@R-project.org, Stefano Iacus}.  The
@c @url{http://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html, ``R for Mac
@c OS X @acronym{FAQ}} has more details.
@CRAN{} 사이트내의 @file{bin/macosx} 디렉토리는 @file{R.dmg}라는 이름의 디스크 이미지가 표준 Apple 인스톨러 패키지를 포함하고 있습니다. 
이것을 다운로드 받아 실행시키면, 설치프로그램은 비개발자 배포판non-developer release)을 설치하게 될 것입니다.
RAqua 는 네이브(naive) Mac OS X Darwin 버전의 R과 R.app Mac OS X @acronym{GUI}를 지칭합니다.
@file{bin/macosx/powerpc/contrib/@var{x}.@var{y}} 디렉토리 내에는, R의 ``@var{x}.@var{y}'' 릴리즈에 대응되는 RAqua 와 함께 사용될 (Mac OS X 의 powerpc 버전을 위하여) 미리 빌드된 바이너리 패키지들이 있을 것입니다. 
이러한 패키지들의 설치는 R.app @acronym{GUI}에 있는 ``Package'' 메뉴를 통하여 가능합니다. 
Mac OS X 에 대한 이러한 R 포트 (port) 는 @email{Stefano.Iacus@@R-project.org, Stefano Iacus}에 의하여 유지 보수 됩니다. 
더 자세한 사항에 대해서는 @url{http://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html, ``R for Mac OS X @acronym{FAQ}} 를 참고하길 바랍니다.

@c The @file{bin/macos} directory of a @CRAN{} site contains bin-hexed
@c (@file{hqx}) and stuffit (@file{sit}) archives for a base distribution
@c and a large number of add-on packages of R 1.7.1 to run under Mac OS 8.6
@c to Mac OS 9.2.2.  This port of R for Macintosh is no longer supported.


@node Are there Unix-like binaries for R?, What documentation exists for R?, How can R be installed?, R Basics
@c @section Are there Unix-like binaries for R?
@section Unix와 같은 바이너리들이 있나요?

@c Linux binaries as of 2011-07-05:

@c debian
@c   etch-cran
@c            i386   2.11.0  Johannes Ranke
@c            amd64  2.11.0  Johannes Ranke
@c   lenny-cran
@c            i386   2.13.0  Johannes Ranke
@c            amd64  2.13.0  Johannes Ranke
@c   squeeze-cran
@c            i386   2.13.0  Johannes Ranke
@c            amd64  2.13.0  Johannes Ranke
@c redhat
@c   el4      i386   2.10.0  Bob Kinney <rhel_cran@hmdc.harvard.edu>
@c            x86_64 2.10.0  Bob Kinney <rhel_cran@hmdc.harvard.edu>
@c   el5      i386   2.10.0  Bob Kinney <rhel_cran@hmdc.harvard.edu>
@c            x86_64 2.10.0  Bob Kinney <rhel_cran@hmdc.harvard.edu>
@c   fedora10 i386   2.10.0  Martyn Plummer <Martyn.Plummer@R-project.org>
@c            x86_64 2.10.0  Martyn Plummer <Martyn.Plummer@R-project.org>
@c   fedora11 i386   2.10.0  Martyn Plummer <Martyn.Plummer@R-project.org>
@c            x86_64 2.10.0  Martyn Plummer <Martyn.Plummer@R-project.org>
@c ubuntu
@c   intrepid [Intrepid Ibex, 8.10]
@c           i386   2.8.1  Vincent Goulet
@c           amd64  2.8.1  Michael Rutter
@c   hardy [Hardy Heron, 8.04]
@c           i386   2.8.1  Vincent Goulet
@c           amd64  2.8.1  Michael Rutter
@c   gutsy [Gutsy Gibbon, 7.10]
@c           i386   2.8.1  Vincent Goulet
@c           amd64  2.8.1  Michael Rutter
@c   dapper [Dapper Drake, 6.06]
@c           i386   2.8.1  Vincent Goulet
@c           amd64  2.8.1  Michael Rutter

@c The @file{bin/linux} directory of a @CRAN{} site contains the following
@c packages.
@CRAN{} 사이트의 @file{bin/linux} 디렉토리는 다음과 같은 패키지들을 포함하고 있습니다.

@quotation
@multitable {Red Hat} {i386/x86_64} {hardy/lucid/natty/oneiric/precise} {Martyn Plummer}
@headitem @tab CPU @tab Versions @tab Provider
@item Debian   @tab i386/amd64 @tab etch/lenny/squeeze @tab Johannes Ranke
@item Red Hat  @tab i386/x86_64 @tab fedora10/fedora11 @tab Martyn Plummer
@item Ubuntu   @tab i386/amd64 @tab hardy/lucid/natty/oneiric/precise @tab Michael Rutter
@end multitable
@end quotation

@c Debian packages, maintained by Dirk Eddelbuettel, have long been part of
@c the Debian distribution, and can be accessed through APT, the Debian
@c package maintenance tool.  Use e.g.@: @code{apt-get install r-base
@c r-recommended} to install the R environment and recommended packages.
@c If you also want to build R packages from source, also run @code{apt-get
@c install r-base-dev} to obtain the additional tools required for this.
@c So-called ``backports'' of the current R packages for at least the
@c @dfn{stable} distribution of Debian are provided by Johannes Ranke, and
@c available from @CRAN{}.  See
@c @url{http://CRAN.R-project.org/bin/linux/debian/README} for details on R
@c Debian packages and installing the backports, which should also be
@c suitable for other Debian derivatives.  Native backports for Ubuntu are
@c provided by Michael Rutter.

Dirk Eddelbuettel에 의해 유지보수되는 데비안(Debian) 패지들은 오랜 시간에 걸쳐 데비안 배포판의 일부분이 되어가고 있으며, 데비안 패키지 관리도구인 APT 를 통하여 쉽게 엑세스 될 수 있습니다. 
R 기본 환경 및 추천 패키지들을 설치하기 위해서는 @code{apt-get install r-base r-recommended}을 입력하면 됩니다.
만약, 원시코드(source)로부터 R 패키지를 빌드하고자 한다면, 이에 필요한 도구들을 설치하기 위해서 @code{apt-get
install r-base-dev}이라고 입력하면 됩니다.
최소한 @dfn{stable}(안정적인 버전의) 데비안에 적용이 될 수 있는 ``backport''라고 불리우는 R 패키지들은 Johannes Ranke에 의하여 제공되며, @CRAN{}으로부터 받을 수 있습니다.
R 데비안 패키지들에 대한 사항들과 백포트(backport)를 설치하는 하는 방법에 대해서는 @url{http://CRAN.R-project.org/bin/linux/debian/README}를 살펴보시길 바랍니다.
이는 데비안으로부터 파생된 다른 배포판에서도 안정적으로 작동될 것입니다.
우분투를 위한 네이티브 백포트 (native backports)는 Michael Rutter에 의해서 제공됩니다.

@c R binaries for Fedora, maintained by Tom ``Spot'' Callaway, are provided
@c as part of the Fedora distribution and can be accessed through
@c @command{yum}, the RPM installer/updater.  The Fedora R RPM is a
@c ``meta-package'' which installs all the user and developer components of
@c R (available separately as @code{R-core} and @code{R-devel}), as well as
@c the standalone R math library (@code{libRmath} and
@c @code{libRmath-devel}).  RPMs for a selection of R packages are also
@c provided by Fedora.  The Extra Packages for Enterprise Linux (EPEL)
@c project (@url{http://fedoraproject.org/wiki/EPEL}) provides ports of the
@c Fedora RPMs for RedHat Enterprise Linux and compatible distributions.
@c When a new version of R is released, there may be a delay of up to 2 
@c weeks until the Fedora RPM becomes publicly available, as it must pass
@c through the statutory Fedora review process.

Fedora(페도라)를 위한 R 바이너리들은 Tom ``Spot'' Callaway에 의해서 유지보수되며, 페도라 배포판의 일부로서 제공되며 RPM 설치 및 업데이트 관리프로그램인 @command{yum}을 통하여 엑세스 할 수 있습니다.
페도라 R RPM 은 사용자와 개발자에게 필요한 모든 구성요소들을 다 함께 설치해주는 메타패키지(``meta-package'')인데, 이는 @code{R-core}와 @code{R-devel}으로 구분되어집니다. 
또한, 독립적인 (standalone) R math library (@code{libRmath}와 @code{libRmath-devel})를 설치할 수 있으며, R 패키지들을 선택하여 설치하는 기능 역시 포함하고 있습니다.
Enterprise Linux (EPEL) 프로젝트 (@url{http://fedoraproject.org/wiki/EPEL})를 위한 추가적인 패키지들은 RedHat Enterprise Linux와 이와 호환되는 배포판들을 위한 Fedora RPM의 포트를 제공합니다.
새로운 버전의 R이 배포될때, 페도라 RPM 에서 새버전을 사용하기 위해서는 최대 2주까지 지연될 가능성이 있습니다. 
이는 반드시 페도라내에 지정된 검증프로세스 (statuory Fedora review process)를 반드시 거쳐야 하기 때문입니다.

@c See @url{http://CRAN.R-project.org/bin/linux/suse/README.html} for
@c information about RPMs for openSUSE.
openSUSE 에서 이용되는 RPM에 관한 정보는 @url{http://CRAN.R-project.org/bin/linux/suse/README.html}를 살펴보시길 바랍니다.

@c The @file{bin/osf} directory of a @CRAN{} site contains RPMs
@c by Albrecht Gebhardt for alpha systems running Alpha Unix
@c (OSF/Tru64).

@c There are also `tar' distributions for NEXTSTEP on the i386 and m68k
@c platforms in @file{bin/nextstep/i386} and @file{bin/nextstep/m68k},
@c created by Stephen Shiboski <steve@biostat.ucsf.edu>.

@c The @file{bin/solaris} directory of a @CRAN{} site contains binary
@c packages for Solaris on the SPARC and x64 platforms, provided by Mithun
@c Sridharan.

@c No other binary distributions are currently publically available via
@c @CRAN{}.
현재 다른 종류들에 대하여 공개적으로 @CRAN{}을 통해 이용가능한 바이너들은 없습니다.

@c A ``live'' Linux distribution with a particular focus on R is
@c @dfn{Quantian}, which provides a directly bootable and self-configuring
@c ``Live DVD'' containing numerous applications of interests to scientists
@c and researchers, including several hundred @CRAN{} and Bioconductor
@c packages, the ``ESS'' extensions for Emacs, the ``JGR'' Java
@c @acronym{GUI} for R, the Ggobi visualization tool as well as several
@c other R interfaces. The @dfn{Quantian} website at
@c @url{http://dirk.eddelbuettel.com/quantian/} contains more details as
@c well download information.

@node What documentation exists for R?, Citing R, Are there Unix-like binaries for R?, R Basics
@c @section What documentation exists for R?
@section R에 대해서 어떤 문서들이 존재하나요?

@c Online documentation for most of the functions and variables in R
@c exists, and can be printed on-screen by typing @kbd{help(@var{name})}
@c (or @kbd{?@var{name}}) at the R prompt, where @var{name} is the name of
@c the topic help is sought for.  (In the case of unary and binary
@c operators and control-flow special forms, the name may need to be be
@c quoted.)
R에서 사용할 수 있는 대부분의 함수들과 변수들에 대해서는 온라인 문서가 있으며, 이들은 R 프롬프트에서 @kbd{help(@var{name})} (또는 @kbd{?@var{name}})이라고 입력함으로서 스크린을 통하여 확인할 수 있습니다.
여기에서 @var{name}은 도움을 받고자 하는 주제를 의미합니다.
(단항과 이항 연산자 (unary and binary operators), 그리고 분기문(control-flow)과 같은 특수한 형태의 경우에는 검색어를 입력할때 따옴표를 함께 넣어주어야 할 수도 있습니다).

@c This documentation can also be made available as one reference manual
@c for on-line reading in @HTML{} and PDF formats, and as hardcopy via
@c @LaTeX{}, see @ref{How can R be installed?}.  An up-to-date @HTML{}
@c version is always available for web browsing at
@c @url{http://stat.ethz.ch/R-manual/}.
본 문서 또한 @HTML{}과 PDF 형식으로 온라인으로 읽을 수 있는 하나의 참고메뉴얼(reference manual)이며, @LaTeX{}를 통하여 출력할 수도 있습니다.
@ref{How can R be installed?}를 참고하시길 바랍니다.
가장 최신버전의 @HTML{} 버전은 항상 @url{http://stat.ethz.ch/R-manual/}에서 확인해 보실수 있습니다.

@c Printed copies of the R reference manual for some version(s) are
@c available from Network Theory Ltd, at
@c @url{http://www.network-theory.co.uk/R/base/}.  For each set of manuals
@c sold, the publisher donates USD 10 to the R Foundation (@pxref{What is
@c the R Foundation?}).
일부 버전들에 대한 참고매뉴얼 (R reference manual)들은 Network Theory Ltd @url{http://www.network-theory.co.uk/R/base/}에서 구매할 수 있습니다.
매뉴얼 한 부가 판매될 때마다, 출판사는 R Foundation (@pxref{What is the R Foundation?})에 USD 10 (미국돈으로 10달러)를 기부합니다.

@c The R distribution also comes with the following manuals.
R은 다음과 같은 매뉴얼들과 함께 배포되고 있습니다.


@c start from this point next time 
@c start from this point next time 
@c start from this point next time 
@c start from this point next time 
@c start from this point next time 
@c start from this point next time 

@itemize @bullet
@item ``An Introduction to R'' (@file{R-intro})
@c includes information on data types, programming elements, statistical
@c modeling and graphics.  This document is based on the ``Notes on
@c @SPLUS{}'' by Bill Venables and David Smith.
는 데이터의 유형, 프로그래밍 구성요소들, 통계 모델링과 그래픽스에 대한 정보를 포함하고 있습니다. 
이 문서는 Bill Venables과 David Smith가 작성한 ``Notes on S-Plus''라는 문서를 토대로 하고 있습니다.

@item ``Writing R Extensions'' (@file{R-exts})
@c currently describes the process of creating R add-on packages, writing R
@c documentation, R's system and foreign language interfaces, and the R
@c @acronym{API}.
는 R 애드온(add-on) 패키지의 작성절차, R 문서 작성요령, R과 다른 언어들과의 인터페이스, 그리고 @acronym{API}에 대해서 기술하고 있습니다.

@item ``R Data Import/Export'' (@file{R-data})
@c is a guide to importing and exporting data to and from R.
는 데이터 입출력에 대한 가이드입니다.

@item ``The R Language Definition'' (@file{R-lang}),
@c a first version of the ``Kernighan & Ritchie of R'', explains
@c evaluation, parsing, object oriented programming, computing on the
@c language, and so forth.
는 ``Kernighan & Ritchie of R''이라는 문서의 최초 버전이기도 하며, 이밸류에이션(evaluation, 평가, 파싱(parsing, 구문해석), 객체지향 프로그래밍 (object oriented programming), 연산(computing) 등의 내용을 다루고 있습니다.

@item ``R Installation and Administration'' (@file{R-admin}).
@item ``R Internals'' (@file{R-ints})
@c is a guide to R's internal structures.
@c (Added in R 2.4.0.)
R의 내부구조(internal structure)에 대한 가이드입니다 (R-2.4.0에서 추가되었습니다).
@end itemize

@c An annotated bibliography (Bib@TeX{} format) of R-related publications
@c can be found at
R과 관련된 문헌(publications)들에 대한 정보는 Bib@TeX{} 형식으로 아래의 주소에서 찾아 볼 수있습니다.

@display
@url{http://www.R-project.org/doc/bib/R.bib}
@end display

@c Books on R by R Core Team members include
R 코어팀 멤버들에 의해서 씌여진 책들은 아래와 같습니다.

@quotation
John M. Chambers (2008), ``Software for Data Analysis: Programming with
R''.  Springer, New York, ISBN 978-0-387-75935-7,
@url{http://stat.stanford.edu/~jmc4/Rbook/}.

Peter Dalgaard (2008), ``Introductory Statistics with R'', 2nd edition.
Springer, ISBN 978-0-387-79053-4,
@url{http://www.biostat.ku.dk/~pd/ISwR.html}.

Robert Gentleman (2008), ``R Programming for Bioinformatics''.  Chapman
& Hall/CRC, Boca Raton, FL, ISBN 978-1-420-06367-7,
@url{http://www.bioconductor.org/pub/RBioinf/}.

Stefano M. Iacus (2008), ``Simulation and Inference for Stochastic
Differential Equations: With R Examples''. Springer, New York, ISBN
978-0-387-75838-1.

Deepayan Sarkar (2007), ``Lattice: Multivariate Data Visualization with
R''. Springer, New York, ISBN 978-0-387-75968-5.

W. John Braun and Duncan J. Murdoch (2007), ``A First Course in
Statistical Programming with R''.  Cambridge University Press,
Cambridge, ISBN 978-0521872652.

P. Murrell (2005), ``R Graphics'', Chapman & Hall/CRC, ISBN:
1-584-88486-X,
@url{http://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html}.

William N. Venables and Brian D. Ripley (2002), ``Modern Applied
Statistics with S'' (4th edition).  Springer, ISBN 0-387-95457-0,
@url{http://www.stats.ox.ac.uk/pub/MASS4/}.

Jose C. Pinheiro and Douglas M. Bates (2000), ``Mixed-Effects Models in
S and S-Plus''. Springer, ISBN 0-387-98957-0.
@end quotation

@c Last, but not least, Ross' and Robert's experience in designing and
@c implementing R is described in 
마지막으로, 최근의 것은 아니지만, Ross와 Robert가 R을 디자인하고 구현하면서 겪은 경험이 다음의 문서에 기록되어 있습니다.
Ihaka & Gentleman (1996), ``R: A Language
for Data Analysis and Graphics'',
@url{http://www.amstat.org/publications/jcgs/, , @emph{Journal of
Computational and Graphical Statistics}}, @strong{5}, 299--314.

@node Citing R, What mailing lists exist for R?, What documentation exists for R?, R Basics
@c @section Citing R
@section R을 인용하는 방법

@c To cite R in publications, use
R을 참고자료로서 인용하고자 한다면, 아래의 Bib@TeX{}를 이용하시면 됩니다.
@example
@group
@@Manual@{,
  title        = @{R: A Language and Environment for Statistical
                  Computing@},
  author       = @{@{R Core Team@}@},
  organization = @{R Foundation for Statistical Computing@},
  address      = @{Vienna, Austria@},
  year         = @value{REL_YEAR},
  note         = @{@{ISBN@} @value{R_ISBN}@},
  url          = @{http://www.R-project.org@}
@}
@end group
@end example

@c Citation strings (or Bib@TeX{} entries) for R and R packages can also be
@c obtained by @code{citation()}.
R과 R 패키지들에 대한 Bib@TeX{} 항목들또는 인용정보들은 @code{citation()}을 통하여 얻을 수 있습니다.

@node What mailing lists exist for R?, What is CRAN?, Citing R, R Basics
@c @section What mailing lists exist for R?
@section 어떤 메일링 리스트가 있나요?

@c Thanks to @email{Martin.Maechler@@R-project.org, Martin Maechler}, there
@c are four mailing lists devoted to R.
이러한 서비스를 제공해 준 @email{Martin.Maechler@@R-project.org, Martin Maechler}에게 감사를 드립니다.
네가지 종류의 메일링 리스트가 있습니다.

@table @code
@item R-announce
@c A moderated list for major announcements about the development of R and
@c the availability of new code.
는 R의 개발과 새로운 코드의 유용성에 관한 주요 공지사항들을 위한 (moderated) 리스트입니다.

@item R-packages
@c A moderated list for announcements on the availability of new or
@c enhanced contributed packages.
는 새롭게 개발되거나 주요기능들이 강화된 패키지들의 유용성에 대한 공지사항들을 위한 (moderated) 리스트입니다.

@item R-help
@c The `main' R mailing list, for discussion about problems and solutions
@c using R, announcements (not covered by `R-announce' and `R-packages')
@c about the development of R and the availability of new code.
@c enhancements and patches to the source code and documentation of R,
@c comparison and compatibility with S and @SPLUS{}, and for the posting of
@c nice examples and benchmarks.
은 R을 사용하면서 겪는 문제들과 이들에 대한 해법들을 논의하는 목적으로 사용되는 주된 메일링 리스트입니다.
R의 개발과 새로운 코드들의 유용성에 관하여 `R-announce'와 `R-packages'에서 다루지 않은 공지사항들을 포함하기도 하며, R의 원시코드와 문서에 대한 강화된 기능 및 패치들에 대한 내용을 다루기도 합니다.
S와 @SPLUS{}와의 호환성과 비교에 대한 내용도 있으며, 좋은 예제들과 벤치마크들을 포스팅할 목적으로도 사용합니다.

@item R-devel
@c This list is for questions and discussion about code development in R.
@c discussions about the future of R, proposals of new functionality, and
@c pre-testing of new versions.  It is meant for those who maintain an
@c active position in the development of R.
는 R의 코드개발 (code development)에 관한 질문들과 논의를 위한 리스트입니다.
R의 미래에 대한 논의, 새로운 기능에 대한 제안, 그리고 새로운 버전에 대한 테스트를 목적으로 이용될 수 있습니다.
이 리스트는 R의 개발에 적극적인 자세 (active position)을 유지하는 사람을 위한 것입니다.
@end table

@noindent
@c Please read the @url{http://www.R-project.org/posting-guide.html,
@c posting guide} @emph{before} sending anything to any mailing list.
위에서 나열한 어떠한 종류의 메일링 리스트에 어떤 내용을 보내기 @emph{전에 반드시} @url{http://www.R-project.org/posting-guide.html, posting guide(포스팅 가이드)}를 읽어보시길 바랍니다.

@c Note in particular that R-help is intended to be comprehensible to
@c people who want to use R to solve problems but who are not necessarily
@c interested in or knowledgeable about programming.  Questions likely to
@c prompt discussion unintelligible to non-programmers (e.g., questions
@c involving C or C++) should go to R-devel.
R-help 는 본래 R을 이용하여 본인의 문제를 해결하고자 하지만 프로그래밍에 대한 지식이 부족한 분들을 위해서 개설되었다는 것을 아셨으면 합니다. 
따라서, 프로그래머가 아닌 사람들이 이해하기 어려운 질문들 (즉, C 혹은 C++ 과 연관된 내용)은 R-devel을 이용하시길 부탁드립니다.

@c Convenient access to information on these lists, subscription, and
@c archives is provided by the web interface at
@c @url{http://stat.ethz.ch/mailman/listinfo/}.  One can also subscribe
@c (or unsubscribe) via email, e.g.@: to R-help by sending @samp{subscribe}
@c (or @samp{unsubscribe}) in the @emph{body} of the message (not in the
@c subject!) to @email{R-help-request@@lists.R-project.org}.
이러한 메일링 리스트들에 대한 구독 및 보관된 자료들에 대한 열람은 @url{http://stat.ethz.ch/mailman/listinfo/}을 통하여 손쉽게 하실 수 있습니다.
이는 @email{R-help-request@@lists.R-project.org}에 이메일을 보낼 때 subject(제목)이 아닌 @emph{body(본문)}에 @samp{subscribe(구독)} (또는 @samp{unsubscribe(구독해지)}라고 이메일을 보냄으로서 이용하실 수 있습니다.

@c Send email to @email{R-help@@lists.R-project.org} to send a message to
@c everyone on the R-help mailing list.  Subscription and posting to the
@c other lists is done analogously, with @samp{R-help} replaced by
@c @samp{R-announce}, @samp{R-packages}, and @samp{R-devel}, respectively.
@c Note that the R-announce and R-packages lists are gatewayed into R-help.
@c Hence, you should subscribe to either of them only in case you are not
@c subscribed to R-help.
R-help 메일링 리스트를 구독하는 모든 이들에게 메시지를 보내기 위해서는 @email{R-help@@lists.R-project.org}로 이메일을 보내주세요.
다른 메일링 리스트들의 구독 및 포스팅 요령은 r-help와 동일합니다. 
@samp{R-help} 대신에 @samp{R-announce}, @samp{R-packages}, @samp{R-devel} 이라고만 변경해주시면 됩니다.
R-announce과 R-packages는 R-help에 이르는 과정이라는 점을 아시길 바랍니다.
만약 R-help를 구독하고 있지 않다면 둘 중 어느 하나는 구독을 해야합니다.

@c It is recommended that you send mail to R-help rather than only to the R
@c Core developers (who are also subscribed to the list, of course).  This
@c may save them precious time they can use for constantly improving R, and
@c will typically also result in much quicker feedback for yourself.
@strong{사용자가 R 코어 개발자들에게 개별적으로 이메일을 보내기 보다는 R-help에 메일을 보내주시길 부탁드립니다 (코어 멤버들 역시 메일링을 사용하고 있습니다)}. 
이러한 부탁을 하는 이유는 코어 개발자들이 지속적으로 R을 향상시키는데 있어서 많은 시간을 줄여주기도 할 뿐더러, 질문자가 가장 빠른 시간내에 답변을 받을 수 있기 때문입니다. 

@c Of course, in the case of bug reports it would be very helpful to have
@c code which reliably reproduces the problem.  Also, make sure that you
@c include information on the system and version of R being used.  See
@c @ref{R Bugs} for more details.
버그리포트를 할 때에는 버그를 정확하게 재구현할 수 있도록 코드를 함께 올려주시면 매우 도움이 됩니다.
또한, 이러한 버그를 보고할 때 사용자가 어떤 시스템과 어떤 버전의 R 을 사용하는지 알려주시길 부탁드립니다.
더 자세한 사항들에 대해서는 @ref{R Bugs}를 살펴보세요.

@c See @url{http://www.R-project.org/mail.html} for more information on
@c the R mailing lists.
R 메일링 리스트들에 대한 좀 더 많은 정보를 알고 싶으시다면 @url{http://www.R-project.org/mail.html}을 살펴보시길 바랍니다.

@c The R Core Team can be reached at @email{R-core@@lists.R-project.org}
@c for comments and reports.
코멘트와 리포트들을 @email{R-core@@lists.R-project.org}을 통하여 R 코어팀에 보내주실 수 있습니다.

@c Many of the R project's mailing lists are also available via
@c @url{http://gmane.org, Gmane}, from which they can be read with a web
@c browser, using an NNTP news reader, or via RSS feeds.  See
@c @uref{http://dir.gmane.org/@/index.php?prefix=gmane.comp.lang.r.}@: for
@c the available mailing lists, and @uref{http://www.gmane.org/rss.php} for
@c details on RSS feeds.
R project의 메일링 리스트들의 대부분은 또한 NNTP 뉴스리더를 이용하는 웹브라우저를 이용하여 읽을 수 있는 @url{http://gmane.org, Gmane} 또는 RSS 피드를 통해서 이용할 수 있습니다.
사용가능한 메일링 리스트들에 대해서는 @uref{http://dir.gmane.org/@/index.php?prefix=gmane.comp.lang.r.}에서 확인하시길 바라며, RSS 피드에 대한 더 자세한 사항들은 @uref{http://www.gmane.org/rss.php}에서 확인부탁드립니다.

@node What is CRAN?, Can I use R for commercial purposes?, What mailing lists exist for R?, R Basics
@c @section What is @acronym{CRAN}?
@section @acronym{CRAN}이란 무엇인가요?

@c The ``Comprehensive R Archive Network'' (@CRAN{}) is a collection of
@c sites which carry identical material, consisting of the R
@c distribution(s), the contributed extensions, documentation for R, and
@c binaries.
``Comprehensive R Archive Network'' (@CRAN{})은 R 배포판, 기여된 확장 프로그램들 (즉, 패키지들), R과 관련된 문서들, 그리고 바이너리들로 구성되어 있는 동일한 자료들을 전달하는 사이트들의 모음을 의미합니다.

@c The @CRAN{} master site at Wirtschaftsuniversit@"at Wien, Austria, can
@c be found at the @acronym{URL}
다음의 @acronym{URL}로부터 오스트리아(Austria) 빈(Wien) Wirtschaftsuniversit@"에서 @CRAN{} 마스터 사이트를 찾을 수 있습니다.

@quotation
@c @multitable @columnfractions .45 .30
@c @item
@url{http://CRAN.R-project.org/}
@c @tab (Austria)
@c @end multitable
@end quotation

@noindent
@c (which is the same as @url{http://cran.at.R-project.org/})
@c Daily mirrors are available at @acronym{URL}s including
데일리 미러(daily mirrors)들은 @acronym{URL}에서 찾을 수 있습니다.

@quotation
@multitable @columnfractions .45 .40
@item @url{http://cran.at.R-project.org/}
@tab (WU Wien, Austria)
@item @url{http://cran.au.R-project.org/}
@tab (PlanetMirror, Australia)
@item @url{http://cran.br.R-project.org/}
@tab (Universidade Federal do Paran@'a, Brazil)
@item @url{http://cran.ch.R-project.org/}
@tab (ETH Z@"urich, Switzerland)
@item @url{http://cran.dk.R-project.org/}
@tab (SunSITE, Denmark)
@item @url{http://cran.es.R-project.org/}
@tab (Spanish National Research Network, Madrid, Spain)
@item @url{http://cran.fr.R-project.org/}
@tab (INRA, Toulouse, France)
@c @item @url{http://cran.hu.R-project.org/}
@c @tab (Semmelweis U, Hungary)
@item @url{http://cran.pt.R-project.org/}
@tab (Universidade do Porto, Portugal)
@item @url{http://cran.uk.R-project.org/}
@tab (U of Bristol, United Kingdom)
@c @item @url{http://cran.us.R-project.org/}
@c @tab (pair Networks, USA)
@item @url{http://cran.za.R-project.org/}
@tab (Rhodes U, South Africa)
@end multitable
@end quotation

@noindent
@c See @url{http://CRAN.R-project.org/mirrors.html} for a complete list of
@c mirrors.  Please use the @CRAN{} site closest to you to reduce network
@c load.
미러들의 모든 목록에 대해서는 @url{http://CRAN.R-project.org/mirrors.html} 를 참고해주세요.
네트워크 부담을 줄이기 위해서 현재 접속하고 계신 위치에서 가장 가까운 위치에 있는 @CRAN{} 사이트를 이용해주세요.

@c From @CRAN{}, you can obtain the latest official release of R, daily
@c snapshots of R (copies of the current source trees), as gzipped and
@c bzipped tar files, a wealth of additional contributed code, as well as
@c prebuilt binaries for various operating systems (Linux, Mac OS Classic,
@c Mac OS X, and MS Windows).  @CRAN{} also provides access to
@c documentation on R, existing mailing lists and the R Bug Tracking
@c system.

@CRAN{}으로부터 R의 가장 최신 공식 릴리즈, R의 데일리 스냅샷 (현재 소스트리의 복사본), gzip과 bzip으로 압축된 tar 파일들, 추가적으로 기여된 코드들, Linux, Mac OS Classic, Mac OS X, 그리고 MS Windows와 같은 다양한 운영체제를 위하여 미리 빌드된 바이너리들을 얻을 수 있습니다.
@CRAN{}은 또한 R 문서들, 메일링 리스트들, 그리고 버그트랙킹 시스템에 접근할 수 있도록 해줍니다.

@c To ``submit'' to @CRAN{}, check that your submission meets the
@c @url{http://CRAN.R-project.org/web/packages/policies.html, CRAN
@c Repository Policy}, upload to @url{ftp://CRAN.R-project.org/incoming/}
@c and send an email to @email{CRAN@@R-project.org}.  Note that @CRAN{}
@c generally does not accept submissions of precompiled binaries due to
@c security reasons.  In particular, binary packages for Windows and Mac OS
@c X are provided by the respective binary package maintainers.
@CRAN{}에 ``submit''(제출)하기 위해서는 사용자의 제출(submission)이 @url{http://CRAN.R-project.org/web/packages/policies.html, CRAN Repository Policy}에 부합하는지 먼저 확인을 해야 합니다.
그리고, @url{ftp://CRAN.R-project.org/incoming/}에 내용을 올려 놓은 후 @email{CRAN@@R-project.org}로 이메일을 보내주셔야 합니다. 
@CRAN{}은 일반적으로 보안적인 문제로 인하여 미리 컴파일된 바이너리를 수용하지 않습니다. 
특히, Windows와 Mac OS X를 위한 바이너리 패키지들은 바이너리 패키지 메인테이너들에 의해서 제공됩니다.

@quotation Note
@c It is very important that you indicate the copyright (license)
@c information (@acronym{GPL-2}, @acronym{GPL-3}, @acronym{BSD}, Artistic,
@c @dots{}) in your submission.
카피라이트 (라이센스) 정보 (@acronym{GPL-2}, @acronym{GPL-3}, @acronym{BSD}, Artistic, @dots{})를 함께 제공하는 것은 매우 중요합니다. 
@end quotation

@c Please always use the @acronym{URL} of the master site when referring to
@c @CRAN{}.
@CRAN{}을 가리킬 때에는 꼭 마스터 사이트의 @acronym{URL}을 사용하시길 바랍니다.

@node Can I use R for commercial purposes?, Why is R named R?, What is CRAN?, R Basics
@c @section Can I use R for commercial purposes?
@section R을 상업적 용도로 사용할 수 있나요?

@c start from this point next time 
@c start from this point next time 
@c start from this point next time 
@c start from this point next time 

@c R is released under the
@c @url{http://www.gnu.org/licenses/old-licenses/gpl-2.0.html,,
@c @acronym{GNU} General Public License (@acronym{GPL}), version 2}.  If
@c you have any questions regarding the legality of using R in any
@c particular situation you should bring it up with your legal counsel.  We
@c are in no position to offer legal advice.
R은 @url{http://www.gnu.org/licenses/old-licenses/gpl-2.0.html,, @acronym{GNU} General Public License (@acronym{GPL}), version 2}를 이용하여 릴리즈 됩니다.
만약, 어떤 특정한 상황에서 R을 사용하는 것이 합법적인가에 대한 의구심이 생길 경우, 반드시 전문 법률상담가와 상의하시길 바랍니다.
우리는 법적 조언을 줄 수 있는 그 어떠한 위치에 있지 않습니다.

@c It is the opinion of the R Core Team that one can use R for commercial
@c purposes (e.g., in business or in consulting).  The @acronym{GPL}, like
@c all Open Source licenses, permits all and any use of the package.  It
@c only restricts distribution of R or of other programs containing code
@c from R.  This is made clear in clause 6 (``No Discrimination Against
@c Fields of Endeavor'') of the
@c @url{http://www.opensource.org/docs/definition.html, Open Source
@c Definition}:
R Core Team은 R 을 상업적 목적 (즉, 비지니스 혹은 컨설팅)으로 사용할 수 있다고 생각합니다. 
모든 종류의 오픈소스의 라이센스들과 같이 @acronym{GPL}은 패키지들의 모든 그리고 어떠한 용도로 사용되는 것을 허용합니다. 
이것은 오로지 R 혹은 R 코드의 일부분을 포함하는 프로그램의 배포를 제한하는 것입니다.
이것은 @url{http://www.opensource.org/docs/definition.html, Open Source Definition}의 제 6항 (clause 6) ``No Discrimination Against Fields of Endeavor''에서 명확하게 나타납니다.

@quotation
The license must not restrict anyone from making use of the program in a
specific field of endeavor.  For example, it may not restrict the
program from being used in a business, or from being used for genetic
research.
@c 라이센스는 특정에서 프로그램을 사용하고자 하는 그 어떠한 사람들을 제약해서는 안됩니다. 
@c 예를들면, 비지니스 혹은 유전자 연구를 목적으로 하는 프로그램에서의 사용에 제한을 두지 않습니다
@end quotation

@noindent
@c It is also explicitly stated in clause 0 of the GPL, which says in part
이것 또한 GPL에 있는 제 0항 (clause 0) 에 아래와 같이 분명하게 언급되어 있습니다.

@quotation
Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of running
the Program is not restricted, and the output from the Program is
covered only if its contents constitute a work based on the Program.
@c 복사, 배포, 및 수정을 제외한 그 외의 활동들에 대해서는 본 라이센스 정책에 영향을 받지 않습니다.
@c 프로그램을 실행하는 행위는 제약받지 아니하고, 프로그램으로부터 생성된 결과물에 대해서도
@c 만약 프로그램에 기초로한 결과물들로 구성된 경우에만 그 제약을 받습니다.
@end quotation

@c Most add-on packages, including all recommended ones, also explicitly
@c allow commercial use in this way.  A few packages are restricted to
@c ``non-commercial use''; you should contact the author to clarify whether
@c these may be used or seek the advice of your legal counsel.

모든 추천패키지들을 포함하여 대부분의 애드온 패키지들 또한 이러한 방법으로 상업적인 목적으로 이용
될 수 있음을 명시하고 있습니다. 단지, 특정 패키지들만이 "비상업용적 용도"로서 그 사용을 제한하고 있습
니다. 이러한 경우에는 사용자는 반드시 저작권자에게 상업적용도로의 활용여부를 문의하거나, 법률상담가로부터의 조언을 찾아야 합니다.
이 섹션에 언급된 모든 내용은 법적조언이 아니며, R Core Team 은 어떠한 경우에도 법적조언을 하지 않
을 것입니다.

@c None of the discussion in this section constitutes legal advice.  The R
@c Core Team does not provide legal advice under any circumstances.

@node Why is R named R?, What is the R Foundation?, Can I use R for commercial purposes?, R Basics
@section Why is R named R?

@c The name is partly based on the (first) names of the first two R authors
@c (Robert Gentleman and Ross Ihaka), and partly a play on the name of the
@c Bell Labs language `S' (@pxref{What is S?}).

R 이라는 명칭은 최초로 R 을 개발한 두 개발자인 Robert Gentleman 과 Ross Ihaka 의 이름에서 기인하
기도 하며, 동시에 Bell 연구소의 'S' 라는 언어에서 영감을 받기도 하였습니다 (What is S? 라는 섹션을 참
고하세요).

@c At the time the name was coined no one expected that the software would
@c get used outside of Auckland, so it seemed ok to make a joke of it.

@node What is the R Foundation?, What is R-Forge?, Why is R named R?, R Basics
@section What is the R Foundation?

@c The R Foundation is a not for profit organization working in the public
@c interest.  It was founded by the members of the R Core Team in order to
@c provide support for the R project and other innovations in statistical
@c computing, provide a reference point for individuals, institutions or
@c commercial enterprises that want to support or interact with the R
@c development community, and to hold and administer the copyright of R
@c software and documentation.  See
@c @url{http://www.R-project.org/foundation/} for more information.

The R Foundation 은 공익을 위한 비영리단체입니다. R Core Team 의 멤버들에 의해 설립된 이 단체의
주목적은 R project 와 statistical computing 에 기여할 기술들을 지원하는 것입니다. 이것은 R 개발커뮤니
티를 지원하거나 협력관계를 맺고자 하는 개인, 기관 및 영리추구의 사업체들에게 그 기준을 제공하며, R
소프트웨어와 문서에 대한 저작권을 관리하기도 합니다. 더 자세한 사항은 http://www.R-project.org
/foundation/ 을 참고하기 바랍니다.



@node What is R-Forge?,  , What is the R Foundation?, R Basics
@section What is R-Forge?

@c R-Forge (@url{http://R-Forge.R-project.org/}) offers a central platform
@c for the development of R packages, R-related software and further
@c projects.  It is based on @url{http://www.gforge.org/, GForge} offering
@c easy access to the best in SVN, daily built and checked packages,
@c mailing lists, bug tracking, message boards/forums, site hosting,
@c permanent file archival, full backups, and total web-based
@c administration.  For more information, see the R-Forge web page and
@c Stefan Theu@ss{}l and Achim Zeileis (2009), ``Collaborative software
@c development using R-Forge'', @url{http://journal.R-project.org/, ,
@c @emph{The R Journal}}, @strong{1}(1):9--14.


R-Forge (http://R-Forge.R-project.org/) 는 R 패키지 및 연관소프트웨어 개발, 그리고 다양한 프로젝
트들을 자유롭게 발전할 수 있도록 해주는 중요한 개발환경을 제공하는 공간입니다. SVN 에 최적화된 손
쉬운 접근, 나날이 구축되고 체크되어지는 패키지들, 메일링 리스트, 버그트래킹, 그리고 메시지보드와 포
럼공간, 사이트 호스팅, 영구파일저장공간, 안정적인 백업, 그리고 웹기반의 관리 등의 기능을 제공하는
GForge 를 기초로 운영됩니다. 더 자세한 사항은 R-Forge 웹사이트와 Stefan Theusl 과 Achim Zeileis
(2009) "Collaborative software development using R-Forge", The R Journal, 1(1):9-14 를 참고해주세
요.

@node R and S, R Web Interfaces, R Basics, Top
@chapter R and S

@menu
* What is S?::                  
* What is S-PLUS?::             
* What are the differences between R and S?::  
* Is there anything R can do that S-PLUS cannot?::  
* What is R-plus?::             
@end menu

@node What is S?, What is S-PLUS?, R and S, R and S
@section What is S?

@c S is a very high level language and an environment for data analysis and
@c graphics.  In 1998, the Association for Computing Machinery
@c (@acronym{ACM}) presented its Software System Award to John M. Chambers,
@c the principal designer of S, for

S 는 데이터 분석과 그래픽스를 위한 하이레벨 언어 (high level language) 이며 환경입니다. Association
for Computing Machinery (ACM) 은 S 언어(S 시스템은 오랜 시간동안 사람들이 데이터를 분석하고, 시
각화하며, 다양화 하는 방법을 변화시켜오고 있다) 의 설계자인 John M. Chambers 에게 아래와 같이 치하
하고 상을 수여하였습니다.

@quotation
the S system, which has forever altered the way people analyze,
visualize, and manipulate data @dots{}

S is an elegant, widely accepted, and enduring software system, with
conceptual integrity, thanks to the insight, taste, and effort of John
Chambers.
@end quotation

@c The evolution of the S language is characterized by four books by John
@c Chambers and coauthors, which are also the primary references for S.
S을 중요하게 추천하고 있는 Chambers 와 coauthors에 의해
발간된 네 가지의 책들은 S 언어의 혁명을 특징적으로 묘사하고 있습니다.

@itemize @bullet
@item
Richard A. Becker and John M. Chambers (1984), ``S.  An Interactive
Environment for Data Analysis and Graphics,'' Monterey: Wadsworth and
Brooks/Cole.

This is also referred to as the ``@emph{Brown Book}'', and of historical
interest only.

@item
Richard A. Becker, John M. Chambers and Allan R. Wilks (1988), ``The New
S Language,'' London: Chapman & Hall.

This book is often called the ``@emph{Blue Book}'', and introduced what
is now known as S version 2.

@item
John M. Chambers and Trevor J. Hastie (1992), ``Statistical Models in
S,''  London: Chapman & Hall.

This is also called the ``@emph{White Book}'', and introduced S version
3, which added structures to facilitate statistical modeling in S.

@item
John M. Chambers (1998), ``Programming with Data,'' New York: Springer,
ISBN 0-387-98503-4
(@url{http://cm.bell-labs.com/cm/ms/departments/sia/Sbook/}).

This ``@emph{Green Book}'' describes version 4 of S, a major revision of
S designed by John Chambers to improve its usefulness at every stage of
the programming process.
@end itemize

See @url{http://cm.bell-labs.com/cm/ms/departments/sia/S/history.html}
for further information on ``Stages in the Evolution of S''.

There is a huge amount of user-contributed code for S, available at the
@url{http://lib.stat.cmu.edu/S/, S Repository} at @acronym{CMU}.

@c The @url{http://lib.stat.cmu.edu/S/faq, ``Frequently Asked Questions
@c about S''} contains further information about S, but is not
@c up-to-date.

@node What is S-PLUS?, What are the differences between R and S?, What is S?, R and S
@section What is @sc{S-Plus}?

@c @SPLUS{} is a value-added version of S sold by
@c @url{http://www.insightful.com, Insightful Corporation}, which in 2008
@c was acquired by @url{http://www.tibco.com/, TIBCO Software Inc}.  See
@c the @url{http://www.insightful.com/products/splus/, Insightful @SPLUS{}
@c page} and the
@c @url{http://spotfire.tibco.com/Products/S-Plus-Overview.aspx, , TIBCO
@c Spotfire S+ Products page} for further information.

S-PLUS는 TIBCO Software Inc.에서 2008년에 인수한Insightful Corporation에서 판매하는 S의 value-added 버전 입니다.  더 많은 정보를 원하시면 Insightful S-PLUS 페이지와 TIBCO Spotfire S+ 제품 페이지를 참조하십시오. 

@node What are the differences between R and S?, Is there anything R can do that S-PLUS cannot?, What is S-PLUS?, R and S
@section What are the differences between R and S?

@c We can regard S as a language with three current implementations or
@c ``engines'', the ``old S engine'' (S version 3; @SPLUS{} 3.x and 4.x),
@c the ``new S engine'' (S version 4; @SPLUS{} 5.x and above), and R.
@c Given this understanding, asking for ``the differences between R and S''
@c really amounts to asking for the specifics of the R implementation of
@c the S language, i.e., the difference between the R and S @emph{engines}.

@c For the remainder of this section, ``S'' refers to the S engines and not
@c the S language.

S를 세가지의 현재 실행 언어 혹은 “engines”, “old S engine” (S version 3; S-Plus 3.x and 4.x), “new S engine” (S version 4; S-Plus 5.x 혹은 그 이후의 버전), 그리고  R로 생각 할 수 있습니다. 이 지식들을 사용하여, “R과 S의 다른점들”을 물어보는 것은 S 언어의 R 실행의 구체적인 것, 즉 R과 S engine들의 다른점들을 물어보는 것에 해당합니다.
이 섹션의 끝으로, “S”는 S engine을 나타내는 것이지 S 언어를 뜻 하는 것이 아닙니다. 



@menu
* Lexical scoping::             
* Models::                      
* Others::                      
@end menu

@node Lexical scoping, Models, What are the differences between R and S?, What are the differences between R and S?
@subsection Lexical scoping

@c Contrary to other implementations of the S language, R has adopted an
@c evaluation model in which nested function definitions are lexically
@c scoped.  This is analogous to the evaluation model in Scheme.

@c This difference becomes manifest when @emph{free} variables occur in a
@c function.  Free variables are those which are neither formal parameters
@c (occurring in the argument list of the function) nor local variables
@c (created by assigning to them in the body of the function).  In S, the
@c values of free variables are determined by a set of global variables
@c (similar to C, there is only local and global scope).  In R, they are
@c determined by the environment in which the function was created.

S언어의 다른 실행들과는 다르게, R은 nested 함수 정의들이 사전적으로 정의된 평가 모델을 채택 했습니다. 
이는 Scheme의 평가 모델과 유사합니다. 
이 차이점은 free variable들이 함수에서 발생할 때 분명해 집니다. 
Free variable들은  전의 parameter (함수의 argument list에서 발생하는)들도 아닐 뿐더러 local variable (함수의 body에 이들을 배치함으로써 생겨나는)들도 아닙니다. 
S에서, free variable들의 값들은 global variable 세트에 의하여 정해집니다 (C와 마찬가지로, 여기에도 local과 global scope만이 존재합니다) .
R에서는 이들은 함수가 생성된 환경에 의하여 결정됩니다. 

@c Consider the following function:
다음의 함수를 보십시오:

@example
@group
cube <- function(n) @{
  sq <- function() n * n
  n * sq()
@}
@end group
@end example

@c Under S, @code{sq()} does not ``know'' about the variable @code{n}
@c unless it is defined globally:
S에서, sq()는 variable n이 global하게 정의되지 않은 이상 variable n을 알지 못합니다: 

@example
@group
S> cube(2)
Error in sq():  Object "n" not found
Dumped
S> n <- 3
S> cube(2)
[1] 18
@end group
@end example

@c In R, the ``environment'' created when @code{cube()} was invoked is
@c also looked in:
R에서는, “environment(환경)”은  cube()가 적용되었을 때 생성되며 아래에서도 찾을 수 있습니다: 

@example
@group
R> cube(2)
[1] 8
@end group
@end example

@c The following more `realistic' example illustrating the differences in
@c scoping is due to @email{tlumley@@u.washington.edu, Thomas Lumley}.
@c The function

@c @example
@c jackknife.lm <- function(lmobj) @{
@c   n <- length(resid(lmobj))
@c   jval <- sapply(1:n, function(i) coef(update(lmobj, subset = -i)))
@c   (n - 1) * (n - 1) * var(jval) / n
@c @}
@c @end example

@c @noindent
@c does something useful in R, but does not work in S.  In order to make it
@c work in S you need to explicitly pass the linear model object into the
@c function nested in @code{apply()}.  If you don't and you are lucky you
@c will get @samp{Error: Object "lmobj" not found}.  If you are unlucky
@c enough to have a linear model called @code{lmobj} in your global
@c environment you will get the wrong answer with no warning.

@c The following version works in S.

@c @example
@c jackknife.S.lm <- function(lmobj) @{
@c   n <- length(resid(lmobj))
@c   jval <- sapply(1:n,
@c                  function(i, lmobj) coef(update(lmobj, subset = -i)), 
@c                  lmobj = lmobj)
@c   (n - 1) * (n - 1) * var(jval) / n
@c @}
@c @end example

@c (The S version was written independently by Thomas and at least three of
@c his fellow students over the past couple of years, causing literally
@c hours of confusion on each occasion.)

@c As a more ``interesting'' real-world problem, suppose you want to write
@c a function which returns the density function of the @math{r}-th order
@c statistic from a sample of size @math{n} from a (continuous)
@c distribution.  For simplicity, we shall use both the cdf and pdf of the
@c distribution as explicit arguments.  (Example compiled from various
@c postings by Luke Tierney.)

더욱 “흥미로운” 실전 문제로, (연속) 분포도에서의 sample size n에서 r번째 order statistic의 밀도 함수를 구하는 함수를 쓰고 싶다고 가정해 봅니다. 
간단하게하기위해서는, cdf 와 pdf  두 가지 모두를 explicit argument로  써야 할 것입니다. ( 예시는 Luke Tierney의 여러가지 포스팅에서 수집 하였습니다)

@c The @SPLUS{} documentation for @code{call()} basically suggests the
@c following:
call()을 위한S-Plus 문서는 기본적으로 다음을 제시합니다: 

@example
@group
dorder <- function(n, r, pfun, dfun) @{
  f <- function(x) NULL
  con <- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
  PF <- call(substitute(pfun), as.name("x"))
  DF <- call(substitute(dfun), as.name("x"))
  f[[length(f)]] <-
    call("*", con,
         call("*", call("^", PF, r - 1),
              call("*", call("^", call("-", 1, PF), n - r),
                   DF)))
  f
@}
@end group
@end example

@c @noindent Rather tricky, isn't it?  The code uses the fact that in S,
@c functions are just lists of special mode with the function body as the
@c last argument, and hence does not work in R (one could make the idea
@c work, though).

헷갈리지 않습니까? 이 코드들은 S의 fact를 사용하고, 함수들은 마지막 argument같은 함수의 body와 special mode의 목록일 뿐이며, 그러므로 R에서는 작동하지 않습니다 (아이디어는 쓸 수 있을지도 모릅니다).

@c A version which makes heavy use of @code{substitute()} and seems to work
@c under both S and R is
S와 R 두 개 모두에서 작동하는 것 처럼 보이는substitute()의 사용빈도가 높은 버전은

@example
@group
dorder <- function(n, r, pfun, dfun) @{
  con <- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
  eval(substitute(function(x) K * PF(x)^a * (1 - PF(x))^b * DF(x),
                  list(PF = substitute(pfun), DF = substitute(dfun),
                       a = r - 1, b = n - r, K = con)))
@}
@end group
@end example

@c @noindent
@c (the @code{eval()} is not needed in S).
(S 에서는 eval() 이 필요하지 않습니다). 


@c However, in R there is a much easier solution:
하지만, R에는 더욱 쉬운 해결책이 있습니다:

@example
@group
dorder <- function(n, r, pfun, dfun) @{
  con <- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
  function(x) @{
    con * pfun(x)^(r - 1) * (1 - pfun(x))^(n - r) * dfun(x)
  @}
@}
@end group
@end example

@noindent
@c This seems to be the ``natural'' implementation, and it works because
@c the free variables in the returned function can be looked up in the
@c defining environment (this is lexical scope).

이는 “자연스러운” 실행처럼 보이고, 지정된 환경에서 returned 함수의 free variable들을 찾을 수 있기 때문에 작동합니다 (이것이 lexical scope입니다). 

@c Note that what you really need is the function @emph{closure}, i.e., the
@c body along with all variable bindings needed for evaluating it.  Since
@c in the above version, the free variables in the value function are not
@c modified, you can actually use it in S as well if you abstract out the
@c closure operation into a function @code{MC()} (for ``make closure''):

함수 closure이 당신이 진정으로 필요한 것이라는 것을 유의하십시오.  즉, 이를 평가하기위한 모든 variable binding들이 있는 body. 위의 버전에서는 value 함수안의 free variable들이 변경되지 않았기 때문에, 이를 S에서 쓸 수 있을 뿐만 아니라, 만약 closure operation에서 mc() 함수로 요약한다면: 


@example
@group
dorder <- function(n, r, pfun, dfun) @{
  con <- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
  MC(function(x) @{
       con * pfun(x)^(r - 1) * (1 - pfun(x))^(n - r) * dfun(x)
     @},
     list(con = con, pfun = pfun, dfun = dfun, r = r, n = n))
@}
@end group
@end example

@c Given the appropriate definitions of the closure operator, this works in
@c both R and S, and is much ``cleaner'' than a substitute/eval solution
@c (or one which overrules the default scoping rules by using explicit
@c access to evaluation frames, as is of course possible in both R and S).

적합한 closure operator의 정의에 의하면, 이는 R과 S 모두에서 작동하고, substitute/eval 보다 “깨끗한” 해결책입니다 (혹은 R과 S에서 확실히 가능한, evaluation frame에 explicit access를 사용하여 기본 scoping rule들을 무효화 시키는 것). 

@c For R, @code{MC()} simply is
R 에서, 간단하게 MC()는

@example
MC <- function(f, env) f
@end example

@noindent (lexical scope!), a version for S is

@example
@group
MC <- function(f, env = NULL) @{
  env <- as.list(env)
  if (mode(f) != "function")
    stop(paste("not a function:", f))
  if (length(env) > 0 && any(names(env) == ""))
    stop(paste("not all arguments are named:", env))
  fargs <- if(length(f) > 1) f[1:(length(f) - 1)] else NULL
  fargs <- c(fargs, env)
  if (any(duplicated(names(fargs))))
    stop(paste("duplicated arguments:", paste(names(fargs)),
         collapse = ", "))
  fbody <- f[length(f)]
  cf <- c(fargs, fbody)
  mode(cf) <- "function"
  return(cf)
@}
@end group
@end example

@c Similarly, most optimization (or zero-finding) routines need some
@c arguments to be optimized over and have other parameters that depend on
@c the data but are fixed with respect to optimization.  With R scoping
@c rules, this is a trivial problem; simply make up the function with the
@c required definitions in the same environment and scoping takes care of
@c it.  With S, one solution is to add an extra parameter to the function
@c and to the optimizer to pass in these extras, which however can only
@c work if the optimizer supports this.

마찬가지로, 대부분이 optimization(혹은 zero-finding) routine들은 optimize되고 데이타에는 의존하지만, optimization에 관해서는 고정된 다른 parameter들을 가진 argument들이 필요합니다. R scoping 룰들로, 이는 대수롭지 않은 문제입니다; 간단하게 같은 환경에서 필요한 정의들로 함수를 만들면 scoping이 알아서 처리를 합니다. S로는, 한가지 방법으로, 함수와 extra parameter들을 전달하기위한 optimizer에 하나의 extra parameter를 더하는 것인데, 이는 optimizer가 이를 지원할 때만 작동합니다.

@c Nested lexically scoped functions allow using function closures and
@c maintaining local state.  A simple example (taken from Abelson and
@c Sussman) is obtained by typing @kbd{demo("scoping")} at the R prompt.
@c Further information is provided in the standard R reference ``R: A
@c Language for Data Analysis and Graphics'' (@pxref{What documentation
@c exists for R?}) and in Robert Gentleman and Ross Ihaka (2000), ``Lexical
@c Scope and Statistical Computing'',
@c @url{http://www.amstat.org/publications/jcgs/, , @emph{Journal of
@c Computational and Graphical Statistics}}, @strong{9}, 491--508.

Nested lexically scoped 함수들은 function closure들의 사용과 local state을 유지하는 것을 허용합니다. 간단한 예로 (Abelson and Sussman에서 인용) R prompt에서 demo(“scoping”)를 입력 함으로써 얻어지는 것입니다. 더 자세한 정보는 기본 R reference의 “R: A Language for Data Analysis and Graphics” (What documentation exists for R을 참고하십시오)와 Robert Gentleman and Ross Ihaka (2000)의 “Lexical Scope and Statistical Computing”,   Journal of Computational and Graphical Statistics, 9, 491–508 를 참고하십시오. 


@c Nested lexically scoped functions also imply a further major difference.
@c Whereas S stores all objects as separate files in a directory somewhere
@c (usually @file{.Data} under the current directory), R does not.  All
@c objects in R are stored internally.  When R is started up it grabs a
@c piece of memory and uses it to store the objects.  R performs its own
@c memory management of this piece of memory, growing and shrinking its
@c size as needed.  Having everything in memory is necessary because it is
@c not really possible to externally maintain all relevant ``environments''
@c of symbol/value pairs.  This difference also seems to make R
@c @emph{faster} than S.

Nested lexically scoped 함수들은 더 큰 차이도 의미합니다. S가 모든 object들을 하나의 directory 어딘가에 (보통 현재 directory의  .Data) 다른 파일들로 저장하는 반면, R은 그렇지 않습니다. R에 있는 모든 object들은 내부로 저장 됩니다. R이 시작되면 이는 memory의 조각을 붙잡고 object들을 저장하는데 사용합니다. R은 필요한대로 사이즈를 늘리고 줄이며이 memory 조각들의 memory 관리를 실행합니다. Symbol/ value pair들의 모든 관련된 “환경들”을 externally 유지하는것이 거의 가능하지 않기 때문에, memory에 모든것을 가지고 있는 것이 필요합니다. 이 다른점 또한 R이 S보다 빠르게 만드는것 처럼 보입니다. 

@c The down side is that if R crashes you will lose all the work for the
@c current session.  Saving and restoring the memory ``images'' (the
@c functions and data stored in R's internal memory at any time) can be a
@c bit slow, especially if they are big.  In S this does not happen,
@c because everything is saved in disk files and if you crash nothing is
@c likely to happen to them.  (In fact, one might conjecture that the S
@c developers felt that the price of changing their approach to persistent
@c storage just to accommodate lexical scope was far too expensive.)
@c Hence, when doing important work, you might consider saving often (see
@c @ref{How can I save my workspace?}) to safeguard against possible
@c crashes.  Other possibilities are logging your sessions, or have your R
@c commands stored in text files which can be read in using
@c @code{source()}.

불리한 점은 만약 R이 crash되면 지금 현재 세션의 모든 work를 잃게 될 것입니다. Memory “이미지” (R의 internal memory에 at any time 저장된 함수들과 데이터)를 저장하고 복원하는것이, 특히 이들의 크기가 크면, 약간 느릴 수도 있습니다. S에서는 이 같은 것이 일어나지 않는데, 이는 모든 것이 디스크 파일에 저장되어있고 crash가 거의 일어나지 않습니다.(의역) (사실적으로, 누군가는 S 개발자들이 lexical scope를 수용하기 위해서만 persistent storage로의 그들의 접근방법을 바꾸는 것의 가격이 너무 비싸다고 느꼈다고 추측할 수 있습니다.) 그래서, 중요한 일을 할 때에는, 가능한 crash들에서 안전하기 위해 저장을 자주하는 것 (How can I save my workspace?를 참조)을 고려할 수도 있습니다. 다른 가능성으로는 세션을 logging하거나 R 명령어들을 source()를 사용하여 읽을 수 있는 텍스트 파일로 저장하는 것 입니다

@c @quotation Note
@c If you run R from within Emacs (see @ref{R and Emacs}), you can save the
@c contents of the interaction buffer to a file and conveniently manipulate
@c it using @code{ess-transcript-mode}, as well as save source copies of
@c all functions and data used.
@c @end quotation

Note: 만약 Emacs (R and Emacs를 참조) 안에서 R을 실행한다면, interaction buffer의 content들을 파일로 저장하고 편리하게 이를 ess-transcript-mode를 사용하여 조작할 수 있고, 사용된 모든 함수들과 데이터의 source copy들을 저장할 수 있습니다. 

@node Models, Others, Lexical scoping, What are the differences between R and S?
@subsection Models

@c There are some differences in the modeling code, such as

Modeling 코드에는 몇가지의 다른점들이 있습니다. 예를 들어, 

@itemize @bullet
@item
@c Whereas in S, you would use @code{lm(y ~ x^3)} to regress @code{y} on
@c @code{x^3}, in R, you have to insulate powers of numeric vectors (using
@c @code{I()}), i.e., you have to use @code{lm(y ~ I(x^3))}.
S에서는 y를 x^3에 regress하기위해lm(y ~ x^3)를 사용하는 반면, R에서는 (I()를 사용한) 숫자 벡터들의 파워를 격리시켜주어야만 합니다. 즉, lm(y ~ I(x^3))를 사용해야 합니다.

@item
@c The glm family objects are implemented differently in R and S.  The same
@c functionality is available but the components have different names.

glm family object들은 R과 S에서 다르게 실행됩니다. 같은 기능이 있기는 하지만 component들은 다른 이름드을 가지고 있습니다. 

@item
@c Option @code{na.action} is set to @code{"na.omit"} by default in R,
@c but not set in S.

옵션na.action가 R에서는 기본값으로 "na.omit"로 설정되지만, S에서는 설정되지 않습니다. 

@item
@c Terms objects are stored differently.  In S a terms object is an
@c expression with attributes, in R it is a formula with attributes.  The
@c attributes have the same names but are mostly stored differently.
Terms object들이 다르게 저장됩니다. S에서 Terms object는 attribute들이 있는 표현이고, R에서는 attribute들이 있는 식입니다. attribute들은 같은 이름들을 가지고 있지만 대부분 다르게 저장됩니다.

@item
@c Finally, in R @code{y ~ x + 0} is an alternative to @code{y ~ x - 1} for
@c specifying a model with no intercept.  Models with no parameters at all
@c can be specified by @code{y ~ 0}.

 마지막으로, R에서y ~ x + 0는 절편이 없는 모델을 명시하기위한y ~ x – 1 대체입니다. parameter들이 없는 모델은 모두 y ~ 0로 명시될 수 있습니다. 

@end itemize

@node Others,  , Models, What are the differences between R and S?
@subsection  Others

@c Apart from lexical scoping and its implications, R follows the S
@c language definition in the Blue and White Books as much as possible, and
@c hence really is an ``implementation'' of S.  There are some intentional
@c differences where the behavior of S is considered ``not clean''.  In
@c general, the rationale is that R should help you detect programming
@c errors, while at the same time being as compatible as possible with S.

Lexical scoping과 그에 연관 된 것들을 떠나서, R은 Blue and White Books의 S 언어 정의를 가능한한 많이 따고, 그렇기 때문에 사실상은 S의 “실행” 입니다. S의 behaviour이 “깨끗하지 않다고: 간주되는 곳에는 의도되는 다른 점들이 있습니다. 일반적으로, R은 당신이 같은 시간동안 S와 호환하면서 프로그래밍 에러를 발견하도록 도와주는 것입니다. 


@c Some known differences are the following.
몇가지의 알려진 다른 점들이 아래에 설명되어 있습니다. 

@itemize @bullet

@item
@c In R, if @code{x} is a list, then @code{x[i] <- NULL} and @code{x[[i]]
@c <- NULL} remove the specified elements from @code{x}.  The first of
@c these is incompatible with S, where it is a no-op.  (Note that you can
@c set elements to @code{NULL} using @code{x[i] <- list(NULL)}.)

 R에서, 만약 x가 목록 형태라면, x[i] <- NULL 과 x[[i]] <- NULL는 x에서 지정된 element들을 없앱니다. 이 중 첫번째는 no-op인 곳에서 S와 호환하지 않습니다. (element를 x[i] <- list(NULL)를 사용하여NULL 지정할 수 있다는 것을 유의하십시오.)

@c @item
@c In R @code{x[-4]} fails if @code{x} is not @code{NULL} but has fewer
@c than 4 elements.  In S it has no effect.

@item
@c In S, the functions named @code{.First} and @code{.Last} in the
@c @file{.Data} directory can be used for customizing, as they are executed
@c at the very beginning and end of a session, respectively.
S에서, .Data 디렉토리 안에서 .First 와 .Last로 이름이 지어진 함수들은 순서대로 세션의 제일 시작과 맨 끝에서 실행될 때 customizing을 위해 사용될 수 있습니다. 

@c In R, the startup mechanism is as follows.  Unless @option{--no-environ}
@c was given on the command line, R searches for site and user files to
@c process for setting environment variables.  Then, R searches for a
@c site-wide startup profile unless the command line option
@c @option{--no-site-file} was given.  This code is loaded in package
@c @pkg{base}.  Then, unless @option{--no-init-file} was given, R
@c searches for a user profile file, and sources it into the user
@c workspace.  It then loads a saved image of the user workspace from
@c @file{.RData} in case there is one (unless @option{--no-restore-data} or
@c @option{--no-restore} were specified).  Next, a function @code{.First()}
@c is run if found on the search path.  Finally, function @code{.First.sys}
@c in the @pkg{base} package is run.  When terminating an R session, by
@c default a function @code{.Last} is run if found on the search path,
@c followed by @code{.Last.sys}.  If needed, the functions @code{.First()}
@c and @code{.Last()} should be defined in the appropriate startup
@c profiles.  See the help pages for @code{.First} and @code{.Last} for
@c more details.

R에서, startup mechanism은 다음과 같습니다. --no-environ이 명령줄에 주어지지 않은 이상, R은 environment variable들을 지정하기위한 프로세스를 하기위해 사이트와 사용자 파일을 검색합니다. 그리고나서 R은 명령줄 옵션--no-site-file가 주어지지 않은 이상 사이트 전체의 시작 프로필을 검색합니다. 이 코드는 base 패키지에 로드되어 있습니다. 그리고나서, --no-init-file가 주어지지 않은 이상, R은 사용자 프로필 파일을 검색하고, 그것을 사용자 workspace로 공급합니다.  그리고나서 그것은 있을 경우를 대비하여 .RData로부터 사용자 workspace의 저장된 이미지로 로드합니다 (--no-restore-data 혹은 --no-restore 가 명시되지 않은 이상). 그 다음, .First() 함수는 검색 경로에서 찾아지면 실행 됩니다. 마지막으로, base 패키지의.First.sys 함수가 실행됩니다. R 세션이 종료되면, .Last.sys 다음에 만약 검색 경로에서 찾아진다면 기본 함수 .Last가 실행됩니다. 만약 필요하다면, 함수.First() 와 .Last()는 적절한 startup 프로필들에서 정의되어야만 할 것입니다. 더 많은 정보는 help 페이지에서 .First 와 .Last를 참고하십시오.


@item
@c In R, @code{T} and @code{F} are just variables being set to @code{TRUE}
@c and @code{FALSE}, respectively, but are not reserved words as in S and
@c hence can be overwritten by the user.  (This helps e.g.@: when you have
@c factors with levels @code{"T"} or @code{"F"}.)  Hence, when writing code
@c you should always use @code{TRUE} and @code{FALSE}.

R에서, T와 F는, 순서대로, TRUE와 FALSE로 지정되는 값이지만, S에서는 reserve된 단어는 아니기 때문에 사용자에의해 덮어쓰여질 수 있습니다. (이는 예를들어 “T” 혹은 “F”레벨들의 factor들이 있을때 도움이 됩니다.) 그러므로, 코드를 쓸때에는 항상 TRUE와 FALSE를 사용해야만 합니다. 

@item
@c In R, @code{dyn.load()} can only load @emph{shared objects}, as created
@c for example by @kbd{R CMD SHLIB}.

R에서, dyn.load()는R CMD SHLIB에의한 예제를위해 생성되었기 때문에 공유된 object들만을 로드할 수 있습니다. 

@item
@c In R, @code{attach()} currently only works for lists and data frames,
@c but not for directories.  (In fact, @code{attach()} also works for R
@c data files created with @code{save()}, which is analogous to attaching
@c directories in S.)  Also, you cannot attach at position 1.

 R에서, attach()는 현재 목록들과 데이터 프레임들에서만 실행되지만, 디렉토리들에서는 실행되지 않습니다. (실제로, attach()는S에서의 디렉토리를 첨부하는것과 유사하게, save()와 함께 생성된 R 데이터 파일들을 위해서도 실행됩니다.) 또한, position 1에는 첨부할 수 없습니다

@item
@c Categories do not exist in R, and never will as they are deprecated now
@c in S.  Use factors instead.
R에서 카테고리는 존재하지않고, S에서 되었기 때문에 앞으로도 존재하지 않을 것 입니다. 대신 factor들을 사용하십시오.

@item
@c In R, @code{For()} loops are not necessary and hence not supported.
R에서, For() loop들은 필요하지않고 그러므로 지원되지 않습니다.

@item
@c In R, @code{assign()} uses the argument @option{envir=} rather than
@c @option{where=} as in S.
R에서, assign()은  S에서와 같이 where= 보다는envir= argument를 사용합니다. 

@item
@c The random number generators are different, and the seeds have different
@c length.
랜덤 숫자 생성기들은 다르고, seed들은 다른 길이를 가지고 있습니다. 

@item
@c R passes integer objects to C as @code{int *} rather than @code{long *}
@c as in S.
R은 S에서와 같이 long* 대신 int* 처럼 정수 object들을 C로 패스합니다.

@item
@c R has no single precision storage mode.  However, as of version 0.65.1,
@c there is a single precision interface to C/@FORTRAN{} subroutines.
R은 단일 정밀도 저장 모드가 없습니다. 하지만, 0.65.1버전부터, C/FORTRAN 서브루틴들로의 단일 정밀도 인터페이스가 존재합니다. 

@item
@c By default, @code{ls()} returns the names of the objects in the current
@c (under R) and global (under S) environment, respectively.  For example,
@c given
기본값으로, ls()는 순서대로 현재 (R에서)와 global (S에서) 환경안의 object들의 이름을 return합니다. 예를들어, 

@example
x <- 1; fun <- function() @{y <- 1; ls()@}
@end example

@noindent
@c then @code{fun()} returns @code{"y"} in R and @code{"x"} (together with
@c the rest of the global environment) in S.
이 주어지면, fun()은 R에서는"y"을, S에서는"x" (나머지 global 환경과 함께)를 return합니다. 

@item
@c R allows for zero-extent matrices (and arrays, i.e., some elements of
@c the @code{dim} attribute vector can be 0).  This has been determined a
@c useful feature as it helps reducing the need for special-case tests for
@c empty subsets.  For example, if @code{x} is a matrix, @code{x[, FALSE]}
@c is not @code{NULL} but a ``matrix'' with 0 columns.  Hence, such objects
@c need to be tested for by checking whether their @code{length()} is zero
@c (which works in both R and S), and not using @code{is.null()}.

R은 zero-extent 행렬들(그리고 array들, 즉 dim attribute 벡터의 몇몇의 element들은 0가 될 수 있습니다)을 허용합니다. 이는 빈 subset에 대한 특별한 테스트들의 필요성을 줄이는데 도움을 주기때문에 유용한 기능이라고 여겨져 왔습니다. 예ㄹㄹㄷㄹ어, 만약 x가 행렬이라면, x[, FALSE]는NULL이 아니고 0 행들로 이루어진 하나의 “행렬”입니다. 그러므로, 이러한 object들은length()가 제로인지 (R과 S 둘 다에서 실행됩니다) 테스트를 해야할 필요가 있고, is.null()를 사용하지 않습니다. 

@item
@c Named vectors are considered vectors in R but not in S (e.g.,
@c @code{is.vector(c(a = 1:3))} returns @code{FALSE} in S and @code{TRUE}
@c in R).
이름이 주어진 벡터들은 R에서는 벡터로 간주되지만 S에서는 그렇지 않습니다 (예를들어, is.vector(c(a = 1:3))는 S에서는 FALSE를 R에서는 TRUE를 return합니다).

@item
@c Data frames are not considered as matrices in R (i.e., if @code{DF} is a
@c data frame, then @code{is.matrix(DF)} returns @code{FALSE} in R and
@c @code{TRUE} in S).
데이터 프레임은 R에서 행렬처럼 간주되지 않습니다 (예를들어, 만약 DF가 데이터 프레임이라면, is.matrix(DF)는 R에서는 FALSE를 S에서는 TRUE를 return합니다).

@item
@c R by default uses treatment contrasts in the unordered case, whereas S
@c uses the Helmert ones.  This is a deliberate difference reflecting the
@c opinion that treatment contrasts are more natural.
 R은 기본값으로 정렬되지 않은 경우에 treatment contrast를 사용하는반면, S는 Helmert들을 사용합니다. 이는 treatment contrast들이 더 자연수럽다는 의견이 반영된 의도된 다른점입니다. 


@item
@c In R, the argument of a replacement function which corresponds to the
@c right hand side must be named @samp{value}.  E.g., @code{f(a) <- b} is
@c evaluated as @code{a <- "f<-"(a, value = b)}.  S always takes the last
@c argument, irrespective of its name.
R에서, 오른쪽에 해당하는 치환 함수의 argument는‘value’로 이름이 지어져야만 합니다. 예를들어, f(a) <- b는 a <- "f<-"(a, value = b)처럼 평가됩니다. S는 이름에 관계없이, 항상 마지막 argument를 취합니다. 


@item
@c In S, @code{substitute()} searches for names for substitution in the
@c given expression in three places: the actual and the default arguments
@c of the matching call, and the local frame (in that order).  R looks in
@c the local frame only, with the special rule to use a ``promise'' if a
@c variable is not evaluated.  Since the local frame is initialized with
@c the actual arguments or the default expressions, this is usually
@c equivalent to S, until assignment takes place.

S에서, substitute()는 세 군데에서 주어진 표현들안의 대체할 이름들을 검색합니다: matching call의 실제와 기본 argument들, 그리고 local  프레임(순서대로). R은 만약 값이 평가되지 않았다면 “promise”를 사용하기위해 특별한 룰을 사용하여, local 프레임 안에서만 찾습니다. Local 프레임이assignment가 일어나기 전까지는 실제 argument들 혹은 기본 표현들로 초기설정 되어있지때문에, 이는 보통 S와 같습니다.

@item
@c In S, the index variable in a @code{for()} loop is local to the inside
@c of the loop.  In R it is local to the environment where the @code{for()}
@c statement is executed.

S에서는, for() loop안의 index 값이 loop안으로의 local입니다. R에서 이는 for() statement가 실행된 환경으로의 local입니다. 

@item
@c In S, @code{tapply(simplify=TRUE)} returns a vector where R returns a
@c one-dimensional array (which can have named dimnames).
S에서, tapply(simplify=TRUE)는 R이 1-차원 배열(dimnames로 이름지어졌을수도 있는)을 return한 벡터를 return합니다. 

@item
@c In S(-@sc{Plus}) the C locale is used, whereas in R the current
@c operating system locale is used for determining which characters are
@c alphanumeric and how they are sorted.  This affects the set of valid
@c names for R objects (for example accented chars may be allowed in R) and
@c ordering in sorts and comparisons (such as whether @code{"aA" < "Bb"} is
@c true or false).  From version 1.2.0 the locale can be (re-)set in R by
@c the @code{Sys.setlocale()} function.

S(-Plus)에서 C locale이 사용되는 반면, R에서는 현재 실행 시스탬 locale이 어떤 character들이 alphanumeric이고 그들이 어떻게 분류되었는지를 알아보기위해 사용됩니다. 이는 R object들의 유효한 이름들의 세트와 (예를들어 R에서 accented chars가 허용될지도 모릅니다) 분류들의 정렬 그리고 비교 ("aA" < "Bb"가 맞는지 틀린지 같은)들에 영향을 줍니다. 1.2.0버전부터 locale은 Sys.setlocale() 함수에의해 R에서 (re-)set될 수 있습니다.



@item
@c In S, @code{missing(@var{arg})} remains @code{TRUE} if @var{arg} is
@c subsequently modified; in R it doesn't.

S에서, missing(arg)은 만약 arg가 나중에 수정되면 TRUE로 남아있습니다; R에서는 그렇지 않습니다.

@item
@c From R version 1.3.0, @code{data.frame} strips @code{I()} when creating
@c (column) names.
R 버전 1.3.0에서부터, data.frame는 (행) 이름을 생성할 때I()를 분해합니다. 

@item
@c In R, the string @code{"NA"} is not treated as a missing value in a
@c character variable.  Use @code{as.character(NA)} to create a missing
@c character value.
 R에서, "NA" string은 character값에서 missing 값처럼 여겨지지 않습니다. Missing character 값을 생성할 때 as.character(NA)를 사용하십시오.

@item
@c R disallows repeated formal arguments in function calls.
R은 함수 call들에서 반복된 전 argument들을 허용하지 않습니다.

@item
@c In S, @code{dump()}, @code{dput()} and @code{deparse()} are essentially
@c different interfaces to the same code.  In R from version 2.0.0, this is
@c only true if the same @code{control} argument is used, but by default it
@c is not.  By default @code{dump()} tries to write code that will evaluate
@c to reproduce the object, whereas @code{dput()} and @code{deparse()}
@c default to options for producing deparsed code that is readable.
S에서, dump(), dput() 그리고 deparse()는 같은 코드로의 근본적으로 다른 인터페이스들 입니다. R의 버저 2.0.0 부터, 이는 만약 control argument가 사용되었을 때만 true이지만, 기본값으로는 사실이 아닙니다. 기본값으로dump()는 object를 다시 생성하기위한 평가를 할 코드를 쓰려고 노력하는반면, dput()와 deparse()는 읽혀질 수 있는 deparsed 코드를 생성하기위한 기본 옵션들 입니다. 


@item
@c In R, indexing a vector, matrix, array or data frame with @code{[} using
@c a character vector index looks only for exact matches (whereas @code{[[}
@c and @code{$} allow partial matches).  In S, @code{[} allows partial
@c matches.
R에서, character 벡터 인덱스를 사용한 [ 와 함께 벡터, 행렬, array를 인덱스 하는 것은 정확한 매치들만을 찾습니다 (반면에 [[와 $는 부분 매치를 허용합니다).

@item
@c S has a two-argument version of @code{atan} and no @code{atan2}.  A call 
@c in S such as @code{atan(x1, x2)} is equivalent to R's @code{atan2(x1, 
@c x2)}.  However, beware of named arguments since S's @code{atan(x = a, y
@c = b)} is equivalent to R's @code{atan2(y = a, x = b)} with the meanings
@c of @code{x} and @code{y} interchanged.  (R used to have undocumented
@c support for a two-argument @code{atan} with positional arguments, but
@c this has been withdrawn to avoid further confusion.)
S는 atan의 두개의 argument 버전이 있고 atan2는 없습니다. S에서의 as atan(x1, x2)와 같은 call은 R의atan2(x1, x2)와 같습니다. 하지만, x와 y가 교환 되었다는 뜻의 S의atan(x = a, y = b)이atan2(y = a, x = b)과 같으므로 이름이 주어진 argument들은 주의하십시오. (R은 위치 매개변수가 있는 두개의 argument atan을 위한 자료가 없는 지원을 하기도 했지만, 이는 더이상의 혼돈을 막기위해 제거되었습니다. 

@item
@c Numeric constants with no fractional and exponent (i.e., only integer)
@c part are taken as integer in @SPLUS{} 6.x or later, but as double in R.
분수나 지수가 없는 수치상수들 (즉, 정수들만)은S-Plus 6.x나 이후에서는 정수처럼 취해지지만, R에서는 double처럼 취해집니다. 

@end itemize

@c There are also differences which are not intentional, and result from
@c missing or incorrect code in R.  The developers would appreciate hearing
@c about any deficiencies you may find (in a written report fully
@c documenting the difference as you see it).  Of course, it would be
@c useful if you were to implement the change yourself and make sure it
@c works.
의도되지 않은 다른점들 또한 있고, 잃어버리거나 잘못된 R의 코드들로부터의 결과도 있습니다. 개발자들은 당신이 찾는 어떠한 부족한 것(당신이 보는것 처럼 다른점들에 대해 충분하게 설명된 기록된 보고서)에 대하여 듣는 것을 감사하게 여길 것 입니다. 물론, 당신이 바꾼것을 실행해보고 그것이 확실하게 실행이되는 것을 확인하면 유용할 것입니다. 


@node Is there anything R can do that S-PLUS cannot?, What is R-plus?, What are the differences between R and S?, R and S
@section Is there anything R can do that @sc{S-Plus} cannot?

@c Since almost anything you can do in R has source code that you could
@c port to @SPLUS{} with little effort there will never be much you can do
@c in R that you couldn't do in @SPLUS{} if you wanted to.  (Note that
@c using lexical scoping may simplify matters considerably, though.)

R에서 할수있는 거의 모든 것들은 약간의 노력만으로 S-Plus로 포트할 수 있는 소스 코드들이 있기때문에 S-Plus에서 하지 못했던것을 R에서 할 수 있는 것은 절대 없을 것 입니다. (lexical scoping의 사용이 문제를 상당히 단순화 시킬지도 모른다는것을 유의하십시오.)

@c R offers several graphics features that @SPLUS{} does not, such as finer
@c handling of line types, more convenient color handling (via palettes),
@c gamma correction for color, and, most importantly, mathematical
@c annotation in plot texts, via input expressions reminiscent of @TeX{}
@c constructs.  See the help page for @code{plotmath}, which features an
@c impressive on-line example.  More details can be found in Paul Murrell
@c and Ross Ihaka (2000), ``An Approach to Providing Mathematical
@c Annotation in Plots'', @url{http://www.amstat.org/publications/jcgs/, ,
@c @emph{Journal of Computational and Graphical Statistics}}, @strong{9},
@c 582--599.

R은 선 종류의 더 나은 처리, (palette를 통한) 더 편리한 색 처리, 색 gamma 보정, 그리고 가장 중요하게,  TeX construct들을 연상시키는 input 표현들을 통한  plot text들의 수학 주석과 같은 S-Plus에는 없는 몇몇의 그래픽 기능들을 제공합니다. 온라인 인상적인 예시를 포함하고있는 Plotmath는 help page를 참고하십시오. 더 자세한 내용은Paul Murrell and Ross Ihaka (2000), “An Approach to Providing Mathematical Annotation in Plots”, Journal of Computational and Graphical Statistics, 9, 582–599 에서 찾을 수 있습니다.  


@node What is R-plus?,  , Is there anything R can do that S-PLUS cannot?, R and S
@section What is R-plus?

@c For a very long time, there was no such thing.
매우 오랜 시간동안, 다음의 것들은 없었습니다. 

@c @url{http://www.xlsolutions-corp.com/, XLSolutions Corporation} is
@c currently beta testing a commercially supported version of R named R+
@c (read R plus).
XLSolutions Corporation 은(R 플러스라고 읽는)R+ 라고 이름지어진 상업적으로 지원되는 R버전이 현재 베타 테스팅 중입니다. 

@c @url{http://www.revolution-computing.com/, REvolution Computing} has
@c released
@c @url{http://www.revolution-computing.com/products/revolution-r.php,
@c REvolution R}, an enterprise-class statistical analysis system based on
@c R, suitable for deployment in professional, commercial and regulated
@c environments.

REvolution Computing은, 전문가용, 상업용, 그리고 규제된 환경 배치에 적합한 R을 베이스로 한 기업용 통계시스템 , REvolution R을 선보였습니다.  


@c @url{http://www.random-technologies-llc.com/, Random Technologies}
@c offers @url{http://random-technologies-llc.com/products/RStat/rstat,
@c RStat}, an enterprise-strength statistical computing environment which
@c combines R with enterprise-level validation, documentation, software
@c support, and consulting services, as well as related R-based products.

Random Technologies, R을 기업용 validation, documentation, 소프트웨어 지원과 상담 서비스들, 그리고 R-based 제품들을 결합한 기업 강화 통계 컴퓨터 조작 환경인, RStat을 제공합니다. 

@c See also
@c @url{http://en.wikipedia.org/wiki/R_programming_language#Commercialized_versions_of_R}
@c for pointers to commercialized versions of R.

상업화 버전의 R의 지표는 http://en.wikipedia.org/wiki/R_programming_language#Commercialized_versions_of_R 를 참고하십시오.


@node R Web Interfaces, R Add-On Packages, R and S, Top
@chapter R Web Interfaces

@c @strong{Rweb} is developed and maintained by
@c @email{jeff@@math.montana.edu, Jeff Banfield}.  The
@c @url{http://www.math.montana.edu/Rweb/, Rweb Home Page} provides access
@c to all three versions of Rweb---a simple text entry form that returns
@c output and graphs, a more sophisticated JavaScript version that provides
@c a multiple window environment, and a set of point and click modules that
@c are useful for introductory statistics courses and require no knowledge
@c of the R language.  All of the Rweb versions can analyze Web accessible
@c datasets if a @acronym{URL} is provided.

Rweb 은 Jeff Banfield에 의해 개발되고 유지되었습니다. Rweb Home Page는 Rweb의 세가지 버전 모두로의 액세스를 제공합니다 – output과 그래프들을 returm하는 간단한 텍스트 입력 방식, 여러개의 윈도우 환경을 제공하는 더 정교한 JavaScript 버전, 그리고 R 언어가 필요없는 기초 통계 과목을을 위한 유용한 포인트와 클릭 모듈들의 세트. 모든 Rweb 버전들은 URL이 제공되어있으면 웹에서 액세스 할 수 있는 dataset들을 분석할 수 있습니다. 

@c The paper ``Rweb: Web-based Statistical Analysis'', providing a detailed
@c explanation of the different versions of Rweb and an overview of how
@c Rweb works, was published in the Journal of Statistical Software
@c (@url{http://www.jstatsoft.org/v04/i01/}).

다른 버전들의 Rweb에 대한 자세한 설명과 Rweb이 어떻게 작동하는지의 개요를 제공하는 논문“Rweb: Web-based Statistical Analysis”은the Journal of Statistical Software (http://www.jstatsoft.org/v04/i01/)에서 출간되었습니다. 

@c @email{ulfi@@cs.tu-berlin.de, Ulf Bartel} has developed
@c @strong{R-Online}, a simple on-line programming environment for R which
@c intends to make the first steps in statistical programming with R
@c (especially with time series) as easy as possible.  There is no need for
@c a local installation since the only requirement for the user is a
@c JavaScript capable browser.  See @url{http://osvisions.com/r-online/}
@c for more information.

Ulf Bartel은 R을 이용한 통계 프록래밍의 첫 단계들을 (특히 시계열에서) 가능한한 쉽게 만들도록 의도한 R의 간단한 온라인 프로그래밍 환경인 R-Online을 개발하였습니다. JavaScript가 가능한 브라우저만이 유일한 필요조건이기 때문에 로컬 설치는 필요하지 않습니다.  더 많은 정보를 위해서는http://osvisions.com/r-online/를 참조하십시오. 

@c @strong{Rcgi} is a CGI WWW interface to R by @email{mjr@@dsl.pipex.com,
@c MJ Ray}.  It had the ability to use ``embedded code'': you could mix
@c user input and code, allowing the @HTML{} author to do anything from
@c load in data sets to enter most of the commands for users without
@c writing CGI scripts.  Graphical output was possible in PostScript or GIF
@c formats and the executed code was presented to the user for revision.
@c However, it is not clear if the project is still active.
@c @c URL no longer seems to work ...
@c @c See @url{http://stats.mth.uea.ac.uk/Rcgi/} for more information.
@c Currently, a modified version of @strong{Rcgi} by
@c @email{mai@@ms.uky.edu, Mai Zhou} (actually, two versions: one with
@c (bitmap) graphics and one without) as well as the original code are
@c available from @url{http://www.ms.uky.edu/~statweb/}.

Rcgi는MJ Ray에 의한R로의CGI WWW 인터페이스입니다. 이는 “embedded code”의 사용을 가능하게 합니다: HTML author이 CGI 스크립들을 쓰지 않고 사용자가 데이터 셋을 로드하는 것 으로부터  대부분의 명령어들을 입력하는 것 까지 어떤 것이든 하도록 허용하는, 사용자 input과 코드를 섞을 수 있습니다. Graphical output은  PostScript 이나 GIF형식들에서 가능했었고 실행된 코드는 수정을 위해 사용자에게 주어졌습니다. 하지만, 프로젝트가 아직 활성화 되 있는지는 확실하지 않습니다. 현재, Mai Zhou에 의한 수정된 버전의 Rcgi (실제로, 두가지 버전입니다: (bitmap) 그래픽이있는 것과 없는 것)와 어울러 기존 코드가http://www.ms.uky.edu/~statweb/에서 사용가능합니다. 


@c CGI-based web access to R is also provided at
@c @url{http://hermes.sdu.dk/cgi-bin/go/}.  There are many additional
@c examples of web interfaces to R which basically allow to submit R code
@c to a remote server, see for example the collection of links available from
@c @url{http://biostat.mc.vanderbilt.edu/twiki/bin/view/Main/StatCompCourse}.

R로의 CGI에 기초한 웹 액세스또한 http://hermes.sdu.dk/cgi-bin/go/에서 제공됩니다. 근본적으로 Remote server로 R 코드를 주는 것을 허용하는 추가의 R로의 웹 인터페이스 예시들이 많고, 이 예시들의 모음 링크들은http://biostat.mc.vanderbilt.edu/twiki/bin/view/Main/StatCompCourse에서 찾을 수 있으니 참조하십시오.

@c @url{http://www.warwick.ac.uk/go/dfirth, David Firth} has written
@c @CRANpkg{CGIwithR}, an R add-on package available from @CRAN{}.  It
@c provides some simple extensions to R to facilitate running R scripts
@c through the CGI interface to a web server, and allows submission of data
@c using both GET and POST methods.  It is easily installed using Apache
@c under Linux and in principle should run on any platform that supports R
@c and a web server provided that the installer has the necessary security
@c permissions.  David's paper ``CGIwithR: Facilities for Processing Web
@c Forms Using R'' was published in the Journal of Statistical Software
@c (@url{http://www.jstatsoft.org/v08/i10/}).  The package is now
@c maintained by @email{duncan@@wald.ucdavis.edu, Duncan Temple Lang} and
@c has a web page at @url{http://www.omegahat.org/CGIwithR/}.

David Firth는  CRAN에서 사용가능한 R add-on패지키인, CGIwithR을 집필했습니다.  이는 CGI 인터페이스를 통하여 웹서버로 R script들을 실행하는 것을 가능하게하는 간단한 R의 extension들을 제공하고, GET과 POST 방법들 두가지 모두를 이용하여 데이터의 접수를 가능하게 합니다. 이는 Linux의 Apache를 사용하여 쉽게 설치되고 원칙적으로는 R을 지원하는 모든 플랫폼과 설치자가 필요한 보안 허가들을 가지고 있는 것을 제공한 웹서버에서 작동을 해야 합니다. David의 논문  “CGIwithR: Facilities for Processing Web Forms Using R”은the Journal of Statistical Software (http://www.jstatsoft.org/v08/i10/)에서 출간되었습니다. 이 패키지는Duncan Temple Lang에 의해 관리되며 웹페이지는 http://www.omegahat.org/CGIwithR/입니다. 

@c @url{http://www.rpad.org/Rpad, Rpad}, developed and actively maintained
@c by Tom Short, provides a sophisticated environment which combines some
@c of the features of the previous approaches with quite a bit of
@c JavaScript, allowing for a @acronym{GUI}-like behavior (with sortable
@c tables, clickable graphics, editable output), etc.

Tom Short에 의해 개발되고 활동적으로 관리되고 있는 Rpad는 꽤 많은 양의 JaveScript와 GUI-와 같은 작용을 하는 것들 등 (배열가능한 테이블들, 클릭할 수 있는 그래픽들, 고칠수 있는 output) 과 같은 이전의 approach들의 몇가지 특징들을 합한 정교한 환경을 제공합니다. 

@c Jeff Horner is working on the R/Apache Integration Project which embeds
@c the R interpreter inside Apache 2 (and beyond).  A tutorial and
@c presentation are available from the project web page at
@c @url{http://biostat.mc.vanderbilt.edu/@/twiki/@/bin/@/view/@/Main/@/RApacheProject}.

Jeff Horner은Apache 2 (와 그 이후) 안의 R interpreter를 보관하는 R/Apache Integration 프로젝트에 공을 들이고 있습니다.  튜토리얼과 프레젠테이션은 프로젝트 웹페이지http://biostat.mc.vanderbilt.edu/twiki/bin/view/Main/RApacheProject에서 이용가능합니다. 

@c @url{http://stats.math.uni-augsburg.de/Rserve/, Rserve} is a project
@c actively developed by Simon Urbanek.  It implements a TCP/IP server which
@c allows other programs to use facilities of R.  Clients are available from
@c the web site for Java and C++ (and could be written for other languages
@c that support TCP/IP sockets).

Rserve는Simon Urbanek에 의해 활동적으로 개발 된 프로젝트입니다. 이는 다른 프로그램들이  R의 facility들을 사용할 수 있도록 허용하는 TCP/IP 서버를 이행합니다. 클라이언트들은 Java와 C++를 위한 웹사이트 (TCP/IP socket들을 지원하는 다른 언어로도 쓰여질 수 있습니다)에서 이용가능합니다. 

@c @url{http://openstatserver.org/index.html, OpenStatServer} is being
@c developed by a team lead by Greg Warnes; it aims ``to provide clean access
@c to computational modules defined in a variety of computational
@c environments (R, SAS, Matlab, etc) via a single well-defined client
@c interface'' and to turn computational services into web services.

OpenStatServer는 Greg Warnes이 지휘하는 팀에의해 개발되고 있습니다; 이는 “단일화된 잘-정의된 클라이언트 인터페이스를 통해 여러가지 computational 환경 (R, SAS, Matlab, 등)에서 정의된 computational 모듈들로의 더 깨끗한 access를 제공하는 것”과 computational 서비스를 웹 서비스로 바꾸는 것을 목표로 합니다. 
두가지 프로젝트는 R로의 웹 인터페이스를 제공하기위해 PHP를 사용합니다. 

@c Two projects use PHP to provide a web interface to R.
@c @url{http://steve-chen.net/R_PHP/, R_PHP_Online} by Steve Chen (though
@c it is unclear if this project is still active) is somewhat similar to
@c the above Rcgi and Rweb.  @url{http://dssm.unipa.it/R-php/?cmd=home,
@c R-php} is actively developed by Alfredo Pontillo and Angelo Mineo and
@c provides both a web interface to R and a set of pre-specified analyses
@c that need no R code input.

Steve Chen의R_PHP_Online은 (이 프로젝트가 아직 활성적인지는 미지수이지만) 위의 Rcgi와 Rweb과 다소 비슷합니다. R-php는  Alfredo Pontillo와Angelo Mineo에 의해 활성적으로 개발되었고 R로의 웹 인터페이스와 R 코드 input이 필요하지 않은 미리 지정된 analysis들의 set을 제공합니다. 

@c @url{http://www.bioconductor.org/, webbioc} is ``an integrated web
@c interface for doing microarray analysis using several of the
@c Bioconductor packages'' and is designed to be installed at local sites
@c as a shared computing resource.

Webbioc 은 “몇몇의 Bioconductor 패키지들을 사용하여 microarray analysis를 하는 통합적인 웹 인터페이스”이고 공유된 컴퓨팅 resource처럼 local 사이트에 인스톨 되도록 디자인 되었습니다.

@c @url{http://sysbio.mrc-bsu.cam.ac.uk/Rwui, Rwui} is a web application to
@c create user-friendly web interfaces for R scripts.  All code for the web
@c interface is created automatically.  There is no need for the user to do
@c any extra scripting or learn any new scripting techniques.

Rwui는 R 스크립들의 사용하기 쉬운 웹 인터페이스를 만들기 위한 웹 어플리케이션입니다. 웹 인터페이스의 모든 코드는 자동으로 생성됩니다. 사용자는 추가의 스크립트를 하거나 새로운 스크립팅  기술을 배울 필요가 없습니다.

@c The @CRANpkg{R.rsp} package by Henrik Bengtsson introduces ``R Server
@c Pages''.  Analogous to Java Server Pages, an R server page is typically
@c @HTML{} with embedded R code that gets evaluated when the page is
@c requested.  The package includes an internal cross-platform HTTP server
@c implemented in Tcl, so provides a good framework for including web-based
@c user interfaces in packages.  The approach is similar to the use of the
@c @CRANpkg{brew} package with @url{http://rapache.net/, Rapache} with the
@c advantage of cross-platform support and easy installation.

Henrik Bengtsson 의 R.rsp 패키지는 “R server Pages”를 소개합니다. Java Server Page들과 유사하게, Rserver page는 보통 페이지가 요구되었을 때 평가되는 저정된 R 코드로 된 HTML입니다. 이 패키지는 Tcl안에서 실행되는internal cross-platform HTTP server를 포함하고, 그래서 패키지의 웹에 기초한 사용자 인터페이스를 포함한 좋은 framework를 제공합니다. 접근성은 cross-platform의 지원과 쉬운 설치의 이점이 있는 Rapach를 가지고 있는 brew패키지의 사용법과 비슷합니다. 

@c The @CRANpkg{Rook} package by Jeffrey Horner provides a web server
@c interface borrowing heavily from Ruby's Rack project.

Jeffrey Horner의 Rook 패키지는 Ruby의 Rack 프로젝트로 부터 아주 많이 빌리는 웹 서버 인터페이스를 제공합니다. 

@c Finally, @uref{http://code.google.com/p/concerto-platform/, Concerto} is
@c a user friendly open-source Web Interface to R developed at the
@c Psychometrics Centre of Cambridge University.  It was designed as an
@c online platform to design and run Computerized Adaptive Tests, but can
@c be also used as a general-purpose R Web Interface.  It allows R users
@c with no programming or web designing background to quickly develop
@c flexible and powerful online applications, websites, and psychometrics
@c tests.  To maximize its reliability, security, and performance, Concerto
@c relies on the popular and reliable open-source elements such as MySQL
@c server (exchange and storage of the data), @uref{http://rstudio.org/,
@c Rstudio} (R code designing and testing, file management), CKEditor
@c (@HTML{} Layer design), and PHP.

마지막으로, Concerto는the Psychometrics Centre of Cambridge University에서 개발된 사용이 쉬운 오픈소스 R로의 웹 인터페이스 입니다. 이는Computerized Adaptive Test를 디자인하고 작동하는 온라인 플랫폼 처럼 디자인 되었으나, R 웹 인터페이스의 일반적인 목적으로도 쓰여질 수 있습니다. 이는 프로그래밍이나 웹디자인의 기초 지식이 없는 R 사용자들이 융통성 있고 강력한 온라인 application들과 웹사이트들, 그리고 심리측정 테스트들을 빨리 개발 할 수 있도록 허용합니다. 신뢰성과 안전성, 그리고 성능을 극대화 시키기위해, Concerto는 MySQL 서버 (데이터의 교환과 저장), Rstudio (R코ㄷ를 디자인하고 테스트, 파일 관리), CKEditor (HTML Layer 디자인), 그리고 PHP와 같은 대중적이고 신뢰할 수 있는 오픈소스 element들에 의존합니다. 

@c See @url{http://rwiki.sciviews.org/doku.php?id=faq-r#web_interfaces} for
@c additional information.

추가의 정보를 위해서는http://rwiki.sciviews.org/doku.php?id=faq-r#web_interfaces를 참조하십시오.


@node R Add-On Packages, R and Emacs, R Web Interfaces, Top
@chapter R Add-On Packages

@menu
* Which add-on packages exist for R?::  
* How can add-on packages be installed?::  
* How can add-on packages be used?::  
* How can add-on packages be removed?::  
* How can I create an R package?::  
* How can I contribute to R?::  
@end menu

@node Which add-on packages exist for R?, How can add-on packages be installed?, R Add-On Packages, R Add-On Packages
@section Which add-on packages exist for R?

@menu
* Add-on packages in R::        
* Add-on packages from CRAN::   
* Add-on packages from Omegahat::  
* Add-on packages from Bioconductor::  
* Other add-on packages::       
@end menu

@node Add-on packages in R, Add-on packages from CRAN, Which add-on packages exist for R?, Which add-on packages exist for R?
@subsection Add-on packages in R

@c The R distribution comes with the following packages:
R distribution은 다음의 패키지들과 함께 옵니다

@table @strong
@c <FIXME>
@c 3.0.0
@item base
@c Base R functions (and datasets before R 2.0.0).
기본 R 함수들 (과 R 2.0.0 전의 dataset들).

@item compiler
@c R byte code compiler (added in R 2.13.0).
R byte 코드 compiler (R 2.13.0에 더해진). 

@item datasets
@c Base R datasets (added in R 2.0.0).
기본 R dataset들 (R 2.0.0에 더해진). 

@item grDevices
@c Graphics devices for base and grid graphics (added in R 2.0.0).
기본 그리고 grid 그래픽들을 위한 그래픽 장치들 (R 2.0.0에 더해진). 

@c </FIXME>
@item graphics
@c R functions for base graphics.
기본 그래픽들을 위한 R 함수들. 

@item grid
@c A rewrite of the graphics layout capabilities, plus some support for
@c interaction.
그래픽들의 레이아웃 기능의 재 작성, 플러스 상호작용을위한 일부 지원. 

@item methods
@c Formally defined methods and classes for R objects, plus other
@c programming tools, as described in the Green Book.
R object들을 위한 공식적으로 정의된 방법들과 클래스, 그리고 Green Book에 설명되어있는 것과 같은, 다른 프로그래밍 툴들.

@item parallel
@c Support for parallel computation, including by forking and by sockets, 
@c and random-number generation (added in R 2.14.0).
by forking과 by socket들 그리고 random number generation(R 2.14.0에 더해진)을 포함한, 병렬 계산을 지원.

@item splines
@c Regression spline functions and classes.
Regression spline 함수와 class들. 

@item stats
@c R statistical functions.
R 통계 기능들. 

@item stats4
@c Statistical functions using S4 classes.
S4 클래스들을 이용한 통계 함수들.

@item tcltk
@c Interface and language bindings to Tcl/Tk @acronym{GUI} elements.
Tcl/Tk GUI element들로의 인터페이스와 언어 묶음들.

@item tools
@c Tools for package development and administration.
패키지 개발과 관리를 위한 툴. 

@item utils
@c R utility functions.
R 유틸리티 함수들.

@end table
@c These ``base packages'' were substantially reorganized in R 1.9.0.  The
@c former @pkg{base} was split into the four packages @pkg{base},
@c @pkg{graphics}, @pkg{stats}, and @pkg{utils}.  Packages @pkg{ctest},
@c @pkg{eda}, @pkg{modreg}, @pkg{mva}, @pkg{nls}, @pkg{stepfun} and
@c @pkg{ts} were merged into @pkg{stats}, package @pkg{lqs} returned to the
@c recommended package @CRANpkg{MASS}, and package @pkg{mle} moved to
@c @pkg{stats4}.
이 “기본 패키지드”은 R 1.9.0에서 실질적으로 개편되었습니다. 전의 base는 base, graphics, stats, 그리고 utils의 네가지의 패키지로 나누어져 있었습니다. ctest, eda, modreg, mva, nls, stepfun 그리고 ts 패키지들은 stats로 통합되었고 lqs 패키지는 권장된 패키지 MASS로 return되었으며, mle 패키지는 stats4로 옮겨졌습니다.

@node Add-on packages from CRAN, Add-on packages from Omegahat, Add-on packages in R, Which add-on packages exist for R?
@subsection Add-on packages from @acronym{CRAN}

@c The @CRAN{} @file{src/contrib} area contains a wealth of add-on
@c packages, including the following @emph{recommended} packages which are
@c to be included in all binary distributions of R.

CRAN src/contrib area는 모든 R의 binary distribution에 포함되어질 다음의 권장된 패키지들을 포함한 다량의 add-on 패키지를 포함하고 있습니다. 

@c <FIXME>
@c 3.0.0
@table @strong
@item KernSmooth
@c Functions for kernel smoothing (and density estimation) corresponding to
@c the book ``Kernel Smoothing'' by M. P. Wand and M. C. Jones, 1995.
1995년에M. P. Wand 와 M. C. Jones 에 의해 쓰여진 책“Kernel Smoothing”에 해당하는 Kernel smoothing을 위한 function들 (그리고 밀도 추정).

@item MASS
@c Functions and datasets from the main package of Venables and Ripley,
@c ``Modern Applied Statistics with S''.
@c (Contained in the @file{VR} bundle for R versions prior to 2.10.0.)
Venables 와 Ripley, “Modern Applied Statistics with S” (2.10.0 전의 R 버전들을위한 VR 번들에 포함된)의 메인 패키지로부터의 function들과 dataset들.

@item Matrix
@c A Matrix package.
@c (Recommended for R 2.9.0 or later.)

행렬 패키지 (R 2.9.0 혹은 이후의 버전에 권장).

@item boot
@c Functions and datasets for bootstrapping from the book ``Bootstrap
@c Methods and Their Applications'' by A. C. Davison and D. V. Hinkley,
@c 1997, Cambridge University Press.

1997년에  Cambridge University Press에서 A. C. Davison 과 D. V. Hinkley에 의해 쓰여진  “Bootstrap Methods and Their Applications”, 책에서의 booststrapping을 위한 function와 dataset들.

@item class
@c Functions for classification (@math{k}-nearest neighbor and LVQ).
@c (Contained in the @file{VR} bundle for R versions prior to 2.10.0.)

분류를 위한 function들 (k-nearest neighbor과 LVQ). (2.10.0 전의 R 버전들을위한 VR 번들에 포함된)

@item cluster
@c Functions for cluster analysis.

Cluster 분석을 위한 function들.


@item codetools
@c Code analysis tools.
@c (Recommended for R 2.5.0 or later.)
코드 분석 툴들. (R 2.5.0. 혹은 이후 버전에 권장)


@item foreign
@c Functions for reading and writing data stored by statistical software
@c like Minitab, S, SAS, SPSS, Stata, Systat, etc.
@c Minitab, S, SAS, SPSS, Stata, Systat 등과 같은 통계 소프트웨어에 의해 저장된 읽고 쓰는 데이터를 위한 function들. 

@item lattice
@c Lattice graphics, an implementation of Trellis Graphics functions.

Trellis 그래픽 function들의 실행인, 격자 그래픽들


@item mgcv
@c Routines for GAMs and other generalized ridge regression problems with
@c multiple smoothing parameter selection by GCV or UBRE.

GCV와 UBRE에 의한 복합적인 smoothing parameter 선택들을 가진 GAM들과 다른 일반적인 ridge regression 문제들을 위한 루틴.

@item nlme
@c Fit and compare Gaussian linear and nonlinear mixed-effects models.
Gaussian 선형과 비선형의 혼합 효과 모델들을 형성하고 비교.

@item nnet
@c Software for single hidden layer perceptrons (``feed-forward neural
@c networks''), and for multinomial log-linear models.
@c (Contained in the @file{VR} bundle for R versions prior to 2.10.0.)
@c 단일로 숨겨진 layer perceptron의 소프트웨어 (“feed-forward neural 네트워크들”)와, 다항 로그 선형 모형들 (2.10.0 과 이전의 R 버전들을 위한 VR 번들에 포함된).

@item rpart
@c Recursive PARTitioning and regression trees.
반복되는PARTitioning과 회귀나무.

@item spatial
@c Functions for kriging and point pattern analysis from ``Modern Applied
@c Statistics with S'' by W. Venables and B. Ripley.
@c (Contained in the @file{VR} bundle for R versions prior to 2.10.0.)

W. Venables와 B. Ripley의 “Modern Applied Statistics with S”에서의 그리그격자법과 point pattern analysis를 위한 function들(2.10.0 과 이전의 R 버전들을 위한 VR 번들에 포함된).


@item survival
@c Functions for survival analysis, including penalized likelihood.

Penalized likelihood를 포함한, survival analysis을위한 function들. 

@end table
@c </FIXME>
@c See the @url{http://CRAN.R-project.org/web/packages/, , @CRAN{}
@c contributed packages page} for more information.

@c Many of these packages are categorized into
@c @url{http://CRAN.R-project.org/web/views/, @CRAN{} Task Views}, allowing
@c to browse packages by topic and providing tools to automatically install
@c all packages for special areas of interest.

@c Some @CRAN{} packages that do not build out of the box on Windows,
@c require additional software, or are shipping third party libraries for
@c Windows cannot be made available on @CRAN{} in form of a Windows binary
@c packages.  Nevertheless, some of these packages are available at the
@c ``@CRAN{} extras'' repository at
@c @url{http://www.stats.ox.ac.uk/pub/RWin/} kindly provided by Brian
@c D. Ripley.  Note that this repository is a default repository for recent
@c versions of R for Windows.

더 많은 정보를 위해서는CRAN contributed packages page를 참조하십시오.
이 패키지들중 많은 것이 주제별로 패키지들을 브라우즈하도록 허락하고 특별한 관심 구역으로의 자동설치를 하도록하는 툴을 제공하는 CRAN Task Views로 분류됩니다. 
Windows에서 패키지로 build되지 않는 몇몇의 CRAN 패키지들은 추가의 소프트웨어가 필요하거나, Windows binary 패키지들의 형태의 CRAN에서 이용가능하게 만들어지지 못한 Windows를 위한 third party library들을 배송합니다. 그럼에도 불구하고, 이 몇몇의 패키지들은Brian D. Ripley가 친절하게 제공한http://www.stats.ox.ac.uk/pub/RWin/의 저장소인the “CRAN extras”에서 이용이 가능합니다. 이 저장소는 Windows를 위한 최신 R 버전들의 기본 저장소라는것을 유의하십시오. 


@node Add-on packages from Omegahat, Add-on packages from Bioconductor, Add-on packages from CRAN, Which add-on packages exist for R?
@subsection Add-on packages from Omegahat

@c The @url{http://www.omegahat.org/, Omega Project for Statistical
@c Computing} provides a variety of open-source software for statistical
@c applications, with special emphasis on web-based software, Java, the
@c Java virtual machine, and distributed computing.  A @acronym{CRAN} style
@c R package repository is available via @url{http://www.omegahat.org/R/}.
@c See @url{http://www.omegahat.org/} for information on most R packages
@c available from the Omega project.

통계적 컴퓨팅을 위한 Omega 프로젝트는 웹에 기초한 소프트웨어, Java, Java virtual machine, 그리고 distributed computing에 특별한 주안점을 둔, 통계 응용프로그램들을 위한 다양한 오픈소스 소프트웨어를 제공합니다. CRAN 스타일 R 패키지 저장소는http://www.omegahat.org/R/를 통해 이용가능합니다. Omega 프로젝트의 대부분의 R 패키지에 대한 정보는http://www.omegahat.org/를 참조하십시오.

@node Add-on packages from Bioconductor, Other add-on packages, Add-on packages from Omegahat, Which add-on packages exist for R?
@subsection Add-on packages from Bioconductor

@c @url{http://www.bioconductor.org/, Bioconductor} is an open source and
@c open development software project for the analysis and comprehension of
@c genomic data.  Most Bioconductor components are distributed as R add-on
@c packages.  Initially most of the
@c @url{http://www.bioconductor.org/packages/bioc/, Bioconductor software
@c packages} focused primarily on DNA microarray data analysis.  As the
@c project has matured, the functional scope of the software packages
@c broadened to include the analysis of all types of genomic data, such as
@c SAGE, sequence, or SNP data.  In addition, there are metadata
@c (annotation, CDF and probe) and experiment data packages.  See
@c @url{http://www.bioconductor.org/download/} for available packages and a
@c complete taxonomy via BioC Views.

Bioconductor은 오픈소스이고 분석과 지놈 데이터의 이해를 위한 오픈 개발 소프트웨어 프로젝트입니다. 대부분의 Bioconductor 구성요소들은 R의 add-on 패키지들처럼 분배되어 있습니다. 처음 Bioconductor 소프트웨어 패키지들의 대부분은 주로 DNA microarray 데이터 분석에 주력했습니다. 프로젝트가 성숙해질수록, SAGE, sequence, 혹은 SNP 데이터와 같은 모든 종류의 지놈 데이터의 분석을 포함한 소프트웨어 패키지들의 기능 범위가 넓어졌습니다. 추가로, metadata(주석, CDF와 probe)와 실험 데이터 패키지들이 있습니다.  이용가능한 패키지들과BioC Views를 통한 완전한 분류 체계를 위해서는 http://www.bioconductor.org/download/를 참조하십시오.  


@node Other add-on packages,  , Add-on packages from Bioconductor, Which add-on packages exist for R?
@subsection Other add-on packages

@c Many more packages are available from places other than the three
@c default repositories discussed above (@CRAN{}, Bioconductor and
@c Omegahat).  In particular, R-Forge provides a @CRAN{} style repository
@c at @url{http://R-Forge.R-project.org/}.

@c More code has been posted to the R-help mailing list, and can be
@c obtained from the mailing list archive.

더 많은 패키지들이 위에서 언급된 세가지 기본 저장소 (CRAN, Bioconductor 그리고 Omegahat) 외의 장소에서도 이용가능합니다. 특히, R-Forge는http://R-Forge.R-project.org/에서 CRAN 스타일 저장소를 제공합니다. 
더 많은 코드는 R-help 메일링 리스트에 포스트되어 있으며, 메일링 리스트 archive에서 얻을 수도 있습니다. 

@node How can add-on packages be installed?, How can add-on packages be used?, Which add-on packages exist for R?, R Add-On Packages
@section How can add-on packages be installed?

@c (Unix-like only.)  The add-on packages on @CRAN{} come as gzipped tar
@c files named @code{@var{pkg}_@var{version}.tar.gz}, which may in fact be
@c ``bundles'' containing more than one package.  Let @var{path} be the
@c path to such a package file.  Provided that @command{tar} and
@c @command{gzip} are available on your system, type

(Unix 같은것 에서만) CRAN의 Add-on 패키지들은 실제로 한개 이상의 “bundle들”을 포함할 수도 있는, pkg_version.tar.gz으로 이름지어진gzipped tar파일들처럼 옵니다. Path를 그런 패키지 파일로의 경로로 놓읍시다. 당신의 시스템에 tar 과 gzip이 이용가능하다는 전제하에, 당신의 library 검색 경로의 첫번째 디렉토리에 근원을 가진 library tree로의 설치를 shell  prompt하는 


@example
$ R CMD INSTALL @var{path}/@var{pkg}_@var{version}.tar.gz
@end example

@c     $ R CMD INSTALL path/pkg_version.tar.gz
를 타입합니다. (검색 경로가 어떻게 결정되는지의 자세한 설명은 .libPaths()에 대한 help page를 참조하십시오. 


@noindent
@c at the shell prompt to install to the library tree rooted at the first
@c directory in your library search path (see the help page for
@c @code{.libPaths()} for details on how the search path is determined).


@c To install to another tree (e.g., your private one), use

다른 tree를 설치하려면 (예, 당신의 개인적인 것), lib 가  설치하는 library tree에대한 경로를 제공하는

@example
$ R CMD INSTALL -l @var{lib} @var{path}/@var{pkg}_@var{version}.tar.gz
@end example

@c      $ R CMD INSTALL -l lib path/pkg_version.tar.gz
을 사용하십시오.

@noindent
@c where @var{lib} gives the path to the library tree to install to.

@c Even more conveniently, you can install and automatically update
@c packages from within R if you have access to repositories such as
@c @CRAN{}.  See the help page for @code{available.packages()} for more
@c information.

더욱더 편리하게, CRAN과 같은 저장소로의 액세스가 있으면 R 내에서부터 패키지들의 설치와 자동 업데이트를 할 수 있습니다.  더 많은 정보를 위해서는available.packages()에 대한 help page를 참조하십시오. 


@c <COMMENT>
@c This is really no longer quite accurate (R_LIBS_USER is preferred to
@c R_LIBS), and described in ?libPaths anyways ... hence comment out.
@c You can use several library trees of add-on packages.  The easiest way
@c to tell R to use these is via the environment variable @env{R_LIBS}
@c which should be a colon-separated list of directories at which R library
@c trees are rooted.  You do not have to specify the default tree in
@c @env{R_LIBS}.  E.g., to use a private tree in @file{$HOME/lib/R} and a
@c public site-wide tree in @file{/usr/local/lib/R-contrib}, put

@c @example
@c R_LIBS="$HOME/lib/R:/usr/local/lib/R-contrib"; export R_LIBS
@c @end example

@c @noindent
@c into your (Bourne) shell profile or even preferably, add the line

@c @example
@c R_LIBS="~/lib/R:/usr/local/lib/R-contrib"
@c @end example

@c @noindent
@c your environment (e.g., @file{~/.Renviron}) file.  (Note that no
@c @code{export} statement is needed or allowed in this file; see the
@c on-line help for @code{Startup} for more information.)

@node How can add-on packages be used?, How can add-on packages be removed?, How can add-on packages be installed?, R Add-On Packages
@section How can add-on packages be used?

@c To find out which additional packages are available on your system, type

당신의 시스템에 어떤 추가의 패키지들이 이용가능한지를 찾아내기위해서는R prompt에

@example
library()
@end example

@noindent
@c at the R prompt.  

를 타입하십시오.

@c This produces something like
이는 다음과 같은 것을 생성합니다.

@quotation
@cartouche
@smallexample
Packages in `/home/me/lib/R':

mystuff       My own R functions, nicely packaged but not documented

Packages in `/usr/local/lib/R/library':

KernSmooth    Functions for kernel smoothing for Wand & Jones (1995)
MASS          Main Package of Venables and Ripley's MASS
Matrix        Sparse and Dense Matrix Classes and Methods
base          The R Base package
boot          Bootstrap R (S-Plus) Functions (Canty)
class         Functions for Classification
cluster       Functions for clustering (by Rousseeuw et al.)
codetools     Code Analysis Tools for R
datasets      The R Datasets Package
foreign       Read Data Stored by Minitab, S, SAS, SPSS, Stata, Systat,
              dBase, ...
grDevices     The R Graphics Devices and Support for Colours and Fonts
graphics      The R Graphics Package
grid          The Grid Graphics Package
lattice       Lattice Graphics
methods       Formal Methods and Classes
mgcv          GAMs with GCV/AIC/REML smoothness estimation and GAMMs
              by PQL
nlme          Linear and Nonlinear Mixed Effects Models
nnet          Feed-forward Neural Networks and Multinomial Log-Linear
              Models
rpart         Recursive Partitioning
spatial       Functions for Kriging and Point Pattern Analysis
splines       Regression Spline Functions and Classes
stats         The R Stats Package
stats4        Statistical functions using S4 Classes
survival      Survival analysis, including penalised likelihood
tcltk         Tcl/Tk Interface
tools         Tools for Package Development
utils         The R Utils Package
@end smallexample
@end cartouche
@end quotation

@c You can ``load'' the installed package @var{pkg} by
에 의해 설치된 pkg 패키지를 “load”할 수 있습니다.

그러고 나서
@example
library(@var{pkg})
@end example

@c You can then find out which functions it provides by typing one of
@example
library(help = @var{pkg})
help(package = @var{pkg})
@end example
들 중 하나를 타입하는것으로 어떤 function들이 이를 제공하는지를 알아낼 수 있습니다.

@c You can unload the loaded package @var{pkg} by
@example
detach("package:@var{pkg}", unload = TRUE)
@end example
에 의해 Loaded 패키지인 pkg를 unload할 수 있습니다.
(namespace가있는 패키지들만이 unload = TRUE가 필요한 곳, ?unload를 참조하십시오).

@noindent
(where @code{unload = TRUE} is needed only for packages with a
namespace, see @code{?unload}).



@node How can add-on packages be removed?, How can I create an R package?, How can add-on packages be used?, R Add-On Packages
@section How can add-on packages be removed?


@c Use

@example
$ R CMD REMOVE @var{pkg_1} @dots{} @var{pkg_n}
@end example

@noindent
@c to remove the packages @var{pkg_1}, @dots{}, @var{pkg_n} from the
@c library tree rooted at the first directory given in @env{R_LIBS} if this
@c is set and non-null, and from the default library otherwise.  (Versions
@c of R prior to 1.3.0 removed from the default library by default.)

를 만약 이가 세트와 null이 아니고, 그렇지 않으면 기본 library에서부터인 R_LIBS안의 첫번째 디렉토리에 근원을 둔 library tree에서부터의pkg_1, ..., pkg_n 패키지를 없애기 위해서 사용합니다. (1.3.0 전의 R의 버전들은 기본으로 기본 library에서부터 지워졌습니다.) 
Library lib에서부터 지우려면,


@c To remove from library @var{lib}, do

@example
$ R CMD REMOVE -l @var{lib} @var{pkg_1} @dots{} @var{pkg_n}
@end example

를 하십시오. 
@node How can I create an R package?, How can I contribute to R?, How can add-on packages be removed?, R Add-On Packages
@section How can I create an R package?

@c A package consists of a subdirectory containing a file
@c @file{DESCRIPTION} and the subdirectories @file{R}, @file{data},
@c @file{demo}, @file{exec}, @file{inst}, @file{man}, @file{po},
@c @file{src}, and @file{tests} (some of which can be missing).  The
@c package subdirectory may also contain files @file{INDEX},
@c @file{NAMESPACE}, @file{configure}, @file{cleanup}, @file{LICENSE},
@c @file{LICENCE}, @file{COPYING} and @file{NEWS}.

파일DESCRIPTION과 subdirectori들 R, data, demo, exec, inst, man, po, src, 그리고 tests (몇몇은 missing되었을 수도 있습니다)들을 포함한 subdirectory를 포함한 패키지 입니다. 패키지 subdirectory는INDEX, NAMESPACE, configure, cleanup, LICENSE, LICENCE, COPYING 그리고 NEWS파일들 또한 포함할 수도 있습니다.   


@ifclear UseExternalXrefs
@c See section ``Creating R packages'' in @cite{Writing R Extensions}, for
@c details.  This manual is included in the R distribution, @pxref{What
@c documentation exists for R?}, and gives information on package
@c structure, the configure and cleanup mechanisms, and on automated
@c package checking and building.

자세한 사항으로는Writing R Extensions의 “Creating R packages” 섹션을 참고하십시오. 이 매튜얼은 R distribution에 포함되어있고, What documentation exists for R?를 참조하십시오,  패키지 구조, configure과 cleanup mechanism들, 그리고 자동 패키지 체크와 building들에 대한 정보를 줍니다. 

@end ifclear
@ifset UseExternalXrefs
@xref{Creating R packages, , Creating R packages, R-exts, Writing R
Extensions}, for details.
@end ifset

@c R version 1.3.0 has added the function @code{package.skeleton()} which
@c will set up directories, save data and code, and create skeleton help
@c files for a set of R functions and datasets.

R 버전 1.3.0은 디렉토리들를 셋업하고, 데이터와 코드를 저장하고, R function들과 dataset들의 skeleton 도움 파일들을 생성하는 package.skeleton() function을 추가했습니다. 


@c @xref{What is CRAN?}, for information on uploading a package to @CRAN{}.

CRAN으로의 파일을 업로드를하는 정보을 위해서는, What is CRAN?를 참조하십시오. 


@node How can I contribute to R?,  , How can I create an R package?, R Add-On Packages
@section How can I contribute to R?

@c R is in active development and there is always a risk of bugs creeping
@c in.  Also, the developers do not have access to all possible machines
@c capable of running R.  So, simply using it and communicating problems is
@c certainly of great value.

R은 활성적인 개발중이고 버그가 생기기 시작할 위험요소가 항상 있습니다. 또한, 개발자들은 R을 실행할 수 있는 가능한 모든 컴퓨터에 액세스 할 수가 없습니다. 그래서, 단순히 이를 사용하며 문제들에 대해 의사소통하는 것이 확실히 큰 가치입니다. 

@c The @url{http://developer.R-project.org/, R Developer Page} acts as an
@c intermediate repository for more or less finalized ideas and plans for
@c the R statistical system.  It contains (pointers to) TODO lists, RFCs,
@c various other writeups, ideas lists, and SVN miscellanea.

R Developer Page는 더도 말고 덜도 말고 R 통계 시스템을 위해 마무리지어진 아이디어들과 플랜들을 위한 중간의 저장소처럼 행동합니다. 그는 (pointers to) TODO 목록들과 RFC들, 여러가지 writeup들, 아이디어 목록들, 그리고 SVN miscellanea를 포함합니다.  


@node R and Emacs, R Miscellanea, R Add-On Packages, Top
@chapter R and Emacs

@menu
* Is there Emacs support for R?::  
* Should I run R from within Emacs?::  
* Debugging R from within Emacs::  
@end menu

@node Is there Emacs support for R?, Should I run R from within Emacs?, R and Emacs, R and Emacs
@section Is there Emacs support for R?

@c There is an Emacs package called @acronym{ESS} (``Emacs Speaks
@c Statistics'') which provides a standard interface between statistical
@c programs and statistical processes.  It is intended to provide
@c assistance for interactive statistical programming and data analysis.
@c Languages supported include: S dialects (R, S 3/4, and @SPLUS{}
@c 3.x/4.x/5.x/6.x/7.x), LispStat dialects (XLispStat, ViSta), SAS, Stata,
@c and BUGS.

통계 프로그램들과 통계 프로세스들 사이의 기본 인터페이스를 제공하는(“Emacs Speaks Statistics”)라고 불리는 Emacs 패키지가 있습니다. 이는통계 프로그래밍과 데이터 분석의 상호작용을 위한 지원을 제공하기위한 목적이었습니다. 지원되는 언어는 다음을 포함합니다: S dialects (R, S 3/4, and S-Plus 3.x/4.x/5.x/6.x/7.x), LispStat dialects (XLispStat, ViSta), SAS, Stata, 그리고 BUGS.


@c @acronym{ESS} grew out of the need for bug fixes and extensions to
@c S-mode 4.8 (which was a @acronym{GNU} Emacs interface to S/@SPLUS{}
@c version 3 only).  The current set of developers desired support for
@c XEmacs, R, S4, and MS Windows.  In addition, with new modes being
@c developed for R, Stata, and SAS, it was felt that a unifying interface
@c and framework for the user interface would benefit both the user and the
@c developer, by helping both groups conform to standard Emacs usage.  The
@c end result is an increase in efficiency for statistical programming and
@c data analysis, over the usual tools.

ESS는 버그를 고치는 것과 S-mode 4.8(S/S-Plus version 3만으로의GNU Emacs interface인터페이스였덤)로의 연장을 위해서 생겼습니다.  현제 개발자들 모임은XEmacs, R, S4, 그리고 MS Windows를 지원하기를 갈망했었습니다. 추가로, 새로운 모드들이 R, Stata, 그리고 SAS를위해 개발되어지고, 이는 사용자 인터페이스가 사용자와 개발자가 기본 Emacs의 사용에 따르는것에 의해 두 그룹 모두가 이익인 단일화된 인터페이스와 프레임워크인 것 처럼 느껴졌었습니다. 최종 결과는 보통의 툴들을 사용하는 것에 비해 통계 프로그래밍과 데이터 분석의 능률을 증가입니다. 


@c R support contains code for editing R source code (syntactic indentation
@c and highlighting of source code, partial evaluations of code, loading
@c and error-checking of code, and source code revision maintenance) and
@c documentation (syntactic indentation and highlighting of source code,
@c sending examples to running @acronym{ESS} process, and previewing),
@c interacting with an inferior R process from within Emacs (command-line
@c editing, searchable command history, command-line completion of R object
@c and file names, quick access to object and search lists, transcript
@c recording, and an interface to the help system), and transcript
@c manipulation (recording and saving transcript files, manipulating and
@c editing saved transcripts, and re-evaluating commands from transcript
@c files).

R support는 R source 코드를 고치는 것 syntactic indentation과 소스코드의 강조, 코드의 부분적인 평가, 코드의 로딩과 오류 체크, 그리고 소스 코드 수정 관리) 그리고 documentation (syntactic indentation과 소스코드의 강조, 실행되고있는 ESS 프로세스로 예제들을 보내는것, 그리고 미리보기), Emacs안에서부터 inferior R 프로세스로 상호작용 (명령줄 고치기, 찾을 수 있는 명령 히스토리, R object와 파일 이름들의 명령줄 완성, object와 검색 목록들로의 빠른 액세스, transcript recording, 그리고 help 시스템으로의 인터페이스), 그리고 transcript manipulation (recording과 transcript 파일드의 저장, 저장된 transcript들을 조작하고 고침, 그리고 transcript 파일들에서부터의 명령들을 재 평가). 


@c The latest stable version of @acronym{ESS} are available via @CRAN{} or
@c the @url{http://ESS.R-project.org/, ESS web page}.  The @HTML{} version
@c of the documentation can be found at @url{http://stat.ethz.ch/ESS/}.


ESS의 최근 안정된 버전은 CRAN 혹은ESS web page를 통해서 이용 가능 합니다. Documentation의 HTML버전은http://stat.ethz.ch/ESS/에서 찾을 수 있습니다. 


@c @acronym{ESS} comes with detailed installation instructions.


ESS는 자세한 설치 설명들과 함께 옵니다. 

@c For help with @acronym{ESS}, send email to
@c @email{ESS-help@@stat.math.ethz.ch}.

ESS에 대한 도움이 필요하면, @email{ESS-help@@stat.math.ethz.ch}로 이메일을 보내십시오.


@c Please send bug reports and suggestions on @acronym{ESS} to
@c @email{ESS-bugs@@stat.math.ethz.ch}.  The easiest way to do this from is
@c within Emacs by typing @kbd{M-x ess-submit-bug-report} or using the
@c [ESS] or [iESS] pulldown menus.

ESS에 대한 버그 리포드들이나 제안사항들을 @email{ESS-bugs@@stat.math.ethz.ch}로 보내주십시오. 이를 하기에 가장 쉬운 방법은 Emacs안에서M-x ess-submit-bug-report를 타입하거나 pulldown 메뉴들에서 [ESS] 혹은 [iESS]를 사용하는 것 입니다.


@node Should I run R from within Emacs?, Debugging R from within Emacs, Is there Emacs support for R?, R and Emacs
@section Should I run R from within Emacs?

@c Yes, @emph{definitely}.  Inferior R mode provides a readline/history
@c mechanism, object name completion, and syntax-based highlighting of the
@c interaction buffer using Font Lock mode, as well as a very convenient
@c interface to the R help system.

네, 확실합니다. Inferior R 모드는 readline/ 히스토리 메카니즘, object 이름 완성, 그리고 Font Lock 모드를 이용한 상호작용 buffer의 syntax-based hightliting, 또한 R  help system으로의 매우 편리한 인터페이스를 제공합니다. 

@c Of course, it also integrates nicely with the mechanisms for editing R
@c source using Emacs.  One can write code in one Emacs buffer and send
@c whole or parts of it for execution to R; this is helpful for both data
@c analysis and programming.  One can also seamlessly integrate with a
@c revision control system, in order to maintain a log of changes in your
@c programs and data, as well as to allow for the retrieval of past
@c versions of the code.

물론, 이는 Emacs를 이용한 R 소스를 고치는 메케니즘과도 잘 통합됩니다. 누군가는 하나의 Emacs buffer에 코드를 쓰고 R로의 실행을 위해 그의 전체나 부분을 보낼수도 있습니다; 이는 데이터 분석과 프로그래밍 두가지 모두에 유용합니다. 누군가는 또 당신의 프로그램들이 데이터안의 변경들의 로그를 유지하고, 또한 코드의 전 버전들의 retrieval을 허락하기위한 revision control system을 균일하게 통합 할 수도 있습니다.  

@c In addition, it allows you to keep a record of your session, which can
@c also be used for error recovery through the use of the transcript mode.

추가로, 이는 transcript 모드의 사용을 통해 에러를 회복할 수도 있는, 당신의 세션의 기록을 보관하도록 허용합니다. 
Inferior R 프로세스의 명령줄 argument들을 지정하기위해서는, R을 시작하는 것에C-u M-x R를 사용하십시오.

@c To specify command line arguments for the inferior R process, use
@c @kbd{C-u M-x R} for starting R.

@c This prompts you for the arguments; in particular, you can increase
@c the memory size this way (@pxref{Why does R run out of memory?}).

@node Debugging R from within Emacs,  , Should I run R from within Emacs?, R and Emacs
@section Debugging R from within Emacs

@c To debug R ``from within Emacs'', there are several possibilities.  To
@c use the Emacs GUD (Grand Unified Debugger) library with the recommended
@c debugger GDB, type @kbd{M-x gdb} and give the path to the R
@c @emph{binary} as argument.  At the @command{gdb} prompt, set
@c @env{R_HOME} and other environment variables as needed (using e.g.@:
@c @kbd{set env R_HOME /path/to/R/}, but see also below), and start the
@c binary with the desired arguments (e.g., @kbd{run --quiet}).

“Emacs내에서” R을 debug하기위해서, 몇가지의 가능성들이 있습니다. 권장된 debugger GDB가 있는 Emacs GUD (Grand Unified Debugger) library를 사용하기위해서는, M-x gdb를 타입하고 argument 처럼 R binary로의 경로를 줍니다. gdb prompt에서, R_HOME과 필요한 대로 다른 환경값들을 타입하고(예로, env R_HOME /path/to/R/를 사용하여, 하지만 아래도 참조하십시오), 원하는 argument들을 가진 binary를 시작합니다 (예,  run –quiet).

@c If you have @acronym{ESS}, you can do @kbd{C-u M-x R @key{RET} - d
@c @key{SPC} g d b @key{RET}} to start an inferior R process with arguments
@c @option{-d gdb}.

만약 ESS가 있다면, argument들-d gdb를 가진 inferior R 프로세스를 시작하기 위해 C-u M-x R <RET> - d <SPC> g d b <RET>를 할 수 있습니다. 


@c A third option is to start an inferior R process via @acronym{ESS}
@c (@kbd{M-x R}) and then start GUD (@kbd{M-x gdb}) giving the R binary
@c (using its full path name) as the program to debug.  Use the program
@c @command{ps} to find the process number of the currently running R
@c process then use the @code{attach} command in gdb to attach it to that
@c process.  One advantage of this method is that you have separate
@c @code{*R*} and @code{*gud-gdb*} windows.  Within the @code{*R*} window
@c you have all the @acronym{ESS} facilities, such as object-name
@c completion, that we know and love.

세 번째 옵션은ESS (M-x R)를 통해 inferior R 프로세스를 시작하고나서 debug로의 프로그램처럼 R binary(전체 경로의 이름을 사용)를 주는GUD (M-x gdb)를 시작합니다. 현재 실행되고있는 R 프로세스의 프로세스 번호를 찾기 위해서 프로그램 ps를 사용하고 그 프로세스에 gdb안에 이를 첨부하기위해 attach를 사용합니다. 이 방법의 하나의 이점은 독립된 *R*과 *gud-gdb* 윈도우즈를 가지고 있다는 것 입니다. *R* 윈도우즈 안에는 object 이름 완성과 같은 우리가 알고 사랑하는 모든 ESS 기능들이 있습니다. 


@c When using GUD mode for debugging from within Emacs, you may find it
@c most convenient to use the directory with your code in it as the current
@c working directory and then make a symbolic link from that directory to
@c the R binary.  That way @file{.gdbinit} can stay in the directory with
@c the code and be used to set up the environment and the search paths for
@c the source, e.g.@: as follows:
Emacs 내에서 debugging을 위해 GUD 모드를 사용할 떄, 현재 실행 디렉토리처럼 코드를 디렉토리를 사용하고 R binary로의 디렉토리로부터 symbolic 링크를 만드는 것이 가장 편리할 것입니다. 그렇게 하면, .gdbinit는 코드와 함께 디렉토리 안에 계속있고 소스의 환경과 검색 경로들을 셋업하는데에 사용됩니다, 예제는 아래와 같습니다: 


@example
set env R_HOME /opt/R
set env R_PAPERSIZE letter
set env R_PRINTCMD lpr
dir /opt/R/src/appl
dir /opt/R/src/main
dir /opt/R/src/nmath
dir /opt/R/src/unix
@end example

@node R Miscellanea, R Programming, R and Emacs, Top
@chapter R Miscellanea

@menu
* How can I set components of a list to NULL?::  
* How can I save my workspace?::  
* How can I clean up my workspace?::  
* How can I get eval() and D() to work?::  
* Why do my matrices lose dimensions?::  
* How does autoloading work?::  
* How should I set options?::   
* How do file names work in Windows?::  
* Why does plotting give a color allocation error?::  
* How do I convert factors to numeric?::  
* Are Trellis displays implemented in R?::  
* What are the enclosing and parent environments?::  
* How can I substitute into a plot label?::  
* What are valid names?::       
* Are GAMs implemented in R?::  
* Why is the output not printed when I source() a file?::  
* Why does outer() behave strangely with my function?::  
* Why does the output from anova() depend on the order of factors in the model?::  
* How do I produce PNG graphics in batch mode?::  
* How can I get command line editing to work?::  
* How can I turn a string into a variable?::  
* Why do lattice/trellis graphics not work?::  
* How can I sort the rows of a data frame?::  
* Why does the help.start() search engine not work?::  
* Why did my .Rprofile stop working when I updated R?::  
* Where have all the methods gone?::  
* How can I create rotated axis labels?::  
* Why is read.table() so inefficient?::  
* What is the difference between package and library?::  
* I installed a package but the functions are not there::  
* Why doesn't R think these numbers are equal?::  
* How can I capture or ignore errors in a long simulation?::  
* Why are powers of negative numbers wrong?::  
* How can I save the result of each iteration in a loop into a separate file?::  
* Why are p-values not displayed when using lmer()?::  
* Why are there unwanted borders::  
* Why does backslash behave strangely inside strings?::  
* How can I put error bars or confidence bands on my plot?::  
* How do I create a plot with two y-axes?::  
* How do I access the source code for a function?::  
* Why does summary() report strange results for the R^2 estimate when I fit a linear model with no intercept?::  
* Why is R apparently not releasing memory?::  
@end menu

@c @node Why does R run out of memory?, Why does sourcing a correct file fail?, R Miscellanea, R Miscellanea
@c @section Why does R run out of memory?

@c Versions of R prior to 1.2.0 used a @emph{static} memory model.  At
@c startup, R asked the operating system to reserve a fixed amount of
@c memory for it.  The size of this chunk could not be changed
@c subsequently.  Hence, it could happen that not enough memory was
@c allocated, e.g., when trying to read large data sets into R.  In such
@c cases, it was necessary to restart R with more memory available, as
@c controlled by the command line options @option{--nsize} and
@c @option{--vsize}.

@c R version 1.2.0 introduces a new ``generational'' garbage collector,
@c which will increase the memory available to R as needed.  Hence, user
@c intervention is no longer necessary for ensuring that enough memory is
@c available.

@c The new garbage collector does not move objects in memory, meaning that
@c it is possible for the free memory to become fragmented so that large
@c objects cannot be allocated even when there is apparently enough memory
@c for them.

@c @node Why does sourcing a correct file fail?, How can I set components of a list to NULL?, Why does R run out of memory?, R Miscellanea
@c @section Why does sourcing a correct file fail?

@c Versions of R prior to 1.2.1 may have had problems parsing files not
@c ending in a newline.  Earlier R versions had a similar problem when
@c reading in data files.  This should no longer happen.

@node How can I set components of a list to NULL?, How can I save my workspace?, R Miscellanea, R Miscellanea
@c @section How can I set components of a list to NULL?
@section 어떻게 해야 list의 구성요소들을 NULL로 지정할 수 있을까요?

@c You can use
먼저 아래의 코드를 보세요.
@example
x[i] <- list(NULL)
@end example

@c @noindent
@c to set component @code{i} of the list @code{x} to @code{NULL}, similarly
@c for named components.  Do not set @code{x[i]} or @code{x[[i]]} to
@c @code{NULL}, because this will remove the corresponding component from
@c the list.
@noindent
이것은 리스트 @code{x}의 @code{i}번째 구성요소를 @code{NULL}로 지정하게 해줍니다. 이름이 주어져 있는 구성요소 역시 이와 같은 방식으로 할 수 있습니다. 그러나, @code{x[i]} 또는 @code{x[[i]]}를 @code{NULL}의 값을 대입하지는 마시길 바랍니다.  그 이유는 이러한 대입은 해당 구성요소 자체를 리스트로부터 삭제합니다. 

@c For dropping the row names of a matrix @code{x}, it may be easier to use
@c @code{rownames(x) <- NULL}, similarly for column names.
행렬 @code{x}의 행의 이름들을 없애기 위해서는 @code{rownames(x) <- NULL}를 하세요.  이러한 방법은 열의 이름들을 없애는데에도 유사하게 적용됩니다.

@node How can I save my workspace?, How can I clean up my workspace?, How can I set components of a list to NULL?, R Miscellanea
@c @section How can I save my workspace?
@section 어떻게 하면 현재 나의 작업공간을 저장할 수 있나요? 

@c @code{save.image()} saves the objects in the user's @code{.GlobalEnv} to
@c the file @file{.RData} in the R startup directory.  (This is also what
@c happens after @kbd{q("yes")}.)  Using @code{save.image(@var{file})} one
@c can save the image under a different name.
@code{save.image()} 함수는 사용자의 @code{.GlobalEnv}에 있는 객체들을 @file{.RData}의 형식으로 R의 스타트업 디렉토리에 저장합니다. (이것은 @kbd{q("yes")}과 동일합니다.)  @code{save.image(@var{file})}을 이용하여 다른 이름으로 저장하는 할 수도 있습니다. 


@node How can I clean up my workspace?, How can I get eval() and D() to work?, How can I save my workspace?, R Miscellanea
@c @section How can I clean up my workspace?
@section 어떻게 해야 나의 작업공간을 깨끗하게 할 수 있을까요?

@c To remove all objects in the currently active environment (typically
@c @code{.GlobalEnv}), you can do

현재 활성화 되어있는 프로그래밍 환경 (주로 @code{.GlobalEnv}를 의미함)에 있는 모든 객체를 지우려고 한다면 다음과 같이 하면 됩니다.

@example
rm(list = ls(all = TRUE))
@end example

@noindent
@c (Without @option{all = TRUE}, only the objects with names not starting
@c with a @samp{.} are removed.)

(만약 @option{all = TRUE}을 사용하지 않는다면, @samp{.}으로 시작하지 않는 객체들만이 삭제됩니다.)

@node How can I get eval() and D() to work?, Why do my matrices lose dimensions?, How can I clean up my workspace?, R Miscellanea
@section How can I get eval() and D() to work?

@c Strange things will happen if you use @code{eval(print(x), envir = e)}
@c or @code{D(x^2, "x")}.  The first one will either tell you that
@c "@code{x}" is not found, or print the value of the wrong @code{x}.
@c The other one will likely return zero if @code{x} exists, and an error
@c otherwise.

만약 @code{eval(print(x), envir = e)} 또는 @code{D(x^2, "x")}를 실행하고자 한다면 예상치 않은 결과가 나타날 것입니다.
전자는 "@code{x}"를 찾을 수 없다고 하거나, 잘못된 @code{x}의 값을 출력할 것입니다. 
후자는 만약 @code{x}가 존재한다면 0값을 돌려줄 수 있으며, 그렇지 않다면 에러를 보여줄 것입니다. 

@c This is because in both cases, the first argument is evaluated in the
@c calling environment first.  The result (which should be an object of
@c mode @code{"expression"} or @code{"call"}) is then evaluated or
@c differentiated.  What you (most likely) really want is obtained by
@c ``quoting'' the first argument upon surrounding it with
@c @code{expression()}.  For example,

두가지 경우 모두 다 불러들어온 환경 내에서 첫번째 인자가 평가되기 때문입니다. 
객체의 모드가 반드시 @code{"expression"} 또는 @code{"call"}이어야 하고 그 결과가 평가되거나 미분된 것입니다.
이를 해결하기 위해서는 아래와 같이 반드시 첫번째 인자를 큰 따옴표로 묶어줘야 한다는것입니다. 

@example
R> D(expression(x^2), "x")
2 * x
@end example

@c Although this behavior may initially seem to be rather strange, is
@c perfectly logical.  The ``intuitive'' behavior could easily be
@c implemented, but problems would arise whenever the expression is
@c contained in a variable, passed as a parameter, or is the result of a
@c function call.  Consider for instance the semantics in cases like

이렇게 하는 것이 처음에는 다소 이상해 보일 수 있으나, 완전히 논리적인 부분일 뿐입니다.

@example
D2 <- function(e, n) D(D(e, n), n)
@end example

@noindent
@c or

또는 
@example
g <- function(y) eval(substitute(y), sys.frame(sys.parent(n = 2)))
g(a * b)
@end example

@c See the help page for @code{deriv()} for more examples.
더 많은 예제들을 @code{deriv()}의 도움말 페이지를 통하여 확인할 수 있습니다. 

@node Why do my matrices lose dimensions?, How does autoloading work?, How can I get eval() and D() to work?, R Miscellanea
@section Why do my matrices lose dimensions?

@c When a matrix with a single row or column is created by a subscripting
@c operation, e.g., @code{row <- mat[2, ]}, it is by default turned into a
@c vector.  In a similar way if an array with dimension, say, @w{2 x 3 x 1
@c x 4} is created by subscripting it will be coerced into a @w{2 x 3 x 4}
@c array, losing the unnecessary dimension.  After much discussion this has
@c been determined to be a @emph{feature}.

단일의 열이나 행으로 이루어진 행렬은 subscripting operation에 의해 생성됩니다, 예로, row <- mat[2, ], 이는 자동적으로 벡터로 바뀝니다. 비슷한 방법으로 만약2 x 3 x 1 x 4라고 하는 dimension이 있는 array는 이를 subscripting에 의해  불필요한 dimension을 잃은 2 x 3 x 4 array로 강제 생성됩니다. 많은  논의 후 이는 feature로 결정되었습니다.  

@c To prevent this happening, add the option @option{drop = FALSE} to the
@c subscripting.  For example,

이런 일을 막기 위해서, subscripting에 옵션drop = FALSE를 더하십히오. 예를들어,

@example
rowmatrix <- mat[2, , drop = FALSE]  # @r{creates a row matrix}
colmatrix <- mat[, 2, drop = FALSE]  # @r{creates a column matrix}
a <- b[1, 1, 1, drop = FALSE]        # @r{creates a 1 x 1 x 1 array}
@end example

@c The @option{drop = FALSE} option should be used defensively when
@c programming.  For example, the statement

drop = FALSE 옵션은 프로그래밍을 할 때에 수동적으로 사용되어야만 합니다. 예를들어, 문장

@example
somerows <- mat[index, ]
@end example

@noindent
@c will return a vector rather than a matrix if @code{index} happens to
@c have length 1, causing errors later in the code.  It should probably be
@c rewritten as

은 만약 index가 이 코드에서 나중에 오류의 원인이 되는 길이 1을 가지고 있다면, 행렬대신 벡터를 return 할 것입니다. 이는 다음과같이 다시 쓰여져야만 할 것입니다.

@example
somerows <- mat[index, , drop = FALSE]
@end example

@node How does autoloading work?, How should I set options?, Why do my matrices lose dimensions?, R Miscellanea
@section How does autoloading work?

@c R has a special environment called @code{.AutoloadEnv}.  Using
@c @kbd{autoload(@var{name}, @var{pkg})}, where @var{name} and
@c @var{pkg} are strings giving the names of an object and the package
@c containing it, stores some information in this environment.  When R
@c tries to evaluate @var{name}, it loads the corresponding package
@c @var{pkg} and reevaluates @var{name} in the new package's
@c environment.

R은.AutoloadEnv라고 불리우는 특별한 환경이 있습니다. Name 과 pkg가 object의 이름과 그를 포함하는 패키지를 주는 string인 곳에서, autoload(name, pkg)를 사용하여, 이 환경 안에서 몇몇의 정보를 저장합니다. R이 name을 평가하려고 할 떄, 이는 해당하는 패키지 pkg를 로드하고 새로운 패키지의 환경안의 name을 재 평가 합니다. 

@c Using this mechanism makes R behave as if the package was loaded, but
@c does not occupy memory (yet).

이 mechanism을 사용하여 패키지가 로드되었지만 (아직) 메모리를 차지하지 않은 것처럼 R이 행동하도록 만듭니다.

@c See the help page for @code{autoload()} for a very nice example.

매우 좋은 예제들은help 페이지에서 autoload()를 참조하십시오. 


@node How should I set options?, How do file names work in Windows?, How does autoloading work?, R Miscellanea
@section How should I set options?

@c The function @code{options()} allows setting and examining a variety of
@c global ``options'' which affect the way in which R computes and displays
@c its results.  The variable @code{.Options} holds the current values of
@c these options, but should never directly be assigned to unless you want
@c to drive yourself crazy---simply pretend that it is a ``read-only''
@c variable.

options() function은 R이 결과를 compute하고 display하는데의 방법에 영향을 미치는 다양한 global “옵션들”을 setting하고 examining하는 것을 허용합니다. .Options 값은 현재 이 옵션들의 값을 가지고 있지만, 당신을 미치게 만들고 싶지 않은 이상 직접적으로 배정되어서는 안됩니다 – 간단하게 이것이 “읽기 전용”값인 것 처럼 하십시오. 

@c For example, given

예를들어, 주어진
@example
test1 <- function(x = pi, dig = 3) @{
  oo <- options(digits = dig); on.exit(options(oo));
  cat(.Options$digits, x, "\n")
@}
test2 <- function(x = pi, dig = 3) @{
  .Options$digits <- dig
  cat(.Options$digits, x, "\n")
@}
@end example

@noindent
@c we obtain:
우리는 아래를 얻습니다. 

@example
R> test1()
3 3.14 
R> test2()
3 3.141593
@end example

@c What is really used is the @emph{global} value of @code{.Options}, and
@c using @kbd{options(OPT = VAL)} correctly updates it.  Local copies of
@c @code{.Options}, either in @code{.GlobalEnv} or in a function
@c environment (frame), are just silently disregarded.

실제로 쓰여진 것은.Options의 global 값이고, options(OPT = VAL)를 씀으로 이를 정확하게 업데이트 합니다. .Options의 local copy들은, .GlobalEnv 안이나 function 환경 (frame)안에, 조용히 무시되어 집니다. 

@node How do file names work in Windows?, Why does plotting give a color allocation error?, How should I set options?, R Miscellanea
@section How do file names work in Windows?

@c As R uses C-style string handling, @samp{\} is treated as an escape
@c character, so that for example one can enter a newline as @samp{\n}.
@c When you really need a @samp{\}, you have to escape it with another
@c @samp{\}.

R이 C-style string handling을 사용함으로써, ‘\’는 escape character처럼 대해지고, 예로써 새로운 줄을 ‘\n’로 쓸 수 있습니다. ‘\’가 정말로 필요할 때, 다른‘\’와 함께 이를 escape 해야만 합니다. 

@c Thus, in filenames use something like @code{"c:\\data\\money.dat"}.  You
@c can also replace @samp{\} by @samp{/} (@code{"c:/data/money.dat"}).

그리하여, 파일 이름 안에 "c:\\data\\money.dat"와 같은 것을 씁니다. ‘\’를 ‘/’로 교체 할 수도 있습니다 ("c:/data/money.dat").  


@node Why does plotting give a color allocation error?, How do I convert factors to numeric?, How do file names work in Windows?, R Miscellanea
@section Why does plotting give a color allocation error?

@c On an X11 device, plotting sometimes, e.g., when running
@c @code{demo("image")}, results in ``Error: color allocation error''.
@c This is an X problem, and only indirectly related to R.  It occurs when
@c applications started prior to R have used all the available colors.
@c (How many colors are available depends on the X configuration; sometimes
@c only 256 colors can be used.)

X11 장치에서, 가끔하는 plotting은, 예를들어demo("image")를 실행할 때, “오류: 색상 할당 오류”의 결과를 초래합니다. 이는 X 문제이고, R과 간접적으로만 관련이 있습니다. 이는 R전에 시작되었던 application들이 모든 이용가능한 색들을 써버렸을 때 일어납니다. (얼마나 많은 색상이 이용가능한지는 X configuration에 의해 결정됩니다; 가끔은 256 색만이 사용할 가능할 수도 있습니다.)


@c One application which is notorious for ``eating'' colors is Netscape.
@c If the problem occurs when Netscape is running, try (re)starting it with
@c either the @option{-no-install} (to use the default colormap) or the
@c @option{-install} (to install a private colormap) option.

“먹는”색으로 악명이 높은 application은 Netscape입니다. 만약 Netscape이 실행되는 도중에 이 문제가 발생하면, -no-install (기본 colormap을 사용하도록하는) 혹은 –install (개인 소유의 colormap을 설치하도록 하는)옵션을 사용하여 (재)시작을 해 보십시오.

@c You could also set the @code{colortype} of @code{X11()} to
@c @code{"pseudo.cube"} rather than the default @code{"pseudo"}.  See the
@c help page for @code{X11()} for more information.

X11()의 colortype을 기본값 "pseudo" 대신에"pseudo.cube"로 설정할 수도 있습니다. 더 많은 정보를 위해서는 help 페이지의 X11()을 참조하십시오.


@c  @node Is R Y2K-compliant?, How do I convert factors to numeric?, Why does plotting give a color allocation error?, R Miscellanea
@c  @section Is R Y2K-compliant?

@c  We expect R to be Y2K compliant when compiled and run on a Y2K compliant
@c  system.  In particular R does not internally represent or manipulate
@c  dates as two-digit quantities.  However, no guarantee of Y2K compliance
@c  is provided for R.  R is free software and comes with @emph{no warranty
@c  whatsoever}.

@c  R, like any other programming language, can be used to write programs
@c  and manipulate data in ways that are not Y2K compliant.

@node How do I convert factors to numeric?, Are Trellis displays implemented in R?, Why does plotting give a color allocation error?, R Miscellanea
@section How do I convert factors to numeric?

@c It may happen that when reading numeric data into R (usually, when
@c reading in a file), they come in as factors.  If @code{f} is such a
@c factor object, you can use

R로 숫자 데이터를 읽을 때 (보통, 파일을 읽을 때), 이들이 factor들 처럼 오는 경우가 있을 수도 있습니다. 만약 f가 그런 factor object라면, 당신은 

@example
as.numeric(as.character(f))
@end example

@noindent
@c to get the numbers back.  More efficient, but harder to remember, is
를 숫자들을 다시 가져오기위해 사용할 수 있습니다. 더 효율적이지만, 기억하기는 더 어려운,

@example
as.numeric(levels(f))[as.integer(f)]
@end example

@c In any case, do not call @code{as.numeric()} or their likes directly for
@c the task at hand (as @code{as.numeric()} or @code{unclass()} give the
@c internal codes).
어떠한 경우에도, 주어진 일(as.numeric()나 unclass() 는 내부 코드들을 줍니다.)에 직접적으로 as.numeric()나 그 비슷한 것을 부르지 마십시오. 


@node Are Trellis displays implemented in R?, What are the enclosing and parent environments?, How do I convert factors to numeric?, R Miscellanea
@section Are Trellis displays implemented in R?

@c The recommended package @CRANpkg{lattice} (which is based on base
@c package @pkg{grid}) provides graphical functionality that is compatible
@c with most Trellis commands.

권장된 패키지 lattice (베이스 패키지 grid에 기초를 두고있는)는 대부분의 Trellis 명령어들과 호환 가능한 그래픽 기능을 제공합니다. 

@c You could also look at @code{coplot()} and @code{dotchart()} which might
@c do at least some of what you want.  Note also that the R version of
@c @code{pairs()} is fairly general and provides most of the functionality
@c of @code{splom()}, and that R's default plot method has an argument
@c @code{asp} allowing to specify (and fix against device resizing) the
@c aspect ratio of the plot.

적어도 당신이 원하는 몇개는 할 수도 있는 coplot()와 dotchart() 또한 살펴볼 수 있습니다. Pairs()의 R버전이 꽤나 일반적이고 splom()의 거의 모든 기능들을 제공하며, R의 기본 plot method가 plot의 aspect ratio를 지정하는 것을 허락하는 (그리고 device 크기를 재조정하는 것에 반하여 fix하는) argument asp를 가지고 있다는 것 또한 유의하십시오.

@c (Because the word ``Trellis'' has been claimed as a trademark we do not
@c use it in R.  The name ``lattice'' has been chosen for the R
@c equivalent.)

(단어 “Trellis”가 상표처럼 주장되었기 떄문에 R에서는 이 단어를 사용하지 않습니다. 이름 “lattice”는 R equivalent에서 선택되었습니다.)

@node What are the enclosing and parent environments?, How can I substitute into a plot label?, Are Trellis displays implemented in R?, R Miscellanea
@section What are the enclosing and parent environments?

@c Inside a function you may want to access variables in two additional
@c environments: the one that the function was defined in (``enclosing''),
@c and the one it was invoked in (``parent'').

Function 안에서 두 개의 추가 환경들안의 값들로의 액세스를 원할지도 모릅니다: function이 정의되지 않은 것(“enclosing”)과 function이 적용된 것 (“parent”).

@c If you create a function at the command line or load it in a package its
@c enclosing environment is the global workspace.  If you define a function
@c @code{f()} inside another function @code{g()} its enclosing environment
@c is the environment inside @code{g()}.  The enclosing environment for a
@c function is fixed when the function is created.  You can find out the
@c enclosing environment for a function @code{f()} using
@c @code{environment(f)}.

만약 명령줄에 function을 생성했거나 패키지 안에 그를 load했다면, 그의 enclosing환경은 global workspace입니다. 만약 function f()를 다른 function g()에 지정했다면, 그의 enclosing 환경은 g()안의 환경입니다. 그 function에 대한 enclosing 환경은 function이 생성되었을 떄 고정되었습니다. Function f()에 대한 enclosing 환경은 environment(f)를 사용하여 찾을 수 있습니다. 

@c The ``parent'' environment, on the other hand, is defined when you
@c invoke a function.  If you invoke @code{lm()} at the command line its
@c parent environment is the global workspace, if you invoke it inside a
@c function @code{f()} then its parent environment is the environment
@c inside @code{f()}.  You can find out the parent environment for an
@c invocation of a function by using @code{parent.frame()} or
@c @code{sys.frame(sys.parent())}.

반면에, “parent” 환경은 function을 적용할 떄 정의됩니다. 만약 명령줄에 lm()을 적용한다면, 이의 parent 환경이 global workspace이고, 만약 이를 function f() 안에 지정한다면, 이의 parent 환경은 f() 안의 환경입니다. parent.frame() 이나 sys.frame(sys.parent())를 사용하여 function의 invocation을 위한 parent 환경을 찾아낼 수 있습니다. 

@c So for most user-visible functions the enclosing environment will be the
@c global workspace, since that is where most functions are defined.  The
@c parent environment will be wherever the function happens to be called
@c from.  If a function @code{f()} is defined inside another function
@c @code{g()} it will probably be used inside @code{g()} as well, so its
@c parent environment and enclosing environment will probably be the same.

그래서, 대부분의 사용자가 볼수있는 function들에 대해 대부분의 function들이 정의된 곳이기 때문에enclosing 환경이 global workspace가 될 것입니다. Parent 환경은 function의 호출이 일어나는 곳 어디든지가 될 것입니다. 만약 function f()가 다른 function g()안에서 정의된다면, 이는 g() 안에서도 사용될 것이고, 그리하여 그의 parent 환경과 enclosing 환경은 아마도 같을 것 입니다.

@c Parent environments are important because things like model formulas
@c need to be evaluated in the environment the function was called from,
@c since that's where all the variables will be available.  This relies on
@c the parent environment being potentially different with each invocation.

Parent 환경들은 model formula들 같은 것들이 모든 값들이 이용가능한 장소인 function이 불려온 환경을 평가하는데 필요하기 때문에 중요합니다. 이는 각각의 invocation에 따라 잠재적으로 다른 parent 환경에 의지합니다. 

@c Enclosing environments are important because a function can use
@c variables in the enclosing environment to share information with other
@c functions or with other invocations of itself (see the section on
@c lexical scoping).  This relies on the enclosing environment being the
@c same each time the function is invoked.  (In C this would be done with
@c static variables.)

Enclosing 환경들은 function이 enclosing 환경 안의 값들을 다른 function들과 혹은 다른 그자신의 invocation들을 가진 정보를 공유하도록 사용할 수 있기 때문에 중요합니다 (lexical scoping에 대한 섹션은 참조하십시오). 이는 function이 invoke될 때마다 enclosing 환경이 같다는 것을 필요로 합니다. (C에서 이는 정적 변수로 행해 질 것입니다.)

@c Scoping @emph{is} hard.  Looking at examples helps.  It is particularly
@c instructive to look at examples that work differently in R and S and try
@c to see why they differ.  One way to describe the scoping differences
@c between R and S is to say that in S the enclosing environment is
@c @emph{always} the global workspace, but in R the enclosing environment
@c is wherever the function was created.

Scoping은 어렵습니다. 예제들을 보는 것이 도움이 됩니다. 이는 R과 S에서 다르게 실행되고 왜 그들이 다른지를 보려고 노력하는 예제들을 보는 것이 특히 유익합니다. R과 S사이의 다른 scoping를 설명하는 하나의 방법으로는 S 안에서 enclosing 환경은 항상 global workspace이지만, R 안에서의 enclosing 환경은function이 생성된 곳 어디든지라는 것 입니다. 


@node How can I substitute into a plot label?, What are valid names?, What are the enclosing and parent environments?, R Miscellanea
@section How can I substitute into a plot label?

@c Often, it is desired to use the value of an R object in a plot label,
@c e.g., a title.  This is easily accomplished using @code{paste()} if the
@c label is a simple character string, but not always obvious in case the
@c label is an expression (for refined mathematical annotation).  In such a
@c case, either use @code{parse()} on your pasted character string or use
@c @code{substitute()} on an expression.  For example, if @code{ahat} is an
@c estimator of your parameter @math{a} of interest, use

자주, plot label 안에 R object의 값을 사용하는 것, 예, 제목, 이 원해 집니다. 이는 만약 label이 단순한 문자열일경우 paste()를 사용하여 쉽게 이뤄지지만, label이 expression (재 정비된 수학 주석에 대한)일때와 같은 경우는 항상 분명하지는 않습니다. 이런 경우에는, 복사하여 붙여진 문자열에parse()를 사용하거나 expression에substitute()를 사용합니다. 예를들어, 만약 ahat이 당신이 관심있어하는 parameter의 estimator이라면, 

@example
title(substitute(hat(a) == ahat, list(ahat = ahat)))
@end example

@noindent
@c (note that it is @samp{==} and not @samp{=}).  Sometimes @code{bquote()}
@c gives a more compact form, e.g.,
를 사용하십시오(‘=’이 아니라 ‘==’ 이라는 것에 유의하십시오). 가끔 bquote()가 더 간편한  형태를 줍니다, 예로, ‘.()’ 안의 subexpression들이 그들의 값에 의해 대체된 

@example
title(bquote(hat(a) = .(ahat)))
@end example

@noindent
@c where subexpressions enclosed in @samp{.()} are replaced by their
@c values.
메일링 리스트 archives에 더 많은 풀어진 예제들이 있습니다. 

@c There are more worked examples in the mailing list archives.

@node What are valid names?, Are GAMs implemented in R?, How can I substitute into a plot label?, R Miscellanea
@section What are valid names?

@c When creating data frames using @code{data.frame()} or
@c @code{read.table()}, R by default ensures that the variable names are
@c syntactically valid.  (The argument @option{check.names} to these
@c functions controls whether variable names are checked and adjusted by
@c @code{make.names()} if needed.)

data.frame() 이나 read.table()을 사용하여 데이터 프레임을 생성할 때, R은 기본적으로 변수 이름들이 구문상으로 반드시 유효하도록 합니다.  ( 이 함수들로의 argument check.names는 변수 이름들이 체크 되었는지를 조정하고, 만약 필요하면make.names()로 조절합니다.)

@c To understand what names are ``valid'', one needs to take into account
@c that the term ``name'' is used in several different (but related) ways
@c in the language:

어떤 이름들이 “유효한지”를 이해하기 위해서는, 언어 안에서 “이름”이 몇몇의 다른 (하지만 연관된) 방법으로 쓰여지는지를 생각 해 보아야 합니다.

@enumerate
@item
@c A @emph{syntactic name} is a string the parser interprets as this type
@c of expression.  It consists of letters, numbers, and the dot and (for
@c version of R at least 1.9.0) underscore characters, and starts with
@c either a letter or a dot not followed by a number.  Reserved words are
@c not syntactic names.
Syntactic name은 parser가 expression의 형태처럼 해석하는 string입니다. 이는 문자들과 숫자들, 그리고 점들과 (적어도 1.9.0 버전의 R에서) 밑줄 표시된 글자들을 포함하고, 숫자가 바로 뒤에 오지 않는 문자나 점으로 시작합니다. 예약어들은 syntactic name들이 아닙니다. 

@item
@c An @emph{object name} is a string associated with an object that is
@c assigned in an expression either by having the object name on the left
@c of an assignment operation or as an argument to the @code{assign()}
@c function.  It is usually a syntactic name as well, but can be any
@c non-empty string if it is quoted (and it is always quoted in the call to
@c @code{assign()}).
Object name은 assignment operation의 왼쪽에 있는 object 이름을 가지고 있는 것이나 assign() function으로의 argument에 의한 expression안에 배정된 object와 관련이 있는 string입니다.  이는 보통 syntactic name이기도 하지만, 만약 quoted(assign()으로 불러지면 항상 quoted입니다)되었다면 비어있지 않은 어떠한 string이 될 수도 있습니다. 

@item
@c An @emph{argument name} is what appears to the left of the equals sign
@c when supplying an argument in a function call (for example,
@c @code{f(trim=.5)}).  Argument names are also usually syntactic names,
@c but again can be anything if they are quoted.
Argument name은 function call (예로, f(trim=.5)) 안의 argument를 제공할 때 등부호의 왼쪽에 나타나는 것 입니다. Argument name들 또한 보통 syntactic name들이지만, 이 또한 만약 quoted면 어떤 것이든 될 수 있습니다. 

@item
@c An @emph{element name} is a string that identifies a piece of an object
@c (a component of a list, for example.)  When it is used on the right of
@c the @samp{$} operator, it must be a syntactic name, or quoted.
@c Otherwise, element names can be any strings.  (When an object is used as
@c a database, as in a call to @code{eval()} or @code{attach()}, the
@c element names become object names.)
Element name은 object의 조각 (예를들어, 목록의 구성요소)을 확인하는 string입니다. ‘$’ operator의 오른쪽에 사용되면, 이는 syntactic name 혹은 quoted여야만 합니다. 그렇지 않으면, element name들은 어떠한 string들이든 될 수 있습니다. (object는 eval()혹은 attach()로 불러지는 것 처럼, 데이터베이스처럼 사용될 때, element name들은 object name들이 됩니다.)


@item
@c Finally, a @emph{file name} is a string identifying a file in the
@c operating system for reading, writing, etc.  It really has nothing much
@c to do with names in the language, but it is traditional to call these
@c strings file ``names''.
마지막으로, file name은 읽고 쓰는 것 등을 위한 운영체계안의 파일을 확인하는 string입니다. 이는 언어 안의 이름들과 아무런 관련도 없지만, 이 string들을 파일 “이름들” 이라고 부르는 것이 인습입니다. 
@end enumerate

@node Are GAMs implemented in R?, Why is the output not printed when I source() a file?, What are valid names?, R Miscellanea
@section Are GAMs implemented in R?

@c Package @CRANpkg{gam} from @CRAN{} implements all the Generalized
@c Additive Models (GAM) functionality as described in the GAM chapter of
@c the White Book.  In particular, it implements backfitting with both
@c local regression and smoothing splines, and is extendable.  There is a
@c @code{gam()} function for GAMs in package @CRANpkg{mgcv}, but it is not
@c an exact clone of what is described in the White Book (no @code{lo()}
@c for example).  Package @CRANpkg{gss} can fit spline-based GAMs too.  And
@c if you can accept regression splines you can use @code{glm()}.  For
@c Gaussian GAMs you can use @code{bruto()} from package @CRANpkg{mda}.

CRAN에서부터의 패키지 gam은White Book의 GAM 챕터에서 설명된 것처럼 모든Generalized Additive Models (GAM) 기능을 시행합니다. 특히, 이는 local regresion과 smoothing sline들 둘 다를 사용하는 backfitting을 시행하고, 이는 연장 가능합니다. 패키지mgcv 안에는 GAM을 위한 gam() function이 있는데, 이는 White Book에 설명되어있는 것과 완전히 똑같지 않습니다 (한 예로 lo()가 없습니다). 패키지 gss는 spline-based GAM에도 적합할 수 있습니다. 그리고 만약 regression spline들을 받아들일 수 있다면 glm()을 사용할 수도 있습니다. Gaussian GAM들에는, 패키지 mda에서의 bruto()를 사용할 수 있습니다. 

@node Why is the output not printed when I source() a file?, Why does outer() behave strangely with my function?, Are GAMs implemented in R?, R Miscellanea
@section Why is the output not printed when I source() a file?

@c Most R commands do not generate any output. The command

대부분의 R 명령어들은 어떠한 output도 생성하지 않습니다. 명령어
@example
1+1
@end example

@noindent
@c computes the value 2 and returns it; the command
은 value 2를 산출하고 그를 return 합니다; 명령어 

@example
summary(glm(y~x+z, family=binomial))
@end example

@noindent
@c fits a logistic regression model, computes some summary information and
@c returns an object of class @code{"summary.glm"} (@pxref{How should I
@c write summary methods?}).
는 logistic regression model을 fit하고 몇몇의 요약 정볼ㄹ 산출하며 class의 object "summary.glm" 를 return합니다. (How should I write summary methods?를 참조하십시오). 

@c If you type @samp{1+1} or @samp{summary(glm(y~x+z, family=binomial))} at
@c the command line the returned value is automatically printed (unless it
@c is @code{invisible()}), but in other circumstances, such as in a
@c @code{source()}d file or inside a function it isn't printed unless you
@c specifically print it.
만약 명령줄에 ‘1+1’ 혹은 ‘summary(glm(y~x+z, family=binomial))’를 타입한다면, return된 겂은 자동으로 프린트되지만 (invisible()가 아닌한), source() 파일이나 function 안에있는 다른 상황에서는, 이는 당신이 특별히 프린트하지 않는 이상 프린트 되지 않습니다.  

@c To print the value use
값을 프린트 하기 위해서는

@example
print(1+1)
@end example

@noindent
를 사용하거나, 대신

@example
print(summary(glm(y~x+z, family=binomial)))
@end example

@noindent
@c instead, or use @code{source(@var{file}, echo=TRUE)}.
, 혹은source(file, echo=TRUE)를 사용하십시오. 

@node Why does outer() behave strangely with my function?, Why does the output from anova() depend on the order of factors in the model?, Why is the output not printed when I source() a file?, R Miscellanea
@section Why does outer() behave strangely with my function?

@c As the help for @code{outer()} indicates, it does not work on arbitrary
@c functions the way the @code{apply()} family does.  It requires functions
@c that are vectorized to work elementwise on arrays.  As you can see by
@c looking at the code, @code{outer(x, y, FUN)} creates two large vectors
@c containing every possible combination of elements of @code{x} and
@c @code{y} and then passes this to @code{FUN} all at once.  Your function
@c probably cannot handle two large vectors as parameters.

outer()의 도움말이 나타내듯이, 이는 apply() family가 하는 방법으로 arbitrary function들에는 실행되지 않습니다. 이는 array들에 elementwise처럼 실행되기위한 벡터화 된 fuction들을 필요로 합니다. 코드outer(x, y, FUN)를 보면 알 수 있듯이, 이는 x와 y의 element들의 모든 가능한 조합들을 포함한 두개의 큰 벡터들을 생성하고나서 FUN으로 한꺼번에 전달합니다. 당신의 function은 아마도 두개의 큰 벡터들을 parameter들 처럼 다루지 못할 것 입니다. 

@c If you have a function that cannot handle two vectors but can handle two
@c scalars, then you can still use @code{outer()} but you will need to wrap
@c your function up first, to simulate vectorized behavior.  Suppose your
@c function is
만약 두 개의 벡터는 다루지 못하지만 두 개의 scalar는 다룰 수 있는 function을 가지고 있다면, outer()를 계속 쓸 수는 있지만 벡터화 behavior를 simulate하기 위해서는 첫번째로 function을 둘러싸야만 할 것입니다. 당신의 function이 다음과 같다고 가정해 봅시다. 

@example
foo <- function(x, y, happy) @{
  stopifnot(length(x) == 1, length(y) == 1) # scalars only!
  (x + y) * happy
@}
@end example

@noindent
@c If you define the general function
만약 일반 function을 아래와 같이 정의한다면,

@example
wrapper <- function(x, y, my.fun, ...) @{
  sapply(seq_along(x), FUN = function(i) my.fun(x[i], y[i], ...))
@}
@end example

@noindent
@c then you can use @code{outer()} by writing, e.g.,
outer()를 사용할 수 있습니다. 예제, 

@example
outer(1:4, 1:2, FUN = wrapper, my.fun = foo, happy = 10)
@end example

@node Why does the output from anova() depend on the order of factors in the model?, How do I produce PNG graphics in batch mode?, Why does outer() behave strangely with my function?, R Miscellanea
@section Why does the output from anova() depend on the order of factors in the model?

@c In a model such as @code{~A+B+A:B}, R will report the difference in sums
@c of squares between the models @code{~1}, @code{~A}, @code{~A+B} and
@c @code{~A+B+A:B}.  If the model were @code{~B+A+A:B}, R would report
@c differences between @code{~1}, @code{~B}, @code{~A+B}, and
@c @code{~A+B+A:B} . In the first case the sum of squares for @code{A} is
@c comparing @code{~1} and @code{~A}, in the second case it is comparing
@c @code{~B} and @code{~B+A}.  In a non-orthogonal design (i.e., most
@c unbalanced designs) these comparisons are (conceptually and numerically)
@c different.

~A+B+A:B와 같은 모델 안에서, R은~1, ~A, ~A+B 와 ~A+B+A:B 모델들 사이의 sums of squares의 다른점을 보고할 것입니다. 만약 모델이~B+A+A:B였다면, R은~1, ~B, ~A+B, 와 ~A+B+A:B의 다른 점을 보고할 것입니다. Non-orthogonal design에서 (즉, 대부분의 불균형한 디자인들)이 비교들은 (개념상으로와 숫자상으로) 다릅니다.

@c Some packages report instead the sums of squares based on comparing the
@c full model to the models with each factor removed one at a time (the
@c famous `Type III sums of squares' from SAS, for example).  These do not
@c depend on the order of factors in the model.  The question of which set
@c of sums of squares is the Right Thing provokes low-level holy wars on
@c R-help from time to time.

몇몇의 패키지들은, 비교에 기초한 sums of squares 대신에, full 모델에서 각각의 factor가 한번에 하나씩 지워지는 모델(한 예로, 유명한 SAS에서의 ‘Type III sums of suqares’)을 보고합니다. 이는 모델 안의 factor들의 순서에 의존하지 않습니다. 어떤 sums of squares의 세트가 Right Thing (맞는 것) 인지의 질문은 이따금 R-help에서 낮은 레벨의 holy war들을 유발합니다. 

@c There is no need to be agitated about the particular sums of squares
@c that R reports.  You can compute your favorite sums of squares quite
@c easily.  Any two models can be compared with @code{anova(@var{model1},
@c @var{model2})}, and @code{drop1(@var{model1})} will show the sums of
@c squares resulting from dropping single terms.

R이 보고하는 특정한 sums of squares에 대해 불안해 할 필요가 없습니다. 당신은 당신이 가장 좋아하는 sums of squares를 꽤나 쉽게 산출할 수 있습니다. anova(model1, model2), 와 drop1(model1)를 사용하요 비교될 수 있는 모든 두개의 모델들은 단일항을 떨어뜨리는 것을 초례하는 sums of squares를 보여줄 것 입니다. 


@node How do I produce PNG graphics in batch mode?, How can I get command line editing to work?, Why does the output from anova() depend on the order of factors in the model?, R Miscellanea
@section How do I produce PNG graphics in batch mode?

@c Under a Unix-like, if your installation supports the
@c @code{type="cairo"} option to the @code{png()} device there should be no
@c problems, and the default settings should just work.  This option is not
@c available for versions of R prior to 2.7.0, or without support for
@c cairo.  From R 2.7.0 @code{png()} by default uses the Quartz device
@c on Mac OS X, and that too works in batch mode.

Unix –like 에서, 만약 당신의 설치가 png()로의type="cairo" 옵션을 지원한다면, 거기의 device는 아무런 문제가 없어야하고, 기본 세팅들이 그냥 실행되어야 합니다. 이 옵션은 2.7.0 이전의 R 버전들이나 cairo의 지원이 없이는 사용이 가능하지 않습니다. R 2.7.0 에서 png()는 기본으로 Mac OS X에서 Quartz device를 사용하고, 이것 또한 batch 모드에서 실행합니다. 

@c Earlier versions of the @code{png()} device uses the X11 driver, which
@c is a problem in batch mode or for remote operation.  If you have
@c Ghostscript you can use @code{bitmap()}, which produces a PostScript or
@c PDF file then converts it to any bitmap format supported by Ghostscript.
@c On some installations this produces ugly output, on others it is
@c perfectly satisfactory.  Many systems now come with Xvfb from
@c @url{http://www.x.org/Downloads.html, X.Org} (possibly as an optional
@c install), which is an X11 server that does not require a screen; and
@c there is the @CRANpkg{GDD} package from @CRAN{}, which produces PNG,
@c JPEG and GIF bitmaps without X11.

png() device의 이전 버전들에서는 batch 모드나 remote operation에서 무네가 있는 X11 드라이버를 사용합니다. 만약Ghostscript가 있다면, PostScript나 PDF 파일을 생산할 수 있는  bitmap()을 사용할 수 있고, 그러고 나서Ghostscript에서 지원하는 모든 bitmap 형식으로 이를 전환할 수 있습니다. 몇몇의 설치들에서 이는 보기 싫은 output을 생성하고, 다른 곳에서는 완벽하게 만족스럽습니다. 요즈음의 많은 시스템들은 스크린을 필요치 않는 X11 서버인 X.Org(옵션적인 설치일 수도 있습니다)에서 나온Xvfb와 함께 옵니다; 그리고 X11 없이 PNG, JPEG, 그리고 GIF bitmap들을 생성하는 CRAN에서 나온 GDD 패키지가 있습니다.  


@node How can I get command line editing to work?, How can I turn a string into a variable?, How do I produce PNG graphics in batch mode?, R Miscellanea
@section How can I get command line editing to work?

@c The Unix-like command-line interface to R can only provide the inbuilt
@c command line editor which allows recall, editing and re-submission of
@c prior commands provided that the @acronym{GNU} readline library is
@c available at the time R is configured for compilation.  Note that the
@c `development' version of readline including the appropriate headers is
@c needed: users of Linux binary distributions will need to install
@c packages such as @code{libreadline-dev} (Debian) or
@c @code{readline-devel} (Red Hat).

R로의 Unix-like 명령줄 인터페이스는 R이 compilation을 위한 구성을 할 때 사용가능한 GNU readline library를 제공하는 전 명령들의 recall, editing 그리고 re-submission을 허용하는 내장된 명령줄 editor만을 제공할 수 있습니다. Readline의 ‘개발’버전은 적합한 header들이 필요하다는 것을 유의하십시오: Linux binary distribution들의 사용자는libreadline-dev (Debian) 나readline-devel (Red Hat)와 같은 설치 패키지가 필요할 것입니다. 

@node How can I turn a string into a variable?, Why do lattice/trellis graphics not work?, How can I get command line editing to work?, R Miscellanea
@section How can I turn a string into a variable?

@c If you have
만약 

@example
varname <- c("a", "b", "d")
@end example

@noindent
@c you can do
를 가지고 있다면 당신은

@example
get(varname[1]) + 2
@end example

@noindent
@c for
를 다음에 대하여 

@example
a + 2
@end example

@noindent
@c or
혹은 

@example
assign(varname[1], 2 + 2)
@end example

@noindent
@c for
다음에 대하여

@example
a <- 2 + 2
@end example

@noindent
@c or
혹은

@example
eval(substitute(lm(y ~ x + variable),
                list(variable = as.name(varname[1]))))
@end example

@noindent
@c for
다음에 대하여

@example
lm(y ~ x + a)
@end example

@c At least in the first two cases it is often easier to just use a list,
@c and then you can easily index it by name
할 수 있습니다.

@example
vars <- list(a = 1:10, b = rnorm(100), d = LETTERS)
vars[["a"]]
@end example

@noindent
@c without any of this messing about.
적어도 처음 두가지의 경우에, 목록을 부르는 것이 종종 쉽고, 그러면 이에 대해 아무것도 지저분하게 만들지 않고 이름에 대해 쉽게 index를 할 수 있습니다. 

@node Why do lattice/trellis graphics not work?, How can I sort the rows of a data frame?, How can I turn a string into a variable?, R Miscellanea
@section Why do lattice/trellis graphics not work?

@c The most likely reason is that you forgot to tell R to display the
@c graph.  Lattice functions such as @code{xyplot()} create a graph object,
@c but do not display it (the same is true of @CRANpkg{ggplot2} graphics,
@c and Trellis graphics in @SPLUS{}).  The @code{print()} method for the
@c graph object produces the actual display.  When you use these functions
@c interactively at the command line, the result is automatically printed,
@c but in @code{source()} or inside your own functions you will need an
@c explicit @code{print()} statement.

대부분의 이유는 당신이 R에 그래프를 display하라고 명령을 내리는 것을 잊은것이 원인입니다. xyplot()과 같은 lattice function들은 그래프 object를 생성하지만, display하지는 않습니다 (ggplot2 그래픽과 S-Plus의 Trellis 그래픽들에서도 마찬가지입니다). 그래프 object를 위한 print() 방법은 실제 display를 생성합니다. 명령줄게 이 function들을 상호 작용적으로 사용한다면, 결과는 자동적으로 프린트 되지만, source() 안 혹은 당신의 function 안에서는 명확한print()문장이 필요할 것입니다. 

@node How can I sort the rows of a data frame?, Why does the help.start() search engine not work?, Why do lattice/trellis graphics not work?, R Miscellanea
@section How can I sort the rows of a data frame?

@c To sort the rows within a data frame, with respect to the values in one
@c or more of the columns, simply use @code{order()} (e.g.,
@c @code{DF[order(DF$a, DF[["b"]]), ]} to sort the data frame @code{DF} on
@c columns named @code{a} and @code{b}).

데이터 프레임 안에서, 한 개 이상의 행 안의 값들에 대하여, 열을 순서대로 정리하려면, 간단하게order()를 사용하십시오 (예, a와 b라고 이름 지어진 행의 데이터 프레임 DF를 순서대로 정리하기 위한DF[order(DF$a, DF[["b"]]), ]).


@node Why does the help.start() search engine not work?, Why did my .Rprofile stop working when I updated R?, How can I sort the rows of a data frame?, R Miscellanea
@section Why does the help.start() search engine not work?

@c The browser-based search engine in @code{help.start()} utilizes a Java
@c applet.  In order for this to function properly, a compatible version of
@c Java must installed on your system and linked to your browser, and both
@c Java @emph{and} JavaScript need to be enabled in your browser.

help.start() 안의 brower-based 검색 엔진은 Java applet을 활용합니다. 이것이 올바르게 작동하게하기 위해서는, Java의 호환가능한 버전이 당신의 시스템에 설치되어있고 당신의 브라우저에 링크가 되어있어야만 하고, Java와 JavaScript 모두 당신의 브라우저에서 가능해야만 합니다.  


@c There have been a number of compatibility issues with versions of Java
@c and of browsers.  
Java와 브라우저의 버전들에 많은 호환성 문제들이 있었습니다. 

@ifclear UseExternalXrefs
@c For further details please consult section ``Enabling search in HTML
@c help'' in @cite{R Installation and Administration}.  This manual is
@c included in the R distribution, @pxref{What documentation exists for
@c R?}, and its @acronym{HTML} version is linked from the @acronym{HTML}
@c search page.
더 자세한 사항은 R installation and Administration의 “Enabling search in HTML help” 섹션에서 상담해 주십시오. 이 메뉴얼은 R distribution에 포함되어 있고, What documentation exists for R?을 참조하십시오, HTML버전은 HTML 검색 페이지에 링크되어 있습니다
@end ifclear
@ifset UseExternalXrefs
@xref{Enabling search in HTML help, , Enabling search in HTML help,
R-admin, R Installation and Administration}, for further details.
@end ifset

@node Why did my .Rprofile stop working when I updated R?, Where have all the methods gone?, Why does the help.start() search engine not work?, R Miscellanea
@section Why did my .Rprofile stop working when I updated R?

@c Did you read the @file{NEWS} file?  For functions that are not in the
@c @pkg{base} package you need to specify the correct package namespace,
@c since the code will be run @emph{before} the packages are loaded.  E.g.,

NEWS 파일을 읽어 보셨습니까? base 패키지에 없는 function들에 대해, 코드들이 패키지가 로드되기 전에 실행될 것이기 떄문에, 정확한 패키지 namespace를 명시해야만 합니다. 예로,

@example
ps.options(horizontal = FALSE)
help.start()
@end example

@noindent
@c needs to be

는

@example
grDevices::ps.options(horizontal = FALSE)
utils::help.start()
@end example

@c <FIXME>
@c 3.0.0
@noindent
(@code{graphics::ps.options(horizontal = FALSE)} in R 1.9.x).
@c </FIXME>

@node Where have all the methods gone?, How can I create rotated axis labels?, Why did my .Rprofile stop working when I updated R?, R Miscellanea
@section Where have all the methods gone?

@c Many functions, particularly S3 methods, are now hidden in namespaces.
@c This has the advantage that they cannot be called inadvertently with
@c arguments of the wrong class, but it makes them harder to view.

많은 function들, 특히 S3 method들, 은 이제 namespace들 안에 숨겨져 있습니다. 이는 틀린 class의 argument와 함께 의도하지 않은 call을 할 수 없는 장점이 있지만, 이는 이들을 보기에 힘들어 지도록 만듭니다. 

@c To see the code for an S3 method (e.g., @code{[.terms}) use
@c S3 method에 대한 코드를 보려면 (예, [.terms) 

@example
getS3method("[", "terms")
@end example
를 사용하십시오.

@noindent
@c To see the code for an unexported function @code{foo()} in the namespace
@c of package @code{"bar"} use @code{bar:::foo}.  Don't use these
@c constructions to call unexported functions in your own code---they are
@c probably unexported for a reason and may change without warning.
패키지 “bar”의 namespace안의 내보내지지않은 function foo()에 대한 코드를 보기위해서는bar:::foo를 사용합니다. 당신만의 코드 안의 내보내지지 않은 function들을 부르기 위해서는 이 construction들을 사용하지 마십시오 – 그들은 아마도 이유가 있어서 내보내지지 않았을 것으고 경고 없이 바뀔지도 모릅니다. 


@node How can I create rotated axis labels?, Why is read.table() so inefficient?, Where have all the methods gone?, R Miscellanea
@section How can I create rotated axis labels?

@c To rotate axis labels (using base graphics), you need to use
@c @code{text()}, rather than @code{mtext()}, as the latter does not
@c support @code{par("srt")}.
(base 그래픽들을 이용하여)축의 label들을 회전하기위해서는, par("srt")을 지원하지 않는  mtext()대신에text()를 사용하여야 합니다. 

@example
## @r{Increase bottom margin to make room for rotated labels}
par(mar = c(7, 4, 4, 2) + 0.1)
## @r{Create plot with no x axis and no x axis label}
plot(1 : 8, xaxt = "n",  xlab = "")
## @r{Set up x axis with tick marks alone}
axis(1, labels = FALSE)
## @r{Create some text labels}
labels <- paste("Label", 1:8, sep = " ")
## @r{Plot x axis labels at default tick marks}
text(1:8, par("usr")[3] - 0.25, srt = 45, adj = 1,
     labels = labels, xpd = TRUE)
## @r{Plot x axis label at line 6 (of 7)}
mtext(1, text = "X Axis Label", line = 6)
@end example

@noindent
@c When plotting the x axis labels, we use @code{srt = 45} for text
@c rotation angle, @code{adj = 1} to place the right end of text at the
@c tick marks, and @code{xpd = TRUE} to allow for text outside the plot
@c region.  You can adjust the value of the @code{0.25} offset as required
@c to move the axis labels up or down relative to the x axis.  See
@c @code{?par} for more information.
x 축 label들을 plot할 때, 문자 회전 각도로srt = 45, 문자의 오른쪽 끝을 tick marks에 놓도록adj = 1, 그리고 바깥쪽의 plot region의 문자를 허용하기 위해xpd = TRUE를 사용합니다. 0.25 offset의 값을 x축에 관하여 축의 label들을 위로나 아래로 움직이도록 필요한 대로 조정할 수 있습니다. 더 많은 정보는?par를 참고하십시오. 

@c Also see Figure 1 and associated code in Paul Murrell (2003),
@c ``Integrating grid Graphics Output with Base Graphics Output'',
@emph{R News}, @strong{3/2}, 7--12.
또한 Figure 1과Paul Murrell (2003), “Integrating grid Graphics Output with Base Graphics Output”, R News, 3/2, 7–12 안의 연관된 코드들을 참조하십시오. 

@node Why is read.table() so inefficient?, What is the difference between package and library?, How can I create rotated axis labels?, R Miscellanea
@section Why is read.table() so inefficient?

@c By default, @code{read.table()} needs to read in everything as character
@c data, and then try to figure out which variables to convert to numerics
@c or factors.  For a large data set, this takes considerable amounts of
@c time and memory.  Performance can substantially be improved by using the
@c @code{colClasses} argument to specify the classes to be assumed for the
@c columns of the table.

기본값으로, read.table()는 character 데이터 처럼 모든것을 읽어야만 하고, 어떤 값을 숫자로나 factor들로 바꿔야 하는지를 알아내려 노력합니다. 큰 데이터 세트에서, 이는 꽤나 많은 양의 시간과 메모리를 차지합니다. 성능은 테이블의 행에 대하여 가정되어질 클래스를 명시하는 colClasses argument를 사용함으로인해 상당히 향상될 수 있습니다. 

@node What is the difference between package and library?, I installed a package but the functions are not there, Why is read.table() so inefficient?, R Miscellanea
@section What is the difference between package and library?

@c A @dfn{package} is a standardized collection of material extending R,
@c e.g.@: providing code, data, or documentation.  A @dfn{library} is a
@c place (directory) where R knows to find packages it can use (i.e., which
@c were @dfn{installed}).  R is told to use a package (to ``load'' it and
@c add it to the search path) via calls to the function @code{library}.
@c I.e., @code{library()} is employed to load a package from libraries
@c containing packages.
package는 R을 연장하는 material들, 예로, 코드, 데이터 혹은 documentation을 제공하는,의 표준화 된 컬렉센 입니다. library는 R이 사용할 수 있는 패키지들(즉, 설치된)을 찾는 장소(directory)입니다. R은 function library로의 call을 통해 패키지를 (“로드”하고 검색 경로에 그를 추가하라고) 사용하라고 명령됩니다. 즉, library()는 library들을 포함하고있는 패키지들에서의 패키지를 로드하도록 쓰여집니다.

@c @xref{R Add-On Packages}, for more details.  See also Uwe Ligges (2003),
@c ``R Help Desk: Package Management'', @emph{R News}, @strong{3/3},
@c 37--39.
더 자세한 사항으로는R Add-On Packages를 참조하십시오. 또한Uwe Ligges (2003), “R Help Desk: Package Management”, R News, 3/3, 37–39도 참조하십시오. 


@node I installed a package but the functions are not there, Why doesn't R think these numbers are equal?, What is the difference between package and library?, R Miscellanea
@section I installed a package but the functions are not there

@c To actually @emph{use} the package, it needs to be @emph{loaded} using
@c @code{library()}.
실제로 패키지를 사용하려면, library() 사용하여 로드가 되어있어야만 합니다. 


@c See @ref{R Add-On Packages} and @ref{What is the difference between
@c package and library?} for more information.
더 자세한 정보는R Add-On Packages 와 What is the difference between package and library?를 참조하십시오.

@node Why doesn't R think these numbers are equal?, How can I capture or ignore errors in a long simulation?, I installed a package but the functions are not there, R Miscellanea
@section Why doesn't R think these numbers are equal?

@c The only numbers that can be represented exactly in R's numeric type 
@c are integers and fractions whose denominator is a power of 2.  Other 
@c numbers have to be rounded to (typically) 53 binary digits accuracy.  As a 
@c result, two floating point numbers will not reliably be equal unless they 
@c have been computed by the same algorithm, and not always even then.  For 
@c example

R의 숫자 형식에 정확하게 표시될 수 있는 숫자들은 분모가 power of 2인 정수와 분수들 뿐입니다. 다른 숫자들은 (보통) 53 이진 숫자의 정확성으로 어림되어야만 합니다. 결과적으로, 두개의 floating point 숫자들은 같은 알고리즘에 의해 산출되지 않은 이상 확실하게 같이 않을 것이고, 항상 동등하지도 않을 것 입니다. 예를 들어,

@example
R> a <- sqrt(2)
R> a * a == 2
[1] FALSE
R> a * a - 2
[1] 4.440892e-16
@end example

@c The function @code{all.equal()} compares two objects using a numeric
@c tolerance of @code{.Machine$double.eps ^ 0.5}.  If you want much greater
@c accuracy than this you will need to consider error propagation
@c carefully.

Function all.equal()은.Machine$double.eps ^ 0.5의 numeric tolerance를 사용하여 두 개의 object들을 비교합니다. 만약 이보다 훨씬 더 좋은 정확도를 원한다면, error propagation을 조심스럽게 생각해 보아야 할 것입니다. 

@c For more information, see e.g.@: David Goldberg (1991), ``What Every
@c Computer Scientist Should Know About Floating-Point Arithmetic'',
@c @emph{ACM Computing Surveys}, @strong{23/1}, 5--48, also available via
@c @url{http://www.validlab.com/goldberg/paper.pdf}.

더 많은 정보를 위해서는, e.g. David Goldberg (1991), “What Every Computer Scientist Should Know About Floating-Point Arithmetic”, ACM Computing Surveys, 23/1, 5–48를 참고하시고, 또한http://www.validlab.com/goldberg/paper.pdf를 통해서도 이용가능합니다. 


@c To quote from ``The Elements of Programming Style'' by Kernighan and
@c Plauger:
 “The Elements of Programming Style” by Kernighan and Plauger에서부터 quote하기를: 


@quotation
@c @emph{10.0 times 0.1 is hardly ever 1.0}.
10.0 곱하기 0.1 는 거의 1.0이 아니다. 
@end quotation


@node How can I capture or ignore errors in a long simulation?, Why are powers of negative numbers wrong?, Why doesn't R think these numbers are equal?, R Miscellanea
@section How can I capture or ignore errors in a long simulation?

@c Use @code{try()}, which returns an object of class @code{"try-error"}
@c instead of an error, or preferably @code{tryCatch()}, where the return
@c value can be configured more flexibly.  For example

에러 대신 class "try-error"의 object를 return하는try(), 혹은 가급적이면 return 값이 더 융통성 있게 구성될 수 있는tryCatch()를 사용하십시오. 예를들어, 

@example
beta[i,] <- tryCatch(coef(lm(formula, data)),
                     error = function(e) rep(NaN, 4))
@end example

@noindent
@c would return the coefficients if the @code{lm()} call succeeded and
@c would return @code{c(NaN, NaN, NaN, NaN)} if it failed (presumably there
@c are supposed to be 4 coefficients in this example).
는 만약lm() call이 성공하면 coefficient들을 return하고, 실패하면 c(NaN, NaN, NaN, NaN)를 return할 것입니다 (짐작컨대 이 예제에는 4개의 coefficient들이 있을 것이라고 추정됩니다). 



@node Why are powers of negative numbers wrong?, How can I save the result of each iteration in a loop into a separate file?, How can I capture or ignore errors in a long simulation?, R Miscellanea
@section Why are powers of negative numbers wrong?

@c You are probably seeing something like
아마 당신은 다음과 같은 것을 보고
@example
R> -2^2
[1] -4
@end example

@noindent
@c and misunderstanding the precedence rules for expressions in R.
@c Write
R에 있는 expression들을 위한 선행 규직을 잘못 이해 할 것입니다. 
and misunderstanding the precedence rules for expressions in R. Square of -2를 얻기위해
@example
R> (-2)^2
[1] 4
@end example

@noindent
@c to get the square of @math{-2}.
를 쓰십시오.

@c The precedence rules are documented in @code{?Syntax}, and to see how R
@c interprets  an expression you can look at the parse tree
선행 규칙은 ?Syntax 안에 기록되어 있고, R이 expression을 어떻게 해석하는지를 보기윟서는 다음의 parse tree를 볼 수 있습니다.
@example
R> as.list(quote(-2^2))
[[1]]
`-`

[[2]]
2^2
@end example

@node How can I save the result of each iteration in a loop into a separate file?, Why are p-values not displayed when using lmer()?, Why are powers of negative numbers wrong?, R Miscellanea
@section How can I save the result of each iteration in a loop into a separate file?

@c One way is to use @code{paste()} (or @code{sprintf()}) to concatenate a
@c stem filename and the iteration number while @code{file.path()}
@c constructs the path.  For example, to save results into files
@c @file{result1.rda}, @dots{}, @file{result100.rda} in the subdirectory
@c @file{Results} of the current working directory, one can use

한가지 방법으로 file.path() 이 경로를 구축하는 동안 Stem filename과 반복되는 숫자를 연결시키기위한 paste()(혹은sprintf())를 사용하는 것입니다. 예를 들어, 현재 실행되고있는 디렉토리의 subdirectory Results안의result1.rda, ..., result100.rda파일들로 저장을 하려면, 아래를 사용할 수 있습니다. 

@example
for(i in 1:100) @{
  ## Calculations constructing "some_object" ...
  fp <- file.path("Results", paste("result", i, ".rda", sep = ""))
  save(list = "some_object", file = fp)
@}
@end example

@node Why are p-values not displayed when using lmer()?, Why are there unwanted borders, How can I save the result of each iteration in a loop into a separate file?, R Miscellanea
@section Why are @math{p}-values not displayed when using lmer()?

@c Doug Bates has kindly provided an extensive response in a post to the 
@c r-help list, which can be reviewed at
@c @uref{https://stat.ethz.ch/pipermail/r-help/2006-May/094765.html}.

Doug Bates는https://stat.ethz.ch/pipermail/r-help/2006-May/094765.html에서 review할 수 있는 친절하게 r-help list의 포스트 안에 폭넓은 응답을 제공해 주었습니다. 


@node Why are there unwanted borders, Why does backslash behave strangely inside strings?, Why are p-values not displayed when using lmer()?, R Miscellanea
@section Why are there unwanted borders, lines or grid-like artifacts when viewing a plot saved to a PS or PDF file?

@c This can occur when using functions such as @code{polygon()},
@c @code{filled.contour()}, @code{image()} or other functions which may
@c call these internally.  In the case of @code{polygon()}, you may observe
@c unwanted borders between the polygons even when setting the
@c @code{border} argument to @code{NA} or @code{"transparent"}.

이는polygon(), filled.contour(), image() 혹은 내부에서 이들을 부를 지도 모르는 다른 function들과 같은 function들을 사용할 때 발생합니다. polygon() 같은 경우, NA나 “transparent”로의 border argument가 세팅 되었을 때에도 polygon들 사이에서 원하지 않는 border들을 발견 할지도 모릅니다. 

@c The source of the problem is the PS/PDF viewer when the plot is
@c anti-aliased.  The details for the solution will be different depending
@c upon the viewer used, the operating system and may change over time.
@c For some common viewers, consider the following:

이 문제들의 근원은 plot이 anti-aliased되었을 때의 PS/PDF 뷰어입니다. 문제 해결의 자세한 사항은 사용된 뷰어, 운영 체제에 따라 다르며, 시간이 지나면서 바뀔지도 모릅니다. 몇몇의 평범한 뷰어들은, 다음을 생각해 보십시오:

@ftable @asis
@item Acrobat Reader (cross platform)
@c There are options in Preferences to enable/disable text smoothing, image
@c smoothing and line art smoothing.
@c Disable line art smoothing.

Text smoothing, image smoothing과 line art smoothing을 enable/disable하는 Preferences안의 옵션이 있습니다. Line art smoothing을 disable하십시오.

@item Preview (Mac OS X)
@c There is an option in Preferences to enable/disable anti-aliasing of
@c text and line art.
@c Disable this option. 

Text의 anti-aliasing과 line art를 enable/disable하는 Preferences 안의 옵션이 있습니다. 이 옵션을 disable하십시오.

@item GSview (cross platform)
@c There are settings for Text Alpha and Graphics Alpha.
@c Change Graphics Alpha from 4 bits to 1 bit to disable graphic
@c anti-aliasing.

Text Alpha와 Graphics Alpha에 대한 세팅이 있습니다. Graphics Alpha를 graphic anti-aliasing을 disable하기위해 4bits에서 1bit로 바꾸십시오. 

@item gv (Unix-like X)
@c There is an option to enable/disable anti-aliasing.
@c Disable this option.

anti-aliasing을 enable/disable 하는 옵션이 있습니다. 이 업션을 disable하십시오

@item Evince (Linux/GNOME)
@c There is not an option to disable anti-aliasing in this viewer.

이 뷰어에는 anti-aliasing을 disable하는 옵션이 없습니다.

@item Okular (Linux/KDE)
@c There is not an option in the GUI to enable/disable anti-aliasing.
@c From a console command line, use:

GUI에는 anti-aliasing을 disable하는 옵션이 없습니다. Console 명령줄에서, 다음을 사용하십시오:
@smallexample
$ kwriteconfig --file okularpartrc --group 'Dlg Performance' \
               --key GraphicsAntialias Disabled
@end smallexample
Then restart Okular.  Change the final word to @samp{Enabled} to restore
the original setting.
@end ftable

@node Why does backslash behave strangely inside strings?, How can I put error bars or confidence bands on my plot?, Why are there unwanted borders, R Miscellanea
@section Why does backslash behave strangely inside strings?

@c This question most often comes up in relation to file names (see
@c @ref{How do file names work in Windows?})  but it also happens that
@c people complain that they cannot seem to put a single @samp{\} character
@c into a text string unless it happens to be followed by certain other
@c characters.

이 질문은 대부분 파일 이름들과 관련하여 종종 올라오지만(How do file names work in Windows?를 참조하십시오), 이는 특정한 다른 character에 뒤이어 일어나지 않는 이상 문자열로의 단일의 ‘\’ character를 넣을 수 없는 것 처럼 보이는 것에 분만을 제기할 때 발생하기도 합니다. 

@c To understand this, you have to distinguish between character strings
@c and @emph{representations} of character strings.  Mostly, the
@c representation in R is just the string with a single or double quote at
@c either end, but there are strings that cannot be represented that way,
@c e.g., strings that themselves contains the quote character.  So

이를 이해하기 위해서는, 문자열과 문자열의 표현을 구분해야만 합니다. 대부분, R에서의 표현은 단지 어떤쪽의 끝이던지에 single quote혹은 double quote가 있는 string이지만, 그런 방법으로 표현 될 수 없는 string들도 있습니다, 예로, quote character를 포함하고있는 string들입니다. 그래서


@example
> str <- "This \"text\" is quoted"
> str
[1] "This \"text\" is quoted"
> cat(str, "\n")
This "text" is quoted
@end example

@noindent
@c The @emph{escape sequences} @samp{\"} and @samp{\n} represent a double
@c quote and the newline character respectively. Printing text strings,
@c using @code{print()} or by typing the name at the prompt will use the
@c escape sequences too, but the @code{cat()} function will display the
@c string as-is. Notice that @samp{"\n"} is a one-character string, not
@c two; the backslash is not actually in the string, it is just generated
@c in the printed representation.

escape sequences ‘\"’ 와 ‘\n’ 은 순서대로 double quote와 새로운 줄의 character를 나타냅니다. print()나 prompt에 이름을 타입하는 것을 사용하여 문자열을 프린트 하는 것 또한 escape sequence들을 사용 할 것이지만, cat() function은 string을 그래로 display할 것입니다. ‘"\n"’이 둘이 아닌 하나의 문자열이라는 것을 주목하십시오; backslash는 실제로 string안에 있는것이 아니고, 프린트 된 표현 안에 생성 된 것일 뿐입니다. 
@example
> nchar("\n")
[1] 1
> substring("\n", 1, 1)
[1] "\n"
@end example

@c So how do you put a backslash in a string? For this, you have to
@c escape the escape character. I.e., you have to double the backslash.
@c as in
그래서 backslash를 string안에 어떻게 넣겠습니까? 여기에서, escape character를 escape해야만 합니다. 즉, 다음과 같이 두개의 backslash를 써야합니다. 

@example
> cat("\\n", "\n")
\n
@end example

@c Some functions, particularly those involving regular expression
@c matching, themselves use metacharacters, which may need to be escaped by
@c the backslash mechanism.  In those cases you may need a @emph{quadruple}
@c backslash to represent a single literal one.

특히 일반적인 expression matching을 포함한 몇몇의 function들은backslash mechanism에 의해escape를 해야 항 수도 있는metacharacter들을 사용합니다. 그런 경우에는, single literal을 표현하기위해 4개의 backlash를 써야할 수도 있습니다. 


@c In versions of R up to 2.4.1 an unknown escape sequence like @samp{\p}
@c was quietly interpreted as just @samp{p}.  Current versions of R emit a
@c warning.

2.4.1까지의 R 버전에서‘\p’와 같은 알려지지않은 escape sequence는 ‘p’처럼 조용히 해석되었습니다. 현재 R 버전들은 경고를 줍니다.


@node How can I put error bars or confidence bands on my plot?, How do I create a plot with two y-axes?, Why does backslash behave strangely inside strings?, R Miscellanea
@section How can I put error bars or confidence bands on my plot?

@c Some functions will display a particular kind of plot with error bars,
@c such as the @code{bar.err()} function in the @CRANpkg{agricolae}
@c package, the @code{plotCI()} function in the @CRANpkg{gplots} package,
@c the @code{plotCI()} and @code{brkdn.plot()} functions in the
@c @CRANpkg{plotrix} package and the @code{error.bars()},
@c @code{error.crosses()} and @code{error.bars.by()} functions in the
@c @CRANpkg{psych} package.  Within these types of functions, some will
@c accept the measures of dispersion (e.g., @code{plotCI}), some will
@c calculate the dispersion measures from the raw values (@code{bar.err},
@c @code{brkdn.plot}), and some will do both (@code{error.bars}).  Still
@c other functions will just display error bars, like the dispersion
@c function in the @CRANpkg{plotrix} package.  Most of the above functions
@c use the @code{arrows()} function in the base @pkg{graphics} package to
@c draw the error bars.

몇몇의 function들은agricolae 패키지 안의 bar.err() function, glots 패키지 안의plotCI() function, plotrix 패키지 안의plotCI() 과 brkdn.plot() function들 그리고psych 패키지 안의error.bars(), error.crosses() 그리고 error.bars.by() function들과 같이 error bar들을 가지고 있는 특정한 종류의 plot을 display할 것입니다. 이론 function드르이 종류안에서, 몇몇은 dispersion의 measure들을 허용 할 것이고(예, plotCI), 몇몇은 raw value들에서부터의 dispersion measure들을 계산할 것이며(bar.err, brkdn.plot), 몇몇은 두가지 다를 할 것입니다(error.bars). 아직까지 다른 function들은plotrix 패키지 않의 dispersion function처럼 error bar들을 display 할 것입니다. 위의 대부분의 function들은 error bar들을 그리기 위해 base graphics 패키지에 있는 arrows() function을 사용합니다. 


@c The above functions all use the base graphics system.  The grid and
@c lattice graphics systems also have specific functions for displaying
@c error bars, e.g., the @code{grid.arrow()} function in the @pkg{grid}
@c package, and the @code{geom_errorbar()}, @code{geom_errorbarh()},
@c @code{geom_pointrange()}, @code{geom_linerange()},
@c @code{geom_crossbar()} and @code{geom_ribbon()} functions in the
@c @CRANpkg{ggplot2} package.  In the lattice system, error bars can be
@c displayed with @code{Dotplot()} or @code{xYplot()} in the
@c @CRANpkg{Hmisc} package and @code{segplot()} in the
@c @CRANpkg{latticeExtra} package.

위의 function들은 모두 base 그래픽 시스템을 사용합니다. Grid와 lattice 그래픽 시스템들 또한 error bar들을 display하기위한 특정한 functin을 가지고 있습니다. 예, grid 패키지 안의grid.arrow() function, ggplot2 패키지 안의geom_errorbar(), geom_errorbarh(), geom_pointrange(), geom_linerange(), geom_crossbar()과 geom_ribbon() function들. Lattice system에서, error bar들은Hmisc 패키지 안의Dotplot() or xYplot()와latticeExtra 패키지 안의segplot()을 사용하여 display될 수도 있습니다. 


@node How do I create a plot with two y-axes?, How do I access the source code for a function?, How can I put error bars or confidence bands on my plot?, R Miscellanea
@section How do I create a plot with two y-axes?

@c Creating a graph with two y-axes, i.e., with two sorts of data that are
@c scaled to the same vertical size and showing separate vertical axes on
@c the left and right sides of the plot that reflect the original scales of
@c the data, is possible in R but is not recommended.  The basic approach
@c for constructing such graphs is to use @code{par(new=TRUE)} (see
@c @code{?par}); functions @code{twoord.plot()} (in the @CRANpkg{plotrix}
@c package) and @code{doubleYScale()} (in the @CRANpkg{latticeExtra}
@c package) automate the process somewhat.  See
@c @url{http://rwiki.sciviews.org/@/doku.php?id=tips:graphics-base:2yaxes}
@c for more information, including strong arguments against this sort of
@c graph.

두 개의 y 축을 사용하여 그래프를 생성하는 것, 즉, 같은 수직 크기로 측정되고 데이터의 원래 측정값을 나타내는 plot의 왼쪽과 오른쪽위의 서로다른 수직축을 보여주는 두 종류의 데이터, 가 R에서 가능하지만 권장되지는 않습니다. 이런 그래프를 구성하기위한 기본 접근법은par(new=TRUE)를 사용하는 것입니다 (?par를 참조하십시오); twoord.plot() (plotrix 패키지 안의) 과 doubleYScale() (latticeExtra 패키지 안의) function은 어느정도 자동화된 프로세스 입니다. 이런 종류의 그래프에 반하는 강력한 argument들은 포함한, 더 많은 정보를 위해서는http://rwiki.sciviews.org/doku.php?id=tips:graphics-base:2yaxes를 참조하십시오.


@node How do I access the source code for a function?, Why does summary() report strange results for the R^2 estimate when I fit a linear model with no intercept?, How do I create a plot with two y-axes?, R Miscellanea
@section How do I access the source code for a function?

@c In most cases, typing the name of the function will print its source 
@c code. However, code is sometimes hidden in a namespace, or compiled.  For 
@c a complete overview on how to access source code, see Uwe Ligges (2006),
@c ``Help Desk: Accessing the sources'', @emph{R News}, @strong{6/4},
@c 43--45 (@url{http://CRAN.R-project.org/doc/Rnews/Rnews_2006-4.pdf}).

대부분의 경우, function의 이름을 타입하는 것은 그의 소스 코드를 프린트 할 것입니다. 하지만, 때때로 코드는 namespace안에 숨어져 있거나 compile되어져 있습니다. 어떻게 소스 코드에 액세스를 하는지에 대한 완전한 개요는Uwe Ligges (2006), “Help Desk: Accessing the sources”, R News, 6/4, 43–45 (http://CRAN.R-project.org/doc/Rnews/Rnews_2006-4.pdf)를 참조하십시오. 


@node Why does summary() report strange results for the R^2 estimate when I fit a linear model with no intercept?, Why is R apparently not releasing memory?, How do I access the source code for a function?, R Miscellanea
@section Why does summary() report strange results for the R^2 estimate when I fit a linear model with no intercept?

@c As described in @code{?summary.lm}, when the intercept is zero (e.g.,
@c from @code{y ~ x - 1} or @code{y ~ x + 0}), @code{summary.lm()} uses the
@c formula

?summary.lm에 설명되어 있듯이, 절편이 제로일 때 (예, y ~ x - 1 나 y ~ x + 0 에서), summary.lm()는 보통 쓰이는R^2 = 1 - Sum(R[i]^2) / Sum((y[i] - mean(y))^2)과는 다른R^2 = 1 - Sum(R[i]^2) / Sum((y[i])^2) 식을 사용합니다. 

@ifnottex
  R^2 = 1 - Sum(R[i]^2) / Sum((y[i])^2)
@end ifnottex
@tex
$ R^2 = 1 - \sum_i R_i^2 / \sum_i y_i^2 $
@end tex
which is different from the usual
@ifnottex
  R^2 = 1 - Sum(R[i]^2) / Sum((y[i] - mean(y))^2).
@end ifnottex
@tex
$ R^2 = 1 - \sum R_i^2 / \sum_i (y_i - \hbox{mean}(y))^2. $ 
@end tex
@c There are several reasons for this:
여기에는 몇가지의 이유들이 있습니다:

@itemize
@item
@c Otherwise the @math{R^2} could be negative (because the model with zero
@c intercept can fit @emph{worse} than the constant-mean model it is
@c implicitly compared to).
그렇지 않으면R^2가 음수가 될 수 있습니다 (제로 절편이 있는 모델은 잠재적으로 비교되는 constant-mean 모델보다 못하게 fit될 수도 있기 때문입니다).

@item
@c If you set the slope to zero in the model with a line through the
@c origin you get fitted values y*=0
원점을 지나는 선 모델에서 기울기를 제로로 설정한다면,  fitted value y*=0를 얻습니다.

@item
@c The model with constant, non-zero mean is not nested in the model
@c with a line through the origin.
상수를 가지고 있는 모덴, non-zero mean은 원점을 지나는 선 모델로 nested되어져 있지 않습니다. 
@end itemize

@c All these come down to saying that if you know @emph{a priori} that
@c @math{E[Y]=0} when @math{x=0} then the `null' model that you should
@c compare to the fitted line, the model where @math{x} doesn't explain any
@c of the variance, is the model where @math{E[Y]=0} everywhere.  (If you
@c don't know a priori that @math{E[Y]=0} when @math{x=0}, then you
@c probably shouldn't be fitting a line through the origin.)
이 모든 것들은 x=0일 때E[Y]=0이라는 것을 미리 알고 있다면 fitted line과 비교해야하는 ‘null’ 모델, x가 어떠한 variance도 설명하지 않는 모델,이  모든 곳이E[Y]=0인 모델이라는 것을 말해 주는 것으로 설명됩니다. (만약 x=0일 때E[Y]=0라는 것을 미리 알지 못한다면, 선을 원점을 통하도록 fitting하면 안될 것입니다.)

@node Why is R apparently not releasing memory?,  , Why does summary() report strange results for the R^2 estimate when I fit a linear model with no intercept?, R Miscellanea
@section Why is R apparently not releasing memory?

@c This question is often asked in different flavors along the lines of
@c ``I have removed objects in R and run @code{gc()} and yet
@c @code{ps}/@code{top} still shows the R process using a lot of
@c memory'', often on Linux machines.

이 질문은, 자주 Linux 기계에서의 “R 안의 object들을 지우고 gc()를 실행했는데 ps/top이 아직도 메모리의 ㅁ낳은 부분을 사용하여 R 프로세스를 보여줍니다”의 문장과 다른 의미로 종종 물어집니다.

@c This is an artifact of the way the operating system (OS) allocates
@c memory.  In general it is common that the OS is not capable of
@c releasing all unused memory.  In extreme cases it is possible that even
@c if R frees almost all its memory, the OS can not release any of it due
@c to its design and thus tools such as @code{ps} or @code{top} will
@c report substantial amount of resident RAM used by the R process even
@c though R has released all that memory.  In general such tools do
@c @emph{not} report the actual memory usage of the process but rather
@c what the OS is reserving for that process.

이는 운영 체제 (OS)가 인공으로 메모리를 지정하는 방법입니다. 일반적으로, 이는 OS가 모든 사용되지 않은 메모리를 방출할 수 없는 것이 흔합니다.  극단적인 경우에는, R이 거의 모든 메모리를 자유롭게 한다고 하더라도, OS가 자기의 디자인 때문에R이 모든 메모리를 방출할다고 하더라도 ps나 top가 R 프로세스에 의해 사용된 resident RAM의 상당한 사용량을 리포트 하는 것과 같은 tool들 때문에 어느것도 방출할 수 없을 가능성도 있습니다. 일반적으로 이런 tool들은 프로세스의 실제 메모리 사용랑을 리포트하지 않고, OS가 프로세스를 위해 reserve해 놓은 것을 리포트 합니다. 


@c The short answer is that this is a limitation of the memory allocator
@c in the operating system and there is nothing R can do about it. That
@c space is simply kept by the OS in the hope that R will ask for it
@c later.  The following paragraph gives more in-depth answer with
@c technical details on how this happens.

짧은 답으로 운영 체제의 메모리 할당기의 한계이고 R이 할 수 있는 것이 아무것도 없습니다. 공간은 간단히 R이 나중에 물어볼 것이라는 희망을 가지고 OS에 의해 관리됩니다. 다음의 문단은 어떻게 이가 발생하는지에대한 기술적인 detail들로 더 심도있는 답을 줍니다. 

@c Most systems use two separate ways to allocate memory. For allocation
@c of large chunks they will use @code{mmap} to map memory into the
@c process address space.  Such chunks can be released immediately when
@c they are completely free, because they can reside anywhere in the
@c virtual memory.  However, this is a relatively expensive operation and
@c many OSes have a limit on the number of such allocated chunks, so this
@c is only used for allocating large memory regions.  For smaller
@c allocations the system can expand the data segment of the process
@c (historically using the @code{brk} system call), but this whole area
@c is always contiguous.  The OS can only move the end of this space, it
@c cannot create any ``holes''. Since this operation is fairly cheap, it
@c is used for allocations of small pieces of memory.  However, the
@c side-effect is that even if there is just one byte that is in use
@c at the end of the data segment, the OS cannot release any memory
@c at all, because it cannot change the address of that byte.  This is
@c actually more common than it may seem, because allocating a lot of
@c intermediate objects, then allocating a result object and removing all
@c intermediate objects is a very common practice.  Since the result is
@c allocated at the end it will prevent the OS from releasing any memory
@c used by the intermediate objects.  In practice, this is not necessarily
@c a problem, because modern operating systems can page out unused
@c portions of the virtual memory so it does not necessarily reduce the
@c amount of real memory available for other applications.  Typically,
@c small objects such as strings or pairlists will be affected by this
@c behavior, whereas large objects such as long vectors will be allocated
@c using @code{mmap} and thus not affected.  On Linux (and possibly other
@c Unix-like systems) it is possible to use the @code{mallinfo} system call
@c (also see the @url{http://rforge.net/mallinfo, mallinfo} package) to
@c query the allocator about the layout of the allocations, including the
@c actually used memory as well as unused memory that cannot be released.

대부분의 시스템들은 메모리를 지정하기위해 두 가지 다른 방법을 사용합니다. 큰 chunk들의 지정에 프로세스 address 공간으로 메모리를 인도하기위해 mmap을 사용할 것입니다. 이러한 chunk들은 가상 메모리 어디에든 속해있을 수 있기 때문에 완전히 자유로울 때에 바로 방출이 가능합니다. 하지만, 이는 꽤나 비싼 operation이고 많은 운영 체제들이 그런 지정chunk들의 숫자에 한계가 있기 때문에, 이는 큰 메모리 region들을 지정하는 데에만 사용됩니다. 작은 지정들을 위해서, 시스템은 프로세스의 data segment(역사적으로 brk 시스템 call을 사용하여)를 확장 할 수 있지만, 이 전체 area는 항상 근접합니다.  OS는 이 공간의 끝만 움직일수 있고, 이는 어떠한 “hole들”도 생성할 수 없습니다. 이 operatin은 꽤나 싸기때문에, 이는 메모리의 작은 조각들의 지정을 위해 사용됩니다. 하지만, 부작용으로 data segment의 끝에 고작 1 byte의 사용되고있는 것이 있더라도, 그 byte의 주소를 바꿀 수 없기 떄문에, OS는 어떠한 메모리도 방출할 수 없습니다. 많은 양의 intermediate object들을 지정하고나서, result object를 지정하고 모든 intermediate object들을 지우는 것이 매우 흔한 연습이기때문에, 이는 실제로 보기보다 더 흔합니다. 결과가 끝에 지정되기 때문에, 이는 OS가 intermediate object들에의해 사용된 어떠한 메모리라도 방출 하는 것을 막을 것 입니다. 실제로, 현대의 운영체제는 쓰이지 않은 가상 메모리 부분을 page out할 수 있고 이가 다른 application들에서 사용가능한 실제 메모리의 양을 줄이지는 않으므로, 이는 문제가 되지는 않습니다. 전형적으로, mmap을 사용하여 지정되어질 긴 벡터들과 같은 큰 object들은 영향을 받지 않는 반면, string들이나 pairlist들 같은 작은 object들은 이런 작용에 영향을 받을 것 입니다. Linux에서 (그리고 아마 Unix-like 시스템들에서도) 실제 사용된 메모리와 함께 방출되지 못하는 사용되지 않은 메모리를 포함한 allocation들의 layout에 대한 할당기에 문의를 하기위한 mallinfo 시스템 call(mallinfo 패키지도 참조하십시오)을 사용할 수도 있습니다. 



@node R Programming, R Bugs, R Miscellanea, Top
@chapter R Programming

@menu
* How should I write summary methods?::  
* How can I debug dynamically loaded code?::  
* How can I inspect R objects when debugging?::  
* How can I change compilation flags?::  
* How can I debug S4 methods?::  
@end menu

@node How should I write summary methods?, How can I debug dynamically loaded code?, R Programming, R Programming
@section How should I write summary methods?

@c Suppose you want to provide a summary method for class @code{"foo"}.
@c Then @code{summary.foo()} should not print anything, but return an
@c object of class @code{"summary.foo"}, @emph{and} you should write a
@c method @code{print.summary.foo()} which nicely prints the summary
@c information and invisibly returns its object.  This approach is
@c preferred over having @code{summary.foo()} print summary information and
@c return something useful, as sometimes you need to grab something
@c computed by @code{summary()} inside a function or similar.  In such
@c cases you don't want anything printed.

당신이 class “foo”를 위한 summary method를 제공하고 싶다고 가정해 봅시다. 그러면summary.foo()는 어떤것도 프린트하지 않아야하지만, class "summary.foo" 의 object를 return해야하며, 요약된 정보를 보기 좋게 프린트하고 그의 object를 보이지 않게 return하는method인 print.summary.foo()를 써야만 합니다. 이 접근법은summary.foo()를 쓰는 것 보다 더 선호 하는데 이는 가끔function이나 비슷한 것들 안에서 summary()에 의해 산출된 것을 grab해야할 때, 요약된 정보를 프린트하고 유용한 것을 return하기 때문입니다. 이런 경우에서, 어떤것도 프린트되는 것을 원하지 않을 것입니다. 

@node How can I debug dynamically loaded code?, How can I inspect R objects when debugging?, How should I write summary methods?, R Programming
@section How can I debug dynamically loaded code?

@c Roughly speaking, you need to start R inside the debugger, load the
@c code, send an interrupt, and then set the required breakpoints.

대략, debugger 안에서 R을 시작하고, 코드를 로드, interrupt를 보내며, 그리고 요구되는 breakpoint를 설정해야만 합니다. 

@ifclear UseExternalXrefs
@c See section ``Finding entry points in dynamically loaded code'' in
@c @cite{Writing R Extensions}.  This manual is included in the R
@c distribution, @pxref{What documentation exists for R?}.
Writing R Extensions에서“Finding entry points in dynamically loaded code” 섹션을 참조하십시오. 이 메뉴얼은 R distribution에 포함되어 있습니다, What documentation exists for R?를 참조하십시오.
@end ifclear
@ifset UseExternalXrefs
@xref{Finding entry points, , Finding entry points in dynamically loaded
code, R-exts, Writing R Extensions}.
@end ifset

@node How can I inspect R objects when debugging?, How can I change compilation flags?, How can I debug dynamically loaded code?, R Programming
@section How can I inspect R objects when debugging?

@c The most convenient way is to call @code{R_PV} from the symbolic
@c debugger.

가장 편리한 방법은 symbolic debugger에서 R_PV를 부르는 것입니다.

@ifclear UseExternalXrefs
See section ``Inspecting R objects when debugging'' in @cite{Writing R
Extensions}.
@end ifclear
@ifset UseExternalXrefs
@xref{Inspecting R objects, , Inspecting R objects when debugging,
R-exts, Writing R Extensions}.
Writing R Extensions에서“Inspecting R objects when debugging” 섹션을 참조하십시오. 
@end ifset

@node How can I change compilation flags?, How can I debug S4 methods?, How can I inspect R objects when debugging?, R Programming
@section How can I change compilation flags?

@c Suppose you have C code file for dynloading into R, but you want to use
@c @code{R CMD SHLIB} with compilation flags other than the default ones
@c (which were determined when R was built).

R로 dynloading하기위한 C 코드 파일이 있지만, 기본값(R이 생성되었을 때 지정된)이 아닌 compilation flag들을 가지고 있는 R CMD SHLIB를 사용하고 싶다고 가정해 보십시오. 

@c Starting with R 2.1.0, users can provide personal Makevars configuration
@c files in @file{$@env{HOME}/.R} to override the default flags.

R 2.1.0부터, 사용자는$HOME/.R에 기본 flag들을 override하기위해 개인의 Makevars configuration file들을 제공할 수 있습니다. R Installation and 
@ifclear UseExternalXrefs
@c See section ``Add-on packages'' in @cite{R Installation and
@c Administration}.
Administration의“Add-on packages” 섹션은 참조하십시오 

@end ifclear
@ifset UseExternalXrefs
@xref{Add-on packages, , Add-on packages, R-admin,
R Installation and Administration}.
@end ifset

@c For earlier versions of R, you could change the file
@c @file{@var{R_HOME}/etc/Makeconf} to reflect your preferences, or (at
@c least for systems using @acronym{GNU} Make) override them by the
@c environment variable @env{MAKEFLAGS}.
이전 버전의 R에서는, 당신의 선호를 반영하기위해서 파일 R_HOME/etc/Makeconf를 바꿀수 있었거나, 혹은 (적어도 GNU Make를 사용하는 시스템을위해서)  
MAKEFLAGS 환경값에의해 그들을 override합니다. 

@ifclear UseExternalXrefs
@c See section ``Creating shared objects'' in @cite{Writing R Extensions}.
Writing R Extensions의 “Creating shared objects” 섹션을 참조하십시오. 
@end ifclear
@ifset UseExternalXrefs
@xref{Creating shared objects, , Creating shared objects, R-exts,
Writing R Extensions}.
@end ifset

@node How can I debug S4 methods?,  , How can I change compilation flags?, R Programming
@section How can I debug S4 methods?

@c Use the @code{trace()} function with argument @code{signature=} to add
@c calls to the browser or any other code to the method that will be
@c dispatched for the corresponding signature.  See @code{?trace} for
@c details.

브라우저로 call들을 추가하기위해 argument signature=가 있는trace() function이나 상응하는 서명에 대해 dispath될 다른 코드들을 사용하십시오. 자세한 사항들은 ?trace를 참조하십시오. 

@node R Bugs, Acknowledgments, R Programming, Top
@chapter R Bugs

@menu
* What is a bug?::              
* How to report a bug::         
@end menu

@node What is a bug?, How to report a bug, R Bugs, R Bugs
@section What is a bug?

@c If R executes an illegal instruction, or dies with an operating system
@c error message that indicates a problem in the program (as opposed to
@c something like ``disk full''), then it is certainly a bug.  If you call
@c @code{.C()}, @code{.Fortran()}, @code{.External()} or @code{.Call()} (or
@c @code{.Internal()}) yourself (or in a function you wrote), you can
@c always crash R by using wrong argument types (modes).  This is not a
@c bug.

만약 R이 불법적인 설명을 수행하거나, 프로그램 내의 문제를 나타내는 (“disk full” 같은것과 반대되는) 운영체제 오류 메세지와 함께 죽는다면, 이는 확실하게 bug입니다. 만약 .C(), .Fortran(), .External() 혹은 .Call() (혹은 .Internal())을 직접 (혹은 , 당신이 쓴 function에)부른다면, 잘못된 argument type들 (mode들)을 사용함으로 인해서 R을 항상 crash 할 수 있습니다.  이는 bug가 아닙니다. 


@c Taking forever to complete a command can be a bug, but you must make
@c certain that it was really R's fault.  Some commands simply take a long
@c time.  If the input was such that you @emph{know} it should have been
@c processed quickly, report a bug.  If you don't know whether the command
@c should take a long time, find out by looking in the manual or by asking
@c for assistance.

명령을 완성하는데 시간이 오래 걸리면 bug일 수 있지만, 이것이 정말 R의 잘못인지를 확실하게 해야만 합니다. 몇몇의 명령들은 원래 오랜시간이 걸립니다. 만약 input이 빨리 프로세스가 되어야만 한다는 것을 알고있다면, bug를 보고하십시오. 만약 명령이 시간이 오래 걸리는지 확실하지 않다면, 메뉴얼에서 찾아보거나 도움을 청하여 알아내십시오.

@c If a command you are familiar with causes an R error message in a case
@c where its usual definition ought to be reasonable, it is probably a bug.
@c If a command does the wrong thing, that is a bug.  But be sure you know
@c for certain what it ought to have done.  If you aren't familiar with the
@c command, or don't know for certain how the command is supposed to work,
@c then it might actually be working right.  For example, people sometimes
@c think there is a bug in R's mathematics because they don't understand
@c how finite-precision arithmetic works.  Rather than jumping to
@c conclusions, show the problem to someone who knows for certain.
@c Unexpected results of comparison of decimal numbers, for example
@c @code{0.28 * 100 != 28} or @code{0.1 + 0.2 != 0.3}, are not a bug.
@c @xref{Why doesn't R think these numbers are equal?}, for more details.

만약 익숙한 명령이 보통의 정의가 합리적인 경우에 R 오류 메세지를 초래한다면, 이는 아마도 bug일 것입니다. 만약 명령어가 틀린것을 한다면, 이는 버그입니다. 하지만 무엇이 되어야만하는지를 당신이 반드시 확실하게 알도록 하십시오. 만약 당신이 명령에 익숙하지 않다거나, 명령이 어떻게 실행되어야하는지를 확실하게 알지 못한다면, 이는 실제로 잘 실행되고 있는것일 것입니다. 예를들어, 사람들은 R의 mathematics 안에 버그가 있다고 생각하는데 이는finite-precision arithmetic이 어떻게 기능하는지 모르기 때문입니다. 결론들로 바로 가기보다는, 확실하게 아는 누군가에게 문제를 보여주십시오. 예상하지 못한 소수의 비교 결과, 예로, 0.28 * 100 != 28 혹은 0.1 + 0.2 != 0.3, 는 bug가 아닙니다. 더 자세한 사항들은 Why doesn't R think these numbers are equal?을 참조하십시오. 


@c Finally, a command's intended definition may not be best for statistical
@c analysis.  This is a very important sort of problem, but it is also a
@c matter of judgment.  Also, it is easy to come to such a conclusion out
@c of ignorance of some of the existing features.  It is probably best not
@c to complain about such a problem until you have checked the
@c documentation in the usual ways, feel confident that you understand it,
@c and know for certain that what you want is not available.  If you are
@c not sure what the command is supposed to do after a careful reading of
@c the manual this indicates a bug in the manual.  The manual's job is to
@c make everything clear.  It is just as important to report documentation
@c bugs as program bugs.  However, we know that the introductory
@c documentation is seriously inadequate, so you don't need to report this.

마지막으로,  명령의 목적 정의어는 통계 분석에 대해 가장 좋지 않을지도 모릅니다. 이는 이런 종류의 문제에서 매우 중요하지만, 이는 판단력의 문제이기도 합니다. 또한, 몇몇의 기존 기능들의 무지에서의 결론과 같은 것에서 나오기 십상입니다. 이는 아마도 당신이 평소의 방법으로 documentation을 체크하고, 그를 이해하는 것에 대해 자신감이 있고 당신이 원하는 것이 이용가능하지 않다는 것을 확실하게 알기 전까지는 이런 문제들에 대하여 불평하지 않는 것이 좋을 것 입니다. 만약 당신이 메뉴얼을 정독 한 후에도 어떤 명령이 실행되어야하는지 확실하지 않을때에는, 메뉴얼에 bug가 있다는 것을 나타냅니다. 이 메뉴얼의 역할은 모든것을 확실하게 만드는 것입니다. Documentation bug들을 보고하는것이 프로그램 bug들만큼 중요합니다. 그렇지만, 서두 문서가 심각하게 무능하다는 것을 알고 있기때문에, 이는 보고하지 않아도 됩니다. 

@c If the online argument list of a function disagrees with the manual, one
@c of them must be wrong, so report the bug.

만약 function의 온라인 argument 목록이 메뉴얼과 일치하지 않는다면, 둘 중하나는 틀린것이므로, bug를 보고하십시오. 

@node How to report a bug,  , What is a bug?, R Bugs
@section How to report a bug

@c When you decide that there is a bug, it is important to report it and to
@c report it in a way which is useful.  What is most useful is an exact
@c description of what commands you type, starting with the shell command
@c to run R, until the problem happens.  Always include the version of R,
@c machine, and operating system that you are using; type @kbd{version} in
@c R to print this.

Bug가 있다고 판단했을 때, 유용한 방법으로 보고하는 것이 중요합니다. 가장 유용한 것은R을 실행하기위한 shell command로 시작하여 어떤 명령을 타입했는지의 정확한 설명을 문제가 나타날때까지 하는 것입니다. 항상 당신이 사용하는 R의 버전, machine, 그리고 운영 체제를 포함하십시오; 이를 프린트하려면 R에 version을 타입하십시오. 

@c The most important principle in reporting a bug is to report
@c @emph{facts}, not hypotheses or categorizations.  It is always easier to
@c report the facts, but people seem to prefer to strain to posit
@c explanations and report them instead.  If the explanations are based on
@c guesses about how R is implemented, they will be useless; others will
@c have to try to figure out what the facts must have been to lead to such
@c speculations.  Sometimes this is impossible.  But in any case, it is
@c unnecessary work for the ones trying to fix the problem.

Bug를 보고할 때 가장 중요한 원칙은 가설이나 categorization들이 아닌, 실제 일어난 것을 보고하십시오. 실제 일어난 것을 보고하는것이 항상 더 쉽지만, 사람들은 이를 사실로 받아여진 설명에 압박감을 받고 그들을 대신 보고하는 것을 더 좋아하는 것 처럼 보입니다. 만약 설명이 R이 어떻게 실행되었는지에 관한 추측에 기초한 것이라면, 그들은 쓸모가 없을 것 입니다; 다른 사람들이 그러한 추측들로 끌어도록 만든 실제 일어난 일이 무엇인지를 알아내려고 노력해야하기 때문입니다. 때때로 이는 가능하지 않습니다. 하지만 어떤 경우에는, 이는 문제를 고치려고 노력하는 사람에게 불필요한 일 입니다. 


@c For example, suppose that on a data set which you know to be quite large
@c the command
예를 들어, 데이터셋에 당신이 꽤나 큰 명령일 것이라고 알고있는

@example
R> data.frame(x, y, z, monday, tuesday)
@end example

@noindent
@c never returns.  Do not report that @code{data.frame()} fails for large
@c data sets.  Perhaps it fails when a variable name is a day of the week.
@c If this is so then when others got your report they would try out the
@c @code{data.frame()} command on a large data set, probably with no day of
@c the week variable name, and not see any problem.  There is no way in the
@c world that others could guess that they should try a day of the week
@c variable name.
는 절대 return하지 않습니다. data.frame()이 큰 데이터에 대해 실패했다고 보고하지 마십시오. 아마도 이는 variable 이름이 요일로 되어있을 때 실패하는 것 일것입니다. 만일 그렇다면 다른 사람들이 당신이 보고한 것을 보았을 때 그들은 큰 데이터 셋에 아마 요일이 들어가지 않은 variable 이름을 가진 data.frame() 명령을 시도해 보고, 아무런 문제도 일어나지 않는 것을 볼 것입니다. 다른사람들이 요일을 variable 이름으로 시도해 보아야만 하는지를 알 길은 전혀 없습니다. 

@c Or perhaps the command fails because the last command you used was a
@c method for @code{"["()} that had a bug causing R's internal data
@c structures to be corrupted and making the @code{data.frame()} command
@c fail from then on.  This is why others need to know what other commands
@c you have typed (or read from your startup file).
혹은 어쩌면 당신이 마지막에 사용한 명령이 R 내부 데이터 구조에 오류가 나게하고 그 지점부터data.frame() 명령이 실패하는 원인을 제공하는 bug를 가지고 있는 "["()에 대한 method였기 때문에 명령이 실패하는 것일지도 모릅니다. 이것이 다른사람들이 당신이 어떠한 다른 명령을 입력했는지 (혹은 당신의 시작 파일을 읽거나)를 알아야만하는 이유입니다. 

@c It is very useful to try and find simple examples that produce
@c apparently the same bug, and somewhat useful to find simple examples
@c that might be expected to produce the bug but actually do not.  If you
@c want to debug the problem and find exactly what caused it, that is
@c wonderful.  You should still report the facts as well as any
@c explanations or solutions.  Please include an example that reproduces
@c (e.g., @url{http://en.wikipedia.org/wiki/Reproducibility}) the problem,
@c preferably the simplest one you have found.

같은 버그를 생성하는 것 처럼 보이는 간단한 예제를 찾아서 시도해 보는것은 굉장히 유용하고, bug가 생성될 것 같지만 실제로는 그렇지 않은 간단한 예제를 찾아서 시도해 보는 것도 다소 유용합니다. 만약 문제를 debug하고 정확하게 어떤 것이 bug를 생성했는지를 찾고싶다면, 당신은 아주 훌륭합니다. 계속해서 실제 일어난 것을 보고해야만 하는 동시에 설명과 해결책들도 같이 보고해야합니다. 문제를 일으키는 예제를, 당신이 찾은 것들 중 가장 간단한 것들 (예, http://en.wikipedia.org/wiki/Reproducibility), 포함해 주십시오. 


@c Invoking R with the @option{--vanilla} option may help in isolating a
@c bug.  This ensures that the site profile and saved data files are not
@c read.

--vanilla옵션이 있는 R을 적용하는 것이 bug를 분리시키는데 도움을 줄지도 모릅니다. 이는 사이트 프로필과 저장된 데이터 파일들이 읽히지 않도록 확실히 합니다. 


@c Before you actually submit a bug report, you should check whether the
@c bug has already been reported and/or fixed.  First, try the ``Show open
@c bugs new-to-old'' or the search facility on
@c @url{http://bugs.R-project.org/}.  Second, consult
@c @url{https://svn.R-project.org/@/R/@/trunk/@/doc/@/NEWS.Rd}, which
@c records changes that will appear in the @emph{next} release of R,
@c including bug fixes that do not appear on the Bug Tracker.  
@c Third, if possible try the current r-patched or r-devel version of R.
@c If a bug has already been reported or fixed, please do not submit
@c further bug reports on it.  Finally, check carefully whether the bug is
@c with R, or a contributed package.  Bug reports on contributed packages
@c should be sent first to the package maintainer, and only submitted to
@c the R-bugs repository by package maintainers, mentioning the package in
@c the subject line.

Bug 보고서를 실제로 제출하기 전에, 그 bug가 이미 보고되고/보고되거나 고쳐졌는지를 확인해야만 합니다. 첫번째로, “Show open bugs new-to-old”나http://bugs.R-project.org/의 검색 기능을 시도해 보십시오. 두번째로, Bug Tracker에도 나타나지 않는 고쳐진 bug들도 포함된, 다음번에 나올 R에서 보여질 수정사항들이 보고된 https://svn.R-project.org/R/trunk/doc/NEWS.Rd와 상담을 해 보십시오. 세번째로, 가능하다면 R의 현재 r-patched나 r-devel 버전을 시도해 보십시오. 만약 bug가 이미 보고되거나 고쳐졌다면, 추가의 bug 보고서들을 제출하지 말아주십시오. 마지막으로, bug가 R에 있는지, 혹은 기여 패키지에 있는지를 잘 체크 하십시오. 기여 패키지들에 대한 bug 보고서들은 패키지 관리자에게 첫번째로 보내져야만하고, 주제 라인에 패키지를 언급하여 패키지 관리자에 의해서만 R-bugs 저장소로 제출될 것입니다. 


@c A bug report can be generated using the function @code{bug.report()}.
@c For reports on R this will open the Web page at
@c @url{http://bugs.R-project.org/}: for a contributed package it will open
@c the package's bug tracker Web page or help you compose an email to the
@c maintainer.

Bug 보고서는function bug.report()를 사용하여 생성될 수 있습니다. R의 보고서들을 위해서 이는 http://bugs.R-project.org/ 웹페이지를 열 것입니다: 기여 패키지를 위해서 이는 패키지의 bug tracker 웹페이지를 열거나 관리자에게 이메일을 쓰는 것을 도와 줄 것입니다. 

@c There is a section of the bug repository for suggestions for
@c enhancements for R labelled @samp{wishlist}.  Suggestions can be
@c submitted in the same ways as bugs, but please ensure that the subject
@c line makes clear that this is for the wishlist and not a bug report, for
@c example by starting with @samp{Wishlist:}.

R labeled ‘wishlist’의 향상을위한 제안들을 위한 bug 저장소의 섹션이 있습니다. 제안들은 bug들과 비슷한 방법으로 제출 할 수 있으나, subject line에, 예를들어 시작을‘Wishlist:’로 하는, 이가 bug 보고서가 아닌 wishlist를 위한 것이라는 것을 확실하게 해 주십시오. 


@c Comments on and suggestions for the Windows port of R should be sent to
@c @email{R-windows@@R-project.org}.

R의 Windows port에 대한 코멘트나 제안사항들은  @email{R-windows@@R-project.org}로 보내져야만합니다.

@c Corrections to and comments on message translations should be sent to the
@c last translator (listed at the top of the appropriate @samp{.po} file)
@c or to the translation team as listed at
@c @url{http://developer.R-project.org/TranslationTeams.html}.

메시지 번역에 대한 수정과 코멘트는 최근 번역자나 (적절한 ‘.po’ 파일의 상단에 리스트되어있는)  http://developer.R-project.org/TranslationTeams.html에 리스트된 번역팀에게 보내져야 합니다.


@node Acknowledgments,  , R Bugs, Top
@chapter Acknowledgments

@c Of course, many many thanks to Robert and Ross for the R system, and to
@c the package writers and porters for adding to it.

@c Special thanks go to Doug Bates, Peter Dalgaard, Paul Gilbert, Stefano
@c Iacus, Fritz Leisch, Jim Lindsey, Thomas Lumley, Martin Maechler, Brian
@c D. Ripley, Anthony Rossini, and Andreas Weingessel for their comments
@c which helped me improve this @acronym{FAQ}.

@c More to come soon @dots{}

물론, R 시스템의 Robert와 Ross, 그리고 패키지 writer들과 porter들에게도 추가로 대단히 감사합니다.
특별히이 FAQ를 향상시키도록 저를 도와주신 Doug Bates, Peter Dalgaard, Paul Gilbert, Stefano
Iacus, Fritz Leisch, Jim Lindsey, Thomas Lumley, Martin Maechler, Brian D.
Ripley, Anthony Rossini, 그리고 Andreas Weingessel의 comment들에 감사합니다.
More to come soon ...


@bye

@c Local Variables: ***
@c mode: TeXinfo ***
@c End: ***
