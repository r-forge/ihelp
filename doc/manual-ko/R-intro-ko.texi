@c 
@c 2013-JUL-15 (Monday)
@c 1.Begining ~ 2.8 by LIJIN)
@c 
@c 작업을 하고 난 뒤에 그 다음날 아래의 주소를 통해서 주이진님께서 변경한 내용을 확인해보세요.
@c http://korea.gnu.org/gnustats/docs/manual-ko/R-intro-ko.html 
@c 
@c 그리고 위의 링크는 자동적으로 2~3 시간 이내에 아래의 주소로 싱크로 되요. 
@c http://ihelp.r-forge.r-project.org/docs/manual-ko/R-intro-ko.html 
@c 

\input texinfo

@c %**start of header
@setfilename R-intro.info
@settitle An Introduction to R (한국어 - 2013.07.09, ver.0.93.2.)
@setchapternewpage on
@c %**end of header

@c Authors: If you edit/add @example(s) ,  please keep
@c  ./R-intro.R   up-to-date !
@c  ~~~~~~~~~~~
@syncodeindex fn vr


@dircategory Programming
@direntry
* R Introduction: (R-intro).    An introduction to R.
@end direntry

@finalout

@include R-defs.texi
@include version.texi

@ifnottex
@macro RIcopyright{}
Copyright @copyright{} 1990 W.@: N.@: Venables@*
Copyright @copyright{} 1992 W.@: N.@: Venables & D.@: M.@: Smith@*
Copyright @copyright{} 1997 R.@: Gentleman & R.@: Ihaka@*
Copyright @copyright{} 1997, 1998 M.@: Maechler@*
Copyright @copyright{} 1997-- R Core Team@*
@Rcopyright{1999}@*
Korean translation copyright @copyright{} 2008--2013 Korean R Translation Team and Chel Hee Lee.
@end macro
@end ifnottex

@iftex
@macro RIcopyright{}
@noindent
Copyright @copyright{} 1990 W.@: N.@: Venables
Copyright @copyright{} 1992 W.@: N.@: Venables & D.@: M.@: Smith
Copyright @copyright{} 1997 R.@: Gentleman & R.@: Ihaka
Copyright @copyright{} 1997, 1998 M.@: Maechler
Copyright @copyright{} 1997-- R Core Team@*
@Rcopyright{1999}@*
Korean translation copyright @copyright{} 2008--2013 Korean R Translation Team and Chel Hee Lee.
@end macro
@end iftex

@c <FIXME>
@c Apparently AUCTeX 11.06 has a problem with '@appendixsection' entries
@c when updating nodes---the equivalent '@appendixsec' seems to work.
@c Hence changed (temporarily?) ...
@c </FIXME>

@c <NOTE>
@c Conversion to PDF fails if sectioning titles contain (user-defined)
@c macros such as @R{}.  Hence in section titles we changed @R{} to R.
@c Revert when this is fixed.
@c </NOTE>

@titlepage
@title An Introduction to R
@subtitle Notes on @R{}: A Programming Environment for Data Analysis and Graphics
@subtitle Version @value{VERSION}
@author W. N. Venables, D. M. Smith
@author and the R Core Team

@page
@vskip 0pt plus 1filll

@flushleft
@RIcopyright{}
@end flushleft

@permission{}

@value{ISBN-intro}
@end titlepage

@c @ifnothtml
@contents
@c @end ifnothtml

@ifnottex
@node Top, Preface, (dir), (dir)
@c @top An Introduction to R
@top R에 대한 소개서 

@c This is an introduction to R (``GNU S''), a language and environment for
@c statistical computing and graphics.  R is similar to the award-winning S
@c system, which was developed at Bell Laboratories by John Chambers et al.
@c It provides a wide variety of statistical and graphical techniques
@c (linear and nonlinear modelling, statistical tests, time series
@c analysis, classification, clustering, ...).

@c This manual provides information on data types, programming elements,
@c statistical modelling and graphics.

@c The current version of this document is @value{VERSION}.

이 문서는 통계계산(statistical computing)과 그래픽(graphics) 작업을 수행하는 언어이며 개발환경이기도 한 @R{}에 대한 기본 안내서입니다. 
@R{}은 벨랩에서 John Chambers 외 다수에 의해서 개발된 이래로 여러 차례 상을 수상한 @Sl{} 라는 시스템과 유사하기 때문에 ``GNU S''라고도 불리우며,
선형 및 비선형 모델링(linear and non-linear modelling), 통계 테스트들(statistical tests), 시계열분석 (time-series analysis), 클래시피케이션 (classification), 그리고 클러스터링 (clustering)등과 같은 다양한 종류의 통계분석 방법들과 그래픽 기능들을 제공합니다. 
이러한 기능들을 @R{}을 처음 사용하시는 분들에게 도움이 될 수 있도록 사용에 반드시 필요한 기본 데이터형, 프로그래밍의 기본 요소들, 그리고 통계 모델링과 그래픽 구현에 대한 기본적인 정보가 이 문서에서 다루어질 것입니다. 

본 한글문서에 대한 영어원문의 버전은 @value{VERSION}.

@value{ISBN-intro}



본 한국어 문서는 @strong{R Development Translation Teams} (@url{http://developer.r-project.org/TranslationTeams.html}) @strong{Korean} 섹션에서 진행하는 프로젝트의 일환으로 제공되어집니다.  
본 문서의 역자는 아래와 같습니다.
@itemize @bullet
@item Chel Hee Lee (이철희), University of Saskatchewan, Saskatoon, Saskatchewan, Canada, @email{gnustats@@gmail.com}, 2009 -- 2013 
@item Lijin Joo (주이진), New York University, New York, New York, U.S.A., @email{lijin.joo@@nyu.edu}, 2009--2013 
@item Eugene Jung (정우준), Hongik University, Seoul, Korea, @email{muoe78@@gmail.com}, 2009-2013.
@end itemize 

문서의 수정과 재배포를 허락해 주신 @strong{R Development Core Team}에게 감사를 드립니다.
@c 또한, 우리의 이러한 활동에 많은 관심과 아낌없는 지원을 해주는 Prof. Friedrich Leisch (Austria), Prof. Duncan Murdoch (Canada), Prof. Mikelis Bickis (Canada)에 깊은 감사의 뜻을 표현합니다.  

본 문서에 대한 최초의 직역은 2009년 07월에 @R{}-2.9.1를 기초로 이루어졌으나, 많은 수정과 내용의 갱신이 R의 버전이 업드레이드 될 때마다 이루어지고 있습니다. 
이러한 계속 된 문서의 업데이트는 아래에 기재되신 분들의 문서 각 부분의 번역 및 교정, 그리고 다양한 관점에서의 검토를 통하여 가능할 수 있었습니다. (의도적인 것은 아니지만 문서의 관리상의 실수로 인하여 이 문서에 기여하셨던 분들의 성함이 혹시 빠져 있을 수도 있습니다. 부디 문서의 책임자 @email{gnustats@@korea.gnu.org}에게 직접 연락주시면 감사하겠습니다).

@itemize @bullet
@item Heather Kim, University of Manitoba, Winnipeg, Manitoba, Canada, 2010-2011
@item 정영하, Pacific Biological Station, Department of Fisheries and Ocean, Canada, 2009-2010
@item 이세연, 이화여자대학교, 2009
@end itemize

본 문서는 언급된 전문용어들에 대한 추가적인 해석, 오역교정, 그리고 이해를 돕기 위한 내용을 추가함으로서, 새로운 R의 배포에 맞추어 지속적으로 관리되어 질 것입니다.
본 문서에 대한 참여 및 제안은 @email{ihelp-translators@@ihelp.r-forge.r-project.org}으로 보내주신다면 감사하겠습니다. 

@RIcopyright{}

@permission{}

@end ifnottex

@menu
* Preface::
* Introduction and preliminaries::  
* Simple manipulations numbers and vectors::  
* Objects::                     
* Factors::                     
* Arrays and matrices::         
* Lists and data frames::       
* Reading data from files::     
* Probability distributions::   
* Loops and conditional execution::  
* Writing your own functions::  
* Statistical models in R::     
* Graphics::                    
* Packages::                    
* A sample session::            
* Invoking R::                  
* The command-line editor::     
* Function and variable index::  
* Concept index::               
* References::                  
@end menu


@node Preface, Introduction and preliminaries, Top, Top
@c @unnumbered Preface
@unnumbered 서문

@c This introduction to @R{} is derived from an original set of notes
@c describing the @Sl{} and @SPLUS{} environments written in 1990--2 by
@c Bill Venables and David M. Smith when at the University of Adelaide.  We
@c have made a number of small changes to reflect differences between the
@c @R{} and @Sl{} programs, and expanded some of the material.

@c We would like to extend warm thanks to Bill Venables (and David Smith)
@c for granting permission to distribute this modified version of the notes
@c in this way, and for being a supporter of @R{} from way back.

@c Comments and corrections are always welcome.  Please address email
@c correspondence to @email{R-core@@R-project.org}.

원래 @R{}에 대한 이 안내서는 1990년부터 1992년 사이에 Bill Venables과 David M. Smith가 Adelaide 대학에서 @Sl{}와 @SPLUS{}에 대하여 작성한 노트를 토대로 하고 있습니다.
그러나,이 문서에서는 @R{}과 @Sl{} 사이의 다른 점들을 반영하기 위하여 원래 노트의 내용에 적절한 수정을 가하고 일부 내용들을 더욱 보강하였습니다.
이렇게 원래의 노트에 대한 수정과 재배포를 허락하고, @R{}을 지지해주신 Bill Venables (그리고 David Smith)에게깊은 감사의 뜻을 전합니다. 

@c @subheading Suggestions to the reader
@subheading 처음 @R{}을 사용하시는 분들께

@c Most @R{} novices will start with the introductory session in Appendix
@c A.  This should give some familiarity with the style of @R{} sessions
@c and more importantly some instant feedback on what actually happens.

@c Many users will come to @R{} mainly for its graphical facilities.  In
@c this case, @ref{Graphics} on the graphics facilities can be read at
@c almost any time and need not wait until all the preceding sections have
@c been digested.

지금 이 글을 읽고 계신 분이 혹시 @R{}을 처음 접하는 분이라면 @R{}이 어떻게 작동하는가를 좀 더 쉽게 익히기 위해 Appendix A 샘플 세션을 먼저 살펴보시길 권장 합니다.
특히, 적지 않은 분들의 경우 @R{}의 우수한 그래픽 기능 때문에 @R{}을 사용하실 것 입니다. 
이러한 분들을 위해 그래픽에 관련된 주제들은 @ref{Graphics} 챕터에 따로 모았으니 문서 전체의 내용을 순서대로 따라갈 필요없이 필요한 내용만 쉽게 찾아 보실 수 있을 것입니다.

@menu
* Introduction and preliminaries::
@end menu

@node Introduction and preliminaries, Simple manipulations numbers and vectors, Preface, Top
@c @chapter 1 Introduction and preliminaries
@chapter 소개와 본문에 들어가기 전에

@menu
* The R environment::           
* Related software and documentation::  
* R and statistics::            
* R and the window system::     
* Using R interactively::       
* Getting help::                
* R commands; case sensitivity etc::  
* Recall and correction of previous commands::  
* Executing commands from or diverting output to a file::  
* Data permanency and removing objects::  
@end menu

@node The R environment, Related software and documentation, Introduction and preliminaries, Introduction and preliminaries
@c @section The R environment
@section R environment (개발환경) 

@c @R{} is an integrated suite of software facilities for data
@c manipulation, calculation and graphical display.  Among other things it
@c has

@c @itemize @bullet
@c @item
@c an effective data handling and storage facility,
@c @item
@c a suite of operators for calculations on arrays, in particular matrices,
@c @item
@c a large, coherent, integrated collection of intermediate tools for data
@c analysis,
@c @item
@c graphical facilities for data analysis and display either directly at
@c the computer or on hardcopy, and
@c @item
@c a well developed, simple and effective programming language (called `S')
@c which includes conditionals, loops, user defined recursive functions and
@c input and output facilities.  (Indeed most of the system supplied
@c functions are themselves written in the @Sl{} language.)
@c @end itemize

@R{}은 데이터의 조작 및 수치연산, 그리고 시각화를 수행할 수 있는 소프트웨어 기능들을 한데 모아놓은 통합 개발환경이라고 할 수 있으며, 다음과 같은 기능들을 수행하는데 특히 강점을 보입니다.
 
@itemize @bullet
@item 
효과적인 데이터의 관리 및 저장,  
@item 
배열(array) 기반의 연산을 수행하기 위한 다양한 연산자의 제공 (행렬 연산에 더욱 특화되어 있음),
@item 
데이터 분석을 수행함에 있어, 중간과정의 단계를 모두 확인할 수 있는 기능들을 일관성있게 조합해 놓은 통합 분석도구 제공,
@item 
데이터 분석으로부터 얻은 결과 및 시각화된 자료들을 직접 컴퓨터에서 출력하거나 하드카피로 출력,
@item 
조건문, 반복문, 사용자 정의 함수, 그리고 표준 입출력과 관련된 기능들 다룰 수 있는 이 언어는 '@Sl{}' 이라고 불리우며 사용이 단순하면서도 효율적이도록 개발되었습니다.
(실제로 @R{} 시스템의 대다수의 함수들은 @Sl{}언어로 작성 되었습니다). 
@end itemize

@c The term ``environment'' is intended to characterize it as a fully
@c planned and coherent system, rather than an incremental accretion of
@c very specific and inflexible tools, as is frequently the case with other
@c data analysis software.

@c @R{} is very much a vehicle for newly developing methods of interactive
@c data analysis.  It has developed rapidly, and has been extended by a
@c large collection of @emph{packages}.  However, most programs written in
@c @R{} are essentially ephemeral, written for a single piece of data
@c analysis.

``environment''(개발환경)라는 용어는 특정 기능만을 수행하기 위해 개발된 도구들을 계속 더해서 기능을 확상하는 대부분의 통계 분석 소트웨어와는 다르게 R은 하나의 시스템으로 미리 계획적이고 일관성 있게 개발 되었음을 드러내기 위해 사용되었습니다.

@R{}은 시스템과 분석자가 서로 대화하는 과정을 통해 데이터를 분석하고, 또 이러한 분석에 필요한 새로운 방법들을 개발하는데 사용하는 수단이라고 볼 수 있습니다. @R{}은 그동안 빠르게 발전해왔고, 수 많은 @emph{package}(패키지)들의 모음으로 그 기능을 확장시켜 왔습니다. 하지만, @R{}로 작성된 대부분의 프로그램들은 사용자에게 주어진 하나의 구체적인 데이터를 분석하기 위해서 작성되는 것이므로 대부분의 경우 다시 사용할 수 없습니다.

@node Related software and documentation, R and statistics, The R environment, Introduction and preliminaries
@c @section Related software and documentation
@section 관련 소프트웨어 및 유용한 문서들

@c @R{} can be regarded as an implementation of the @Sl{} language which
@c was developed at Bell Laboratories by Rick Becker, John Chambers and
@c Allan Wilks, and also forms the basis of the @SPLUS{} systems.

@c The evolution of the @Sl{} language is characterized by four books by
@c John Chambers and coauthors.  For @R{}, the basic reference is @emph{The
@c New @Sl{} Language: A Programming Environment for Data Analysis and
@c Graphics} by Richard A.@: Becker, John M.@: Chambers and Allan R.@:
@c Wilks.  The new features of the 1991 release of @Sl{}
@c (@Sl{} version 3) JMC says the 1988 version is S3.
@c are covered in @emph{Statistical Models in @Sl{}} edited by John M.@:
@c Chambers and Trevor J.@: Hastie.  The formal methods and classes of the
@c @pkg{methods} package are based on those described in @emph{Programming
@c with Data} by John M.@: Chambers.  @xref{References}, for precise
@c references.

@c There are now a number of books which describe how to use @R{} for data
@c analysis and statistics, and documentation for @Sl{}/@SPLUS{} can
@c typically be used with @R{}, keeping the differences between the @Sl{}
@c implementations in mind.  @xref{What documentation exists for R?, , ,
@c R-FAQ, The R statistical system FAQ}.

여러분은 @R{}을 Bell 연구소에서 근무하던 Rick Becker, John Chambers 그리고 Allan Wilks가 @SPLUS{} 시스템의 구축을 위해 개발한 @Sl{} 라는 언어를 다른 형태로 실행시킨 것이라고 생각하셔도 좋을 것입니다. 

이 @Sl{} 언어의 진화과정은 John Chambers와 그의 동료들이 쓴 네 권의 책에 의해서 잘 정리되어 있습니다.
만약, 여러분이 @R{}의 가장 기본적인 참고자료를 원하시면 Richard A.@: Becker, John M.@: Chambers 그리고 Allan R.@: Wilks가 저술한 @emph{The New @Sl{} Language: A Programming Environment for Data Analysis and Graphics}라는 책을 찾아보실 것을 권합니다. 
또 1991년 버전에 추가된 @Sl{}의 새로운 기능들에 대해서는 John M.@: Chambers와 Trevor J.@: Hastie가 편집한 @emph{Statistical Models in @Sl{}} 라는 책을 참고하시길 바랍니다. 
@pkg{methods} 패키지에 구현되어 있는 method(메소드)와 class(클래스)들은 John M.@: Chambers가 저술한 @emph{Programming with Data}에서 찾아 볼 수 있으며, 더 구체적인 내용을 원하시면 링크된 참고자료들을 @ref{References} 살펴보시길 바랍니다.

이미 시중에 @R{}을 이용한 데이터 분석과 통계학에 관련된 많은 서적들이 나와 있습니다.
또한, @Sl{}/@SPLUS{}를 위해 작성된 문서들을 참고하는 것 역시 @R{}을 사용하시는데 도움이 될 것입니다.
그러나, 여러분은 반드시 @Sl{} 과 @R{} 은 서로 다른 언어라는 점을 기억하셔야 합니다.
더 자세한 사항은 @ref{What documentation exists for R?, , , R-FAQ, The R statistical system FAQ}를 참고해주시길 바랍니다.

@node R and statistics, R and the window system, Related software and documentation, Introduction and preliminaries
@c @section R and statistics
@section R 과 통계
@cindex Packages

@c Our introduction to the @R{} environment did not mention
@c @emph{statistics}, yet many people use @R{} as a statistics system.  We
@c prefer to think of it of an environment within which many classical and
@c modern statistical techniques have been implemented.  A few of these are
@c built into the base @R{} environment, but many are supplied as
@c @emph{packages}.  There are about 25 packages supplied with @R{} (called
@c ``standard'' and ``recommended'' packages) and many more are available
@c through the @acronym{CRAN} family of Internet sites (via
@c @uref{http://CRAN.R-project.org}) and elsewhere.  More details on
@c packages are given later (@pxref{Packages}).

@c Most classical statistics and much of the latest methodology is
@c available for use with @R{}, but users may need to be prepared to do a
@c little work to find it.

@c There is an important difference in philosophy between @Sl{} (and hence
@c @R{}) and the other main statistical systems.  In @Sl{} a statistical
@c analysis is normally done as a series of steps, with intermediate
@c results being stored in objects.  Thus whereas SAS and SPSS will give
@c copious output from a regression or discriminant analysis, @R{} will
@c give minimal output and store the results in a fit object for subsequent
@c interrogation by further @R{} functions.

@R{} 에 대한 본 안내서는 @emph{statistics}(통계학) 자체를 설명하기 위해 작성된 것은 아니지만, 이미 많은 독자 여러분이 @R{} 은 통계 시스템이라는 것을 잘 알고 계시리라 믿습니다.
여기에 더해, 저희는 여러분이 @R{} 이라는 시스템이 과거로부터 현재에 이르기까지 개발되어 온 수많은 통계적 방법들을 사용할 수 있도록 해주는 하나의 환경으로 생각해주셨으면 합니다.
이러한 많은 방법들 중 일부는 @R{}의 기본 환경 안에 이미 포함되어 있으나, 대부분은 @emph{packages}(패키지)를 통해  사용 가능 합니다.
기본적으로 @R{} 은 ``standard''(표준) 혹은 ``recommended''(권장)패키지라고 불리는 총 25개의 패키지들이 포함된 채로 설치 됩니다.
그 외의 패키지들은 @acronym{CRAN}이라는 인터넷 저장소를 통해서 찾을 수 있으며, 이 저장소의 주소는 @uref{http://CRAN.R-project.org})입니다.
패키지에 대한 더 자세한 내용은 (@pxref{Packages})에서 설명 하겠습니다.

가장 고전적인 통계 방법부터 최근에 개발된 것까지 거의 모든 통계적 방법들이 @R{}에서 사용될 수 있으나, 사용자의 목적에 맞는 적절한 패키지를 찾는 것은 여러분 스스로의 몫 입니다.

또한, 여러분은 @Sl{} (이 문서에서는 @R{})은 다른 주요 통계 시스템들과 분석 결과물을 출력하는 방식이 다르다는 점을 알고 계셔야 합니다.
예를 들면, @Sl{}에서는 통계적 분석을 일련의 절차로써 수행하게 되는데, 각 과정마다 얻어진 결과물들을 객체로써 저장 됩니다. 즉 SAS 또는 SPSS와 같은 분석도구로 회귀분석 또는 판별분석을 수행하면 분석 과정 중에 생성된 모든 결과가 한번에 출력되는 반면, @R{}은 최소한의 결과값 만을 제공하므로 더 자세한 중간분석결과 및 수행과정을 확인하고 싶다면 다른 함수를 추가로 사용해야 합니다.

@node R and the window system, Using R interactively, R and statistics, Introduction and preliminaries
@c @section R and the window system
@section R 과 윈도우 시스템

@c The most convenient way to use @R{} is at a graphics workstation running
@c a windowing system.  This guide is aimed at users who have this
@c facility.  In particular we will occasionally refer to the use of @R{}
@c on an X window system although the vast bulk of what is said applies
@c generally to any implementation of the @R{} environment.

@c Most users will find it necessary to interact directly with the
@c operating system on their computer from time to time.  In this guide, we
@c mainly discuss interaction with the operating system on UNIX machines.
@c If you are running @R{} under Windows or Mac OS you will need to make
@c some small adjustments.

@c Setting up a workstation to take full advantage of the customizable
@c features of @R{} is a straightforward if somewhat tedious procedure, and
@c will not be considered further here.  Users in difficulty should seek
@c local expert help.

@R{}을 사용하는 가장 손쉬운 방법은 윈도잉 시스템(windowing sytem, 즉 여러개의 창을 띄어줄 수 있는 시스템)을 사용하는 그래픽 워크스테이션을 이용하는 것입니다. 
본 문서는 이러한 기능을 사용할 수 있는 분들을 위해서 작성 되었습니다.
주로 X 윈도우 시스템(유닉스와 같은 운영체제에서 사용하는 윈도윙 시스템의 이름)에서 @R{}을 사용하는 방법을 위주로 서술하게 되겠지만, 이러한 설명들은 @R{}을 실행할 수 있는 다른 체제에서도 동일하게 적용될 수 있습니다.

때때로, 여러분은 작업을 위해 여러분의 컴퓨터의 운영체제와 직접 대화를 해야할 필요가 있을 것 입니다.
본 문서에서는 여러분이 UNIX로 작업한다고 가정하고 있으므로, 만약 여러분이 주로 Windows 혹은 Mac에서 @R{}을 사용하신다면, 여기서 설명하는 방법들과 다소 차이가 있을 수 있다는 점을 기억하시기 바랍니다.

이러한 각각의 환경에서 최적화된 성능의 @R{}을 사용하기 위해서는 약간의 기술적인 설정이 요구되지만, 본 문서에서는 이러한 내용들을 다루지 않을 것입니다.
만약, 이러한 조정이 어려운 분이라면 주변 전문가에게 도움을 요청하시길 바랍니다.

@node Using R interactively, Getting help, R and the window system, Introduction and preliminaries
@c @section Using R interactively
@section 대화형으로 사용하는 R

@c When you use the @R{} program it issues a prompt when it expects input
@c commands.  The default prompt is @samp{@code{>}}, which on UNIX might be
@c the same as the shell prompt, and so it may appear that nothing is
@c happening.  However, as we shall see, it is easy to change to a
@c different @R{} prompt if you wish.  We will assume that the UNIX shell
@c prompt is @samp{@code{$}}.

@R{} 은 대화형 프로그램이라, 프로그램을 실행시키면 사용자의 입력을 기다리는 표시 @samp{@code{>}}ㅊ(프롬프트)가 시작 됩니다.
이 표시는 UNIX에서의 쉘 프롬프트와도 동일하다고 볼 수 있는데, 사용자가 원하면 @R{}의 프롬프트를 다른 모양으로 변경하는 것도 가능합니다.
본 문서에서는 내용의 명확성을 위해서 UNIX의 쉘 프롬프트는 @samp{@code{$}} (스트링)이라는 기호를 이용하여 따로 표시 하겠습니다.

@c In using @R{} under UNIX the suggested procedure for the first occasion
@c is as follows:

UNIX에서 @R{} 을 사용하기 위해서는 아래 명령문을 따라하시면 됩니다.

@enumerate
@item
@c Create a separate sub-directory, say @file{work}, to hold data files on
@c which you will use @R{} for this problem.  This will be the working
@c directory whenever you use @R{} for this particular problem.

우선 아래의 코드와 같이 @R{}에서 사용할 데이터 파일들을 불러들일 장소인 @file{work}라는 별도의 디렉토리를 생성 합니다. R에서는 이 디렉토리 내에 데이터를 두고 분석을 수행하게 되는데, 이를 working directory (워킹 디렉토리 또는 작업 디렉토리)라고 합니다. 

@example
$ mkdir work
$ cd work
@end example

@item
@c Start the @R{} program with the command

아래의 명령어를 입력하면 @R{} 프로그램이 시작됩니다.
@example
$ R
@end example

@item
@c At this point @R{} commands may be issued (see later).
이제부터 @R{} 에서 제공되는 명령어들을 이용하여 작업을 할 수 있습니다.

@item
@c To quit the @R{} program the command is

아래의 명령어를 이용하면 @R{} 프로그램을 종료 할 수 있습니다.
이때, @R{} 프로그램은 현재 @R{} 세션에서 작업하던 데이터를 저장할 것인지에 대한 여부를 @kbd{yes} (예), @kbd{no} (아니요) 혹은 프로그램 종료를 @kbd{cancel} (취소)하고 다시 @R{} 세션으로 돌아갈 것인지를 확인합니다.
이러한 메시지는 일부 시스템에서는 대화창으로 뜨기도 하고, 종료 명령어 다음 줄에 일반 텍스트로 나타날 수도 있습니다.
만약, 저장을 선택하면 데이터는 워킹 디렉토리에 저장이 되고, 다음번에 @R{}을 실행할 때 저장된 데이터를 불러와서 다시 사용할 수 있습니다.

@example
> q()
@end example

@c At this point you will be asked whether you want to save the data from
@c your @R{} session.  On some systems this will bring up a dialog box, and
@c on others you will receive a text prompt to which you can respond
@c @kbd{yes}, @kbd{no} or @kbd{cancel} (a single letter abbreviation will
@c do) to save the data before quitting, quit without saving, or return to
@c the @R{} session.  Data which is saved will be available in future @R{}
@c sessions.

@end enumerate

@c Further @R{} sessions are simple.
이렇게 @R{} 프로그램을 종료 한 뒤 새로운 @R{} 세션을 시작하는 것은 간단합니다. 
@enumerate

@item
@c Make @file{work} the working directory and start the program as before:
위에서 했던 것 처럼 다시 @file{work}이라는 작업 (또는 워킹) 디렉토리를 만들고 @R{} 명령어를 입력하면 됩니다.
@example
$ cd work
$ R
@end example

@item
@c Use the @R{} program, terminating with the @code{q()} command at the end
@c of the session.

이렇게 실행시킨 @R{} 프로그램은 사용하고 난 뒤에, 마지막에 @code{q()} 명령어를 이용하여 종료할 수도 있습니다.  
@end enumerate

@c To use @R{} under Windows the procedure to
@c follow is basically the same.  Create a folder as the working directory,
@c and set that in the @file{Start In} field in your @R{} shortcut.
@c Then launch @R{} by double clicking on the icon.

Windows에서 @R{}을 사용하는 방법은 기본적으로 UNIX에서의 R 사용 방법과 동일합니다.
먼저 워킹 디렉토리에 해당하는 폴더를 생성하고, @file{Start In} 메뉴에서 @R{} 바로가기를 바탕화면에 생성합니다.
그리고, 이 바탕화면의 바로가기 아이콘을 더블 클릭하면 @R{}을 실행시킬 수 있습니다. 

@c @section An introductory session
@section 기초 소개 세션

@c Readers wishing to get a feel for @R{} at a computer before proceeding
@c are strongly advised to work through the introductory session
@c given in @ref{A sample session}.

@R{}에 좀 더 빠르게 적응하고 싶은 분이라면 @ref{A sample session}(샘플세션)에 있는 코드들을 따라 입력해 보고 어떤 결과가 출력되는지 확인하는 과정을 통해 R이 대강 어떤 식으로 작동하는지를 먼저 이해하시는 것이 도움이 될 것입니다.

@node Getting help, R commands; case sensitivity etc, Using R interactively, Introduction and preliminaries
@c @section Getting help with functions and features
@section 함수와 기능에 대한 도움말 사용법
@findex help

@c @R{} has an inbuilt help facility similar to the @code{man} facility of
@c UNIX.  To get more information on any specific named function, for
@c example @code{solve}, the command is

@R{}은 UNIX에서 @code{man} 명령어를 이용하여 도움말을 찾는 것과 유사한 기능을 제공하고 있습니다.
예를 들어, @code{solve} 라는 이름을 가진 함수가 어떤 기능을 가지고 있고, 이를 어떻게 사용하는지 알고 싶다면 아래와 같이 @code{help} 라는 명령어를 사용할 수 있습니다.

@example
> help(solve)
@end example
@findex help

@c An alternative is
아래와 같은 방법으로도 동일한 도움말 기능을 이용할 수 있습니다.

@example
> ?solve
@end example
@findex ?

@c For a feature specified by special characters, the argument must be
@c enclosed in double or single quotes, making it a ``character string'':
@c This is also necessary for a few words with syntactic meaning including
@c @code{if}, @code{for} and @code{function}.

어떤 경우에는 함수명이 아닌 special character (특수문자)에 대해서 알고 싶을 수도 있을 것 입니다. 
이러한 특수문자의 기능을 알고 싶다면 반드시 아래와 같이 특수문자를 큰 따옴표 혹은 작은 따옴표와 함께 사용하여 ``character string(문자열)''의 형식을 갖춰야 해당 문자에 대한 검색이 가능합니다.
이러한 형식은 @code{if}, @code{for} 그리고 @code{function} 과 같은 @R{} 의 구문(syntax)적 의미를 검색할 때도 필요합니다.

@example
> help("[[")
@end example

@c Either form of quote mark may be used to escape the other, as in the
@c string @code{"It's important"}.  Our convention is to use
@c double quote marks for preference.

일반적으로 두 가지 종류의 따옴표를 모두 이용할 수 있으나, 큰 따옴표를 사용하는 것을 주로 권장하는 데,
그 이유는 @code{"It's important"} 와 같이 작은 따옴표가 문자열 내에서 쓰일 수도 있기 때문입니다.

@c On most @R{} installations help is available in @HTML{} format by
@c running

대부분의 경우 @R{} 을 설치할때 @HTML{} 도움말이 함께 설치되며, 아래와 같이 @code{help.start} 함수를 이용하여 이를 사용할 수 있습니다.

@example
> help.start()
@end example
@findex help.start

@noindent
@c which will launch a Web browser that allows the help pages to be browsed
@c with hyperlinks.  On UNIX, subsequent help requests are sent to the
@c @HTML{}-based help system.  The `Search Engine and Keywords' link in the
@c page loaded by @code{help.start()} is particularly useful as it is
@c contains a high-level concept list which searches though available
@c functions.  It can be a great way to get your bearings quickly and to
@c understand the breadth of what @R{} has to offer.

위의 함수를 입력하면, 하이퍼링크로 연결된 도움말 페이지들을 검색할 수 있는 @HTML{} 기반의 도움말 시스템을 이용할 수 있도록 웹브라우저가 실행됩니다.
@code{help.start()} 를 실행하면 나타나는 초기 페이지에 있는 'Search Engine and Keywords'라는 링크는 사용 가능한 함수의 리스트 함께 검색어의 상위 개념(high-level concept)을 포함하기 때문에 매우 유용합니다.
이 링크를 사용하면 본인의 @R{}시스템에 대한 이해의 정도와 현재 @R{} 내에서 이용가능한 기능들을 확인하는데 큰 도움이 될 것 입니다.

@findex help.search
@c The @code{help.search} command (alternatively @code{??}) 
@c allows searching for help in various
@c ways. For example,

@code{help.search} 명령어 (또 다른 표현으로 @code{??})를 이용하면 더욱 다양한 방법으로 도움말을 검색하는 것이 가능합니다.
아래와 같은 명령문을 입력해보고 이렇게 검색하는 것이 어떤 식으로 다른지 확인할 수 있을 것 입니다.
같은 함수를 더 자세히 알고 싶다면 @code{?help.search}를 이용하여 도움말을 확인하시기 바랍니다.

@example
> ??solve
@end example
@findex ??

대부분의 경우 도움말을 모두 읽어 사용법을 배우지는 않을 것 입니다.
또, 도움말을 읽어도 이해가 되지 않는 경우도 있습니다.
이런 경우에는 예제를 실행해서 직접 사용해보는 것이 더 빠를 것이며, 해당 함수와 관련된 예제를 연습해 볼 수 있도록 도와주는 @code{example} 이라는 함수가 있습니다.
만약, 특별히 찾고자 하는 주제와 연관된 예제들을 모두 수행해 보고 싶다면 아래와 같이 입력해 보시길 바랍니다.

@example
> example(@var{topic})
@end example
@findex example

Windows에서 실행되는 @R{} 에서는 다른 방법으로도 도움말을 찾을 수 있습니다.
이에 대한 내용은 @code{help} 의 도움말을 확인하시길 바랍니다.
@c Windows versions of @R{} have other optional help systems: use

@example
> ?help
@end example

@noindent
@c for further details.

@node R commands; case sensitivity etc, Recall and correction of previous commands, Getting help, Introduction and preliminaries
@c @section R commands, case sensitivity, etc.
@section R 명령어 및 대소문자 구별과 미리 알아두면 좋은 사항들

@c Technically @R{} is an @emph{expression language} with a very simple
@c syntax.  It is @emph{case sensitive} as are most UNIX based packages, so
@c @code{A} and @code{a} are different symbols and would refer to different
@c variables.  The set of symbols which can be used in @R{} names depends
@c on the operating system and country within which @R{} is being run
@c (technically on the @emph{locale} in use).  Normally all alphanumeric
@c symbols are allowed@footnote{For portable @R{} code (including that to
@c be used in @R{} packages) only A--Za--z0--9 should be used.} (and in
@c some countries this includes accented letters) plus @samp{@code{.}} and
@c @samp{@code{_}}, with the restriction that a name must start with
@c @samp{@code{.}} or a letter, and if it starts with @samp{@code{.}} the
@c second character must not be a digit.  Names are currently effectively
@c unlimited, but were limited to 256 bytes prior to @R{} 2.13.0

테크니컬한 측면에서 @R{}을 설명하면 아주 단순한 문법을 가진 @emph{expression language}(표현언어)라고 할 수 있습니다. 여기서 표현언어란 expression(표현식 = 수학에서의 수식을 의미함)을 기초로 하는 언어를 의미하며, 이는 데이터 값을 출력하는데 사용하는 방법들 중 하나입니다. R은 UNIX를 기반으로 하는 다른 패키지들과 같이 @emph{case sensitive}(케이스 센서티브 = 대소문자를 구별)하므로, @code{A} 와 @code{a} 는 서로 다른 기호로 인식되어 다른 변수로 사용된다는 점을 기억하셔야 합니다.
@R{} 에서 사용할 수 있는 기호들은 사용자의 운영체제 및 @emph{locale}(로케일 = 운영체제에서 언어설정과 관계되어 사용자의 국가설정을 하는 기능을 의미함)에 따라 달라질 수 있습니다.
일반적으로 모든 알파벳 기호들 @footnote{@R{} 패키지들에서 사용되는 @R{}코드들을 포함하여, 오로지 A--Za--z0--9 (즉, 대문자 A부터 Z, 소문자 a부터 z, 그리고 숫자 0부터 9)을 지칭함}을 사용할 수 있으며, 일부국가에서만 사용되는 특수문자들 역시 사용 가능 합니다.
또한, @samp{@code{.}} 와 @samp{@code{_}} 을 함께 조합하여 사용하는 것도 가능합니다.
그러나, 표현식을 작성할 때에는 문장을 @samp{@code{.}} 또는 문자로만 시작할 수 있습니다.
만약 표현식이 @samp{@code{.}} 로 시작되었다면, 표현식의 두번째 문자는 반드시 숫자가 아닌 문자가 사용되어야 합니다.
@R{} 2.13.0 이전버전들은 표현식의 길이가 256바이트를 넘을 수 없었으나, 현재는 제약이 없습니다. 


@c Elementary commands consist of either @emph{expressions} or
@c @emph{assignments}.  If an expression is given as a command, it is
@c evaluated, printed (unless specifically made invisible), and the value
@c is lost.  An assignment also evaluates an expression and passes the
@c value to a variable but the result is not automatically printed.

@c Commands are separated either by a semi-colon (@samp{@code{;}}), or by a
@c newline.  Elementary commands can be grouped together into one compound
@c expression by braces (@samp{@code{@{}} and @samp{@code{@}}}).
@c @emph{Comments} can be put almost@footnote{@strong{not} inside strings,
@c nor within the argument list of a function definition} anywhere,
@c starting with a hashmark (@samp{@code{#}}), everything to the end of the
@c line is a comment.

명령문 (command 또는 명령)이라는 것은 @emph{expressions}(표현식)과 @emph{assignment}(할당)이라는 두가지 요소로 구성됩니다.
만약 표현식이 할당 없이 홀로 사용되게 된다면, 이는 단순 명령어로 처리되어 (따로 결과가 출력되지 않도록 지정한 것이 아니면) 그 결과가 자동으로 출력된 뒤, 그 값은  어디에도 저장되지 않고 사라집니다.
반면, 할당의 경우는 표현식을 처리해서 그 값을 지정된 변수에 보낼 뿐, 이 결과는 자동으로 출력하지는 않습니다.

일반적으로 여러 개의 명령문들을 구분하기 위해 세미콜론(@samp{@code{;}})을 사용하거나 또는 각 줄에 다른 명령어를 입력 합니다. 
기본적인 명령문들은 한 쌍의 열린 중괄호 @samp{@code{@{}} 와 하나의 닫힌 중괄호 @samp{@code{@}}} 에 의해 하나의 그룹으로 묶일 수 있습니다.
이렇게 그룹화된 표현식을 compound expression(복합 표현식)이라고 합니다. 
해쉬마크 (@samp{@code{#}})로 시작하는 @emph{Comments} (주석)은 해쉬마크가 있는 곳으로부터 해당 행 (또는 라인)의 끝까지 적용되는 것으로 입력된 결과는 처리되지 않고 단지 사용자에게 추가적인 정보를 제공하기 위해 사용되며, 한 프로그램 내 어디에든 위치할 수 있습니다 
@footnote{@strong{단, } 문자열 내에서는 해쉬마크를 사용할 수 없으며, 또 새 함수를 정의하는 할당(ASSINGMENT)문 안에서도 사용될 수 없습니다}.

@c If a command is not complete at the end of a line, @R{} will
@c give a different prompt, by default

만약, 명령어가 한 줄에 입력되지 않고 다음행으로 계속 이어지면, @R{} 은 자동적으로 아래와 같은 다른 기호로 프롬프트를 바꿔 명령문이 계속 이어지고 있음을 나타낼 것입니다. 
@example
+
@end example

@noindent
@c on second and subsequent lines and continue to read input until the
@c command is syntactically complete.  This prompt may be changed by the
@c user.  We will generally omit the continuation prompt
@c and indicate continuation by simple indenting.

명령문이 문법적으로 완성될 때까지 명령문의 두 번째 줄과 그 이후의 줄에서 이 프롬프트가 계속 나타나게 됩니다. 
이러한 continuation (컨티뉴에이션) 프롬프트는 사용자에 의해서 변경될 수 있습니다. 
이 문서에서는 컨티뉴에이션 프롬프트를 생략하고 단순히 인덴팅 (한 문자를 들여씀)을 사용하여 명령어가 계속 이어짐을 표현할 것입니다.

@c Command lines entered at the console are limited@footnote{some of the
@c consoles will not allow you to enter more, and amongst those which do
@c some will silently discard the excess and some will use it as the start
@c of the next line.} to about 4095 bytes (not characters).

일반적으로 콘솔 내에서 입력할 수 있는 명령어 라인은 4095바이트로 제한 됩니다. 
@footnote{콘솔에 따라 이 크기 이상을 아예 입력이 되지 않는 경우도 있고, 자동으로 입력 가능 범위 이상의 명령어들을 임의로 잘라내서 새로운 명령문으로 인식하기도 합니다.}

@node Recall and correction of previous commands, Executing commands from or diverting output to a file, R commands; case sensitivity etc, Introduction and preliminaries
@c @section Recall and correction of previous commands

@section 이전에 사용한 명령어를 다시 불러오고 교정하기

@c Under many versions of UNIX and on Windows, @R{} provides a mechanism
@c for recalling and re-executing previous commands.  The vertical arrow
@c keys on the keyboard can be used to scroll forward and backward through
@c a @emph{command history}.  Once a command is located in this way, the
@c cursor can be moved within the command using the horizontal arrow keys,
@c and characters can be removed with the @key{DEL} key or added with the
@c other keys.  More details are provided later: @pxref{The command-line
@c editor}.

@c The recall and editing capabilities under UNIX are highly customizable.
@c You can find out how to do this by reading the manual entry for the
@c @strong{readline} library.

@c Alternatively, the Emacs text editor provides more general support
@c mechanisms (via @acronym{ESS}, @emph{Emacs Speaks Statistics}) for
@c working interactively with @R{}.  @xref{R and Emacs, , , R-FAQ, The R
@c statistical system FAQ}.

다양한 버전의 UNIX와 윈도우즈에서 실행되는 @R{}은 이전에 사용되었던 명령어들을 다시 불러오고 이를 재실행을 시킬 수 있는 매커니즘(mechanism)을 가지고 있습니다.
이전에 실행되었던 명령문 히스토리 목록(@emph{command history})을 살펴보기 위해서 키보드의 위 또는 아래로 이동하는 화살표 키를 이용하시면 됩니다. 이렇게 해서 재실행하고 싶은 명령어를 찾고 나면, 이 명령어 내에서 좌 또는 우로 이동하는 화살표 키를 이용하여 커서를 변경하고자 하는 위치로 옮기고, @key{DEL} 및 다른 키들을 이용하여 해당 부분만 삭제하거나 수정하는 것 역시 가능합니다. 
더 자세한 사항은 @pxref{The command-line editor} 을 살펴보시길 바랍니다.

UNIX 상에서는 이러한 명령문 히스토리를 불러오고 수정하는 기능을 사용자의 취향에 따라 매우 쉽게 조정 (customizable)가능합니다. 이러한  조정 방법은 @strong{readline} 라이브러리 내 관련 매뉴얼 항목에서 찾으실 수 있습니다. 

또한, Emacs라는 텍스트 에디터는 @R{}을 보다 파워풀하게 사용할 수 있도록 도와주는 @acronym{ESS}(@emph{Emacs Speaks Statistics})라는 보조시스템을 제공해줍니다.  
이와 관련해서는 @ref{R and Emacs, , , R-FAQ, The R statistical system FAQ}을 참고하시길 바랍니다. 

@node Executing commands from or diverting output to a file, Data permanency and removing objects, Recall and correction of previous commands, Introduction and preliminaries
@c @section Executing commands from or diverting output to a file

@section 외부파일에 저장된 명령 실행 및 외부파일로 결과 저장하기
@cindex Diverting input and output

@c If commands@footnote{of unlimited length.} are stored in an external
@c file, say @file{commands.R} in the working directory @file{work}, they
@c may be executed at any time in an @R{} session with the command

만약 @file{work}이라는 작업 디렉토리내에 (매우 방대한 양의) 명령문들이 @file{commands.R} 라는 이름으로 외부파일에 위치하고 있다면, 다음과 같은 명령문을 사용하여 @R{} 세션 내 어느 때라도 이 명령문들을 실행할 수 있습니다.
윈도우즈에서는 @strong{File} 메뉴 항목에 위치한 @strong{Source} 라는 기능도 동일한 작업을 수행합니다.

@example
> source("commands.R")
@end example
@findex source

@c For Windows @strong{Source} is also available on the
@c @strong{File} menu.  

@c The function @code{sink},

@example
> sink("record.lis")
@end example
@findex sink


다음의 @code{sink} 라는 함수를 사용하면 앞으로의 모든 결과물이 현재 사용중인 콘솔이 아니라 @file{record.lis} 라는 외부파일에 저장 됩니다. 따라서, 이 함수가 사용된 이후로는 (명령문을 입력해도) 콘솔 상에 아무것도 출력되지 않게 됩니다.
다음의 명령문을 입력하면, 

@noindent
@c will divert all subsequent output from the console to an external file,
@c @file{record.lis}.  The command
@example
> sink()
@end example

@noindent
@c restores it to the console once again.
다시 결과값이 콘솔창에 나타나게 됩니다.

@node Data permanency and removing objects,  , Executing commands from or diverting output to a file, Introduction and preliminaries
@c @section Data permanency and removing objects
@section 영구적인 데이터 생성 및 객체 제거하기 

@c The entities that @R{} creates and manipulates are known as
@c @emph{objects}.  These may be variables, arrays of numbers, character
@c strings, functions, or more general structures built from such
@c components.
@c During an @R{} session, objects are created and stored by name (we
@c discuss this process in the next session).  The @R{} command

@R{} 을 사용해서 생성하고 다루게되는 모든 대상을 우리는 @emph{objects}(객체)라고 정의 합니다. 
변수 (variables), 숫자 배열 (arrays of numbers), 문자열 (character strings), 함수 (functions), 그리고 이러한 요소들이 바탕으로 한 좀 더 일반적인 구조물  등 모든 것들이 객체에 해당 합니다. 
그리고, 한 @R{} 세션 내에서 사용 중인 객체들은 이름(name)을 갖게 됨으로써 생성되고 저장이 되어집니다 (이 과정에 대해서는 다음 섹션에서 더 자세히 설명할 것입니다).

현재 @R{} 세션내에서 사용 중인 모든 객체들의 목록을 확인하고자 한다면 아래의 명령어를 사용하면 됩니다.

@example
> objects()
@end example

@noindent
@c (alternatively, @code{ls()}) can be used to display the names of (most
@c of) the objects which are currently stored within @R{}.  The collection
@c of objects currently stored is called the @emph{workspace}.

@code{ls()} 역시 현재 @R{} 세션 내에 사용 중인 (대부분의) 객체의 이름을 보여줄 것입니다. 
그리고, 이렇게 현재 사용중인 객체들이 저장되어 있는 공간을 @emph{workspace}(워크스페이스 또는 작업공간)이라고 합니다. 
@cindex Workspace

@c To remove objects the function @code{rm} is available:
이 작업 공간에서 객체를 삭제하기 위해서는 아래와 같이 @code{rm} 을 사용합니다:

@example
> rm(x, y, z, ink, junk, temp, foo, bar)
@end example
@findex rm
@cindex Removing objects

@c All objects created during an @R{} session can be stored permanently in
@c a file for use in future @R{} sessions.  At the end of each @R{} session
@c you are given the opportunity to save all the currently available
@c objects.  If you indicate that you want to do this, the objects are
@c written to a file called @file{.RData} @footnote{The leading ``dot'' in
@c this file name makes it @emph{invisible} in normal file listings in
@c UNIX.} in the current directory, and the command lines used in the
@c session are saved to a file called @file{.Rhistory}.

하나의 @R{} 세션 내에서 생성된 모든 객체들은 다음 세션에서 다시 사용하기 위해 파일 형태로 영구 저장하는 것이 가능합니다.
각 @R{}세션을 종료할 때는, 현재 세션에서 사용중인 모든 객체들을 저장할 수 있는 기회가 주어집니다. 
만약, 당신이 객체들을 저장하고 싶다고 선택하면, 객체들은 @file{.RData}이라는 파일형식으로 워킹 디렉토리에 저장됩니다. @footnote{``dot''으로 시작하는 이런 파일명은  UNIX 시스템 상에서는 일반 파일 목록 출력시 파일을 @emph{보이지 않게 합니다}.}
동시에 같은 디렉토리에 이 세션에서 사용되었던 모든 명령어들 역시 @file{.Rhistory}이라는 파일에 함께 저장되게 됩니다.

@c When @R{} is started at later time from the same directory it reloads
@c the workspace from this file.  At the same time the associated commands
@c history is reloaded.

추후에 @R{}이 같은 디렉토리에서 실행될 경우, 이 저장된 파일로부터 저장된 작업 공간이 다시 열리며 이전 세션에서 사용했던 객체들과 명령어들이 다시 사용 가능하게 됩니다.

@c It is recommended that you should use separate working directories for
@c analyses conducted with @R{}.  It is quite common for objects with names
@c @code{x} and @code{y} to be created during an analysis.  Names like this
@c are often meaningful in the context of a single analysis, but it can be
@c quite hard to decide what they might be when the several analyses have
@c been conducted in the same directory.

@R{}을 이용하여 여러 개의 분석을 진행한다면, 각각의 분석 별로 다른 작업 공간을 생성하실 것을 권장합니다.
그 이유는 @code{x} 와 @code{y} 같은 매우 일반적인 이름으로 객체를 생성하게 되는 경우가 매우 흔하기 때문입니다.
만약 분석을 한 번만 한다면 큰 문제가 없겠지만, 여러 개의 분석이 같은 작업 공간에서 이루어진다면 비슷한 이름을 가진 각각의 객체들이  각각의 분석에서 어떤 식으로 사용되고 있는지 알아차리기가 쉽지 않을 것이기 때문입니다. 


@node Simple manipulations numbers and vectors, Objects, Introduction and preliminaries, Top
@c @chapter Simple manipulations; numbers and vectors
@chapter 기초 조작법
@cindex Vectors

@menu
* Vectors and assignment::      
* Vector arithmetic::           
* Generating regular sequences::  
* Logical vectors::             
* Missing values::              
* Character vectors::           
* Index vectors::               
* Other types of objects::      
@end menu

@node Vectors and assignment, Vector arithmetic, Simple manipulations numbers and vectors, Simple manipulations numbers and vectors
@c @section Vectors and assignment
@section 벡터와 할당

@c @R{} operates on named @emph{data structures}.  The simplest such
@c structure is the numeric @emph{vector}, which is a single entity
@c consisting of an ordered collection of numbers.  To set up a vector
@c named @code{x}, say, consisting of five numbers, namely 10.4, 5.6, 3.1,
@c 6.4 and 21.7, use the @R{} command

@R{}은 @emph{data structures}(데이터 구조)라는 것을 기반으로 작동합니다.
가장 단순한 데이터의 구조는 임의의 숫자들의 정렬인 숫자형 (numeric) @emph{vector}(벡터)입니다.
예를들어, 10.4, 5.6, 3.1, 6.4, 그리고 21.7 라는 일련의 숫자로 @code{x}라는 이름을 가진 벡터를 생성하기 위해서는 다음과 같은 @R{} 명령어를 입력합니다

@example
> x <- c(10.4, 5.6, 3.1, 6.4, 21.7)
@end example
@findex c
@findex vector

@c This is an @emph{assignment} statement using the @emph{function}
@c @code{c()} which in this context can take an arbitrary number of vector
@c @emph{arguments} and whose value is a vector got by concatenating its
@c arguments end to end.@footnote{With other than vector types of argument,
@c such as @code{list} mode arguments, the action of @code{c()} is rather
@c different.  See @ref{Concatenating lists}.}

위에서 사용된 표현식을 @emph{assignment statement}(할당문) 이라고 하며, 여기서 사용된 @code{c()}라는 @emph{function}(함수)는 함수 안에 입력된 여러 개의 임의의 숫자들을 하나로 연결하여 하나의 벡터를 생성합니다. 여기서 쉽표 @code{,} 에 의해 구분된 하나 하나의 숫자는 그 자체로 길이가 1인 벡터로 볼 수도 있습니다.  

@footnote{@code{list} 처럼 벡터형의 인자가 아닌 데이터에 대해 @code{c()} 함수를 사용하면, 그 결과가 다소 다르게 나타납니다. 자세한 것은 @ref{Concatenating lists}를 참고하시길 바랍니다.}

@c A number occurring by itself in an expression is taken as a vector of
@c length one.

@c Notice that the assignment operator (@samp{@code{<-}}), which consists
@c of the two characters @samp{@code{<}} (``less than'') and
@c @samp{@code{-}} (``minus'') occurring strictly side-by-side and it
@c `points' to the object receiving the value of the expression.
@c In most contexts the @samp{@code{=}} operator can be used as an alternative.
@c In this text, the assignment operator is printed as @samp{<-}, rather
@c than ``@code{<-}''.

또한, 띄어쓰기 없이 @samp{@code{<}}(부등호, 좌측이 우측보다 작음을 표시하는 수학적 기호) 와 @samp{@code{-}}(음수를 나타내는 기호)를 붙여 써서 만든 @samp{@code{<-}} 라는 기호는 할당 연산자(assignment operator)라고 하며, 이 기호의 오른쪽의 표현식에 의해 생성된 값을 갖는 객체를 왼쪽의 이름을 갖도록 지정합니다. 
대부분의 경우 @samp{@code{=}} 연산자를 같은 작업을 이용하여 할 수 있습니다.

@cindex Assignment

@c Assignment can also be made using the function @code{assign()}.  An
@c equivalent way of making the same assignment as above is with:

할당(Assignment) 작업은 @code{assign()} 함수를 통해서도 이루어질 수 있습니다.
위에서 수행한 것과 동일한 연산을 아래와 같은 방법으로도 할 수 있습니다.

@example
> assign("x", c(10.4, 5.6, 3.1, 6.4, 21.7))
@end example

@noindent
@c The usual operator, @code{<-}, can be thought of as a syntactic
@c short-cut to this.
여러분은 할당 연산자 @code{<-}를 단순히 @code{assign()} 함수와 같은 작업을 하는, 문법적으로는 더 쉬운 방법(short-cut)이라고 생각하셔도 됩니다.

@c Assignments can also be made in the other direction, using the obvious
@c change in the assignment operator.  So the same assignment could be made
@c using

또, 이 할당 연산자의 방향을 바꾸어 아래와 같은 방법으로 사용할 수도 있습니다.

@example
> c(10.4, 5.6, 3.1, 6.4, 21.7) -> x
@end example

@c If an expression is used as a complete command, the value is printed
@c @emph{and lost} @footnote{Actually, it is still available as
@c @code{.Last.value} before any other statements are executed.}.  So now if we
@c were to use the command

만약 아래와 같이 할당 연산자를 사용하지 않고 표현식만으로 명령문을 작성하면, 결과물은 출력 되지만, 이 값이 저장되지 않아 @emph{다시 불러 낼 수 없습니다}. @footnote{실제로 이 표현식 실행 후, 아직 다음 명령문을 실행하지 않았다면 @code{.Last.value} 함수를 사용하여 결과물을 한 번 더 확인하는 것은 가능합니다. }.

@example
> 1/x
@end example

@noindent
@c the reciprocals of the five values would be printed at the terminal (and
@c the value of @code{x}, of course, unchanged).

이제 위의 명령문을 실행하여 (위에서 할당한) @code{x}의  다섯 개 숫자의 역수 다섯 개를 출력 해 봅시다. 

@c The further assignment

다음은 여기에 할당 연산자를 적용해보도록 합니다.
다음의 할당문은 2개의 @code{x} 벡터 사이에 0 을 입력한, 총 11개의 숫자로 구성된 @code{y} 라는 새로운 벡터를 생성 합니다.

@example
> y <- c(x, 0, x)
@end example

@noindent
@c would create a vector @code{y} with 11 entries consisting of two copies
@c of @code{x} with a zero in the middle place.

@node Vector arithmetic, Generating regular sequences, Vectors and assignment, Simple manipulations numbers and vectors
@c @section Vector arithmetic



@section 벡터 연산

@c Vectors can be used in arithmetic expressions, in which case the
@c operations are performed element by element.  Vectors occurring in the
@c same expression need not all be of the same length.  If they are not,
@c the value of the expression is a vector with the same length as the
@c longest vector which occurs in the expression.  Shorter vectors in the
@c expression are @emph{recycled} as often as need be (perhaps
@c fractionally) until they match the length of the longest vector.  In
@c particular a constant is simply repeated.  So with the above assignments
@c the command

벡터(vector)는 요소 단위의 (element by element) 산술연산 표현식(arithmetic expression)에 사용 가능 합니다. 이 때, 같은 (산술) 표현식 내의 벡터들이 모두 같은 길이를 가질 필요는 없습니다.
만약, 벡터들의 길이가 다르면 가장 긴 길이의 벡터를 기준으로, 상대적으로 짧은 길이를 갖는 벡터는 긴 벡터의 길이에 맞추기 위해 그 구성 요소를 재활용(@emph{recycled})하여 연산을 수행 합니다. 즉, 더 짧은 길이의 벡터는 가장 긴 벡터와 같은 길이를 같도록 구성 요소를 필요한 만큼 (경우에 따라서는 일부만) 반복 사용 합니다. 특히, 벡터의 길이가 1인 상수(constant)를 벡터와의 연산에 사용할 경우, 이 상수가 벡터의 길이만큼 반복되서 사용 됩니다. 

위의 예제를 이용해서 설명하면, 다음 명령문을 실행하면 @R{}은 연산을 하기 전 @code{x}의 길이를 @code{y}에 맞추기 위해서 그 구성 요소를 대략 2.2 번 반복하여 길이 11의 벡터를 만듭니다. 그리고, 2를 @code{x} 의 각 요소에 곱한 뒤 (11번의 곱하기 연산이 필요합니다), @code{y}의 각 요소와 더하기 연산을 수행합니다. 마지막으로 상수 @code{1}과의 더하기 연산 역시 11 번에 걸쳐 수행하며, 이렇게 벡터의 각 요소별로 수행된 연산의 결과는 길이 11의 벡터인 @code{v}에 할당 됩니다. 

 
@cindex Recycling rule

@example
> v <- 2*x + y + 1
@end example

@noindent
@c generates a new vector @code{v} of length 11 constructed by adding
@c together, element by element, @code{2*x} repeated 2.2 times, @code{y}
@c repeated just once, and @code{1} repeated 11 times.


@cindex Arithmetic functions and operators
@c The elementary arithmetic operators are the usual @code{+}, @code{-},
@c @code{*}, @code{/} and @code{^} for raising to a power.

@R{}에서 제공하는 요소 단위 기본 연산자는 @code{+}(더하기), @code{-}(빼기), @code{*}(곱하기), @code{/}(나누기), 그리고 @code{^}(자승) 입니다.

@findex +
@findex -
@findex *
@findex /
@findex ^

@c In addition all of the common arithmetic functions are available.
@c @code{log}, @code{exp}, @code{sin}, @code{cos}, @code{tan}, @code{sqrt},
@c and so on, all have their usual meaning.

@R{}에서는 일반적인 수학 연산에 자주 사용되는 @code{log}, @code{exp}, @code{sin}, @code{cos}, @code{tan}, @code{sqrt}와 같은 함수가 모두 제공되며, 수학에서 사용하는 것과 동일한 방법으로 사용 됩니다. 

@findex log
@findex exp
@findex sin
@findex cos
@findex tan
@findex sqrt

@c @code{max} and @code{min} select the largest and smallest elements of a
@c vector respectively.

@code{max}와 @code{min}는 벡터의 구성요소들 중에서 가장 큰 값과 작은 값을 보여주는 함수입니다. 

@findex max
@findex min

@c @code{range} is a function whose value is a vector of length two, namely
@c @code{c(min(x), max(x))}.
@code{range}는 주어진 벡터 @code{x}의 모든 구성요소 중 최소값과 최대값을 @code{c(min(x), max(x))}의 형태로 출력하며, 이름 그대로 벡터 변수의 범위를 구할 때 사용 합니다.

@findex range

@c @code{length(x)} is the number of elements in @code{x},
@code{length(x)}는 벡터 @code{x} 의 구성요소가 몇 개인가를 알려주며, 이를 보통 @code{x}의 길이라고 합니다.

@findex length

@c @code{sum(x)} gives the total of the elements in @code{x},
@code{sum(x)}는 @code{x}의 모든 구성요소들의 합을 구하고자 할 때 사용하고, 

@findex sum

@c and @code{prod(x)} their product.
@code{prod(x)}는 모든 구성요소들의 곱을 구할 때 이용됩니다.
@findex prod

@c Two statistical functions are @code{mean(x)} which calculates the sample
@c mean, which is the same as @code{sum(x)/length(x)},

R에서는 통계학에서 자주 이용되는 평균과 분산을 계산하는 함수들도 제공됩니다.
샘플 평균(sample mean)은 @code{sum(x)/length(x)}으로 계산 되는데, @code{mean(x)}를 사용해서도 같은 결과를 얻을 수 있습니다. 
@findex mean
@c and @code{var(x)} which gives
그리고, 샘플 분산(sample variance)은 아래와 같은 공식을 통해 계산하는데, 이 역시 @code{var(x)}를 사용하면 아주 간단하게 계산할 수 있습니다. 
@example
sum((x-mean(x))^2)/(length(x)-1)
@end example
@findex var

@noindent
@c or sample variance.  If the argument to @code{var()} is an
@c @math{n}-by-@math{p} matrix the value is a @math{p}-by-@math{p} sample
@c covariance matrix got by regarding the rows as independent
@c @math{p}-variate sample vectors.
만약, @code{var()} 에 사용되는 입력인자(argument)가 @math{n}-by-@math{p} 크기의 행렬이라면, 입력인자가@math{p}개의 변수들에 대한 @math{n} 개의 관측치를 갖는 데이터로 인식되어 @math{p}-by-@math{p} 크기의 샘플 공분산 행렬(sample covariance matrix)을 계산 합니다. 

@c @code{sort(x)} returns a vector of the same size as @code{x} with the
@c elements arranged in increasing order; however there are other more
@c flexible sorting facilities available (see @code{order()} or
@c @code{sort.list()} which produce a permutation to do the sorting).

@code{sort(x)}는 벡터 @code{x}를 인자로 받아 @code{x}의 모든 구성요소들을 오름차순(increasing order, 즉, 작은 값에서 큰 값의 순서로)으로 재배열하여 @code{x}와 같은 길이의 벡터를 출력하는 함수 입니다. 이와 비슷한 다른 정렬 함수들 역시 매우 유용하며, 가장 빈번하게 사용되는 예로는 인자로 사용된 @code{x} 벡터의 정렬 순서를 확인하기 위해 @code{order()} 또는 @code{sort.list()}를 사용하는 것을 들 수 있습니다.

@findex sort
@findex order

@c Note that @code{max} and @code{min} select the largest and smallest
@c values in their arguments, even if they are given several vectors.  The
@c @emph{parallel} maximum and minimum functions @code{pmax} and
@c @code{pmin} return a vector (of length equal to their longest argument)
@c that contains in each element the largest (smallest) element in that
@c position in any of the input vectors.

@code{max}와 @code{min}에 여러 개의 벡터가 동시에 입력인수로 사용되었을지라도, 입력된 모든 구성요소들 중에서 최대값과 최소값 하나씩 만을 출력합니다.
만약, 여러 개의 벡터 입력인자들을 동시에 입력해서 최대값과 최소값의 병렬(@emph{parallel} 원한다면, 즉 입력된 여러 개 벡터 인자들을 입력순서 별 최대값 혹은 최소값을 찾는 과정) 원한다면, @code{pmax}와 @code{pmin} 함수를 각각 이용할 수 있습니다. 이 때 반환되는 벡터의 길이는 입력 인자들 중에서 가장 길이가 긴 벡터와 동일합니다. (즉, 길이가 다른 벡터들의 입력시, 길이가 짧은 벡터와 긴 벡터의 비교가 불가능한 구간에서는 오직 비교 가능한 벡터들끼리만 비교해서, 혹은 가장 길기가 긴 벡터의 구성요소를 그대로 출력하게 됩니다).  

@findex pmax
@findex pmin

@c For most purposes the user will not be concerned if the ``numbers'' in a
@c numeric vector are integers, reals or even complex.  Internally
@c calculations are done as double precision real numbers, or double
@c precision complex numbers if the input data are complex.

대부분의 연산에서, 숫자형 벡터(numeric vector)의 구성요소인 ``numbers''(숫자)의 종류가 정수(integer)인지, 실수(real)인지, 또는 허수(complex)인지는 중요하지 않습니다. 
@R{}은 자체적으로 입력된 벡터가 실수인 경우 double precision을 갖는 실수로, 복소수(허수)이면 double precision을 갖는 복소수로 연산을 수행할 수 있습니다. 

@c To work with complex numbers, supply an explicit complex part.  Thus
단, 복소수 연산의 경우, 어느 부분이 허수 부분(copmlex part)인지는 정확히 명시해주어야 합니다. 
아래 예시와 같이 허수 부분이 지정하지 않고 명령문을 사용하면, @code{NaN} 값과 경고(warning) 메시지가 출력 될 것입니다. 

@example
sqrt(-17)
@end example

@noindent
@c will give @code{NaN} and a warning, but

따라서, 다음과 같이 명령문을 입력해야 복소수 연산이 올바르게 수행 됩니다. 

@example
sqrt(-17+0i)
@end example

@noindent
@c will do the computations as complex numbers.

@menu
* Generating regular sequences::
@end menu

@node Generating regular sequences, Logical vectors, Vector arithmetic, Simple manipulations numbers and vectors
@c @section Generating regular sequences
@section 일반적인 수열의 생성
@cindex Regular sequences

@c @R{} has a number of facilities for generating commonly used sequences
@c of numbers.  For example @code{1:30} is the vector @code{c(1, 2,
@c @dots{}, 29, 30)}.
@R{}은 수열 (sequence)을 생성하는 다양한 방법을 제공합니다.
예를 들면, @code{1:30}이라는 명령어는 @code{c(1, 2, @dots{}, 29, 30)}과 같은 벡터를 생성합니다. 
@c <NOTE>
@c Info cannot handle ':' as an index entry.
@ifnotinfo
@findex :
@end ifnotinfo
@c </NOTE>
@c The colon operator has high priority within an expression, so, for
@c example @code{2*1:15} is the vector @code{c(2, 4, @dots{}, 28, 30)}.
@c Put @code{n <- 10} and compare the sequences @code{1:n-1} and
@c @code{1:(n-1)}.
또 R의 표현식에서는 콜론(colon) 연산자가 다른 어떤 연산 보다 최우선으로 처리됩니다. 
예를 들면, @code{2*1:15}은 @code{c(2, 4, @dots{}, 28, 30)}과 같은 벡터를 생성합니다. 
좀 더 정확한 이해를 위해, @code{n <- 10}을 입력한 뒤, @code{1:n-1}과 @code{1:(n-1)}로부터 생성되는 두개의 벡터를 비교해보시길 바랍니다.

@c The construction @code{30:1} may be used to generate a sequence
@c backwards.

또 @code{30:1}이라는 명령문은 역순으로 (큰 수부터 작은 수로) 나열된 수열을 생성합니다.

@findex seq
@c The function @code{seq()} is a more general facility for generating
@c sequences.  It has five arguments, only some of which may be specified
@c in any one call.  The first two arguments, if given, specify the
@c beginning and end of the sequence, and if these are the only two
@c arguments given the result is the same as the colon operator.  That is
@c @code{seq(2,10)} is the same vector as @code{2:10}.

@code{seq()} 함수는 수열을 생성하는 좀 더 일반적인 방법 입니다. 
@code{seq()}는 5개의 파라미터를 가질 수 있는데, 이중의 일부만 사용해도 다양한 수열의 생성이 가능합니다.
먼저, 처음 두개의 파라미터는 수열의 처음과 마지막 값을 지정합니다.
이 두 개의 인자만 지정하면, 콜론 연산자를 사용한 것과 동일한 결과를 얻게 됩니다. 
즉, @code{seq(2,10)}에 의하여 생성된 수열은 @code{2:10}으로부터 생성된 수열과 동일합니다. 

@c Parameters to @code{seq()}, and to many other @R{} functions, can also
@c be given in named form, in which case the order in which they appear is
@c irrelevant.  The first two parameters may be named
@c @code{from=@var{value}} and @code{to=@var{value}}; thus
@c @code{seq(1,30)}, @code{seq(from=1, to=30)} and @code{seq(to=30,
@c from=1)} are all the same as @code{1:30}.  The next two parameters to
@c @code{seq()} may be named @code{by=@var{value}} and
@c @code{length=@var{value}}, which specify a step size and a length for
@c the sequence respectively.  If neither of these is given, the default
@c @code{by=1} is assumed.

@R{}의 다른 많은 함수들처럼 함수 @code{seq()}가 사용하는 파라미터들은 반드시 함수에 지정된 순서로 입력되야 하며, 이 지정된 순서를 따를 경우 파라미터의 입력이 언뜻 이상하게 보일 수도 있습니다. 
위에서 사용한 예제 @code{seq(1,30)}를 통해 설명하면, @code{seq()}의 처음 두 파라미터들은 처음 시작값 @code{from=@var{value}}과 마지막 값 @code{to=@var{value}}을 각각 의미하기 때문에, @code{seq(1,30)}, @code{seq(from=1, to=30)}, @code{seq(to=30, from=1)} 모두 @code{1:30}으로부터 생성된 수열과 동일한 수열을 생성합니다.  
@code{seq()}의 다음 두개(세번째와 네번째)의 파라미터들은 @code{by=@var{value}}와 @code{length=@var{value}} 입니다. 
@code{by=@var{value}}는 나열하게 될 숫자들 간의 차이 (step size)를 지정하며, @code{length=@var{value}}는 나열하게 될 숫자의 길이(length)를 지정합니다. 
만약, 이 두가지 모두 지정되지 않는다면, 기본적으로  @code{by=1}를 가정한 상태에서 수열을 생성하게 됩니다. 

@c For example

다음의 예시를 살펴봅니다.

@example
> seq(-5, 5, by=.2) -> s3
@end example

@noindent
@c generates in @code{s3} the vector @code{c(-5.0, -4.8, -4.6, @dots{},
@c 4.6, 4.8, 5.0)}.  Similarly

위 명령어를 실행하면 @code{c(-5.0, -4.8, -4.6, @dots{}, 4.6, 4.8, 5.0)}라는 수열을 생성하여, 이를 @code{s3}라는 이름의 벡터형 객체로 저장하게 됩니다.
아래와 같은 방법으로도 @code{s3}와 같은 벡터 @code{s4}를 생성할 수 있습니다. 

@example
> s4 <- seq(length=51, from=-5, by=.2)
@end example

@noindent
@c generates the same vector in @code{s4}.

@c The fifth parameter may be named @code{along=@var{vector}}, which if
@c used must be the only parameter, and creates a sequence @code{1, 2,
@c @dots{}, length(@var{vector})}, or the empty sequence if the vector is
@c empty (as it can be)


마지막으로 @code{seq()} 함수의 다섯번 째 파라미터는 @code{along=@var{vector}}이며, 다른 파라이터의 입력 없이 이 파라미터만 사용할 경우, @code{1, 2, @dots{}, length(@var{vector})}인 수열을 생성 합니다. 

@c A related function is @code{rep()}
@findex rep
@c which can be used for replicating an object in various complicated ways.
@c The simplest form is

@code{seq()}와 비슷한 수열 생성 함수 중, 객체를 반복하는데 사용할 수 있는 @code{rep()}라는 함수가 있습니다. 
이 함수의 사용법은 아래와 같습니다.

@example
> s5 <- rep(x, times=5)
@end example

@noindent
@c which will put five copies of @code{x} end-to-end in @code{s5}.  Another
@c useful version is

위 명령어는 @code{x}라는 벡터를 처음부터 끝까지 5번 반복해서 나열한 객체를 @code{s5}로 지정 합니다.
위 함수와 같은 결과를 얻기 위해 아래와 같은 명령문을 사용할 수도 있습니다. 

@example
> s6 <- rep(x, each=5)
@end example

@noindent
@c which repeats each element of @code{x} five times before moving on to
@c the next.

둘 다 @code{x}란 벡터가 가지고 있는 각각의 요소들을 5번씩 반복 나열하여 수열을 생성 합니다. 

@node Logical vectors, Missing values, Generating regular sequences, Simple manipulations numbers and vectors
@c @section Logical vectors
@section 논리형 벡터

@c As well as numerical vectors, @R{} allows manipulation of logical
@c quantities.  The elements of a logical vector can have the values
@c @code{TRUE}, @code{FALSE}, and @code{NA} (for ``not available'', see
@c below).  The first two are often abbreviated as @code{T} and @code{F},
@c respectively.  Note however that @code{T} and @code{F} are just
@c variables which are set to @code{TRUE} and @code{FALSE} by default, but
@c are not reserved words and hence can be overwritten by the user.  Hence,
@c you should always use @code{TRUE} and @code{FALSE}.
@R{}은 수치형 벡터 뿐만 아니라 논리값에 대한 연산도 가능합니다.
논리형 벡터는 @code{TRUE}, @code{FALSE}, 그리고 @code{NA} (즉 ``not available'' - 해당 값이 이용가능하지 않아 사용에는 많은 제약이 따름)와 같은 요소로 구성 됩니다.
처음 두 개의 요소인 @code{TRUE}와 @code{FALSE}가 각각 @code{T}와 @code{F}라는 약어로 표기하기도 하며, 이러한 약어 사용은 R에서 초기값으로 지정된 것입니다. 하지만, 사용자가 이 두 문자를 다른 변수나 함수 이름으로 사용할 경우, 더 이상 이러한 초기 약어 지정은 성립하지 않습니다. 
따라서, 논리값을 표현할 때에는 @code{TRUE}와 @code{FALSE}와 같이 정확하게 표기할 것을 권장 합니다. 
@findex FALSE
@findex TRUE
@findex F
@findex T

Logical vectors are generated by @emph{conditions}.  For example
논리형 벡터는 조건문 (@emph{conditions})에 의해서 생성됩니다.
예를 들어 아래의 명령문을 입력하면, @code{x} 벡터의 각 구성요소에 대해 13 보다 크다는 조건문이 참인지 거짓인지를 판단하여, 해당 구성 요소가 13 보다 큰 위치에는 @code{TRUE}, 그렇지 않은 경우에는 @code{FALSE}를 출력하여 원래의 @code{x}와 같은 길이를 갖는 새 벡터@code{temp}를 생성 합니다. 

@example
> temp <- x > 13
@end example

@noindent
@c sets @code{temp} as a vector of the same length as @code{x} with values
@c @code{FALSE} corresponding to elements of @code{x} where the condition
@c is @emph{not} met and @code{TRUE} where it is.

@c The logical operators are @code{<}, @code{<=}, @code{>}, @code{>=},
@c @code{==} for exact equality and @code{!=} for inequality.
논리 연산자에는 @code{<} (작음), @code{<=} (작거나 같음), @code{>} (큼), @code{>=} (크거나 같음), @code{==} (같음), 그리고 @code{!=} (다름) 등이 있습니다. 
@findex <
@findex <=
@findex >
@findex >=
@findex ==
@findex !=

@c In addition if @code{c1} and @code{c2} are logical expressions, then
@c @w{@code{c1 & c2}} is their intersection (@emph{``and''}), @w{@code{c1 | c2}}
@c is their union (@emph{``or''}), and @code{!c1} is the negation of
@c @code{c1}.
또한, @code{c1}과 @code{c2}와 같이 두 개의 논리 표현식이 있는 경우, @w{@code{c1 & c2}}는 (@emph{``and''})를 나타내는 교집합을 @w{@code{c1 | c2}}는 (@emph{``or''})를 나타내는 합집합을 의미하며, @code{!c1}는 @code{c1}를 만족하지 않는 차집합을 의미 합니다.
  
@findex !
@findex |
@findex &

@c Logical vectors may be used in ordinary arithmetic, in which case they
@c are @emph{coerced} into numeric vectors, @code{FALSE} becoming @code{0}
@c and @code{TRUE} becoming @code{1}.  However there are situations where
@c logical vectors and their coerced numeric counterparts are not
@c equivalent, for example see the next subsection.

논리형 벡터들은 일반적인 산술연산에 사용할 수도 있으며, 이 경우 논리값인 @code{FALSE}는 숫자 @code{0}으로 @code{TRUE}는 숫자 @code{1}로 변환 되어야 합니다. 
이러한 변환을 @emph{coerced}(강제형변환)이라고 합니다. 
그러나 논리형 벡터들이 수치형 벡터로의 강제형변환이 항상 위와 같은 방식으로만 이루어지는 것은 아니며, 여기에 대해서는 다음 섹션에서 살펴보도록 하겠습니다. 

@node Missing values, Character vectors, Logical vectors, Simple manipulations numbers and vectors
@c @section Missing values
@section 결측값
@cindex Missing values

@c In some cases the components of a vector may not be completely
@c known.  When an element or value is ``not available'' or a ``missing
@c value'' in the statistical sense, a place within a vector may be
@c reserved for it by assigning it the special value @code{NA}.
가끔 벡터의 구성요소들 중 일부가 완전하지 않은 경우가 있습니다.
통계적 의미에서 이러한 구성요소 또는 값들은 ``not available'' (사용이 가능하지 않음) 또는 ``missing value''(결측치 혹은 누락된 값)을 의미하며, 이러한 값들은 벡터 내에서 @code{NA}라는 특수 문자로 표기 됩니다. 
@findex NA
@c In general any operation on an @code{NA} becomes an @code{NA}.  The
@c motivation for this rule is simply that if the specification of an
@c operation is incomplete, the result cannot be known and hence is not
@c available.

일반적으로 어떤 연산이든 @code{NA}에 대한 연산의 결과는 @code{NA}가 됩니다.
이러한 규칙을 만들게 된 동기는 단순합니다. 이러한 결측치의 연산법을 따로 지정하지 않으면, 결측치의 포함으로 인해 해당 연산이 정의되지 않거나 결과가 출력되지 않기 때문입니다. 
@findex is.na
@c The function @code{is.na(x)} gives a logical vector of the same size as
@c @code{x} with value @code{TRUE} if and only if the corresponding element
@c in @code{x} is @code{NA}.

함수 @code{is.na(x)}는 @code{x}의 각 구성요소 중 @code{NA}가 포함되었는지를 확인하여, 논리값인 @code{TRUE}또는 @code{FALSE}를 갖는 새로운 벡터를 생성 합니다. 
따라서, 생성된 벡터의 길이는 원래 벡터인 @code{x}와 같아야 하며, 이는 아래의 명령문을 통해 확인해 볼 수 있습니다. 

@example
> z <- c(1:3,NA);  ind <- is.na(z)
@end example

@c Notice that the logical expression @code{x == NA} is quite different
@c from @code{is.na(x)} since @code{NA} is not really a value but a marker
@c for a quantity that is not available.  Thus @code{x == NA} is a vector
@c of the same length as @code{x} @emph{all} of whose values are @code{NA}
@c as the logical expression itself is incomplete and hence undecidable.

그러나, @code{NA}라는 것은 실제로 단순히 벡터를 구성하는 요소의 값이 사용가능한지에 대한 마커일 뿐 해당 요소에 대한 값이 아니기 때문에 @code{x == NA}이라는 논리적 표현식과 @code{is.na(x)}는 서로 다른 것을 의미한다는 점을 이해하셔야 합니다. 
즉 @code{x == NA}는 벡터 @code{x}와 길이는 같지만 그 구성요소 @emph{모두}가 @code{NA}값을 가지므로, 이 식 자체가 논리형 표현식이라 어떤 연산을 수행하기에는 불완전하고 불충분하기 때문입니다. 

@c Note that there is a second kind of ``missing'' values which are
@c produced by numerical computation, the so-called @emph{Not a Number},
@c @code{NaN},
@findex NaN
@c values.  Examples are
또한 수치연산의 결과로서 발생하는 또 다른 종류의 결측치(``missing'')인 @code{NaN}은 @emph{Not a Number}(숫자가 아님)을 의미 합니다. 다음의 두 예제를 통해서 좀 더 자세히 알아 봅시다. 

@example
> 0/0
@end example

@noindent
또는 

@example
> Inf - Inf
@end example

@noindent
@c which both give @code{NaN} since the result cannot be defined sensibly.
위의 두가지 경우 모두 수학적 정의에 따른 계산을 수행할 수 없기 때문에 @code{NaN}이라는 결과를 출력하게 됩니다. 

@c In summary, @code{is.na(xx)} is @code{TRUE} @emph{both} for @code{NA}
@c and @code{NaN} values.  To differentiate these, @code{is.nan(xx)} is only
@c @code{TRUE} for @code{NaN}s.
@findex is.nan
요약해보면, @code{is.na(xx)}는 구성요소 중 하나 이상이 @code{NA}이거나 @code{NaN}인 두가지 경우 모두 @code{TRUE} 값을 돌려줍니다.
그러나, @code{is.nan(xx)}은 오직 구성 요소에 @code{NaN}이 포함될 때만 @code{TRUE}가 됩니다. 

@c Missing values are sometimes printed as @code{<NA>} when character
@c vectors are printed without quotes.
때때로 이렇게 @code{<NA>}로 표시된 값들 중, 실제 결측치가 아니라 단지 문자형 벡터가 인용 부호 ("quotes") 없이 사용되었기 때문인 경우도 있으므로 주의하시기 바랍니다. 

@node Character vectors, Index vectors, Missing values, Simple manipulations numbers and vectors
@c @section Character vectors
@section 문자형 벡터
@cindex Character vectors

@c Character quantities and character vectors are used frequently in @R{},
@c for example as plot labels.  Where needed they are denoted by a sequence
@c of characters delimited by the double quote character, e.g.,
@c @code{"x-values"}, @code{"New iteration results"}.
문자값 또는 문자형 벡터는 종종 @R{}에서 플롯의 라벨 등으로 사용 됩니다. 이러한 문자열은 @code{"x-values"} 또는 @code{"New iteration results"}과 같이 @code{""} (큰 따옴표)에 의해 구분 됩니다.

@c Character strings are entered using either matching double (@code{"}) or
@c single (@code{'}) quotes, but are printed using double quotes (or
@c sometimes without quotes).  They use C-style escape sequences, using
@c @code{\} as the escape character, so @code{\\} is entered and printed as
@c @code{\\}, and inside double quotes @code{"} is entered as @code{\"}.
@c Other useful escape sequences are @code{\n}, newline, @code{\t}, tab and
@c @code{\b}, backspace---see @command{?Quotes} for a full list.

문자열의 입력은 큰 따옴표 (@code{"})와 작은 따옴표 (@code{'})를 모두 사용할 수 있지만, 입력된 문자열을 출력할 때는 큰 따옴표에 의해 각 구성요소가 구분 됩니다. (경우에 따라 큰 따옴표 없이 출력되는 것도 가능 합니다).
R에서는 C 언어처럼 @code{\}를 확장 문자(escape sequence)로 사용하여 문자열을 처리하는 것이 가능합니다. 
따라서, @code{\\}를 출력하기 위해서는 (@code{"}로 구분된) 문자열 내에 @code{\\}을 사용하고, 큰 따옴표 @code{"}를 출력하기 위해서는 @code{\"}를 사용하도록 합니다. 
그 밖의 유용한 이스케이프 시퀀스들로는 @code{\n}이 있는데 이는 새로운 행(즉, 개행)을, @code{\t}는 탭(tab)을, @code{\b}는 백스페이스를 나타냅니다. 
사용 가능한 확장 문자 대한 전체 목록을 확인하고 싶으시면 @command{?Quotes}을 입력하시길 바랍니다. 

@c Character vectors may be concatenated into a vector by the @code{c()}
@c function; examples of their use will emerge frequently.
@code{c()}라는 함수를 이용하면 문자열을 연결하여 새로운 문자열 벡터를 생성할 수 있습니다. 이러한 문자 벡터의 생성은 앞으로 자주 등장하게 될 것입니다. 
@findex c

@findex paste
@c The @code{paste()} function takes an arbitrary number of arguments and
@c concatenates them one by one into character strings.  Any numbers given
@c among the arguments are coerced into character strings in the evident
@c way, that is, in the same way they would be if they were printed.  The
@c arguments are by default separated in the result by a single blank
@c character, but this can be changed by the named parameter,
@c @code{sep=@var{string}}, which changes it to @code{@var{string}},
@c possibly empty.

@code{paste()} 함수는 임의의 개수의 인자들을 입력받아, 이들을 한데 묶어 하나의 문자열로 생성 합니다.
이 때, 주어진 인자들 중 일부가 숫자라도, 이들 역시 문자형으로 강제형변환이 이루어짐을 아셔야 합니다. 이러한 형변환 결과는 출력을 통해 확일할 수 있는데, 합쳐진 각각의 문자형 인자들 사이는 하나에는 공백문자(white space 또는 blank character)가 포함되어 두 요소가 합쳐졌다는 것을 알 수 있습니다. 
이러한 공백문자를 포함한 새로운 문자형 인자의 생성은 @code{sep=@var{string}} 옵션을 사용하여 다른 문자에 의해 구분되도록 지정하는 것이 가능하며, 아래의 예제처럼 입력시 @code{@var{string}}은 공백 없이 두 요소를 하나로 합치는 것도 가능합니다.  
@c For example
@example
> labs <- paste(c("X","Y"), 1:10, sep="")
@end example

@noindent
@c makes @code{labs} into the character vector

위 명령문에서 @code{paste()}라는 함수는 @code{c("X", "Y")}라는 문자형 벡터와 @code{1:10}이라는 숫자형 벡터를 하나로 묶어 문자형 벡터를 생성하는데, 두 벡터의 길이가 다르므로 @code{c("X", "Y")}가 5번 반복되게 될 것입니다. 
또, 구분자가 @code{sep=""}로 지정 되었으므로 두 문자 사이에는 아무런 공백이 없을 것입니다. 
따라서, 위 명령문의 수행 결과는 아래와 같습니다.  

@example
c("X1", "Y2", "X3", "Y4", "X5", "Y6", "X7", "Y8", "X9", "Y10")
@end example

@c Note particularly that recycling of short lists takes place here too;
@c thus @code{c("X", "Y")} is repeated 5 times to match the sequence
@c @code{1:10}.

@footnote{@code{paste(..., collapse=@var{ss})} joins the
arguments into a single character string putting @var{ss} in between.
There are more tools for character manipulation, see the help
for @code{sub} and @code{substring}.}

@footnote{@code{paste(..., collapse=@var{ss})}라고 하게되면 인자들 사이에 @var{ss}를 넣어 하나의 문자열을 만듭니다. 문자열을 다루는 방법에 대해 더 많이 알고 싶으시다면 @code{sub}와 @code{substring}를 살펴보시길 바랍니다.}

@node Index vectors, Other types of objects, Character vectors, Simple manipulations numbers and vectors
@c @section Index vectors; selecting and modifying subsets of a data set
@section 인덱스 벡터를 사용한 데이터셋의 선택과 수정
@cindex Indexing vectors

@c Subsets of the elements of a vector may be selected by appending to the
@c name of the vector an @emph{index vector} in square brackets.  More
@c generally any expression that evaluates to a vector may have subsets of
@c its elements similarly selected by appending an index vector in square
@c brackets immediately after the expression.

벡터의 이름 바로 뒤에 대괄호(@code{[]})와 함께 사용된 @emph{index vector}(인덱스 벡터)를 통해 벡터의 일부 구성 요소만 선택하는 것이 가능합니다. 여기서 인덱스 벡터란 대괄호 내부에 쓰인 벡터를 의미 합니다.
좀 더 일반적으로 말하면, 연산의 결과로 벡터를 생성하게 되는 어떠한 표현식이라도 표현식 바로 다음에 대괄호와 함께 인덱스 벡터를 사용해서 벡터 구성요소 중 일부만 선택하는 것이 가능합니다. 

@c FIXME: Add a forward reference to  subset()  here
@c FIXME  and  add a paragraph about subset() {which needs to come after
@c FIXME  data frames ...

@c Such index vectors can be any of four distinct types.
이러한 인덱스 벡터에는 다음과 같은 네가지 유형이 있습니다. 

@enumerate

@item
@c @strong{A logical vector}.  In this case the index vector must be of the
@c same length as the vector from which elements are to be selected.
@c Values corresponding to @code{TRUE} in the index vector are selected and
@c those corresponding to @code{FALSE} are omitted.  For example

@strong{논리형 인덱스 벡터}:  이 경우는 인덱스 벡터는 반드시 선택할 구성요소를 포함한 벡터와 길이가 같아야 합니다. 
인덱스 벡터에서 @code{TRUE}에 대응하는 요소들만 선택되고, @code{FALSE}에 대응하는 요소들은 제거될 것입니다. 
예를 들면, 아래의 명령문은 @code{x} 벡터 중 결측치가 아닌 요소들만을 원래의 순서대로 포함하는 객체 @code{y}를 생성합니다. 
만약 @code{x}에 결측치가 포함되어 있다면 새로 생성된 @code{y}의 길이는 @code{x} 보다 짧을 것입니다. 
@example
> y <- x[!is.na(x)]
@end example

@noindent
@c creates (or re-creates) an object @code{y} which will contain the
@c non-missing values of @code{x}, in the same order.  Note that if
@c @code{x} has missing values, @code{y} will be shorter than @code{x}.
@c Also

다음은 또 다른 예제입니다. 
아래의 명령어는 @code{x}의 구성요소들 중 결측치가 아니면서 양수인 요소들만을 모으로 이들에 각각 1을 더하여 객체 @code{z}를 생성합니다.

@example
> (x+1)[(!is.na(x)) & x>0] -> z
@end example

@noindent
@c creates an object @code{z} and places in it the values of the vector
@c @code{x+1} for which the corresponding value in @code{x} was both
@c non-missing and positive.

@item
@c @strong{A vector of positive integral quantities}.  In this case the
@c values in the index vector must lie in the set @{1, 2, @dots{},
@c @code{length(x)}@}.  The corresponding elements of the vector are
@c selected and concatenated, @emph{in that order}, in the result.  The
@c index vector can be of any length and the result is of the same length
@c as the index vector.  For example @code{x[6]} is the sixth component of
@c @code{x} and

@strong{양의 정수 인덱스 벡터}: 이 경우의 인덱스 벡터는 반드시 @{1, 2, @dots{}, @code{length(x)}@} 범위 내에 있어야 합니다. 선택된 구성요소들은 인덱스 벡터에서 @emph{지정한 순서} 대로 선택되어 하나로 묶여지게 됩니다. 선택된 결과는 사용된 인덱스 벡터의 길이와 같으며, 인덱스 벡터의 길이는 임의로 선택 가능합니다. 
예를 들어, @code{x[6]}는 @code{x}의 여섯번째 구성요소를 선택하며, 아래 명령문은 (@code{x}의 길이가 10보다 작지만 않다면,) @code{x}가 가진 구성요소 중 처음 10개의 요소들을 선택 합니다. 

@example
> x[1:10]
@end example

@noindent
@c selects the first 10 elements of @code{x} (assuming @code{length(x)} is
@c not less than 10).  Also

또, 아래의 명령문은 (물론 이렇게 어렵게 사용하는 경우는 거의 없지만) @code{"x", "y", "y", "x"}가 4번씩 반복되어 구성된 전체 길이 16인 문자형 벡터를 생성 합니다. 

@example
> c("x","y")[rep(c(1,2,2,1), times=4)]
@end example

@noindent
@c (an admittedly unlikely thing to do) produces a character vector of
@c length 16 consisting of @code{"x", "y", "y", "x"} repeated four times.

@item
@c @strong{A vector of negative integral quantities}.  Such an index vector
@c specifies the values to be @emph{excluded} rather than included.  Thus
@strong{음의 정수 인덱스 벡터}:  이 경우, 인덱스 벡터는 선택된 요소들을 포함하는 것이 아니라 @emph{제외}할 목적으로 사용됩니다. 
따라서, 아래 명령문은 @code{x}의 처음 5개의 구성요소들만 제외시켜 @code{y}를 생성 합니다. 

@example
> y <- x[-(1:5)]
@end example

@noindent
@c gives @code{y} all but the first five elements of @code{x}.

@item
@c @strong{A vector of character strings}.  This possibility only applies
@c where an object has a @code{names} attribute to identify its components.
@c In this case a sub-vector of the names vector may be used in the same way
@c as the positive integral labels in item 2 further above.

@strong{문자형 인덱스 벡터}: 이 경우는 객체의 각 구성요소들이 @code{names}라는 속성(i.e.객체 안의 각 구성요소(변수)의 이름)을 가지고 있을 때에만 인덱스 벡터의 이용이 가능합니다. 이때, @code{names}를 한 데 묶어 나열한 벡터를 네임벡터 (names vector)라고하며, 위에서 설명한 양의 정수 인덱스 벡터와 동일한 방식으로 사용하면 됩니다.
다음의 예제를 보면,  우선 @code{fruit}이라는 수치형 벡터에 @code{names()} 라는 함수를 이용하여 각각의 구성요소에 @code{"orange", "banana", "apple", "peach"}라는 @code{names} 속성을 부여합니다.
이제, 만약 @code{fruit} 벡터의 세번째와 첫번째 요소를 선택하고 싶다면, @code{[c("apple","orange")]}를 사용하면 됩니다.
  
@example
> fruit <- c(5, 10, 1, 20)
> names(fruit) <- c("orange", "banana", "apple", "peach")
> lunch <- fruit[c("apple","orange")]
@end example

@c The advantage is that alphanumeric @emph{names} are often easier to
@c remember than @emph{numeric indices}.  This option is particularly
@c useful in connection with data frames, as we shall see later.

이렇게 영문과 숫자의 조합(alphanumeric)인 @emph{names}를 이용할 경우 @emph{수치형 인덱스}를 이용하여 구성요소를 선택할 때 보다 기억하기에 편리하다는 장점이 있습니다. 이 옵션은 특히 나중에 설명하게 될 데이터 프레임과 연관이 있습니다.
 
@end enumerate

@c An indexed expression can also appear on the receiving end of an
@c assignment, in which case the assignment operation is performed
@c @emph{only on those elements of the vector}.  The expression must be of
@c the form @code{vector[@var{index_vector}]} as having an arbitrary
@c expression in place of the vector name does not make much sense here.

인덱스를 사용한 표현식은 벡터의 일부 구성요소에 새로운 값을  할당하기 위한 목적으로도 사용 되는데,
이 경우 주로 인덱스 벡터를 적용한 벡터 그 자신이 할당의 대상이 됩니다. 여기서 표현식은 반드시@code{vector[@var{index_vector}]}의 형태로 사용되야 하며, 네임벡터의 위치에 어떠한 표현식이든 자유롭게 사용될 수 있는 것은 아닙니다. 

예제를 통해 살펴보면, 다음과 같은 명령문을 사용하면 @code{x}에서 결측값이 있는 위치를 확인하여 이 위치의 결측값에 0을 할당 하는 것이 가능합니다.
 
@c For example

@example
> x[is.na(x)] <- 0
@end example

@noindent
@c replaces any missing values in @code{x} by zeros and

또 다음의 예제에서는 @code{y}의 값들 중 0 보다 작은 값들을 찾고 이들의 부호를 바꿔줍니다.
@example
> y[y < 0] <- -y[y < 0]
@end example

@noindent
@c has the same effect as
결과적으로 위의 예제는 아래의 명령문을 수행한 것과 같은 결과를 얻습니다. 

@example
> y <- abs(y)
@end example

@node Other types of objects,  , Index vectors, Simple manipulations numbers and vectors
@c @section Other types of objects
@section 객체의 다른 유형들

@c Vectors are the most important type of object in @R{}, but there are
@c several others which we will meet more formally in later sections.

벡터는 @R{}에서 가장 중요한 객체입니다. 하지만 이번 섹션에서는 다른 유형의 객체들에 대해 간단히 소개하도록 하겠습니다. 

@itemize @bullet
@item
@c @emph{matrices} or more generally @emph{arrays} are multi-dimensional
@c generalizations of vectors.  In fact, they @emph{are} vectors that can
@c be indexed by two or more indices and will be printed in special ways.
@c @xref{Arrays and matrices}.

@emph{matrices}(행렬) 또는 좀 더 일반적으로 @emph{arrays}(배열)이라는 것은 1차원인 벡터를 다차원으로 일반화시킨 것 입니다. 실제로, 행렬과 배열은 두개 또는 그 이상의 인덱스를 사용하여 표현되는 @emph{벡터}로 볼 수 있으며, 정해진 형태로 출력될 것입니다.

@xref{Arrays and matrices}.

@item
@c @emph{factors} provide compact ways to handle categorical data.
@c @xref{Factors}.

@emph{factors}(요인)을 이용하면 범주형 자료(categorical data)를 간단하게 다룰 수 있습니다. 
@xref{Factors}. 

@item
@c @emph{lists} are a general form of vector in which the various elements
@c need not be of the same type, and are often themselves vectors or lists.
@c Lists provide a convenient way to return the results of a statistical
@c computation.  @xref{Lists}.

@emph{lists}는 가장 일반적인 형태의 벡터로 각 구성요소들이 같은 데이터 형태로 되어야한다는 제약이 없으며, 종종 벡터나 리스트를 그 자체로 포함하기도 합니다. 
또한 리스트는 통계연산의 결과를 편리하게 출력하기 위해 사용될 수도 있습니다.
@xref{Lists}.

@item
@c @emph{data frames} are matrix-like structures, in which the columns can
@c be of different types.  Think of data frames as `data matrices' with one
@c row per observational unit but with (possibly) both numerical and
@c categorical variables.  Many experiments are best described by data
@c frames: the treatments are categorical but the response is numeric.
@c @xref{Data frames}.

@emph{data frames}은 행렬과 비슷한 구조를 가지고 있지만, 각각의 열이 다른 데이터 형태일 수 있습니다. 데이터 프레임은, 각 행이 하나의 관측 단위이고 각 열은 이 관측단위에서 얻어진 연속형 또는 이산형 변수인 `데이터 행렬'이라고 생각해도 무방할 것 입니다. 예를들어, 실험의 처리 수준을 범주화(categorical)해서 나타내고, 각 처리에서 얻어진 결과물(반응 변수)은 연속형일 경우, 데이터 프레임을 사용하는 것이 이 실험을 가장 잘 기록할 수 있는 방법일 것입니다. 
@xref{Data frames}.

@item
@c @emph{functions} are themselves objects in @R{} which can be stored in
@c the project's workspace.  This provides a simple and convenient way to
@c extend @R{}.  @xref{Writing your own functions}.

@R{}에서 @emph{functions}(함수)는 그 자체로 프로젝트의 작업공간 내에 저장 될 수 있는 객체이기도 합니다. 함수의 사용은 @R{}의 기능을 좀 더 간편하게 확장할 수 있게 합니다 . 
@xref{Writing your own functions}.
@end itemize


@node Objects, Factors, Simple manipulations numbers and vectors, Top
@c @chapter Objects, their modes and attributes
@chapter 객체의 속성과 모드
@cindex Objects
@cindex Attributes

@c <FIXME>
@c This needs to be re-written for R.  We really have data types (as
@c returned by typeof()) and that functions mode() and storage.mode()
@c are for S compatibility mostly.  Hence in particular, there is no
@c intrinsic attribute `mode'.

@menu
* The intrinsic attributes mode and length::  
* Changing the length of an object::  
* Getting and setting attributes::  
* The class of an object::      
@end menu

@node The intrinsic attributes mode and length, Changing the length of an object, Objects, Objects
@c @section Intrinsic attributes: mode and length
@section 기본적으로 내재된 속성들: 모드와 길이

@c The entities @R{} operates on are technically known as @emph{objects}.
@c Examples are vectors of numeric (real) or complex values, vectors of
@c logical values and vectors of character strings.  These are known as
@c ``atomic'' structures since their components are all of the same type,
@c or @emph{mode}, namely @emph{numeric}@footnote{@emph{numeric} mode is
@c actually an amalgam of two distinct modes, namely @emph{integer} and
@c @emph{double} precision, as explained in the manual.}, @emph{complex},
@c @emph{logical}, @emph{character} and @emph{raw}.

전문적으로 말해보자면 @R{}에서 정보처리 (연산 및 수행)의 기본단위는 @emph{objects}(객체)라고 알려진 것입니다.
이러한 객체들에 가장 간단한 예는 (실수) 수치형 및 복소수형 벡터, 논리형 또는 문자열 벡터등과 같은 벡터입니다.
이들은 ``atomic'' 구조로서 알려져 있습니다. 
왜냐하면 이들 벡터들에 대한 구성요소는 반드시 같은 타입 또는 @emph{numeric} 
@footnote{@emph{numeric}(수치형) 모드라는 것은 실제로는 @emph{integer}(정수형)과 @emph{double} precision (배정밀도)라는 두가지의 다른 모드가 합쳐진 것입니다}, @emph{complex}, @emph{logical}, @emph{character}, 그리고 @emph{raw}와 같은 @emph{mode}(모드)를 가지고 있기 때문입니다. 

@c Vectors must have their values @emph{all of the same mode}.  Thus any
@c given vector must be unambiguously either @emph{logical},
@c @emph{numeric}, @emph{complex}, @emph{character} or @emph{raw}.  (The
@c only apparent exception to this rule is the special ``value'' listed as
@c @code{NA} for quantities not available, but in fact there are several
@c types of @code{NA}).  Note that a vector can be empty and still have a
@c mode.  For example the empty character string vector is listed as
@c @code{character(0)} and the empty numeric vector as @code{numeric(0)}.

벡터는 반드시 @emph{각 구성요소가 가질 수 있는 값에 대한 모드가 모든 구성요소에 있어서 같아야 합니다}.
그러므로 어떠한 벡터라도 반드시 @emph{logical}(논리형), @emph{numeric}(수치형), @emph{complex}(복소수형), @emph{character}(문자형) or @emph{raw} 모드 중 하나입니다.
(이 규칙에 대한 예외가 있다면 그것은 @code{NA}로 표기되는 값입니다. 
그러나, 사실은 여러가지 종류의 @code{NA}가 있습니다).
벡터는 empty(아무런 구성요소가 없이 비어있는 상태)일 수 있음에도 불구하고 모드를 가질 수 있습니다. 
예를들어, 비어있는 문자열은 @code{character(0)}이며, 비어있는 수치형 벡터는 @code{numeric(0)}입니다. 

@c @R{} also operates on objects called @emph{lists}, which are of mode
@c @emph{list}.  These are ordered sequences of objects which individually
@c can be of any mode.  @emph{lists} are known as ``recursive'' rather than
@c atomic structures since their components can themselves be lists in
@c their own right.

@R{}은 또한 @emph{list}(리스트)라는 모드를 가지고 있는 @emph{lists}(리스트)라고 불리는 객체를 특정한 방식으로 조작하고 있습니다. 
이것은 모든 구성요소가 동일한 모드를 가지지 않는 일련의 순서에 의해서 정리된 시퀀스입니다.
@emph{lists}(리스트)는 또한 atomic structure (가장 근본적인 기본구조)이기 보다는 ``recursive''(재귀적) 구조를 가집니다.
그 이유는 이 객체의 구성요소 자체가 리스트가 될 수 있기 때문입니다. 

@c The other recursive structures are those of mode @emph{function} and
@c @emph{expression}.  Functions are the objects that form part of the @R{}
@c system along with similar user written functions, which we discuss in
@c some detail later.  Expressions as objects form an
@c advanced part of @R{} which will not be discussed in this guide, except
@c indirectly when we discuss @emph{formulae} used with modeling in @R{}.

또 다른 재귀적 구조는 모드가 @emph{function}(함수) 또는 @emph{expression}(표현식)으로부터 찾을 수 있습니다.
함수의 경우는 나중에 설명하게 될 사용자 정의 함수와 함께 @R{}시스템의 부분을 구성하는 객체이기 때문이며,
표현식의 경우는 @R{}에서 모델링을 할때 사용하는 @emph{formulae}(모델식)을 언급하면서 간접적으로 얘기할 때를 제외하고는 이 문서에서는 설명하지 않지만 이 또한 @R{}시스템의 고급적 부분을 형성하는 객체이기 때문입니다.

@c By the @emph{mode} of an object we mean the basic type of its
@c fundamental constituents.  This is a special case of a ``property''
@c of an object.  Another property of every object is its @emph{length}.  The
@c functions @code{mode(@var{object})} and @code{length(@var{object})} can be
@c used to find out the mode and length of any defined structure
@c @footnote{Note however that @code{length(@var{object})} does not always
@c contain intrinsic useful information, e.g., when @code{@var{object}} is a
@c function.}.
객체의 @emph{mode}(모드)는 우리가 다루는 객체를 구성하는 요소들에 대한 기본형(basic type)을 알 수 있습니다.
모든 객체에 있는 또 다른 속성은 @emph{length}(길이)입니다. 
@code{mode(@var{object})}와 @code{mode(@var{object})}라는 명령어를 통하여 객체에 정의된 구조의 모드와 길이를 알 수 있습니다. 
@footnote{그러나, @code{length(@var{object})}가 항상 본질적인 정보를 포함하는 것은 아닙니다.  @code{@var{object}}의 경우가 이에 해당합니다.}.


@c Further properties of an object are usually provided by
@c @code{attributes(@var{object})}, see @ref{Getting and setting attributes}.
@c Because of this, @emph{mode} and @emph{length} are also called ``intrinsic
@c attributes'' of an object.
객체에 대한 더 많은 속성들은 @code{attributes(@var{object})}를 통해서 알 있으며, @ref{Getting and setting attributes}를 참고하시길 바랍니다.
이러한 이유로 @emph{mode}(모드)와 @emph{length}(길이)는 객체의 ``intrinsic attributes''(본질적 속성들)이라고도 합니다.
@findex mode
@findex length

@c For example, if @code{z} is a complex vector of length 100, then in an
@c expression @code{mode(z)} is the character string @code{"complex"} and
@c @code{length(z)} is @code{100}.

예를들어, 만약 @code{z}가 길이가 100인 복소수형 벡터라고 한다면, @code{mode(z)}는 문자열 @code{"complex"}(복소수)이고 @code{length(z)}은 @code{100}입니다.
@c @R{} caters for changes of mode almost anywhere it could be considered
@c sensible to do so, (and a few where it might not be).  For example with
@R{}은 어디에서든지 모드를 변경할 수 있도록 해줍니다. 
아래의 예제를 보도록 합니다.

@example
> z <- 0:9
@end example

@noindent
@c we could put
위에서 생성한 0 부터 9까지의 숫자로 된 수열 @code{z}는 아래와 같이 @code{c("0", "1", "2", @dots{}, "9")}와 문자로 된 벡터로 변환할 수 있습니다.
 
@example
> digits <- as.character(z)
@end example

@noindent
@c after which @code{digits} is the character vector @code{c("0", "1", "2",
@c @dots{}, "9")}.  A further @emph{coercion}, or change of mode,
@c reconstructs the numerical vector again:
수치형 벡터로의 @emph{coercion}(강제형변환) 또는 모드의 변환은 아래에서 보이는 것과 같이 다시 한 번 이루어질 수 있습니다. 

@example
> d <- as.integer(digits)
@end example

@noindent
@c Now @code{d} and @code{z} are the same.@footnote{In general, coercion
@c from numeric to character and back again will not be exactly reversible,
@c because of roundoff errors in the character representation.}  There is a
@c large collection of functions of the form @code{as.@var{something}()}
@c for either coercion from one mode to another, or for investing an object
@c with some other attribute it may not already possess.  The reader should
@c consult the different help files to become familiar with them.

이제 @code{d}와 @code{z}는 동일한 벡터임을 확인하실 수 있을 것입니다.
@footnote{일반적으로 숫자에서 문자로의 강제형변환 한 뒤 다시 숫자로 변경할때에는 본래의 숫자와 완전히 똑같지 않습니다. 
그 이유는 문자로서 표현될때의 roundoff errors(반올림 오차)때문입니다.}  
이와 같이 형의 변환을 도와주는 강제형변환 기능은 @code{as.@var{something}} 형태의 함수로서 이루어지며, 
객체가 어떤 속성을 가지고 있는가 혹은 없는가에 확인하기 위한 방대한 양의 함수들이 제공되고 있습니다.
이러한 함수들의 사용에 익숙해지기 위해서는 도움말 파일을 참고하시길 부탁드립니다.

@c </FIXME>

@node Changing the length of an object, Getting and setting attributes, The intrinsic attributes mode and length, Objects
@c @section Changing the length of an object
@section 객체의 길이 변경하기

@example
> e <- numeric()
@end example

@noindent
@c makes @code{e} an empty vector structure of mode numeric.  Similarly
@c @code{character()} is a empty character vector, and so on.  Once an
@c object of any size has been created, new components may be added to it
@c simply by giving it an index value outside its previous range.  Thus

위의 명령문은 @code{e}라는 수치형 모드를 가지며 아무런 구성요소도 가지지 않은 (즉, 비어있는) 벡터를 생성합니다.
유사한 방식으로 @code{character()}은 아무런 구성요소를 가지고 있는 문자형 벡터를 생성하는데 쓰입니다.
이렇게 하는 것은 임의의 크기를 가지는 객체를 생성하는데 쓰이며, 
새로운 구성요소는 아래와 같이 벡터가 원래 가지고 있던 인덱스의 범위 밖의 값을 넣어줌으로서 추가할 수 있습니다. 

@example
> e[3] <- 17
@end example

@noindent
@c now makes @code{e} a vector of length 3, (the first two components of
@c which are at this point both @code{NA}).  This applies to any structure
@c at all, provided the mode of the additional component(s) agrees with the
@c mode of the object in the first place.

이제 길이가 3인 @code{e}라는 벡터가 만들어진 것입니다 (처음 두개의 구성요소들은 @code{NA}가 될 것입니다). 
이러한 방식으로 구성요소를 추가하는 것은 새로 추가되는 구성요소의 모드가 존재하는 객체를 구성하는 객체의 모드와 일치만 한다면 어떠한 구조를 가진 객체에 모두 적용이 가능합니다. 

@c This automatic adjustment of lengths of an object is used often, for
@c example in the @code{scan()} function for input.  (@pxref{The scan()
@c function}.)

종종 자동적으로 객체의 길이가 조정될 때가 있습니다. 
예를들면, 입력을 받기 위한 @code{scan()}가 사용될 때입니다. 
(@pxref{The scan() function}.)

@c Conversely to truncate the size of an object requires only an assignment
@c to do so.  Hence if @code{alpha} is an object of length 10, then
이와는 반대로 객체의 크기를 줄이고자 한다면 단순히 대입문을 사용하면 됩니다.
예를들어, @code{alpha}가 길이가 10인 객체라고 가정합니다.
아래의 대입문은 @code{alpha}의 인덱스 벡터의 길이가 5인데, 이 벡터에 2를 곱하였으므로, @code{alpha}의 인덱스 벡터가 짝수에 해당하는 @code{alpha}의 구성요소들만 선택된 새로운 @code{alpha}를 생성하는 것입니다. 
 
@example
> alpha <- alpha[2 * 1:5]
@end example

@noindent
@c makes it an object of length 5 consisting of just the former components
@c with even index.  (The old indices are not retained, of course.)  We can
@c then retain just the first three values by
(물론 이전에 사용한 인덱스는 더 이상 유효하지 않습니다). 
벡터의 길이를 변경하여 처음 세가의 구성요소만을 가지는 @code{alpha}를 생성하고자 한다면 아래와 같은 방법을 사용할 수도 있습니다. 

@example
> length(alpha) <- 3
@end example

@noindent
@c and vectors can be extended (by missing values) in the same way.

@node Getting and setting attributes, The class of an object, Changing the length of an object, Objects
@c @section Getting and setting attributes
@section 속성의 확인과 설정
@findex attr
@findex attributes

@c The function @code{attributes(@var{object})}
@c @findex attributes
@c returns a list of all the non-intrinsic attributes currently defined for
@c that object.  The function @code{attr(@var{object}, @var{name})}
@c @findex attr
@c can be used to select a specific attribute.  These functions are rarely
@c used, except in rather special circumstances when some new attribute is
@c being created for some particular purpose, for example to associate a
@c creation date or an operator with an @R{} object.  The concept, however,
@c is very important.

함수 @code{attributes(@var{object})}는 현재 정의되어 있는 객체들의 모든 속성들의 목록을 보여줍니다.
@findex attributes
단, 이 속성들은 본질적으로 내재되어 있는 것들이 아닙니다.
함수 @code{attr(@var{object}, @var{name})}은 특정한 속성을 선택하는데 사용되어 집니다.
@findex attr
그러나, @R{}객체에 날짜 및 연산자의 결합과 같은 어떤 새로운 속성이 어떤 특정한 목적으로 생성되는 것과 같은 특별한 경우가 아니라면 이러한 함수들은 거의 사용되지 않습니다. 
그러나, 이 속성에 대한 개념은 매우 중요합니다.

@c Some care should be exercised when assigning or deleting attributes
@c since they are an integral part of the object system used in @R{}.

속성을 새로이 추가하거나 삭제할때는 사용의 주의가 매우 요구되어 집니다. 
그 이유는 @R{}에서 사용되는 객체 시스템의 주요한 부분이기 때문입니다.

@c When it is used on the left hand side of an assignment it can be used
@c either to associate a new attribute with @code{@var{object}} or to
@c change an existing one.  For example

대입문의 좌측에 @code{@var{object}}를 이용하여 새로운 속성을 연결하거나 존재하는 속성을 변경할 수 있습니다. 
다음의 예제는 @code{z}라는 벡터의 크기가 10행 10열이라는 행렬로 다루라는 의미입니다.

@example
> attr(z, "dim") <- c(10,10)
@end example

@noindent
@c allows @R{} to treat @code{z} as if it were a 10-by-10 matrix.

@node The class of an object,  , Getting and setting attributes, Objects
@c @section The class of an object
@section 객체의 클래스
@cindex Classes

@c All objects in @R{} have a @emph{class}, reported by the function
@c @code{class}.  For simple vectors this is just the mode, for example
@c @code{"numeric"}, @code{"logical"}, @code{"character"} or @code{"list"},
@c but @code{"matrix"}, @code{"array"}, @code{"factor"} and
@c @code{"data.frame"} are other possible values.

@R{}에 존재하는 모든 객체들은 @emph{class}(클래스)라는 것을 가집니다.
이는 함수 @code{class}의 사용으로 확인할 수 있습니다.
간단한 벡터의 예를 들어보면, @code{"numeric"}, @code{"logical"}, @code{"character"} 또는 @code{"list"}와 같이 이것은 단순하게 벡터의 모드라는 것을 알 수 있습니다.
그러나, @code{"matrix"}, @code{"array"}, @code{"factor"} 그리고 @code{"data.frame"}는 다른 값들을 가집니다.

@c A special attribute known as the @emph{class} of the object is used to
@c allow for an object-oriented style@footnote{A different style using
@c `formal' or `S4' classes is provided in package @code{methods}.} of
@c programming in @R{}.  For example if an object has class
@c @code{"data.frame"}, it will be printed in a certain way, the
@c @code{plot()} function will display it graphically in a certain way, and
@c other so-called generic functions such as @code{summary()} will react to
@c it as an argument in a way sensitive to its class.

객체의 @emph{class}(클래스)로서 알려진 특별한 속성은 @R{}의 object-oriented style (객체지향스타일) 프로그래밍에서 사용됩니다 @footnote{`formal' 또는 `S4' 클래스들을 사용하는 다른 종류의 스타일들은 패키지 @code{methods}내에서 제공되어지고 있습니다.}.
예를들면, 만약 객체가 @code{"data.frame"}를 가진다고 할때, 
이 객체에 @code{plot()} 함수의 이용은 이 객체는 @code{plot()}내에 미리 정해져 있는 특정한 방식대로 데이터를 불러와 해당 클래스에 정의되어 있는대로 시각화처리를 하게 됩니다. 
또한, 일명 @code{summary()}라고 불리는 제네릭 함수가 사용될 때 객체가 가지고 있는 클래스를 인자의 형태로 받아, 이에 따라 정의되어 있는대로 결과물에 대한 요약을 보여주게 됩니다. 

@c To remove temporarily the effects of class, use the function
@c @code{unclass()}.
@findex unclass
@c For example if @code{winter} has the class @code{"data.frame"} then

클래스의 미치는 영향을 일시적으로 제거하기 위해서는 @code{unclass()}라는 함수를 사용하면 됩니다.
예를들어 만약 @code{winter}라는 객체가 클래스 @code{"data.frame"}(데이터 프레임)을 가지고 있다면, 아래의 명령문은 행렬처럼 보이기 보다는 데이터 프레임의 형식에 맞춰 결과를 보여주게 됩니다. 
@example
> winter
@end example

@noindent
@c will print it in data frame form, which is rather like a matrix, whereas
반면에 아래와 같은 명령문을 수행하게 된다면 본래 가지고 있던 리스트의 형식으로 출력되게 됩니다.
@example
> unclass(winter)
@end example

@noindent
@c will print it as an ordinary list.  Only in rather special situations do
@c you need to use this facility, but one is when you are learning to come
@c to terms with the idea of class and generic functions.

이러한 클래스의 활용은 매우 특수한 경우에 사용할 수 있으나, 지금은 단순히 클래스와 제네릭 함수의 개념에만 익숙해지시면 됩니다.

@c Generic functions and classes will be discussed further in @ref{Object
@c orientation}, but only briefly.
이것들에 대해서 @ref{Object orientation}에서 더 자세히 살펴보게 되겠지만, 여기에서는 간단히 마치도록 합니다.

@node Factors, Arrays and matrices, Objects, Top
@c @chapter Ordered and unordered factors
@chapter 순위형과 비순위형 요인들
@cindex Factors
@cindex Ordered factors

@c A @emph{factor} is a vector object used to specify a discrete
@c classification (grouping) of the components of other vectors of the same length.
@c @R{} provides both @emph{ordered} and @emph{unordered} factors.
@c While the ``real'' application of factors is with model formulae
@c (@pxref{Contrasts}), we here look at a specific example.

@emph{factor}(요인)은 같은 길이를 가지고 있는 다른 벡터들의 구성요소들을 이산형 클래시피케이션 또는 그룹핑을 하는데 쓰이는 벡터형 객체입니다.
@R{}은 @emph{ordered}(순위형)과 @emph{unordered}(비순위형) 두가지 종류의 요인을 제공하고 있습니다.
요인을 활용하는 실 응용예제는 @pxref{Contrasts}에서 설명하는 model formulae(모델식)을 통해 알수 있지만, 여기에서는 특수한 예제를 통해서 요인이 무엇인지 이해하는데 중점을 둡니다.

@c @section A specific example
@section 특별한 예제

@c Suppose, for example, we have a sample of 30 tax accountants from all
@c the states and territories of Australia@footnote{Readers should note
@c that there are eight states and territories in Australia, namely the
@c Australian Capital Territory, New South Wales, the Northern Territory,
@c Queensland, South Australia, Tasmania, Victoria and Western Australia.}
@c and their individual state of origin is specified by a character vector
@c of state mnemonics as

예를들어, Australia(오스트레일리아, 호주)의 모든 지역@footnote{호주에는 Australian Capital Territory, New South Wales, the Northern Territory, Queensland, South Australia, Tasmania, Victoria and Western Australia 이라는 총 8개의 주와 영토가 있다는 점을 알면 도움이 될 것입니다.}에 있는 30명의 회계사들에 대한 정보를 가지고 있는 샘플이 있다고 가정합니다. 
그리고, 그들의 근무지에 대한 정보가 @code{state}에 문자형 벡터의 형식으로 다음과 같이 입력되어 있습니다.


@example
> state <- c("tas", "sa",  "qld", "nsw", "nsw", "nt",  "wa",  "wa",
             "qld", "vic", "nsw", "vic", "qld", "qld", "sa",  "tas",
             "sa",  "nt",  "wa",  "vic", "qld", "nsw", "nsw", "wa",
             "sa",  "act", "nsw", "vic", "vic", "act")
@end example

@c Notice that in the case of a character vector, ``sorted'' means sorted
@c in alphabetical order.

문자형 벡터의 경우에는 ``sorted''(정렬)이라는 것은 알파벳순서로 나열하는 것을 의미합니다.

@c A @emph{factor} is similarly created using the @code{factor()} function:
@emph{factor}(요인)는 @code{factor()}함수를 이용하여 생성하게 됩니다.

@findex factor

@example
> statef <- factor(state)
@end example

@c The @code{print()} function handles factors slightly differently from
@c other objects:

@code{print()}함수는 아래와 같이 요인의 구성요소들을 다른 객체들과는 다소 다른 방식으로 출력하여 보여줍니다.

@example
> statef
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa
[16] tas sa  nt  wa  vic qld nsw nsw wa  sa  act nsw vic vic act
Levels:  act nsw nt qld sa tas vic wa
@end example

@c To find out the levels of a factor the function @code{levels()} can be
@c used.
요인의 수준(levels)를 알기 위해서는 함수 @code{levels()}를 아래와 같은 방법으로 사용합니다.
@findex levels

@example
> levels(statef)
[1] "act" "nsw" "nt"  "qld" "sa"  "tas" "vic" "wa"
@end example

@menu
* The function tapply() and ragged arrays::  
* Ordered factors::             
@end menu

@node The function tapply() and ragged arrays, Ordered factors, Factors, Factors
@c @section The function @code{tapply()} and ragged arrays
@section 함수 @code{tapply()}와 래그드된 배열
@findex tapply

@c To continue the previous example, suppose we have the incomes of the
@c same tax accountants in another vector (in suitably large units of
@c money)

이전에 사용된 예제를 계속 이용해봅니다.
그리고, 이제는 동일한 회계사의 수입(income)에 대한 정보가 아래와 같은 다른 벡터에 저장되어 있다고 가정합니다.

@example
> incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,
               61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,
               59, 46, 58, 43)
@end example

@c To calculate the sample mean income for each state we can now use the
@c special function @code{tapply()}:

각 근무지별 평균소득을 계산을 하고 싶다면 @code{tapply()}를 아래와 같이 이용하면 됩니다.

@example
> incmeans <- tapply(incomes, statef, mean)
@end example

@noindent
@c giving a means vector with the components labelled by the levels

위 명령어의 결과는 아래와 같이 수준(levels)별로 그 평균값을 보여주게 됩니다.

@example
   act    nsw     nt    qld     sa    tas    vic     wa
44.500 57.333 55.500 53.600 55.000 60.500 56.000 52.250
@end example

@c The function @code{tapply()} is used to apply a function, here
@c @code{mean()}, to each group of components of the first argument, here
@c @code{incomes}, defined by the levels of the second component, here
@c @code{statef}@footnote{Note that @code{tapply()} also works in this case
@c when its second argument is not a factor, e.g.,
@c @samp{@code{tapply(incomes, state)}}, and this is true for quite a few
@c other functions, since arguments are @emph{coerced} to factors when
@c necessary (using @code{as.factor()}).}, as if they were separate vector
@c structures.  The result is a structure of the same length as the levels
@c attribute of the factor containing the results.  The reader should
@c consult the help document for more details.

함수 @code{tapply()}는 첫번째 인자에 30명의 회계사들의 소득을 포함하고 있는 @code{incomes} 이라는 벡터를 불러들이고, 두번째 인자는 회계사들의 근무지가 어디에 속하는지에 대한 정보가 있는 @code{statef}가 이용되며, 마지막으로 세번째 인자는 각 근무지별로 분류된 데이터에 평균을 산출해 내는 @code{mean}이라는 함수명이 사용되었습니다
@footnote{@samp{@code{tapply(incomes, state)}}와 같이 @code{tapply()}의 두번째 인자가 꼭 요인(factor)이 아니어도 괜찮습니다.
그 이유는 인자는 필요에 의하여 @code{as.factor()}를 이용하여 강제형변환 @emph{coerced}이 내부적으로 수행되기 때문입니다}
따라서, 생성된 벡터의 길이는 반드시 요인의 수준들의 개수와 같아야 합니다.
더 자세한 사항들에 대해서는 도움말을 참고하시길 바랍니다.

@c Suppose further we needed to calculate the standard errors of the state
@c income means.  To do this we need to write an @R{} function to calculate
@c the standard error for any given vector.  Since there is an builtin
@c function @code{var()} to calculate the sample variance, such a function
@c is a very simple one liner, specified by the assignment:

아마도 독자는 평균소득에 대한 표준오차(standard error)를 알고 싶을 수도 있습니다.
이것을 하기 위해서 우리는 아래와 같이 표준오차를 계산하는 @R{}함수를 작성하였습니다.
@code{var()}는 샘플의 분산을 계산해주는 빌트인 함수이기 때문에, 아래와 같이 한줄로 표시가 가능합니다.
 
@example
> stderr <- function(x) sqrt(var(x)/length(x))
@end example

@noindent
@c (Writing functions will be considered later in @ref{Writing your own
@c functions}, and in this case was unnecessary as @R{} also has a builtin
@c function @code{sd()}.)
(함수를 작성하는 방법에 대해서는 추후에 @ref{Writing your own functions}에서 다룰 것입니다. 
또한, 이러한 함수를 작성하는 것은 다소 무의미합니다. 그 이유는 @R{}은 또한 @code{sd()}를 제공하기 때문입니다).
@findex sd
@findex var
@c After this assignment, the standard errors are calculated by

위의 대입문을 수행한 뒤에 표준오차는는 아래와 같은 방법으로 계산되어 집니다.

@example
> incster <- tapply(incomes, statef, stderr)
@end example

@noindent
@c and the values calculated are then
그리고, 아래와 같이 보여지게 됩니다.

@example
> incster
act    nsw  nt    qld     sa tas   vic     wa
1.5 4.3102 4.5 4.1061 2.7386 0.5 5.244 2.6575
@end example

@c As an exercise you may care to find the usual 95% confidence limits for
@c the state mean incomes.  To do this you could use @code{tapply()} once
@c more with the @code{length()} function to find the sample sizes, and the
@c @code{qt()} function to find the percentage points of the appropriate
@c @math{t}-distributions.  (You could also investigate @R{}'s facilities
@c for @math{t}-tests.)

연습삼아서 평균소득에 대한 95% 신뢰구간을 찾고자 하시는 독자도 있을 것입니다.
이것을 하기 위해서는 아마도 @code{tapply()}, @code{length()}, @code{qt()}라는 함수들이 필요한데,
@code{length()}는 샘플 사이즈를, @code{qt()}는 t-분포에서 95% 에 해당하는 계수 를 찾아 줄 것입니다.
(@R{}에서 제공하는 @math{t}-테스트 기능을 이용할 수도 있습니다).

@c The function @code{tapply()} can also be used to handle more complicated
@c indexing of a vector by multiple categories.  For example, we might wish
@c to split the tax accountants by both state and sex.  However in this
@c simple instance (just one factor) what happens can be thought of as
@c follows.  The values in the vector are collected into groups
@c corresponding to the distinct entries in the factor.  The function is
@c then applied to each of these groups individually.  The value is a
@c vector of function results, labelled by the @code{levels} attribute of
@c the factor.

위의 예제에서 살펴 본 @code{tapply()}는 다소 복잡한 구조를 가지는 그룹핑 벡터에도 유용하게 사용될 수 있습니다.
예를들어, 회계사의 평균 소득을 근무지와 성별이라는 요인들에 따라서 분석을 해 본다고 가정해 봅니다.
이것이 @code{tapply()}내에서 처리되는 방법은 다음과 같습니다.
먼저, 요인의 수준들에 맞추어 데이터를 그룹화합니다. 
이렇게 그룹화된 데이터에 함수가 적용이 된 후, 최종결과물에 @code{levels} 속성을 라벨링 해주는 것입니다.

@c The combination of a vector and a labelling factor is an example of what
@c is sometimes called a @emph{ragged array}, since the subclass sizes are
@c possibly irregular.  When the subclass sizes are all the same the
@c indexing may be done implicitly and much more efficiently, as we see in
@c the next section.

벡터와 요인의 값들에 대한 라벨링을 조합하는 것은 @emph{ragged array}(레그드 어레이)라고도 불리는 하나의 예제입니다.
그 이윤는 각 그룹내의 데이터 개수가 동일하지 않기 때문입니다.
만약, 각 그룹의 사이즈가 동일하다면 우리가 다음섹션에서 살펴보게 될 것과 같이 훨씬 효율적으로 다루어질 수 있습니다.

@node Ordered factors,  , The function tapply() and ragged arrays, Factors
@c @section Ordered factors
@section 순위가 있는 요인들
@findex ordered

@c The levels of factors are stored in alphabetical order, or in the order
@c they were specified to @code{factor} if they were specified explicitly.

요인(factor)에 대한 수준(levels)들은 기본적으로 알파벳순서로 저장이 되지만, @code{factor}를 이용하여 사용자가 그 순서를 지정할 수도 있습니다.

@c Sometimes the levels will have a natural ordering that we want to record
@c and want our statistical analysis to make use of.  The @code{ordered()}
@findex ordered
@c function creates such ordered factors but is otherwise identical to
@c @code{factor}.  For most purposes the only difference between ordered
@c and unordered factors is that the former are printed showing the
@c ordering of the levels, but the contrasts generated for them in fitting
@c linear models are different.
어떤 경우에는 레벨들이 우리가 원하고자 했던 대로 이미 기록이 되어 있거나, 통계분석시 필요로 하는 데이터 형태를 미리 가지고 있을 수도 있습니다. 
@code{ordered()}라는 함수는 순위형 요인들을 생성하는 것외에는 @code{factor}와 다른 점은 없습니다.
순위형과 비순위형의 다른점이라고 한다면 순위형은 레벨의 정렬된 순서대로 출력을 하게 되지만, 이로부터 적합된 선형모델을 이용하여 contrasts(대조)를 할 경우에는 다른 결과값을 산출한다는 점에서 주의를 해야합니다.


@node Arrays and matrices, Lists and data frames, Factors, Top
@c @chapter Arrays and matrices
@chapter  배열과 행렬

@menu
* Arrays::                      
* Array indexing::              
* Index matrices::              
* The array() function::        
* The outer product of two arrays::  
* Generalized transpose of an array::  
* Matrix facilities::           
* Forming partitioned matrices::  
* The concatenation function c() with arrays::  
* Frequency tables from factors::  
@end menu

@node Arrays, Array indexing, Arrays and matrices, Arrays and matrices
@c @section Arrays
@section 배열
@cindex Arrays
@cindex Matrices

@c An array can be considered as a multiply subscripted collection of data
@c entries, for example numeric.  @R{} allows simple facilities for
@c creating and handling arrays, and in particular the special case of
@c matrices.

@c A dimension vector is a vector of non-negative integers.  If its length is
@c @math{k} then the array is @math{k}-dimensional, e.g.@ a matrix is a
@c @math{2}-dimensional array.  The dimensions are indexed from one up to
@c the values given in the dimension vector.

배열(array)이라는 것은 쉽게 표현하면 다차원상에 데이터가 놓아질 수 있도록 데이터 엔트리(data entry, 데이터가 위치하는 하나하나를 공간 또는 한개의 데이터을 의미함)를 구조화 한 것입니다.
실제로 다차원이라는 것은 우리 머릿속에만 존재하는데, 데이터를 일렬로 벡터와 같은 형태로 읽어들이는 컴퓨터는 다차원의 개념을 모릅니다.
그래서, 이러한 다차원을 표현하고자 하는 방법을 배열이라고 하며, @R{}은 이러한 배열을 생성하고 다룰 수 있는 간편한 기능들을 제공합니다. 

이러한 다차원 구조의 실제적인 구현을 위해서 차원벡터 (dimension vector)라는 것을 활용하게 되는데, 이는 음의 값을 가지지 않는 정수로 이루어진 벡터를 의미합니다.
예를들어, 차원벡터의 길이가 @math{k}라면, 데이터는 @math{k}-차원의 배열위에 놓여지게 됩니다.
행렬이라는 것은 @math{2}-차원을 가진 배열의 특수한 경우이라고 생각하실 수 있습니다. 
그리고, 각 차원 (즉, 차원벡터의 구성요소)은 양의 정수를 인덱스 값으로 가지게 됩니다.

@c A vector can be used by @R{} as an array only if it has a dimension
@c vector as its @emph{dim} attribute.  Suppose, for example, @code{z} is a
@c vector of 1500 elements.  The assignment

이해를 돕기 위해서 아래의 예제를 살펴보도록 합니다.
이 예제에서 @code{z}는 1500개의 구성요소를 가지는 벡터라고 가정합니다.
벡터는 @R{}에서 차원이 @math{1}인 배열의 특수한 경우에 해당하며, 이 정보는 @emph{dim}이라는 속성(attribute)을 통해 확인할 수 있습니다.
이 벡터를 데이터를 @math{3}-차원 구조를 가지며, 각 차원은 순서대로 @math{3}개, @math{5}개, @math{100}개의 크기 (즉, 구성요소의 개수)를 가지도록 하고자 한다면 아래와 같이 @emph{dim}의 속성을 변경함으로서 이를 만들 수 있습니다. 
여기에서 첫번째 차원은 @math{3}개의 구성요소를 가지므로, 각 구성요소는 인덱스 @math{1}, @math{2}, @math{3}에 의해서 선택될 수 있습니다. 
이와 마찬가지로 두번째 차원은 @math{5}개의 구성요소를 가지므로, 각 구성요소에 대한 인덱스 @math{1}, @math{2}, @math{3}, @math{4}, @math{5}에 의해서 선택이 될 수 있습니다. 
마지막 세번째 차원도 이와 동일한 논리입니다. 
따라서, 차원벡터의 각 구성요소는 각 차원이 가질 수 있는 인덱스벡터의 길이를 의미하는 것입니다.   

@example
> dim(z) <- c(3,5,100)
@end example
@findex dim

@noindent
@c gives it the @emph{dim} attribute that allows it to be treated as a
@c @math{3} by @math{5} by @math{100} array.

@c 위의 대입문은 @emph{dim}이라는 속성에 의해서 길이가 3이므로 3차원 데이터 구조를 가지는데, 각 차원은 @math{3}, @math{5}, @math{100}의 인덱스를 가지고 있다는 것을 의미합니다. 

@c Other functions such as @code{matrix()} and @code{array()} are available
@c for simpler and more natural looking assignments, as we shall see in
@c @ref{The array() function}.

이렇게 @code{dim}이라는 속성을 이용하여 배열을 생성하는 방법외에도 @code{matrix()}와 @code{array()}와 같은 함수는 보다 더 간편하고 자연스러운 배열을 만들 수 있도록 도와줍니다. 
이들의 사용에 대해서는 @ref{The array() function}를 살펴보시길 바랍니다.

@c The values in the data vector give the values in the array in the same
@c order as they would occur in FORTRAN, that is ``column major order,''
@c with the first subscript moving fastest and the last subscript slowest.

@c For example if the dimension vector for an array, say @code{a}, is
@c @code{c(3,4,2)} then there are @eqn{3 \times 4 \times 2 = 24, 3 * 4 * 2
@c = 24} entries in @code{a} and the data vector holds them in the order
@c @code{a[1,1,1], a[2,1,1], @dots{}, a[2,4,2], a[3,4,2]}.

데이터 벡터의 구성요소들의 값이 배열에 나열되는 방식은 FORTRAN 프로그램에서 사용되는 것과 동일한 ``column major order'' 방법이 이용됩니다. 
이 말의 뜻은 차원벡터의 첫번째 요소의 인덱스가 다른 요소들의 인덱스보다 제일 빠르게 업데이트되고 맨 마지막 요소의 인덱스가 제일 느리게 업데이트 되는 것을 의미합니다.

예를들어, @code{a}라는 배열의 차원벡터가 @code{c(3,4,2)}이라고 가정합니다.
배열 @code{a}에는 총 @eqn{3 \times 4 \times 2 = 24, 3 * 4 * 2 = 24} 개의 데이터 엔트리들이 있을 것입니다.
그리고, 데이터 벡터는 @code{a[1,1,1], a[2,1,1], @dots{}, a[2,4,2], a[3,4,2]}의 순서대로 배열에 나열되는 것입니다.

@c Arrays can be one-dimensional: such arrays are usually treated in the
@c same way as vectors (including when printing), but the exceptions can
@c cause confusion.

배열은 1차원일 수 있는데, 이들은 벡터와 같이 사용이 되기도 합니다 (어떻게 출력이 되는지 살펴보시면 쉽게 이해가 가실 것입니다).
그러나, 예외의 경우도 있지만, 이는 사용의 혼란을 가져오므로 이 문서에서 다루지 않습니다.

@node Array indexing, Index matrices, Arrays, Arrays and matrices
@c @section Array indexing.  Subsections of an array
@section 배열 인덱싱과 구성요소의 선택적 지정
@cindex Indexing of and by arrays

@c Individual elements of an array may be referenced by giving the name of
@c the array followed by the subscripts in square brackets, separated by
@c commas.

@c More generally, subsections of an array may be specified by giving a
@c sequence of @emph{index vectors} in place of subscripts; however
@c @emph{if any index position is given an empty index vector, then the
@c full range of that subscript is taken}.

@c Continuing the previous example, @code{a[2,,]} is a @eqn{4 \times 2, 4 *
@c 2} array with dimension vector @code{c(4,2)} and data vector containing
@c the values

배열의 각 구성요소들은 배열의 이름 바로 뒤에 오는 열린 대괄호([)와 닫힌 대괄호(])사이에 위치하여 컴마로 구분된 첨자(subscript)를 이용하여 지정할 수 있습니다. 
컴마로 구분되어진 각 첨자의 위치에 주로 하나의 숫자들을 이용하여 그 구성요소를 표현하게 되는데, 각 첨자의 위치에 @emph{index vectors}(인덱스 벡터)를 이용하여 배열의 특정한 구성요소들을 선택적으로 지정할 수도 있습니다. 

먼저, 배열의 첨자에 인덱스 벡터의 구성요소가 특별히 지정되지 않은 상태 (즉, 비어있는 상태)를 생각해 봅니다.
첨자에 아무것도 지정되지 않았다면 배열의 해당첨자에 해당하는 차원이 가질 수 있는 모든 값(즉, 해당 첨자가 위치하는 차원의 크기 또는 차원을 구성하는 요소의 개수)을 의미하게 됩니다.
이해를 돕기 위해 위에서 사용한 @code{a}라는 벡터를 다시 살펴봅니다.
만약, @code{a[2,,]}라는 배열의 첨자들은 @code{[2,,]}로서 세 개의 숫자의 조합으로 되어 있으나, 첫번째 첨자를 제외하고 두번째와 세번째 첨자가 비어 있습니다.
이것은 @code{a}라는 배열의 차원은 @c{c(3,4,2)}였으므로, 첫번째 첨자가 @math{2}에 해당하고 아래와 같이 차원벡터 @code{c(4,2)}에 해당하는 데이터 엔트리로만 이루어진 벡터를 의미하게 됩니다. 
그러나, 출력시에는 차원벡터의 길이에 맞추어 @math{4}행 @math{2}열을 가진 행렬의 형식으로 보여지게 됩니다.

@example
c(a[2,1,1], a[2,2,1], a[2,3,1], a[2,4,1],
  a[2,1,2], a[2,2,2], a[2,3,2], a[2,4,2])
@end example

@noindent
@c in that order.  @code{a[,,]} stands for the entire array, which is the
@c same as omitting the subscripts entirely and using @code{a} alone.

@c For any array, say @code{Z}, the dimension vector may be referenced
@c explicitly as @code{dim(Z)} (on either side of an assignment).

만약, @code{a[,,]}와 같이 모든 첨자를 지정하지 않는다면 @code{a}라는 배열 자체를 의미하게 됩니다. 
이러한 벡터의 차원은 @code{dim()}이라는 함수를 이용하여 알 수 있습니다. 
예를들어, @code{Z}라는 배열이 있다면 이 배열의 차원은 @code{dim(Z)}를 통하여 확인이 가능합니다. 

@c Also, if an array name is given with just @emph{one subscript or index
@c vector}, then the corresponding values of the data vector only are used;
@c in this case the dimension vector is ignored.  This is not the case,
@c however, if the single index is not a vector but itself an array, as we
@c next discuss.

또한, 만약 배열의 이름 뒤에 @math{a[3]} 또는 @math{a[3:10]}과 같이 @emph{오로지 한개의 첨자 또는 인덱스 벡터}가 함께 주어지게 된다면 이 인덱스에 해당하는 데이터 엔트리로만 구성된 벡터가 사용되게 됩니다.
즉, 이러한 경우에는 차원벡터가 무시되는 것입니다.
만약, 인덱스가 배열의 형태로서 주어질 경우도 있으며, 이에 대해서는 다음 섹션에서 다룰 것입니다. 

@menu
* Index matrices::
* The array() function::
@end menu

@node Index matrices, The array() function, Array indexing, Arrays and matrices
@c @section Index matrices
@section 인덱스 행렬

@c As well as an index vector in any subscript position, a matrix may be
@c used with a single @emph{index matrix} in order either to assign a vector
@c of quantities to an irregular collection of elements in the array, or to
@c extract an irregular collection as a vector.

@c A matrix example makes the process clear.  In the case of a doubly
@c indexed array, an index matrix may be given consisting of two columns
@c and as many rows as desired.  The entries in the index matrix are the
@c row and column indices for the doubly indexed array.  Suppose for
@c example we have a @math{4} by @math{5} array @code{X} and we wish to do
@c the following:

배열의 첨자에는 인덱스 벡터외에도 불특정 위치에 있는 배열의 구성요소들에 접근하여 새로운 값을 대입하거나, 이들의 값을 뽑아내고자 할때 @emph{index matrix}(인덱스 행렬)을 사용할 수 있습니다. 
아래의 예제와 같이 배열의 크기가 @math{4}행 @math{5}열로 구성된 행렬 형식의 배열 @code{X}가 있다고 가정하고, @code{X}에 대해서 다음의 것을 수행하고자 합니다.

@itemize @bullet
@item
@c Extract elements @code{X[1,3]}, @code{X[2,2]} and @code{X[3,1]} as a
@c vector structure, and
@code{X[1,3]}, @code{X[2,2]} 그리고 @code{X[3,1]}의 위치에 해당하는 구성요소들만 뽑아내어 벡터의 형태로 구성하려 합니다.

@item
@c Replace these entries in the array @code{X} by zeroes.
그리고, 배열 @code{X}의 뽑아낸 위치에 있는 데이터를 0의 값으로 대체하고자 합니다. 
@end itemize
@c In this case we need a @math{3} by @math{2} subscript array, as in the
@c following example.
이를 수행하기 위해서는 첨자의 위치에 놓일 @math{2}행 @math{2}열로 구성된 배열이 필요합니다. 
이제 아래의 명령을 따라 읽어보시면 이해가 쉬울 것입니다.
 
@example
> x <- array(1:20, dim=c(4,5))   @r{# 4행 5열로 구성된 2차원 배열을 생성합니다.}                                  @c @r{Generate a 4 by 5 array.}
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
> i <- array(c(1:3,3:1), dim=c(3,2))
> i                             @r{# i 이라는 3행 2열의 인덱스행렬을 생성합니다.}                                  @c @r{@code{i} is a 3 by 2 index array.}
     [,1] [,2]
[1,]    1    3
[2,]    2    2
[3,]    3    1
> x[i]                          @r{# 인덱스행렬 i를 이용하여 원하는 값만 뽑아냅니다}                                 @c @r{Extract those elements}
[1] 9 6 3
> x[i] <- 0                     @r{# 인덱스행렬 i에 해당하는 값들을 0으로 교체합니다.}                                 @c @r{Replace those elements by zeros.}
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    0   13   17
[2,]    2    0   10   14   18
[3,]    0    7   11   15   19
[4,]    4    8   12   16   20
>
@end example
@noindent
@c Negative indices are not allowed in index matrices.  @code{NA} and zero
@c values are allowed: rows in the index matrix containing a zero are
@c ignored, and rows containing an @code{NA} produce an @code{NA} in the
@c result.

인덱스행렬의 구성요소는 음의 값을 가질 수 없으나, @code{NA}와 0의 값은 사용할 수 있습니다.
만약, 인덱스행렬이 0의 값을 가지고 있는 행이 발견된다면, 해당 행은 무시되어 질 것입니다.
이와 유사하게, @code{NA}를 포함하는 행이 발견된다면, 해당 행은 모두 @code{NA}를 출력하게 됩니다.

@c As a less trivial example, suppose we wish to generate an (unreduced)
@c design matrix for a block design defined by factors @code{blocks}
@c (@code{b} levels) and @code{varieties} (@code{v} levels).  Further
@c suppose there are @code{n} plots in the experiment.  We could proceed as
@c follows:

다소 쉬운 예제는 아니지만, @code{b}개의 수준을 가지고 있는 @code{blocks}이라는 요인과 @code{v}개의 수준을 가지고 있는 @code{varieties}라는 요인에 의하여 정의되는 블락디자인 (block design)에 사용될 디자인 매트릭스(design matrix)를 생성하고자 합니다. 
더 나아가, 실험에는 @code{n}개의 플랏이 있다고 가정합니다. 
아래와 같이 이를 수행할 수 있을 것입니다.

@example
> Xb <- matrix(0, n, b)
> Xv <- matrix(0, n, v)
> ib <- cbind(1:n, blocks)
> iv <- cbind(1:n, varieties)
> Xb[ib] <- 1
> Xv[iv] <- 1
> X <- cbind(Xb, Xv)
@end example

@c To construct the incidence matrix, @code{N} say, we could use

만약 @code{N}이라는 인시던스 행렬(incidence matrix)를 생성하고자 한다면 아래와 같이 할 수 있습니다.

@example
> N <- crossprod(Xb, Xv)
@end example
@findex crossprod

@c However a simpler direct way of producing this matrix is to use

그러나, @code{table()}함수를 이용하면 보다 쉬운 방법으로 위에서 얻은 동일한 인시던스 행렬을 얻을 수 있습니다.

@findex table

@example
> N <- table(blocks, varieties)
@end example

@c Index matrices must be numerical: any other form of matrix (e.g.@ a
@c logical or character matrix) supplied as a matrix is treated as an
@c indexing vector.

인덱스행렬은 반드시 수치형으로 구성되어야 합니다.
만약, 논리형 또는 문자형 행렬의 형식으로 제공된 인덱스행렬이라면 단순히 인덱스 벡터로서 간주되게 됩니다.

@node The array() function, The outer product of two arrays, Index matrices, Arrays and matrices
@c @section The @code{array()} function
@section @code{array()} 함수 
@findex array

@c As well as giving a vector structure a @code{dim} attribute, arrays can
@c be constructed from vectors by the @code{array} function, which has the
@c form

배열은 벡터에 @code{dim}이라는 속성을 부여하여 생성하는 방법외에도, 아래와 같이 @code{array} 함수를 이용하여 생성이 가능합니다.

@example
> Z <- array(@var{data_vector}, @var{dim_vector})
@end example

@c For example, if the vector @code{h} contains 24 or fewer, numbers then
@c the command

예를 들어 @code{h}가 24개 또는 그 보다 적은 개수의 숫자로 구성된 벡터라고 가정한다면, 
아래의 표현식은 @math{3}행 @math{4}열로 구성된 @math{2}개의 행렬을 3차원 공간에 배열 한 결과를 @code{Z}에 대입하였음을 알 수 있습니다.

@example
> Z <- array(h, dim=c(3,4,2))
@end example

위에서는 배열 @code{Z}를 @code{array}함수를 이용하여 생성하였으나, 아래의 표현식은 벡터 @code{h}의 속성 @code{dim}을 변경하여 배열 @code{Z}와 동일한 벡터를 생성함을 보여줍니다.

@noindent
@c would use @code{h} to set up @math{3} by @math{4} by @math{2} array in
@c @code{Z}.  If the size of @code{h} is exactly 24 the result is the same as

@example
> Z <- h ; dim(Z) <- c(3,4,2)
@end example

@c However if @code{h} is shorter than 24, its values are recycled from the
@c beginning again to make it up to size 24 (@pxref{The recycling rule})
@c but @code{dim(h) <- c(3,4,2)} would signal an error about mismatching
@c length.

그런데, 만약 벡터 @code{h}가 24보다 적은 수의 구성원소를 가진다면, @code{array}함수 사용시 24개라고 지정된 배열의 크기를 맞추기 위해서 벡터 @code{h}의 첫번째 원소부터 재사용하게 됩니다.
이 재활용 규칙(recycling rule)에 대해서는 @pxref{The recycling rule}를 살펴보시길 바랍니다.
그러나, @code{dim(h) <- c(3,4,2)}와 같이 @code{dim} 속성을 변경하여 배열을 생성하고자 할 때는 에러를 보여줄 것 입니다.

@c As an extreme but common example
아래의 표현식은 다소 극단적인 경우이지만, 흔히 사용되는 예제이기도 합니다.
이는 배열 @code{Z}의 모든 구성요소가 0 값을 가지는 특수한 경우입니다.

@example
> Z <- array(0, c(3,4,2))
@end example

@noindent
@c makes @code{Z} an array of all zeros.

@c At this point @code{dim(Z)} stands for the dimension vector
@c @code{c(3,4,2)}, and @code{Z[1:24]} stands for the data vector as it was
@c in @code{h}, and @code{Z[]} with an empty subscript or @code{Z} with no
@c subscript stands for the entire array as an array.

여기에서의 @code{dim(Z)}는 차원벡터를 의미하게 되며, @code{Z[1:24]}는 벡터 @code{h}와 동일한 데이터벡터를 의미합니다. 
@code{Z[]}와 같이 아무런 첨자를 가지지 않는 경우는 단순히 @code{Z}라고 배열이름을 사용하는 것은 @code{Z}의 모든 구성요소로 이루어진 배열 그 자체를 의미하게 됩니다.

@c Arrays may be used in arithmetic expressions and the result is an array
@c formed by element-by-element operations on the data vector.  The
@c @code{dim} attributes of operands generally need to be the same, and
@c this becomes the dimension vector of the result.  

배열에서의 산술연산은 기본적으로 배열을 구성하는 원소단위에서 이루어지게 됩니다.
이때 각각의 배열이 가지는 @code{dim}이라는 차원벡터의 속성이 일치해야지만, 동일한 차원을 가진 결과값을 얻을 수 있습니다.
따라서 아래의 예제는 @code{A}, @code{B}, @code{C}가 모든 같은 @code{dim}속성을 가지고 있다면, 이를 원소단위에서 연산을 수행한 뒤에 배열 @code{D}에 대입함을 의미하는 표현식입니다. 
@c So if @code{A},
@c @code{B} and @code{C} are all similar arrays, then

@example
> D <- 2*A*B + C + 1
@end example

@noindent
@c makes @code{D} a similar array with its data vector being the result of
@c the given element-by-element operations.  However the precise rule
@c concerning mixed array and vector calculations has to be considered a
@c little more carefully.
배열과 벡터를 혼용하여 연산을 수행하는 경우에는 많은 주의가 요구됩니다.


@menu
* The recycling rule::          
@end menu

@node The recycling rule,  , The array() function, The array() function
@c @subsection Mixed vector and array arithmetic.  The recycling rule
@subsection 벡터와 배열가 혼용되는 산술연산과 재활용 규칙
@cindex Recycling rule

@c The precise rule affecting element by element mixed calculations with
@c vectors and arrays is somewhat quirky and hard to find in the
@c references.  From experience we have found the following to be a reliable
@c guide.

산술연산시 벡터와 배열의 혼용이 있는 경우에 많은 주의가 요구됩니다.
이것이 어떻게 수행되는가를 설명하기는 다소 복잡하지만, 우리의 경험을 바탕으로 아래와 같은 내용을 알려드립니다.

@itemize @bullet
@item
@c The expression is scanned from left to right.
표현식에 있는 수식을 평가하는 것은 좌에서 우로 이루어집니다.

@item
@c Any short vector operands are extended by recycling their values until
@c they match the size of any other operands.
연산에 이용되는 벡터의 길이가 서로 다른 경우에는 길이가 짧은 벡터의 원소를 재활용하여 길이가 긴 벡터의 길이를 맞추게 됩니다.

@item
@c As long as short vectors and arrays @emph{only} are encountered, the
@c arrays must all have the same @code{dim} attribute or an error results.
동일한 @code{dim}속성을 가지지 않는 배열끼리 연산이 될 경우에는 에러가 발생합니다.

@item
@c Any vector operand longer than a matrix or array operand generates an error.
벡터의 길이가 행렬 또는 배열의 길이보다 긴 경우에도 에러가 발생합니다. 

@c @item
@c If array structures are present and no error or coercion to vector has
@c been precipitated, the result is an array structure with the common
@c @code{dim} attribute of its array operands.
@end itemize

@node The outer product of two arrays, Generalized transpose of an array, The array() function, Arrays and matrices
@c @section The outer product of two arrays
@section 두 배열의 외적
@cindex Outer products of arrays

@c An important operation on arrays is the @emph{outer product}.  If
@c @code{a} and @code{b} are two numeric arrays, their outer product is an
@c array whose dimension vector is obtained by concatenating their two
@c dimension vectors (order is important), and whose data vector is got by
@c forming all possible products of elements of the data vector of @code{a}
@c with those of @code{b}.  The outer product is formed by the special
@c operator @code{%o%}:

배열의 연산에서 가장 중요한 것은 아래와 같이 @code{%o%}라고 정의된 연산자를 이용하여 연산이 이루어지는 @emph{외적(outer product)}이라는 것입니다. 
예를 들어 @code{a}와 @code{b}이라는 두개의 수치형 배열이 있다고 가정합니다.
이 두 배열의 외적(outer product)의 결과로 얻어지는 배열에 대한 차원은 @code{c(dim(a), dim(b))}이어야 하고,
데이터 벡터는 배열 @code{a}의 모든 구성요소와 @code{b}의 구성요소로 얻어진 모든 조합의 곱이 됩니다.

@findex %o%

@example
> ab <- a %o% b
@end example

@c An alternative is

외적에 대하여 위에서 수행한 것과 동일한 결과를 아래와 같이 @code{outer}라는 함수를 이용하여 얻을 수 있습니다.

@example
> ab <- outer(a, b, "*")
@end example
@findex outer

@c The multiplication function can be replaced by an arbitrary function of
@c two variables.  For example if we wished to evaluate the function
@c @eqn{f(x; y) = \cos(y)/(1 + x^2), f(x; y) = cos(y)/(1 + x^2)}
@c over a regular grid of values with @math{x}- and @math{y}-coordinates
@c defined by the @R{} vectors @code{x} and @code{y} respectively, we could
@c proceed as follows:

이 외적(outer product)이라는 연산은 두 개의 변수와 어떤 임의의 함수가 있을 때 유용하게 사용될 수 있습니다.
예를 들어, @code{x}- 와 @code{y}-좌표평면상에 있는 모든 좌표에 대하여 @eqn{f(x;y)=cos(y)/(1+x^2)}이라는 함수가 가질 수 있는 모든 값을 아래와 같은 방법으로 쉽게 구할 수 있습니다. 

@example
> f <- function(x, y) cos(y)/(1 + x^2)
> z <- outer(x, y, f)
@end example

@c In particular the outer product of two ordinary vectors is a doubly
@c subscripted array (that is a matrix, of rank at most 1).  Notice that
@c the outer product operator is of course non-commutative.  Defining your
@c own @R{} functions will be considered further in @ref{Writing your own
@c functions}.

외적에 대해서 알아두어야 것은 당연히 함수의 입력값들에 대한 교환법칙이 성립하지 않는다(non-commutative)는 것입니다.
이에 대해서는 @ref{Writing your own functions}에서 살펴볼 사용자 정의함수를 만들어 이용하는 법에 대해서 더 다루어지게 될 것입니다.

@c @subsubheading An example: Determinants of 2 by 2 single-digit matrices
@subsubheading 예제: 2행 2열인 행렬의 행렬계수 (determinant) 계산하기

@c As an artificial but cute example, consider the determinants of @math{2}
@c by @math{2} matrices @math{[a, b; c, d]} where each entry is a
@c non-negative integer in the range @math{0, 1, @dots{}, 9}, that is a
@c digit.

다소 인위적이지만, 이해하기 쉬운 예를 하나 들어봅니다.
먼저, @math{[a, b; c,d]}의 형태를 가지는 @math{2}행 @math{2}열의 행렬이 있으며, 이 행렬의 각 구성요소는 음수 아닌 정수값을 @math{0, 1, @dots{}, 9}의 범위내에서 가질 수 있다고 가정합니다.
또한, 각각의 요소들이 가질 수 있는 값은 균등한 확률(uniformly at random)으로 독립적(independently)으로 얻어진다고 가정합니다.
이렇게 주어진 가정하에서 위에서 설명한 형식을 가지는 행렬이 가질 수 있는 모든 행렬계수의 값에 대한 확률분포를 찾은 뒤 이를 플랏해보고자 한다면, 아래에서 보이는 것과 같이 @code{outer()} 함수를 두번 사용함으로서 해결할 수 있습니다.
행렬계수 (determinant)는 @math{ad-bc}이라는 공식으로 계산할 수 있습니다.

@c The problem is to find the determinants, @math{ad - bc}, of all possible
@c matrices of this form and represent the frequency with which each value
@c occurs as a @emph{high density} plot.  This amounts to finding the
@c probability distribution of the determinant if each digit is chosen
@c independently and uniformly at random.

@c A neat way of doing this uses the @code{outer()} function twice:

@example
> d <- outer(0:9, 0:9)
> fr <- table(outer(d, d, "-"))
> plot(as.numeric(names(fr)), fr, type="h",
       xlab="Determinant", ylab="Frequency")
@end example

@c Notice the coercion of the @code{names} attribute of the frequency table
@c to numeric in order to recover the range of the determinant values.  The
@c ``obvious'' way of doing this problem with @code{for} loops, to be
@c discussed in @ref{Loops and conditional execution}, is so inefficient as
@c to be impractical.

여기에서 행렬계수가 가질 수 있는 모든 값에 대한 도수분포표를 가리키고 있는 @code{fr}를 주의깊게 살펴보아야 합니다.
@code{fr}이 가지는 @code{name} 속성은 행렬계수가 가지는 모든 값의 범위를 나타냅니다.
이 속성을 @code{plot}에서 사용하고자 할 때에는 이 속성이 가지는 값들은 모두 문자형으로 저장되어 있기 때문에 수치형으로 강제형변환을 해야합니다.
본래 이 문제를 가장 분명한 방식으로 해결하는 것은 @code{for}라는 반복문을 이용하는 것인데, 이것은 비효율적이므로 실용적이지 못합니다. 
그러나, 반복문에 대해서는 @ref{Loops and conditional execution}에서 다루도록 할 것입니다.

@c It is also perhaps surprising that about 1 in 20 such matrices is
@c singular.

@node Generalized transpose of an array, Matrix facilities, The outer product of two arrays, Arrays and matrices
@c @section Generalized transpose of an array
@section 배열의 전치를 일반적인 방법으로 수행하는 법
@cindex Generalized transpose of an array

@c The function @code{aperm(a, perm)}
@c @findex aperm
@c may be used to permute an array, @code{a}.  The argument @code{perm}
@c must be a permutation of the integers @math{@{1, @dots{}, k@}}, where
@c @math{k} is the number of subscripts in @code{a}.  The result of the
@c function is an array of the same size as @code{a} but with old dimension
@c given by @code{perm[j]} becoming the new @code{j}-th dimension.  The
@c easiest way to think of this operation is as a generalization of
@c transposition for matrices.  Indeed if @code{A} is a matrix, (that is, a
@c doubly subscripted array) then @code{B} given by

@code{aperm(a, perm)}이라는 함수는 @code{a}라는 배열의 차원을 재배치하는 역할을 합니다.
@findex aperm
@code{perm}이라는 인자는 반드시 @math{@{1, @dots{}, k@}}범위 안에 있는 정수들의 조합이어야 합니다.
여기에서 @math{k}는 배열 @code{a}이 가지는 첨자의 개수입니다.
이 인자는 첨자의 위치를 변경하여 배열이 가지는 구성요소들을 재배열하는 정보를 제공해주는 것입니다.
따라서, 이 함수의 사용결과는 @code{a}와 동일한 크기를 가지는 배열을 돌려주지만, 본래의 배열 @code{a}가 가지는 차원 @code{perm[j]}의 위치에 해당하는 데이터들이 새로이 주어진 @code{j}번째 차원의 위치에 해당하는 구성요소들로 재배치 되었음을 아셔야 합니다.

이 함수가 어떻게 작동하는지 직관적 이해를 주는 예제는 행렬의 전치(transpose)입니다. 
만약 @math{2}행 @math{2}열인 @code{A}라는 행렬이 있다면 이의 차원벡터 @code{dim(A)}는 @code{c(1,2)}입니다.
아래에서 보여지는 것과 같이 @code{aperm()}을 이용하여 차원벡터의 순서를 @code{c(2,1)}로 바꾸는 것은 행렬 @code{A}를 전치하는 것과 동일합니다.

@example
> B <- aperm(A, c(2,1))
@end example

@noindent
@c is just the transpose of @code{A}.  For this special case a simpler
@c function @code{t()}

이러한 행렬의 전치는 @code{t()}라는 함수를 통해 더욱 편리하게 얻을 수 있으며, 위와 동일한 결과는 @code{B <- t(A)}를 통해 얻을 수 있습니다. 
@findex t
@c is available, so we could have used @code{B <- t(A)}.

@node Matrix facilities, Forming partitioned matrices, Generalized transpose of an array, Arrays and matrices
@c @section Matrix facilities
@section 행렬의 기능들

@macro xTx{}
 @eqn{@strong{x}^T @strong{x}, x'x}
@end macro
@macro xxT{}
 @eqn{@strong{x}@strong{x}^T, x x'}
@end macro

@c As noted above, a matrix is just an array with two subscripts.  However
@c it is such an important special case it needs a separate discussion.
@c @R{} contains many operators and functions that are available only for
@c matrices.  For example @code{t(X)} is the matrix transpose function, as
@c noted above.  The functions @code{nrow(A)} and @code{ncol(A)} give the
@c number of rows and columns in the matrix @code{A} respectively.

위에서 언급했던것과 같이, 행렬은 2개의 첨자를 활용하는 배열의 특수한 경우입니다.
그러나, 배열의 섹션으로부터 분리하여 행렬에 대해서만 따로 설명하는 이유는 @R{}은 행렬에 특화된 다양한 연산기능을 제공하기 때문입니다.
예를들면, @code{t(X)}는 전치를 하는데 사용되는 함수이며, @code{nrow(A)}와 @code{ncol(A)}은 행렬 @code{A}의 행의 개수와 열의 개수를 알려주는데 사용되는 함수들입니다.
@findex nrow
@findex ncol

@menu
* Multiplication::              
* Linear equations and inversion::  
* Eigenvalues and eigenvectors::  
* Singular value decomposition and determinants::  
* Least squares fitting and the QR decomposition::  
@end menu

@node  Multiplication, Linear equations and inversion, Matrix facilities, Matrix facilities
@c @subsection Matrix multiplication
@subsection 행렬의 곱셈연산

@cindex Matrix multiplication
@c The operator @code{%*%} is used for matrix multiplication.
@findex %*%

@c An @math{n} by @math{1} or @math{1} by @math{n} matrix may of course be
@c used as an @math{n}-vector if in the context such is appropriate.
@c Conversely, vectors which occur in matrix multiplication expressions are
@c automatically promoted either to row or column vectors, whichever is
@c multiplicatively coherent, if possible, (although this is not always
@c unambiguously possible, as we see later).

@c If, for example, @code{A} and @code{B} are square matrices of the same
@c size, then

@code{%*%}기호는 행렬의 곱셈을 수행하는 연산자입니다.
본래 @math{n}개의 구성요소로 이루어진 @math{1}개의 행 또는 @math{1}개의 열로 된 행렬은 @math{n}개의 구성요소를 가진 벡터로 상황에 따라 적절히 변경됩니다.
행렬의 수식에서 사용되는 행 또는 열 벡터들은 수학적으로 올바른 표현이기만 하다면 자동으로 곱셈연산을 수행합니다 (그러나, 항상 이렇게 올바르게 분명한 방식으로 작동하는게 아니므로, 주의해야 합니다.  
이러한 예제에 대해서는 조금 뒤에 살펴보게 될 것입니다).

만약, @code{A}와 @code{B} 모두 정방행렬이라면, 다음과 같이 원소단위의 곱셈을 수행할 수 있습니다.

@example
> A * B
@end example

@noindent

@c is the matrix of element by element products and

그러나, 다음의 표현은 원소의 곱셈이 아닌 행렬의 곱셈이라는 것을 분명히 구분하셔야 합니다.

@example
> A %*% B
@end example

@noindent

@c is the matrix product.  If @code{x} is a vector, then

만약, @code{x}가 벡터라면 아래와 같은 표현은 쿼드래딕 형식(quadratic form)을 나타냅니다.
@footnote{여기에서 @code{x %*% x}는 올바른 사용이라고 보기 어렵습니다.
그 이유는 사용자가 수행하고자 하는 연산이 @xTx{} 또는 @xxT{}일 수도 있기 때문입니다.
여기에서 사용된 @eqn{@strong{x},x}는 열벡터임을 기억하시길 바랍니다.
만약, 이런 표현식이 입력된다면 스칼라 값(즉, 한개의 숫자)을 결과로 가지는 @xTx{}를 수행하게 됩니다.
@xxT{}와 같은 행렬연산을 수행하고 싶다면 @code{cbind(x)%*% x} 또는 @code{x %*% rbind(x)}라고 해야합니다.
그 이유는 @code{rbind()} 또는 @code{cbind()}의 사용의 결과는 항상 행렬의 형식을 유지하기 때문입니다.
그러나, @xTx{} 또는 @xxT{}을 연산하기 위한 가장 좋은 방법은 함수 @code{crossprod(x)} 또는 @code{x %o% x}를 사용하는 것입니다.}

@example
> x %*% A %*% x
@end example

@noindent
@c is a quadratic form.
@c @footnote{Note that @code{x %*% x} is ambiguous, as
@c it could mean either @xTx{} or @xxT{}, where @eqn{@strong{x},x} is the
@c column form.  In such cases the smaller matrix seems implicitly to be
@c the interpretation adopted, so the scalar @xTx{} is in this case the
@c result.  The matrix @xxT{} may be calculated either by @code{cbind(x)
@c %*% x} or @code{x %*% rbind(x)} since the result of @code{rbind()} or
@c @code{cbind()} is always a matrix.  However, the best way to compute
@c @xTx{} or @xxT{} is @code{crossprod(x)} or @code{x %o% x}
@c respectively.}

@findex crossprod
@c The function @code{crossprod()} forms ``crossproducts'', meaning that
@c @code{crossprod(X, y)} is the same as @code{t(X) %*% y} but the
@c operation is more efficient.  If the second argument to
@c @code{crossprod()} is omitted it is taken to be the same as the first.

함수 @code{crossprod()}는 ``크로스 프라닥트 (crossproduct)''라고도 불리는 @code{t(X) %*% y} 연산을 수행하게 되며, 이의 사용법은 @code{corssprod(X, y)} 입니다.
다른 점은 단순히 좀 더 효율적이라는 점입니다.
만약, 함수 @code{crossprod()}에 사용되는 두번째가 인자가 생략되어 있다면, 첫번째 인자를 이용하여 연산을 수행하게 됩니다.

@findex diag
@c The meaning of @code{diag()} depends on its argument.  @code{diag(v)},
@c where @code{v} is a vector, gives a diagonal matrix with elements of the
@c vector as the diagonal entries.  On the other hand @code{diag(M)}, where
@c @code{M} is a matrix, gives the vector of main diagonal entries of
@c @code{M}.  This is the same convention as that used for @code{diag()} in
@c @sc{Matlab}.  Also, somewhat confusingly, if @code{k} is a single
@c numeric value then @code{diag(k)} is the @code{k} by @code{k} identity
@c matrix!

함수 @code{diag()}는 입력받는 인자에 따라 다른 결과를 줍니다.
만약, @code{diag(v)}와 같이 @code{v}라는 벡터 인자가 입력되면 행렬의 대각원소를 @code{v}를 가지는 대각행렬을 생성합니다.
그러나, @code{diag(M)}과 같이 @code{M}라는 행렬 인자가 입력되면 행렬 @code{M}이 가지는 대각원소들을 벡터의 형식으로 출력하게 됩니다.
이것은 @sc{Matlab}에서 사용되는 함수 @code{diag()}의 기능과 동일합니다.
다소 혼돈스러울 수도 있으나, @code{diag(k)}와 같이 @code{k}라는 스칼라 인자가 입력되면, @code{k}행 @code{k}열을 가지는 단위행렬 (identity matrix) 를 생성해주니다.


@node Linear equations and inversion, Eigenvalues and eigenvectors, Multiplication, Matrix facilities
@c @subsection Linear equations and inversion
@subsection 선형방정식의 해와 역행렬 

@cindex Linear equations
@findex solve
@c Solving linear equations is the inverse of matrix multiplication.
@c When after

행렬 @code{A}의 구성요소들의 값을 알고, 벡터 @code{b} 구성요소들의 값을 미리 알고 있다고 가정하고, 아래와 같은 선형방정식의 해를 찾는 것은 @code{x}의 값을 구하는 것과 동일합니다.

@example
> b <- A %*% x
@end example

@noindent
@c only @code{A} and @code{b} are given, the vector @code{x} is the
@c solution of that linear equation system.  In @R{},

@R{}에서는 아래와 같은 방법으로 선형방정식의 해 @code{x}를 구할 수 있습니다.

@example
> solve(A,b)
@end example

@noindent
@c solves the system, returning @code{x} (up to some accuracy loss).
@c Note that in linear algebra, formally
@c @eqn{@strong{x} = @strong{A}^{-1} @strong{b}, @code{x = A^@{-1@} %*% b}}
@c where
@c @eqn{@strong{A}^{-1}, @code{A^@{-1@}}} denotes the @emph{inverse} of
@c @eqn{@strong{A},@code{A}}, which can be computed by

즉, @eqn{@strong{x} = @strong{A}^{-1} @strong{b}, @code{x = A^@{-1@} %*% b}}입니다. 
여기에서 @eqn{@strong{A}^{-1}, @code{A^@{-1@}}} 은 @eqn{@strong{A},@code{A}}의 역행렬이며, 이는 아래와 같은 방법으로 얻을 수 있습니다.

@example
solve(A)
@end example

@noindent
@c but rarely is needed.  Numerically, it is both inefficient and
@c potentially unstable to compute @code{x <- solve(A) %*% b} instead of
@c @code{solve(A,b)}.

하지만, 위와 같이 역행렬을 이용하여 @code{x <- solve(A) %*% b} 연산을 하는 것은 함수 @code{solve(A,b)}를 이용하는 것보다 비효율적입니다.

@c The quadratic form @eqn{@strong{x^T  A^{-1} x},@ @code{x %*% A^@{-1@} %*%
@c x} @ } which is used in multivariate computations, should be computed by
@c something like@footnote{Even better would be to form a matrix square
@c root @eqn{B, B} with @eqn{A = BB^T, A = BB'} and find the squared length of the
@c solution of @eqn{By = x, By = x}, perhaps using the Cholesky or
@c eigendecomposition of @eqn{A, A}.} @code{x %*% solve(A,x)}, rather than
@c computing the inverse of @code{A}.

다변량 연산에 이용되는 쿼드래딕 형식 (quadratic form) @eqn{@strong{x^T  A^{-1} x},@ @code{x %*% A^@{-1@} %*% x} @ }은 @code{A}의 역행렬을 찾는 것 보다 @code{x %*% solve(A,x)}으로 계산해야 합니다.
@footnote{좀 더 좋은 방법은 matrix square root @eqn{B, B}를 찾는 것입니다. 
여기에서 @eqn{A = BB^T, A = BB'}이며, @eqn{A, A}의 콜레스키 분해 (Cholesky) 또는 eigendecomposition를 이용하여 @eqn{By = x, By = x}의 해들에 대한 the squared length 를 찾는것입니다.} 


@node Eigenvalues and eigenvectors, Singular value decomposition and determinants, Linear equations and inversion, Matrix facilities
@c @subsection Eigenvalues and eigenvectors
@subsection 고유값과 고유벡터
@cindex Eigenvalues and eigenvectors

@findex eigen
@c The function @code{eigen(Sm)} calculates the eigenvalues and
@c eigenvectors of a symmetric matrix @code{Sm}.  The result of this
@c function is a list of two components named @code{values} and
@c @code{vectors}.  The assignment

함수 @code{eigen(Sm)}는 대칭행렬 (symmetric matrix) @code{Sm} 의 고유값 (eigenvalues)과 고유벡터 (eigenvectors)를 계산해주며 아래에서 보이는 것처럼 사용합니다.

@example
> ev <- eigen(Sm)
@end example

@noindent
@c will assign this list to @code{ev}.  Then @code{ev$val} is the vector of
@c eigenvalues of @code{Sm} and @code{ev$vec} is the matrix of
@c corresponding eigenvectors.  Had we only needed the eigenvalues we could
@c have used the assignment:
이 함수를 적용한 결과는 @code{values}라는 고유값 벡터와 @code{vectors}라는 고유벡터들의 행렬을 구성요소로 가지는 리스트입니다.
따라서, 고유값 벡터는 @code{ev$val}라고 함으로서 얻을 수 있고, 고유벡터들의 행렬들은 @code{ev$eigen}을 통해 얻을 수 있습니다.
만약 사용자가 단순히 고유값만을 얻어 @code{evals}에 저장하고 싶다면 아래와 같이 할 수 있습니다. 
이때 @code{evals}는 고유벡터에 대한 결과는 가지지 않습니다.

@example
> evals <- eigen(Sm)$values
@end example

@noindent
@c @code{evals} now holds the vector of eigenvalues and the second
@c component is discarded.  If the expression

만약, 아래와 같이 @code{eigen} 함수를 사용한다면 고유값 벡터와 고유벡터들의 행렬 모두 출력됩니다.
@example
> eigen(Sm)
@end example

@noindent
@c is used by itself as a command the two components are printed, with
@c their names.  For large matrices it is better to avoid computing the
@c eigenvectors if they are not needed by using the expression

행렬의 크기가 크고, 고유벡터들에 대한 정보보다는 고유값 벡터에 대한 정보만이 필요한 경우 아래와 같이 할 수 있습니다.

@example
> evals <- eigen(Sm, only.values = TRUE)$values
@end example

@node Singular value decomposition and determinants, Least squares fitting and the QR decomposition, Eigenvalues and eigenvectors, Matrix facilities
@c @subsection Singular value decomposition and determinants
@subsection 특이해 분해법과 행렬계수
@cindex Singular value decomposition

@findex svd
@c The function @code{svd(M)} takes an arbitrary matrix argument, @code{M},
@c and calculates the singular value decomposition of @code{M}.  This
@c consists of a matrix of orthonormal columns @code{U} with the same
@c column space as @code{M}, a second matrix of orthonormal columns
@c @code{V} whose column space is the row space of @code{M} and a diagonal
@c matrix of positive entries @code{D} such that @code{M = U %*% D %*%
@c t(V)}.  @code{D} is actually returned as a vector of the diagonal
@c elements.  The result of @code{svd(M)} is actually a list of three
@c components named @code{d}, @code{u} and @code{v}, with evident meanings.

@c If @code{M} is in fact square, then, it is not hard to see that

함수 @code{svd(M)}는 @code{M}이라는 임의의 행렬을 인자로 가지며 특이해분해 (the singular value decomposition)을 수행합니다.
이 함수로부터는 세가지 결과가 얻어집니다.
첫번째는 @code{M}행렬의 열을 기초로 하는 직교행렬 (orthonormal matrix) @code{U}이고,
두번째는 @code{M}행렬의 행을 기초로 한 직교행렬 @code{V}이며,
세번째는 @code{M = U %*% D %*% t(V)}이라는 조건을 만족하는 대각행렬 @code{D}입니다.
@code{svd(M)}의 실제 계산결과는 위의 세가지를 구성요소로 가지는 리스트이며, 각 구성요소들은 @code{d}, @code{u}, @code{v}라는 이름을 가집니다.

만약, 행렬 @code{M}의 행렬계수 (determinant)의 절대값을 구하고자 한다면, 아래와 같은 방법으로 특이해분해를 이용할 수 있습니다.

@example
> absdetM <- prod(svd(M)$d)
@end example

@noindent
@c calculates the absolute value of the determinant of @code{M}.  If this
@c calculation were needed often with a variety of matrices it could be
@c defined as an @R{} function

또한, 아래와 같이 사용자 정의함수 @code{abdet()}를 작성하여 사용할수도 있습니다.

@example
> absdet <- function(M) prod(svd(M)$d)
@end example

@cindex Determinants
@noindent
@c after which we could use @code{absdet()} as just another @R{} function.
@c As a further trivial but potentially useful example, you might like to
@c consider writing a function, say @code{tr()}, to calculate the trace of
@c a square matrix.  [Hint: You will not need to use an explicit loop.
@c Look again at the @code{diag()} function.]

또 다른 예로는 정방행렬의 트레이스(trace)를 계산해주는 @code{tr()}이라는 함수를 작성할 수도 있습니다.

@findex det
@findex determinant
@c @R{} has a builtin function @code{det} to calculate a determinant,
@c including the sign, and another, @code{determinant}, to give the sign
@c and modulus (optionally on log scale),

@R{}은 행렬계수 (determinant)를 구하는데 사용되는 함수 @code{det}를 제공합니다.
또한 함수 @code{determinant}는 이의 부호와 모듈러스의 결과도 함께 알려줍니다.

@c Functions will be discussed formally later in these notes.

@node Least squares fitting and the QR decomposition,  , Singular value decomposition and determinants, Matrix facilities
@c @subsection Least squares fitting and the QR decomposition
@subsection 최소제곱적합과 QR 분해
@cindex Least squares fitting
@cindex QR decomposition

@c The function @code{lsfit()} returns a list giving results of a least
@c squares fitting procedure.  An assignment such as

함수 @code{lsfit()}은 최소제곱적합 (least squares fitting)을 수행하여 얻은 결과를 리스트의 형식으로 돌려줍니다.
만약, @code{y}는 관측값 벡터이고, @code{X}는 디자인 행렬이라고 할때, 아래와 같이 사용된 함수 @code{lsfit()}는 최소제곱법 (least square)을 이용하여 적합된 값을 @code{ans}에 할당하는 것입니다. 

@example
> ans <- lsfit(X, y)
@end example
@findex lsfit

@noindent
@c gives the results of a least squares fit where @code{y} is the vector of
@c observations and @code{X} is the design matrix.  See the help facility
@c for more details, and also for the follow-up function @code{ls.diag()}
@c for, among other things, regression diagnostics.  Note that a grand mean
@c term is automatically included and need not be included explicitly as a
@c column of @code{X}.  Further note that you almost always will prefer
@c using @code{lm(.)} (@pxref{Linear models}) to @code{lsfit()} for
@c regression modelling.

더 자세한 사항은 도움말을 참조하시길 바랍니다.
만약, 최소제곱법을 이용한 회귀분석을 통한 모델진단에 대해서 알고 싶으시다면 함수 @code{ls.diag()}를 살펴보시길 바랍니다. 
그러나, 회귀분석을 수행하고자 한다면 @code{lsfit()}을 이용하기 보다는 @code{lm(.)}를 사용하는 것이 더욱 편리하며, 이에 대해서는 @ref{Linear models}를 살펴보시길 바랍니다.

@findex qr
@c Another closely related function is @code{qr()} and its allies.
@c Consider the following assignments

다음의 코드는 @code{qr()} 함수를 활용하여 회귀분석을 수행하는 것입니다.
여기에서 @code{b}는 회귀계수를, @code{fit}은 벡터 @code{y}가 @code{X}에 직사영(orthogonal projection)된 값(즉, fitted 된 값)을, 그리고 @code{res}는 잔차 (the projection onto the orthogonal complement)입니다.
특히, @code{b}의 결과는 @sc{Matlab}에서 `백슬래쉬' 연산자를 이용하여 얻은 것과 동일합니다.
@example
> Xplus <- qr(X)
> b <- qr.coef(Xplus, y)
> fit <- qr.fitted(Xplus, y)
> res <- qr.resid(Xplus, y)
@end example

@noindent
@c These compute the orthogonal projection of @code{y} onto the range of
@c @code{X} in @code{fit}, the projection onto the orthogonal complement in
@c @code{res} and the coefficient vector for the projection in @code{b},
@c that is, @code{b} is essentially the result of the @sc{Matlab}
@c `backslash' operator.

@c It is not assumed that @code{X} has full column rank.  Redundancies will
@c be discovered and removed as they are found.

디자인 행렬 @code{X}가 이 full column rank이라는 조건을 만족해야 하는 것은 아닙니다.
만약, 이 조건이 만족하지 않으면 선형독립이 아닌 열들을 찾아내고 이들을 제거할 것입니다.

@c This alternative is the older, low-level way to perform least squares
@c calculations.  Although still useful in some contexts, it would now
@c generally be replaced by the statistical models features, as will be
@c discussed in @ref{Statistical models in R}.


@node Forming partitioned matrices, The concatenation function c() with arrays, Matrix facilities, Arrays and matrices
@c @section Forming partitioned matrices, @code{cbind()} and @code{rbind()}
@section @code{cbind()}과 @code{rbind()}
@findex cbind
@findex rbind

@c As we have already seen informally, matrices can be built up from other
@c vectors and matrices by the functions @code{cbind()} and @code{rbind()}.
@c Roughly @code{cbind()} forms matrices by binding together matrices
@c horizontally, or column-wise, and @code{rbind()} vertically, or
@c row-wise.

위에서도 잠깐 언급했었지만, @code{cbind()}와 @code{rbind()}라는 함수는 벡터와 행렬을 열방향 혹은 행방향으로 묶어 새로운 행렬을 생성할 때 이용됩니다.

@c In the assignment
아래에서 사용된 함수 @code{cbind()}에 사용되는 입력인자는 임의의 길이를 가진 벡터 또는 행렬입니다.
단, 인자로서 사용되는 행렬들은 각각의 행렬이 같은 수의 행을 가지고 있어야 합니다. 

@example
> X <- cbind(@var{arg_1}, @var{arg_2}, @var{arg_3}, @dots{})
@end example

@noindent
@c the arguments to @code{cbind()} must be either vectors of any length, or
@c matrices with the same column size, that is the same number of rows.
@c The result is a matrix with the concatenated arguments @var{arg_1},
@c @var{arg_2}, @dots{} forming the columns.


@c If some of the arguments to @code{cbind()} are vectors they may be
@c shorter than the column size of any matrices present, in which case they
@c are cyclically extended to match the matrix column size (or the length
@c of the longest vector if no matrices are given).

@c The function @code{rbind()} does the corresponding operation for rows.
@c In this case any vector argument, possibly cyclically extended, are of
@c course taken as row vectors.

함수 @code{rbind()}는 함수 @code{cbind()}와 유사한 기능을 가지고 있으나, 입력받는 모든 인자들 각각이 가지는 열의 개수가 동일해야만 합니다. 

@c Suppose @code{X1} and @code{X2} have the same number of rows.  To
@c combine these by columns into a matrix @code{X}, together with an
@c initial column of @code{1}s we can use

예를 들어, @code{X1}과 @code{X2}라는 두 행렬이 같은 개수의 행을 가지고 있다고 가정합니다.
아래에서 보여지는 것과 같이 @code{X}는 @code{1}, @code{X1}, @code{X2}라는 인자를 가지는데, 여기에서 @code{1}이라는 인자는 @code{X1}이 가진 행의 길이만큼 @code{1}을 리사이클링 시켜 @code{1}이라는 열벡터를 생성한뒤, @code{1}, @code{X1}, @code{X2}를 열방향으로 한데 묶어 @code{X}라는 새로운 행렬을 생성시켜 줍니다.

@example
> X <- cbind(1, X1, X2)
@end example

@c The result of @code{rbind()} or @code{cbind()} always has matrix status.
@c Hence @code{cbind(x)} and @code{rbind(x)} are possibly the simplest ways
@c explicitly to allow the vector @code{x} to be treated as a column or row
@c matrix respectively.

@code{rbind()} 또는 @code{cbind()}의 사용으로 얻어진 결과는 항상 행렬입니다.
따라서, @code{cbind(x)}와 @code{rbind(x)}는 벡터 @code{x}를 행벡터 혹은 열벡터로 표현할 수 있는 유용한 함수들입니다.

@node The concatenation function c() with arrays, Frequency tables from factors, Forming partitioned matrices, Arrays and matrices
@c @section The concatenation function, @code{c()}, with arrays
@section 배열과 함께 사용할 수 있는 결합함수 @code{c()}

@c It should be noted that whereas @code{cbind()} and @code{rbind()} are
@c concatenation functions that respect @code{dim} attributes, the basic
@c @code{c()} function does not, but rather clears numeric objects of all
@c @code{dim} and @code{dimnames} attributes.  This is occasionally useful
@c in its own right.

만약, @code{cbind()}와 @code{rbind()} 함수들이 행렬의 @code{dim} 속성을 기초로 여러개의 행렬을 한데 묶어준다고 한다면, 
함수 @code{c()}는 @code{dim}과 @code{dimnames} 속성 모두를 무시한 채 결합을 수행한다고 할 수 있습니다. 
따라서, @code{c()}를 이용하는 것이 때때로 더 유용한 경우가 있습니다.

@c The official way to coerce an array back to a simple vector object is to
@c use @code{as.vector()}

본래 이렇게 주어진 속성들을 무시하고, 배열을 단순 벡터로 강제형변환하는 방법은 아래와 같이 @code{as.vector()}이라는 함수를 이용하는 것입니다.

@example
> vec <- as.vector(X)
@end example
@findex as.vector

@c However a similar result can be achieved by using @code{c()} with just
@c one argument, simply for this side-effect:

이와 같은 결과를 아래와 같이 함수 @code{c()}를 이용하여 얻을 수도 있습니다. 

@example
> vec <- c(X)
@end example
@findex c

@c There are slight differences between the two, but ultimately the choice
@c between them is largely a matter of style (with the former being
@c preferable).

실제로는 다소 다른 점이 존재하기는 하지만, 어떤 함수를 이용하여 이를 수행할 것인가는 단순히 프로그래밍 스타일의 차이일뿐입니다.

@node Frequency tables from factors,  , The concatenation function c() with arrays, Arrays and matrices
@c @section Frequency tables from factors
@section 요인을 이용한 도수분포표
@cindex Tabulation

@c Recall that a factor defines a partition into groups.  Similarly a pair
@c of factors defines a two way cross classification, and so on.
@findex table
@c The function @code{table()} allows frequency tables to be calculated
@c from equal length factors.  If there are @math{k} factor arguments,
@c the result is a @math{k}-way array of frequencies.

위에서 데이터를 그룹화하는데 요인 (factor)이 사용됨을 보았습니다. 
만약 2개의 요인이 존재한다면 2차원 분류 (two way cross classification)가 가능할 것이고, 더 나아가 k 개의 요인이 있다면 k-차원의 분류가 가능할 것입니다.
함수 @code{table()}은 이러한 분류가 가능하도록 도와줍니다. 
만약, 여러 개의 수준을 가진 지역코드란 요인에 대한 정보가 @code{statef}에 저장되어 있다면, 지역코드별 도수분포를 아래와 같이 구할 수 있습니다. 
이때 각 도수는 수준 (level)이 가진 이름순으로 정렬됩니다. 

@c Suppose, for example, that @code{statef} is a factor giving the state
@c code for each entry in a data vector.  The assignment

@example
> statefr <- table(statef)
@end example

@noindent
@c gives in @code{statefr} a table of frequencies of each state in the
@c sample.  The frequencies are ordered and labelled by the @code{levels}
@c attribute of the factor.  This simple case is equivalent to, but more
@c convenient than,

이와 동일한 역할을 수행하는 또 다른 방법은 다음과 같습니다.

@example
> statefr <- tapply(statef, statef, length)
@end example

@c Further suppose that @code{incomef} is a factor giving a suitably
@c defined ``income class'' for each entry in the data vector, for example
@c with the @code{cut()} function:

지역별 코드의 경우에는 데이터값이 이산형이지만, 소득수준의 경우는 연속형의 데이터를 가집니다. 
이런 경우, 소득수준 (``income class'')에 대한 구간을 나누는 편리한 방법은 아래와 같이 @code{cut()}이라는 함수를 사용하는 것입니다.

@example
> factor(cut(incomes, breaks = 35+10*(0:7))) -> incomef
@end example
@findex cut

@c Then to calculate a two-way table of frequencies:

이렇게 함수 @code{cut()}을 이용하여 구간화된 @code{incomef}라는 요인을 이용하여 지역코드별 소득수준에 대한 도수분포를 아래와 같이 보여줄 수 있습니다. 

@example
> table(incomef,statef)
         statef
incomef   act nsw nt qld sa tas vic wa
  (35,45]   1   1  0   1  0   0   1  0
  (45,55]   1   1  1   1  2   0   1  3
  (55,65]   0   3  1   3  2   2   2  1
  (65,75]   0   1  0   0  0   0   1  0
@end example

@c Extension to higher-way frequency tables is immediate.

@node Lists and data frames, Reading data from files, Arrays and matrices, Top
@c @chapter Lists and data frames
@chapter 리스트와 데이터프레임

@menu
* Lists::                       
* Constructing and modifying lists::  
* Data frames::                 
@end menu

@node Lists, Constructing and modifying lists, Lists and data frames, Lists and data frames
@c @section Lists
@section 리스트
@cindex Lists

@c An @R{} @emph{list} is an object consisting of an ordered collection of
@c objects known as its @emph{components}.

@c There is no particular need for the components to be of the same mode or
@c type, and, for example, a list could consist of a numeric vector, a
@c logical value, a matrix, a complex vector, a character array, a
@c function, and so on.  Here is a simple example of how to make a list:

@R{}에서 @emph{리스트(list)}라는 것은 @emph{컴포넌트 (components)}라고 불리는 객체들의 집합입니다.
독자는 벡터, 행렬, 혹은 배열과 같이 @R{}에서 제공되는 또 다른 데이터 구조라고 생각해 두시길 바랍니다.
그러나, 리스트가 벡터, 행렬, 혹은 배열과 같은 데이터형과 구분되는 점은 리스트의 구성요소 (즉, 컴포넌트)들의 모드가 같지 않아도 된다는 점입니다.
예를들면, 수치형 벡터의 모든 구성원소는 수치형 모드를 가져야만 했습니다.
그러나, 리스트의 구성요소는 모두 동일한 모드를 가질 필요가 없이, 수치형 벡터, 논리형 벡터, 행렬, 복소수형 벡터, 문자형 배열, 그리고 함수 등의 객체들이 복합적으로 사용될 수 있습니다.
다음은 리스트를 생성하는 간단한 예를 보여줍니다.

@example
> Lst <- list(name="Fred", wife="Mary", no.children=3,
              child.ages=c(4,7,9))
@end example
@findex list

@c Components are always @emph{numbered} and may always be referred to as
@c such.  Thus if @code{Lst} is the name of a list with four components,
@c these may be individually referred to as @code{Lst[[1]]},
@c @code{Lst[[2]]}, @code{Lst[[3]]} and @code{Lst[[4]]}.  If, further,
@c @code{Lst[[4]]} is a vector subscripted array then @code{Lst[[4]][1]} is
@c its first entry.

리스트의 구성객체인 컴포넌트들은 항상 @emph{숫자로 구분(numbered)}되어 있어, 각각의 컴포넌트들을 이에 상응하는 숫자 (즉, 컴포넌트 인덱스)를 이용하여 접근이 가능합니다.
독자는 벡터에서 구성요소를 인덱스를 활용하여 인덱스에 상응하는 구성요소의 값에 접근했었음을 기억하실 것입니다.
이와 동일한 원리로 생각하시면 됩니다.
예를 들어, 위와 같이 4개의 컴포넌트들로 구성된 리스트 @code{Lst}가 있다면, 각각의 컴포넌트는 @code{Lst[[1]]},@code{Lst[[2]]}, @code{Lst[[3]]} 그리고, @code{Lst[[4]]}라고 사용함으로서 접근할 수 있습니다.
더 나아가, 마지막 네번째 컴포넌트 @code{Lst[[4]]}의 첫번째 구성요소의 값을 알고자 한다면, @code{Lst[[4]][1]}이라고 하면 됩니다.

@c If @code{Lst} is a list, then the function @code{length(Lst)} gives the
@c number of (top level) components it has.

만약 리스트가 몇개의 컴포넌트로 구성된지 모를 경우 @code{length()} 함수를 이용하면 됩니다.
예를들어 위에서 사용한 @code{Lst}라는 리스트를 예를 들면, @code{length(Lst)}은 4라는 값을 알려줄 것입니다.

@c Components of lists may also be @emph{named}, and in this case the
@c component may be referred to either by giving the component name as a
@c character string in place of the number in double square brackets, or,
@c more conveniently, by giving an expression of the form

컴포넌트 인덱스를 이용하는 방법외에도 리스트의 컴포넌트들을 접근하는 방법은 아래와 같이 @emph{컴포넌트에 주어진 이름}을 활용하는 것입니다.

@example
> @var{name}$@var{component_name}
@end example

@noindent
@c for the same thing.

@c This is a very useful convention as it makes it easier to get the right
@c component if you forget the number.

@c So in the simple example given above:

@c @code{Lst$name} is the same as @code{Lst[[1]]} and is the string
@c @code{"Fred"},

@c @code{Lst$wife} is the same as @code{Lst[[2]]} and is the string
@c @code{"Mary"},

@c @code{Lst$child.ages[1]} is the same as @code{Lst[[4]][1]} and is the
@c number @code{4}.

@var{name}는 리스트의 이름이고, 스트링($) 뒤의 @var{component_name}는 컴포넌트의 이름입니다.
이렇게 이름을 사용하는 방법은 사용자가 컴포넌트 인덱스를 일일이 기억하지 않도록 도와줍니다. 
위에서 사용된 예제를 다시 보면, @code{Lst$name}이라는 것은 @code{Lst[[1]]}와 동일하고, @code{"Fred"}라는 값을 가집니다.
@code{Lst$wife}는 @code{Lst[[2]]}와 동일하고 @code{"Mary"}라는 값을 가집니다.
@code{Lst$child.ages[1]} 역시 @code{Lst[[4]][1]}동일하며, @code{4}라는 값을 가집니다.

@c Additionally, one can also use the names of the list components in
@c double square brackets, i.e., @code{Lst[["name"]]} is the same as
@c @code{Lst$name}.  This is especially useful, when the name of the
@c component to be extracted is stored in another variable as in

또한, @code{Lst[["name"]]}와 @code{Lst$name}은 동일한 표현입니다.
이것은 아래와 같이 리스트의 이름을 다른 변수에 따로 저장하여 활용 할 수 있도록 하는 아주 유용한 기능입니다.

@example
> x <- "name"; Lst[[x]]
@end example

@c It is very important to distinguish @code{Lst[[1]]} from @code{Lst[1]}.
@c @samp{@code{[[@var{@dots{}}]]}} is the operator used to select a single
@c element, whereas @samp{@code{[@var{@dots{}}]}} is a general subscripting
@c operator.  Thus the former is the @emph{first object in the list}
@c @code{Lst}, and if it is a named list the name is @emph{not} included.
@c The latter is a @emph{sublist of the list @code{Lst} consisting of the
@c first entry only.  If it is a named list, the names are transferred to
@c the sublist.}

리스트를 사용함에 있어서 @code{Lst[[1]]}와 @code{Lst[1]}를 구분하는 것은 매우 중요합니다. 
@samp{@code{[[@var{@dots{}}]]}}은 한 개의 구성객체 (컴포넌트)에 접근하기 위해 사용되는 연산자인 반면,
@samp{@code{[@var{@dots{}}]}}은 일반적인 첨자로 사용되는 서브리스트(sublist)로서 사용되는 연산자 입니다.
따라서, 전자는 @emph{리스트 @code{Lst}의 첫번째 구성객체}를 나타내므로 만약 컴포넌트에 이름이 있어도 이름이 없이 해당 구성객체만을 접근하게 됩니다.
후자는 리스트 @code{Lst}의 첫번째 항목만을 가지는 서브리스트 (sublit)이므로 구성객체에 이름이 있다면 이름과 함께 리스트의 첫번째 객체를 하위 리스트형식으로 접근하게 됩니다.

@c The names of components may be abbreviated down to the minimum number of
@c letters needed to identify them uniquely.  Thus @code{Lst$coefficients}
@c may be minimally specified as @code{Lst$coe} and @code{Lst$covariance}
@c as @code{Lst$cov}.

만약 리스트를 구성하는 컴포넌트들의 이름이 길다면, @R{}은 동일한 이름이 없는 한 컴포넌트들을 구분할 수 있는 약어기능을 제공합니다. 
예를들면, 리스트 @code{Lst}가 @code{coefficients}와 @code{covariance}라는 이름의 두 개의 컴포넌트들을 가지고 있다면, 
이들을 접근하기 위해서  @code{Lst$coefficients} 또는 @code{Lst$covariance}라고 할 필요가 없이 @code{Lst$coe}또는 @code{Lst$cov}와 같이 사용할 수 있습니다. 

@c The vector of names is in fact simply an attribute of the list like any
@c other and may be handled as such.  Other structures besides lists may,
@c of course, similarly be given a @emph{names} attribute also.

@node Constructing and modifying lists, Data frames, Lists, Lists and data frames
@c @section Constructing and modifying lists
@section 리스트를 생성하고 수정하기

@c New lists may be formed from existing objects by the function
@c @code{list()}.  An assignment of the form

만약 이미 작업하고 있던 여러개의 객체가 존재한다면, 
@code{list()} 함수를 이용하여 새로운 리스트를 생성할 수 도 있습니다. 
아래에서 보이는 바와 같이 @code{object_1}이라는 객체를 첫번째 컴포넌트로 @code{name_1}이라는 이름과 함께 사용할 것이며, 
이와 같은 방법으로 @code{m}개의 객체를 가지는 새로운 리스트를 정의하겠다는 의미입니다.

@example
> Lst <- list(@var{name_1}=@var{object_1}, @var{@dots{}}, @var{name_m}=@var{object_m})
@end example

@noindent
@c sets up a list @code{Lst} of @math{m} components using @var{object_1},
@c @dots{}, @var{object_m} for the components and giving them names as
@c specified by the argument names, (which can be freely chosen).  If these
@c names are omitted, the components are numbered only.  The components
@c used to form the list are @emph{copied} when forming the new list and
@c the originals are not affected.

만약, 컴포넌트에 사용할 이름이 정해지지 않았다면, @R{}은 자동으로 몇 번째 컴포넌트인지 숫자를 이름으로 사용하게 됩니다.
새로운 리스트가 생성될 때 기존의 객체들은 단순히 컴포넌트로서 복사 되는 것이기 때문에 새로운 리스트가 정의되어도 기존의 객체들은 아무런 영향을 받지 않습니다.

@c Lists, like any subscripted object, can be extended by specifying
@c additional components.  For example

만약, 리스트에 새로운 컴포넌트를 추가하고 싶을 경우에는 아래와 같이 첨자를 이용할 수 있습니다.

@example
> Lst[5] <- list(matrix=Mat)
@end example

@menu
* Concatenating lists::         
@end menu

@node Concatenating lists,  , Constructing and modifying lists, Constructing and modifying lists
@c @subsection Concatenating lists
@subsection 리스트 결합하기
@cindex Concatenating lists

@findex c
@c When the concatenation function @code{c()} is given list arguments, the
@c result is an object of mode list also, whose components are those of the
@c argument lists joined together in sequence.

만약 여러개의 리스트를 한데 묶고 싶다면 아래와 같이 함수 @code{c()}를 이용하면 사용된 순서대로 한데 묶인 새로운 리스트를 생성해 줍니다.

@example
> list.ABC <- c(list.A, list.B, list.C)
@end example

@c Recall that with vector objects as arguments the concatenation function
@c similarly joined together all arguments into a single vector structure.
@c In this case all other attributes, such as @code{dim} attributes, are
@c discarded.

@node Data frames,  , Constructing and modifying lists, Lists and data frames
@c @section Data frames
@section 데이터 프레임
@cindex Data frames

@c A @emph{data frame} is a list with class @code{"data.frame"}.  There are
@c restrictions on lists that may be made into data frames, namely
@emph{데이터 프레임 (data frame)}은 @code{"data.frame"}이라는 클래스를 가진 리스트의 특수한 경우입니다.
데이터 프레임은 리스트와 구분되는 몇가지 특징이 있습니다.

@itemize @bullet
@item
@c The components must be vectors (numeric, character, or logical),
@c factors, numeric matrices, lists, or other data frames.
데이터 프레임에 입력될 수 있는 자료는 반드시 (수치형, 문자형, 혹은 논리형) 벡터, 수치형 행렬, 리스트, 또는 다른 데이터 프레임이어야만 합니다.

@item
@c Matrices, lists, and data frames provide as many variables to the new
@c data frame as they have columns, elements, or variables, respectively.
데이터 프레임을 구성하는 각각의 열은 변수로 인식되므로, 입력되는 행렬의 열의 개수, 리스트의 컴포넌트 개수, 혹은 데이터 프레임의 변수의 개수만큼 새로운 데이터 프레임은 자동으로 이들의 개수만큼 확장되어 생성되어 집니다. 

@item
@c Numeric vectors, logicals and factors are included as is, and by
@c default@footnote{Conversion of character columns to factors is
@c overridden using the @code{stringsAsFactors} argument to the
@c @code{data.frame()} function.} character vectors are coerced to be
@c factors, whose levels are the unique values appearing in the vector.
데이터 프레임에 입력되는 수치형, 문자형, 그리고 논리형 벡터는 모두 요인으로 강제형변환이 이루어지게 되며, 입력된 벡터내에 중복되지 않은 값들이 요인의 수준으로 간주되어 집니다 @footnote{문자형 벡터는 @code{data.frame()}함수의 인자 @code{stringsAsFactors}을 이용하여 입력시 요인으로 강제변환이 가능합니다}.
 
@item
@c Vector structures appearing as variables of the data frame must all have
@c the @emph{same length}, 
@c and matrix structures must all have the same
@c @emph{row size}.
데이터프레임 내에 있는 모든 변수 (즉, 열벡터)는 @emph{동일한 길이 (same length)}를 가져야 합니다.
@end itemize

@c A data frame may for many purposes be regarded as a matrix with columns
@c possibly of differing modes and attributes.  It may be displayed in
@c matrix form, and its rows and columns extracted using matrix indexing
@c conventions.

데이터 프레임을 단순히 추가적인 모드(mode)와 속성(attribute)을 가진 행렬로 보아도 무방합니다. 
행렬에서 인덱스 벡터와 인덱스 행렬을 이용하여 행렬의 부분집합을 구한 것과 동일한 방법으로 데이터프레임의 일부분을 임의선택 할 수 있습니다.

@menu
* Making data frames::          
* attach() and detach()::       
* Working with data frames::    
* Attaching arbitrary lists::   
* Managing the search path::    
@end menu

@node Making data frames, attach() and detach(), Data frames, Data frames
@c @subsection Making data frames
@subsection 데이터 프레임 생성하기

@c Objects satisfying the restrictions placed on the columns (components)
@c of a data frame may be used to form one using the function
@c @code{data.frame}:
@c @findex data.frame

데이터 프레임은 아래에서 보이는 것과 같이 @code{data.frame} 함수내에 데이터 프레임에서 사용될 각각의 열에 대한 변수명과 이에 상응하는 데이터 벡터를 지정함으로서 생성할수 있습니다. 
위의 예제에서 사용된 @code{statef}는 이산형 데이터를 가지는 벡터이고, @code{incomes}는 연속형 데이터를 가지는 벡터, 그리고 @code{incomef}는 구간화 된 값을 가지는 벡터입니다. 
따라서 새로이 생성될 데이터 프레임 @code{accountants}은 @code{home}, @code{loot}, 그리고 @code{shot} 이라는 세가지 변수를 가질 것인데, @code{home}변수는 @code{statef}의 데이터가, @code{loot} 변수에는 @code{incomes} 데이터가, 그리고 @code{shot} 변수에는 @code{incomef}이라는 데이터 벡터가 이용될 것이라는 것을 의미하게 됩니다.

@example
> accountants <- data.frame(home=statef, loot=incomes, shot=incomef)
@end example

@c A list whose components conform to the restrictions of a data frame may
@c be @emph{coerced} into a data frame using the function
@c @code{as.data.frame()}
@c @findex as.data.frame

@c The simplest way to construct a data frame from scratch is to use the
@c @code{read.table()} function to read an entire data frame from an
@c external file.  This is discussed further in @ref{Reading data from
@c files}.

만약 이미 벡터로 구성된 리스트가 존재한다면, @code{as.data.frame()} 함수를 이용하여 리스트를 데이터 프레임의 형식으로 강제형변환 시킬 수 있습니다. 
데이터 프레임을 생성하는 가장 편리한 방법은 @code{read.table()} 함수를 이용하여 컴퓨터에 저장되어 있는 데이터 파일을 불러들어오는 것입니다. 
이것에 대해서는 @ref{Reading data from files}에서 더 다루도록 하겠습니다.

@node attach() and detach(), Working with data frames, Making data frames, Data frames
@c @subsection @code{attach() and @code{detach()}}
@subsection @code{attach()와 @code{detach()}}
@findex attach
@findex detach

@c The @code{$} notation, such as @code{accountants$home}, for list
@c components is not always very convenient.  A useful facility would be
@c somehow to make the components of a list or data frame temporarily
@c visible as variables under their component name, without the need to
@c quote the list name explicitly each time.

스트링(@code{$}) 연산자는 리스트의 컴포넌트에 접근시에 사용했었습니다. 
그러나, 데이터 프레임 @code{accountants}에 정의 되어 있는 @code{home}에 접근하기 위해서 @code{accountants$home}와 같이 사용하는것은 많은 불편함이 있습니다. 
따라서 @R{}은 @code{attach()}라는 함수를 제공하여 이러한 불편함을 줄이고자 했습니다.

@c The @code{attach()} function takes a `database' such as a list or data
@c frame as its argument.  Thus suppose @code{lentils} is a
@c data frame with three variables @code{lentils$u}, @code{lentils$v},
@c @code{lentils$w}.  The attach

예를들어 @code{lentils$u}, @code{lentils$v}, @code{lentils$w}라는 세개의 변수로 구성된 @code{lentils}이라는 데이터 프레임이 있다고 가정합니다. 
아래에서 보이는 것과 같이 @code{attach()} 함수의 사용은 탐색경로(search path)를 자동으로 position 1(작업공간내 객체를 검색하는 최상위 탐색경로)에서 position 2 (작업공간내 존재하는 특정 객체의 내부를 검색하는 탐색경로)로 변경하는 역할을 수행합니다. 
따라서, @code{attach(lentils)}라는 명령은 작업공간 내 @code{lentils}이라는 특정한 데이터프레임 내부내에서 사용되는 @code{u}, @code{v}, @code{w}을 데이터프레임의 이름없이 검색이 가능하도록 해줍니다.

@example
> attach(lentils)
@end example

@c @noindent
@c places the data frame in the search path at @w{position 2}, and provided
@c there are no variables @code{u}, @code{v} or @code{w} in @w{position 1},
@c @code{u}, @code{v} and @code{w} are available as variables from the data
@c frame in their own right.  At this point an assignment such as

@code{attach()}를 사용하기 전에 반드시 알아야 할 점이 있습니다. 
예를들어, 아래의 명령은 @code{lentils}내 변수 @code{v}와 @code{w}의 더하기 연산의 결과를 @code{u}에 대입할 것을 의미합니다.
그러나 이러한 대입은 데이터 프레임 @code{lentils}내에 @code{u}라는 변수에 저장되지 않습니다. 
그 이유는 어떠한 연산결과의 할당 및 대입은 최상위 탐색경로 @w{position 1}에서 이루어져 새로운 @code{u}라는 벡터를 생성해 내기 때문입니다.

@example
> u <- v+w
@end example

@c @noindent
@c does not replace the component @code{u} of the data frame, but rather
@c masks it with another variable @code{u} in the working directory at
@c @w{position 1} on the search path.  To make a permanent change to the
@c data frame itself, the simplest way is to resort once again to the
@c @code{$} notation:

만약, @code{lentils}라는 데이터 프레임내에 있는 @code{u}라는 변수에 연산결과를 할당하고 싶다면 반드시 아래에서 보이는 것과 같이 @code{$}를 사용하여야 합니다. 

@example
> lentils$u <- v+w
@end example

@c However the new value of component @code{u} is not visible until the
@c data frame is detached and attached again.
그러나, @code{u}의 값들은 @code{lentils} 데이터 프레임이 @code{detach()} 함수된 후 다시 @code{attach()} 함수가 사용될 때까지는 육안으로 확인할 수 없습니다.

@c To detach a data frame, use the function

아래의 @code{detach()} 함수는 현재 사용하고 있는 특정 데이터 프레임에 대한 탐색경로 @w{position 2}를 @w{position 1}로 재변경을 해주는 역할을 합니다.

@example
> detach()
@end example

@c More precisely, this statement detaches from the search path the entity
@c currently at @w{position 2}.  Thus in the present context the variables
@c @code{u}, @code{v} and @code{w} would be no longer visible, except under
@c the list notation as @code{lentils$u} and so on.  Entities at positions
@c greater than 2 on the search path can be detached by giving their number
@c to @code{detach}, but it is much safer to always use a name, for example
@c by @code{detach(lentils)} or @code{detach("lentils")}

여러 개의 데이터의 프레임을 동시에 @code{attach()} 함수와 함께 사용할 수 있기 때문에 @code{detach(lentils)} 혹은 @code{detach("lentils")}와 같이 데이터 프레임의 이름을 정확히 명시하는게 프로그래밍의 오류를 줄이는 방법입니다.

@c @quotation Note
@c In @R{} lists and data frames can only be attached at position 2 or
@c above, and what is attached is a @emph{copy} of the original object.
@c You can alter the attached values @emph{via} @code{assign}, but the
@c original list or data frame is unchanged.
@c @end quotation

@node Working with data frames, Attaching arbitrary lists, attach() and detach(), Data frames
@c @subsection Working with data frames
@subsection 데이터 프레임들과 작업하기

@c A useful convention that allows you to work with many different problems
@c comfortably together in the same working directory is
만약 여러분들이 여러 가지 분석작업을 동일한 작업 디렉토리에서 수행하고 있다면, 
아래에 나열한 몇 가지 방법들이 오류를 최소화하는데 도움이 될 것입니다.

@itemize @bullet
@item
@c gather together all variables for any well defined and separate problem
@c in a data frame under a suitably informative name;
문제를 세분화하여, 문제별로 의미가 분명한 데이터 프레임의 이름을 부여하고, 데이터 프레임내에 정의된 변수들도 그 의미를 쉽게 알수있는 변수명을 사용하도록 합니다. 

@item
@c when working with a problem attach the appropriate data frame at
@c @w{position 2}, and use the working directory at @w{level 1} for
@c operational quantities and temporary variables;
특정 데이터 프레임을 @w{position 2}로 이동시켜 작업을 하되, 임시변수의 생성 및 연산은 @w{position 1}에서 수행하도록 합니다. 

@item
@c before leaving a problem, add any variables you wish to keep for future
@c reference to the data frame using the @code{$} form of assignment, and
@c then @code{detach()};
@w{position 2}에서의 특정 데이터 프레임과 연관된 연산이 끝났다면 @code{$}를 이용하여 그 연산결과를 저장한뒤 @code{detach()}를 이용하여 @w{position 1}으로 돌아옵니다.
@item
@c finally remove all unwanted variables from the working directory and
@c keep it as clean of left-over temporary variables as possible.
마지막으로 워킹 디렉토리에 있는 임시적으로 사용했던 변수들은 모두 삭제하도록 합니다.
@end itemize

@c In this way it is quite simple to work with many problems in the same
@c directory, all of which have variables named @code{x}, @code{y} and
@c @code{z}, for example.
많은 경우에 @code{x}, @code{y}, @code{z}와 같은 변수명들을 이용하여 같은 디렉토리내에서 많은 문제를 작업하는 것이 비일비재하기 때문입니다.

@node Attaching arbitrary lists, Managing the search path, Working with data frames, Data frames
@c @subsection Attaching arbitrary lists
@subsection 임의의 리스트를 연결하기

@c @code{attach()} is a generic function that allows not only directories
@c and data frames to be attached to the search path, but other classes of
@c object as well.  In particular any object of mode @code{"list"} may be
@c attached in the same way:

실제로 @code{attach()}는 제네릭 함수 (generic function)이므로 데이터 프레임 외에도 다른 클래스의 객체를 탐색경로(search path)와 연결하는 작업을 수행할 수 있습니다.
만약, 객체의 모드가 @code{"list"}이라면 데이터프레임과 동일한 방법으로 사용이 가능합니다.

@example
> attach(any.old.list)
@end example

@c Anything that has been attached can be detached by @code{detach}, by
@c position number or, preferably, by name.

@code{attach()}에 의해서 연결된 리스트형의 객체는 @code{detach} 함수에 의해서 그 연결이 종료됩니다.

@node Managing the search path,  , Attaching arbitrary lists, Data frames
@c @subsection Managing the search path
@subsection 탐색경로 관리하기
@findex search
@cindex Search path

@c The function @code{search} shows the current search path and so is
@c a very useful way to keep track of which data frames and lists (and
@c packages) have been attached and detached.  Initially it gives

@code{search} 함수는 현재의 탐색경로를 보여줌으로서 사용자가 현재 연결하여 작업하고 있는 데이터 프레임 및 리스트 (그리고 패키지들)를 확인할 수 있도록 해줍니다. 
기본적으로 @code{search}를 수행하면 아래와 같은 결과를 보여줍니다. 

@example
> search()
[1] ".GlobalEnv"   "Autoloads"    "package:base"
@end example
@noindent
@c where @code{.GlobalEnv} is the workspace.@footnote{See the on-line help
@c for @code{autoload} for the meaning of the second term.}
여기에서 @code{.GlobalEnv}이라는 것은 현재 작업하고 있는 작업공간을 의미합니다.
@footnote{@code{autoload}에 대해서는 온라인 도움말을 살펴보시길 바랍니다}.

@c After @code{lentils} is attached we have

만약 데이터프레임 @code{lentils}이 연결(attached)되었다면, @code{search()}는 아래와 같은 결과를 보여줍니다.

@example
> search()
[1] ".GlobalEnv"   "lentils"      "Autoloads"    "package:base"
> ls(2)
[1] "u" "v" "w"
@end example

@c @noindent
@c and as we see @code{ls} (or @code{objects}) can be used to examine the
@c contents of any position on the search path.

@code{ls} 혹은 @code{objects} 함수를 이용하여 데이터 프레임 @code{lentils}내에 어떤 객체가 있는지 확인해 볼 수 있습니다. 
여기에서 함수 @code{ls()}안에 사용된 숫자 @math{2}라는 것은 @w{position 2}에 놓인 탐색경로(serach path)를 의미하는 것입니다.

@c Finally, we detach the data frame and confirm it has been removed from
@c the search path.

마지막으로 사용하고 있던 데이터프레임 @code{lentils}을 연결종료 (detach)한다면 아래와 같은 결과를 확인할 수 있습니다.

@example
> detach("lentils")
> search()
[1] ".GlobalEnv"   "Autoloads"    "package:base"
@end example

@node Reading data from files, Probability distributions, Lists and data frames, Top
@c @chapter Reading data from files
@chapter 파일로부터 데이터 불러오기
@cindex Reading data from files

@c Large data objects will usually be read as values from external files
@c rather than entered during an @R{} session at the keyboard.  @R{} input
@c facilities are simple and their requirements are fairly strict and even
@c rather inflexible.  There is a clear presumption by the designers of
@c @R{} that you will be able to modify your input files using other tools,
@c such as file editors or Perl@footnote{Under UNIX, the utilities Sed or
@c Awk can be used.} to fit in with the requirements of @R{}.  Generally
@c this is very simple.

@c If variables are to be held mainly in data frames, as we strongly
@c suggest they should be, an entire data frame can be read directly with
@c the @code{read.table()} function.  There is also a more primitive input
@c function, @code{scan()}, that can be called directly.

@c For more details on importing data into @R{} and also exporting data,
@c see the @emph{R Data Import/Export} manual.

용량이 큰 데이터는 키보드로 입력하는 것보다는 외부에 저장되어 있는 데이터파일을 현재 작업하고 있는 @R{} 세션으로 불러들이는 것이 편리하고 빠른 방법입니다. 
@R{}의 입력기능은 사용하기 간단하지만, 다소 불편한 점이 없는 것은 아닙니다.
독자는 파일에디터(file editor) 혹은 Perl@footnote{유닉스 운영체제에서 Sed 또는 Awk와 같은 유틸리티들이 함께 사용될 수 있습니다.}과 같은 다른 프로그래밍 언어를 이용하여 먼저 @R{}에서 데이터를 읽어들일 수 있는 조건과 형식으로 변경할 수 있다는 가정하에 @R{}의 입력기능이 개발되었다는 점을 알고 계셨으면 합니다. 
 
이렇게 데이터 전처리를 실시할때 가급적이면 데이터를 쉽게 불러올 수 있도록 사용자가 데이터 파일을 데이터프레임과 같은 형식을 가지도록 편집하는 것을 권장합니다. 
만약, 데이터가 데이터 프레임과 같이 정리가 되어 있다면 @code{read.table()} 함수를 이용하여 데이터 파일안에 있는 모든 데이터를 @R{} 세션내로 불러들일 수 있습니다. 
@code{read.table()} 외에도 @code{scan()}과 같은 함수를 이용할 수 있습니다.

데이터의 입출력에 관한 더 자세한 사항에 대해서는 @emph{R Data Import/Export} 문서를 참조하시길 바랍니다.

@menu
* The read.table() function::   
* The scan() function::         
* Accessing builtin datasets::  
* Editing data::                
@end menu

@node The read.table() function, The scan() function, Reading data from files, Reading data from files
@c @section The @code{read.table()} function
@section @code{read.table()} 사용하기
@findex read.table

@c To read an entire data frame directly, the external file will normally
@c have a special form.

데이터 프레임 전체를 한번에 불러오기 위해서는, 외부 파일이 특정한 형식을 가지고 있어야만 합니다.

@itemize @bullet
@item
@c The first line of the file should have a @emph{name} for each variable
@c in the data frame.
데이터 파일내의 첫번째 행은 데이터 프레임 안으로 불러올 데이터들의 @emph{변수명}이 저장되어 있어야 합니다. 

@item
@c Each additional line of the file has as its first item a @emph{row label}
@c and the values for each variable.
데이터 파일내의 변수명 다음 행부터는 @emph{행레이블 (row label)}과 함께 변수값이 저장되어 있어야 합니다. 
@end itemize

@c If the file has one fewer item in its first line than in its second, this
@c arrangement is presumed to be in force.  So the first few lines of a file
@c to be read as a data frame might look as follows.
만약, 첫번째 행을 구성하는 항목들의 개수가 두번째 행을 구성하는 항목들의 개수보다 적을 경우, 
강제적으로 첫번째 행의 구조에 따라 맞추어지게 됩니다.
따라서, 사용자는 데이터 파일을 아래와 같은 데이터 프레임의 형식을 갖출 것을 권장합니다.

@quotation
@cartouche
@example
@r{Input file form with names and row labels:}

     Price    Floor     Area   Rooms     Age  Cent.heat
01   52.00    111.0      830     5       6.2      no
02   54.75    128.0      710     5       7.5      no
03   57.50    101.0     1000     5       4.2      no
04   57.50    131.0      690     6       8.8      no
05   59.75     93.0      900     5       1.9     yes
...
@end example
@end cartouche
@end quotation

@c By default numeric items (except row labels) are read as numeric
@c variables and non-numeric variables, such as @code{Cent.heat} in the
@c example, as factors.  This can be changed if necessary.

@c The function @code{read.table()} can then be used to read the data frame
@c directly

기본적으로 @R{}이 데이터 파일을 읽어올때, 행레이블를 제외하고서 변수의 값이 수치형이면 수치형으로, 그렇지 않다면 요인(factor)으로서 강제형변환이 이루어지게 됩니다.
위에 사용된 데이터 파일을 예로 들면, @code{Price}, @code{Floor}, @code{Area}, @code{Rooms}, @code{Age}는 수치형으로 읽어들이지만, @code{Cent.heat}는 요인(factor)으로 읽어들입니다. 
따라서 위와 같은 데이터 프레임의 형식을 가지고 있는 데이터 파일이라면 @code{read.table()} 함수를 아래와 같이 사용하여 데이터를 불러들이면 됩니다.

@example
> HousePrice <- read.table("houses.data")
@end example

@c Often you will want to omit including the row labels directly and use the
@c default labels.  In this case the file may omit the row label column as in
@c the following.

아래에 보이는 것과 같이 종종 데이터 파일에는 행레일블이 없는 경우가 있거나, 혹은 사용자가 행레이블을 원하지 않는 경우가 존재합니다.

@quotation
@cartouche
@example
@r{Input file form without row labels:}

Price    Floor     Area   Rooms     Age  Cent.heat
52.00    111.0      830     5       6.2      no
54.75    128.0      710     5       7.5      no
57.50    101.0     1000     5       4.2      no
57.50    131.0      690     6       8.8      no
59.75     93.0      900     5       1.9     yes
...
@end example
@end cartouche
@end quotation

@c The data frame may then be read as


이런 경우에는 아래와 같이 @code{read.table()} 함수를 사용시 @code{header=TRUE} 옵션을 함께 사용합니다.

@example
> HousePrice <- read.table("houses.data", header=TRUE)
@end example

@c @noindent
@c where the @code{header=TRUE} option specifies that the first line is a
@c line of headings, and hence, by implication from the form of the file,
@c that no explicit row labels are given.


@menu
* The scan() function::
@end menu

@node The scan() function, Accessing builtin datasets, The read.table() function, Reading data from files
@c @section The @code{scan()} function
@section @code{scan()} 함수 사용하기
@findex scan

@c Suppose the data vectors are of equal length and are to be read in
@c parallel.  Further suppose that there are three vectors, the first of
@c mode character and the remaining two of mode numeric, and the file is
@c @file{input.dat}.  The first step is to use @code{scan()} to read in the
@c three vectors as a list, as follows

만약에 데이터 벡터들이 같은 길이를 가지고 있고 이들은 동시에 병렬적으로 읽어들여진다고 가정합니다.
그리고, 벡터의 개수는 세개인데 첫번째 벡터는 문자형 모드를 가지고, 나머지 두 벡터는 수치형 모드를 가지며, 이 데이터 벡터들은 @code{input.dat}라는 파일내에 저장이 되어 있다고 가정합니다.
먼저 @code{scan()}함수를 이용하여 @code{input.dat} 내의 세개의 벡터를 리스트 형식으로서 불러오는 방법은 다음과 같습니다.

@example
> inp <- scan("input.dat", list("",0,0))
@end example

@c The second argument is a dummy list structure that establishes the mode
@c of the three vectors to be read.  The result, held in @code{inp}, is a
@c list whose components are the three vectors read in.  To separate the
@c data items into three separate vectors, use assignments like

@code{scan()}함수의 두번째 인자에는 어떤 모드(mode)로서 데이터의 벡터들을 읽어올 것인가에 대한 더미 리스트 구조(dummy list structure)가 사용되었음을 알 수 있습니다.
이 더미 리스트 구조에 사용된 큰따옴표는 문자형을 의미하고, @code{0}이란 수치형을 의미합니다. 
따라서, @code{scan()}함수를 통해서 불러들인 @code{input.dat} 파일은 @code{inp}이라는 리스트에 데이터를 저장하게 되므로 아래와 같은 방법으로 각각의 데이터 변수를 엑세스 할 수 있습니다.

@example
> label <- inp[[1]]; x <- inp[[2]]; y <- inp[[3]]
@end example

@c More conveniently, the dummy list can have named components, in which
@c case the names can be used to access the vectors read in.  For example

위에서 소개한 방법보다 더 편한 방법은 아래에서 보는 것과 같이 더미 리스트 구조를 사용할 때 바로 이름을 부여하는 것입니다.

@example
> inp <- scan("input.dat", list(id="", x=0, y=0))
@end example

@c If you wish to access the variables separately they may either be
@c re-assigned to variables in the working frame:

이와 같이 불러들어온 데이터가 리스트형이므로 아래와 같은 방법으로 각각의 데이터 변수에 접근할 수 있으며, 또는 @code{inp} 리스트를 @w{position 2}의 탐색경로에 연결하여 접근할 수도 있습니다 (이에 대해서는 @pxref{Attaching arbitrary lists}를 참고하시길 바랍니다).

@example
> label <- inp$id; x <- inp$x; y <- inp$y
@end example

@c @noindent
@c or the list may be attached at @w{position 2} of the search path
@c (@pxref{Attaching arbitrary lists}).

@c If the second argument is a single value and not a list, a single vector
@c is read in, all components of which must be of the same mode as the
@c dummy value.

만약, 아래와 같이 두번째 인자가 리스트가 아닌 단일 숫자값이라면, 하나의 벡터가 읽혀지게 됩니다.
그리고 반드시 벡터의 모든 구성요소는 더미 값(dummy value)와 같은 모드를 가지고 있어야 합니다.

@example
> X <- matrix(scan("light.dat", 0), ncol=5, byrow=TRUE)
@end example

@c There are more elaborate input facilities available and these are
@c detailed in the manuals.

@node Accessing builtin datasets, Editing data, The scan() function, Reading data from files
@c @section Accessing builtin datasets
@section 내장데이터셋에 접근하기
@cindex Accessing builtin datasets
@findex data

@c Around 100 datasets are supplied with @R{} (in package @pkg{datasets}),
@c and others are available in packages (including the recommended packages
@c supplied with @R{}).  To see the list of datasets currently available
@c use

@R{}은 기본적으로 대략 100여개의 데이터셋을 @pkg{datasets} 패키지를 통하여 제공하고 있습니다. 
만약 이 데이터셋의 목록을 확인하고 싶으시다면 아래와 같이 @code{data()}함수를 이용하시면 됩니다.

@example
data()
@end example

@c @noindent
@c As from @R{} version 2.0.0 all the datasets supplied with @R{} are
@c available directly by name.  However, many packages still use the
@c earlier convention in which @code{data} was also used to load datasets
@c into @R{}, for example

@R{} 버전 2.0.0 부터 제공되는 모든 데이터셋은 아래에서 보여지는 것과 같이 데이터셋의 이름을 통하여 바로 접근이 가능합니다.

@example
data(infert)
@end example

@noindent
@c and this can still be used with the standard packages (as in this
@c example).  In most cases this will load an @R{} object of the same name.
@c However, in a few cases it loads several objects, so see the on-line
@c help for the object to see what to expect.

@c @subsection Loading data from other R packages
@subsection 다른 R 패키지들로부터 데이터를 로딩하기

@c To access data from a particular package, use the @code{package}
@c argument, for example

만약 특정 패키지 내에 제공되어지는 데이터셋을 확인하고 싶다면 아래와 같이 @code{data()}함수의 @code{package}라는 인자를 사용합니다.

@example
data(package="rpart")
data(Puromycin, package="datasets")
@end example

@c If a package has been attached by @code{library}, its datasets are
@c automatically included in the search.

만약 특정 패키지를 @code{library} 함수를 이용하여 현재의 작업공간에 연결이 되어 있다면, 패키지에 내장된 데이터셋들은 자동으로 검색되게 됩니다.

@c User-contributed packages can be a rich source of datasets.

@node Editing data,  , Accessing builtin datasets, Reading data from files
@c @section Editing data
@section 데이터 편집하기
@findex edit

@c When invoked on a data frame or matrix, @code{edit} brings up a separate
@c spreadsheet-like environment for editing.  This is useful for making
@c small changes once a data set has been read.  The command

만약 사용자가 데이터 프레임이나 행렬의 일부내용을 수정 및 편집을 하고 싶을때 @code{edit} 함수를 사용합니다.
이는 윈도우즈 기반의 스프레드시트 형식의 편집기능을 제공해 주므로 매우 편리하게 작업을 할 수 있습니다.

@example
> xnew <- edit(xold)
@end example

@noindent
@c will allow you to edit your data set @code{xold}, and on completion the
@c changed object is assigned to @code{xnew}.  If you want to alter the
@c original dataset @code{xold}, the simplest way is to use
@c @code{fix(xold)}, which is equivalent to @code{xold <- edit(xold)}.

@code{edit()}함수는 데이터셋 @code{xold}을 편집한 뒤, 편집된 새로운 내용을 새로운 데이터셋 @code{xnew}로 저장한다는 의미입니다. 
만약, 사용자가 원본 데이터셋 @code{xold} 자체를 변경하고자 한다면 @code{fix(xold)} 함수를 이용하시길 바랍니다. 
이것은 @code{xold <- edit(xold)}와 동일한 표현입니다.

@c Use
만약에 여러분이 비어있는 데이터 프레임으로부터 윈도우즈 기반의 스프레드시트를 통하여 새로운 데이터를 입력하고자 한다면 아래와 같이 할 수 있습니다.

@example
> xnew <- edit(data.frame())
@end example

@c @noindent
@c to enter new data via the spreadsheet interface.


@node Probability distributions, Loops and conditional execution, Reading data from files, Top
@c @chapter Probability distributions
@chapter 확률분포
@cindex Probability distributions

@menu
* R as a set of statistical tables::  
* Examining the distribution of a set of data::  
* One- and two-sample tests::   
@end menu

@node R as a set of statistical tables, Examining the distribution of a set of data, Probability distributions, Probability distributions
@c @section R as a set of statistical tables
@section R에서 제공되는 통계분포표

@c One convenient use of @R{} is to provide a comprehensive set of
@c statistical tables.  Functions are provided to evaluate the cumulative
@c distribution function @eqn{P(X \le x), P(X <= x)},
@c the probability density function and the quantile function (given
@c @math{q}, the smallest @math{x} such that @eqn{P(X \le x) > q, P(X <= x) > q}),
@c and to simulate from the distribution.

@R{}의 많은 장점들 중 한가지는 다양한 통계분포표를 제공하는 것입니다. 
@eqn{P(X \le x), P(X <= x)}을 알려주는 누적확률(cumulative probability)값, 주어진 확률함수로부터 밀도(density)계산, 주어진 @math{q}에 해당하는 퀀타일(quantile)을 계산, @eqn{P(X \le x) > q, P(X <= x) > q})라는 조건을 만족하는 @code{x}값 찾기 및 주어진 분포로부터의 난수를 생성할 수 있습니다.

@quotation
@multitable{Distribution namessss}{names, names}{arguments, arguments}
@headitem 확률분포 @tab @R{}함수명 @tab 필요한 인자들
@item beta @tab @code{beta} @tab @code{shape1, shape2, ncp}
@item binomial @tab  @code{binom} @tab @code{size, prob}
@item Cauchy @tab @code{cauchy} @tab @code{location, scale}
@item chi-squared @tab @code{chisq} @tab @code{df, ncp}
@item exponential @tab @code{exp} @tab @code{rate}
@item F @tab @code{f} @tab @code{df1, df2, ncp}
@item gamma @tab @code{gamma} @tab @code{shape, scale}
@item geometric @tab @code{geom} @tab @code{prob}
@item hypergeometric @tab @code{hyper} @tab @code{m, n, k}
@item log-normal @tab @code{lnorm} @tab @code{meanlog, sdlog}
@item logistic @tab @code{logis} @tab @code{location, scale}
@item negative binomial @tab @code{nbinom} @tab @code{size, prob}
@item normal @tab @code{norm} @tab @code{mean, sd}
@item Poisson @tab @code{pois} @tab @code{lambda}
@item signed rank @tab @code{signrank} @tab @code{n}
@item Student's t @tab @code{t} @tab @code{df, ncp}
@item uniform @tab @code{unif} @tab @code{min, max}
@item Weibull @tab @code{weibull} @tab @code{shape, scale}
@item Wilcoxon @tab @code{wilcox} @tab @code{m, n}
@end multitable
@end quotation

@noindent
@c Prefix the name given here by @samp{d} for the density, @samp{p} for the
@c CDF, @samp{q} for the quantile function and @samp{r} for simulation
@c (@emph{r}andom deviates).  The first argument is @code{x} for
@c @code{d@var{xxx}}, @code{q} for @code{p@var{xxx}}, @code{p} for
@c @code{q@var{xxx}} and @code{n} for @code{r@var{xxx}} (except for
@c @code{rhyper}, @code{rsignrank} and @code{rwilcox}, for which it is
@c @code{nn}).  In not quite all cases is the non-centrality parameter
@c @code{ncp} currently available: see the on-line help for details.

위의 표를 잘 살펴보면 하나의 규칙을 알 수 있습니다.
@samp{d}로 시작하는 함수명은 확률밀도(density)를 구하기 위해 사용이 되고,
@samp{p}로 시작하는 함수명은 누적확률값(cumulative probability)를 구하기 위해 사용이 되며,
@samp{q}로 시작하는 함수명은 퀀타일(quantile)을 구하며,
@samp{r}로 시작하는 함수명은 시뮬레이션을 위한 난수를 생성하는데 사용됩니다.
또한, @code{d@var{xxx}}의 첫번째 인자는 @code{x}이며,
@code{p@var{xxx}}는 @code{q}, 
@code{q@var{xxx}}는 @code{p},
@code{r@var{xxx}}는 @code{n}입니다.
그러나, @code{rhyper}, @code{rsignrank} 그리고 @code{rwilcox}의 경우에는 @code{nn}입니다.
그리고, 모든 함수에 non-centrality parameter(비중심화 모수)인  @code{ncp}를 사용할 수 있는 것은 아닙니다.
더 자세한 사항은 온라인 도움말을 참고해주세요.

@c The @code{p@var{xxx}} and @code{q@var{xxx}} functions all have logical
@c arguments @code{lower.tail} and @code{log.p} and the @code{d@var{xxx}}
@c ones have @code{log}.  This allows, e.g., getting the cumulative (or
@c ``integrated'') @emph{hazard} function, @eqn{H(t) = - \log(1 - F(t)),
@c H(t) = - log(1 - F(t))}, by

또한, @code{p@var{xxx}}와 @code{q@var{xxx}}함수들은 @code{lower.tail}와 @code{log.p}라는 인자를 가지며, @code{d@var{xxx}}는 인자 @code{log}를 가집니다.
이러한 옵션의 사용은 아래에서 보이는 바와 같이 생존분석(survival analysis)에서 사용되는 @eqn{H(t) = - \log(1 - F(t)), H(t) = - log(1 - F(t))}이라는 @emph{hazard}함수의 계산을 가능하게 합니다.

@example
 - p@var{xxx}(t, ..., lower.tail = FALSE, log.p = TRUE)
@end example

@noindent
@c or more accurate log-likelihoods (by @code{d@var{xxx}(..., log =
@c TRUE)}), directly.

또한, @code{d@var{xxx}(..., log = TRUE)}와 같은 인자의 설정은 더 정교한 로그우도(log-likelihood) 값을 얻을 수 있도록 도와줍니다.

@c In addition there are functions @code{ptukey} and @code{qtukey} for the
@c distribution of the studentized range of samples from a normal
@c distribution, and @code{dmultinom} and @code{rmultinom} for the
@c multinomial distribution. Further distributions are available in
@c contributed packages, notably @CRANpkg{SuppDists}.

더 나아가 정규분포로부터 얻은 샘플에 대해서 표준화된 범위에 대한 분포를 함수 @code{ptukey}와 @code{qtukey}를 통하여 얻을 수 있습니다. 
또한, 멀티노미얼 (multinomial) 분포에 대한 밀도값과 난수생성은 @code{dmultinom}과 @code{rmultinom}이라는 함수를 통하여 얻을 수 있습니다. 
더 많은 분포에 대해서는 @CRANpkg{SuppDists}라는 사용자개발패키지를 찾아보시길 바랍니다.

@c Here are some examples

밀도함수를 활용하는 두 가지 예제입니다.

@example
> ## @r{2-tailed p-value for t distribution}
> 2*pt(-2.43, df = 13)
> ## @r{upper 1% point for an F(2, 7) distribution}
> qf(0.01, 2, 7, lower.tail = FALSE)
@end example

@c See the on-line help on @code{RNG} for how random-number generation is
@c done in @R{}.

@R{}에서 어떻게 난수를 생성하는지 알고 싶으시다면 온라인 도움말 @code{RNG}를 살펴보시길 바랍니다.

@node  Examining the distribution of a set of data, One- and two-sample tests, R as a set of statistical tables, Probability distributions
@c @section Examining the distribution of a set of data
@section 데이터 셋의 분포를 살펴보기

@c Given a (univariate) set of data we can examine its distribution in a
@c large number of ways.  The simplest is to examine the numbers.  Two
@c slightly different summaries are given by @code{summary} and
@c @code{fivenum}
@findex summary
@findex fivenum
@c and a display of the numbers by @code{stem} (a ``stem and leaf'' plot).
@findex stem

많은 방법을 통하여 주어진 (일변량) 데이터의 분포를 확인해 볼 수 있습니다. 
가장 쉬운 방법은 함수 @code{summary} 혹은 @code{fivenum}를 이용하여 수치적 요약정보를 보는 것입니다. 
혹은 @code{stem} 함수를 이용하여 줄기-잎 (stem and leaf) 플랏을 이용하여 확인해 볼수도 있습니다.

@example
> attach(faithful)
> summary(eruptions)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  1.600   2.163   4.000   3.488   4.454   5.100
> fivenum(eruptions)
[1] 1.6000 2.1585 4.0000 4.4585 5.1000
> stem(eruptions)

  The decimal point is 1 digit(s) to the left of the |

  16 | 070355555588
  18 | 000022233333335577777777888822335777888
  20 | 00002223378800035778
  22 | 0002335578023578
  24 | 00228
  26 | 23
  28 | 080
  30 | 7
  32 | 2337
  34 | 250077
  36 | 0000823577
  38 | 2333335582225577
  40 | 0000003357788888002233555577778
  42 | 03335555778800233333555577778
  44 | 02222335557780000000023333357778888
  46 | 0000233357700000023578
  48 | 00000022335800333
  50 | 0370
@end example

@c A stem-and-leaf plot is like a histogram, and @R{} has a function
@c @code{hist} to plot histograms.
@findex hist

실은 줄기-잎 그림은 @R{}에서 제공하는 @code{hist} 함수가 제공하는 히스토그램과 비슷합니다.

@example
> hist(eruptions)
## @r{make the bins smaller, make a plot of density}
> hist(eruptions, seq(1.6, 5.2, 0.2), prob=TRUE)
> lines(density(eruptions, bw=0.1))
> rug(eruptions) # @r{show the actual data points}
@end example

@findex density
@cindex Density estimation
@c More elegant density plots can be made by @code{density}, and we added a
@c line produced by @code{density} in this example.  The bandwidth
@c @code{bw} was chosen by trial-and-error as the default gives too much
@c smoothing (it usually does for ``interesting'' densities).  (Better
@c automated methods of bandwidth choice are available, and in this example
@c @code{bw = "SJ"} gives a good result.)

위의 예제에서 사용된 것과 같이 히스토그램보다 좀 더 정교한 확률분포를 살펴보기 위해서 @code{density} 함수에 의해서 계산되는 밀도플랏 (density plot) 을 함께 사용하는 것이 좋습니다. 
@code{density}함수의 @code{bw}(bandwidth) 인자의 값은 trial-and-error를 통해 얻어집니다.
(Bandwidth의 선택에 있어서 자동화된 방법이 있는데, @code{bw='SJ'}를 이용해보시길 바랍니다).

@iftex
@image{images/hist,9cm} 
@end iftex

@c We can plot the empirical cumulative distribution function by using the
@c function @code{ecdf}.
@findex ecdf
@cindex Empirical CDFs

@code{ecdf} 함수를 이용하여 empirical cumulative distribution function을 플랏해 볼 수 있습니다.

@example
> plot(ecdf(eruptions), do.points=FALSE, verticals=TRUE)
@end example

@c This distribution is obviously far from any standard distribution.
@c How about the right-hand mode, say eruptions of longer than 3 minutes?
@c Let us fit a normal distribution and overlay the fitted CDF.

이 분포는 표준정규분포로부터 많은 차이가 있음을 명백히 알 수 있습니다.
하지만, 화산폭발이 3분이상 지속될 경우에 대한 분포는 어떨까요? 
3분이상의 데이터으로부터의 생성된 누적분포를 만들어 본뒤 그 위에 정규분포와 겹쳐봄으로서 비교해봅니다.

@example
> long <- eruptions[eruptions > 3]
> plot(ecdf(long), do.points=FALSE, verticals=TRUE)
> x <- seq(3, 5.4, 0.01)
> lines(x, pnorm(x, mean=mean(long), sd=sqrt(var(long))), lty=3)
@end example

@iftex
@image{images/ecdf,9cm}
@end iftex

@c Quantile-quantile (Q-Q) plots can help us examine this more carefully.
@cindex Quantile-quantile plots
@findex qqnorm
@findex qqline

Q-Q 플랏을 이용하여 화산폭발 3분이상의 데이터에 대한 정규성을 검토해보는 것도 도움이 됩니다.

@example
par(pty="s")       # arrange for a square figure region
qqnorm(long); qqline(long)
@end example

@noindent
@c which shows a reasonable fit but a shorter right tail than one would
@c expect from a normal distribution.  Let us compare this with some
@c simulated data from a @math{t} distribution

Q-Q 플랏으로부터 오른쪽 꼬리 부분이 생각보다 짧은 것을 제외하고는 정규분포를 대체적으로 따르는 것 같습니다.
그럼 @code{t}-분포함수로부터 생성된 난수의 분포와는 어떤 관계를 가질지 생각해봅니다.

@iftex
@image{images/QQ,7cm}
@end iftex

@example
x <- rt(250, df = 5)
qqnorm(x); qqline(x)
@end example

@noindent
@c which will usually (if it is a random sample) show longer tails than
@c expected for a normal.  We can make a Q-Q plot against the generating
@c distribution by

@code{t}-분포로부터 얻어진 난수의 분포가 정규분포의 꼬리보다 길다는 것을 알 수 있습니다.

@example
qqplot(qt(ppoints(250), df = 5), x, xlab = "Q-Q plot for t dsn")
qqline(x)
@end example

@c Finally, we might want a more formal test of agreement with normality
@c (or not).  @R{} provides the Shapiro-Wilk test
@cindex Shapiro-Wilk test
@findex shapiro.test

마지막으로 정규성과 얼마나 따르는지를 확인하는 테스트를 수행하고자 할 것입니다.
@R{}은 아래와 같은 Shpiro-Wilk 테스트를 제공합니다.

@example
> shapiro.test(long)

         Shapiro-Wilk normality test

data:  long
W = 0.9793, p-value = 0.01052
@end example

@noindent
@c and the Kolmogorov-Smirnov test
@cindex Kolmogorov-Smirnov test
@findex ks.test

Shpiro-Wilk 테스트 외에도 Kolmogorov-Smirnov 테스트를 이용하여 정규성을 확인해 볼 수 있습니다.

@example
> ks.test(long, "pnorm", mean = mean(long), sd = sqrt(var(long)))

         One-sample Kolmogorov-Smirnov test

data:  long
D = 0.0661, p-value = 0.4284
alternative hypothesis: two.sided
@end example

@noindent
@c (Note that the distribution theory is not valid here as we
@c have estimated the parameters of the normal distribution from the same
@c sample.)

@node One- and two-sample tests,  , Examining the distribution of a set of data, Probability distributions
@c @section One- and two-sample tests
@section 단일 샘플과 두개의 샘플에 이용되는 테스트들 
@cindex One- and two-sample tests

@c So far we have compared a single sample to a normal distribution.  A
@c much more common operation is to compare aspects of two samples.  Note
@c that in @R{}, all ``classical'' tests including the ones used below are
@c in package @pkg{stats} which is normally loaded.

지금까지 하나의 샘플을 정규분포와 비교해 보았습니다. 
두개의 샘플을 비교하고자 한다면 더 많은 작업이 요구될 것입니다.
@R{}에서는 다음 예제에 사용되는 통계적 테스트를 포함하여 모든 전형적인 테스트들을 @pkg{stats} 패키지에 넣어두었습니다.

@c Consider the following sets of data on the latent heat of the fusion of
@c ice (@emph{cal/gm}) from Rice (1995, p.490)

1995년에 Rice가 the latent heat of the fusion of ice (@emph{cal/gm})에 대해서 연구한 논문의 490 쪽에 게재된 내용입니다. 
다음 두 개의 데이터셋이 이용되었습니다.

@example
Method A: 79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97
          80.05 80.03 80.02 80.00 80.02
Method B: 80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97
@end example

@noindent
@c Boxplots provide a simple graphical comparison of the two samples.

박스플랏(boxplot)은 두개의 샘플에 대하여 시각적인 비교를 제공합니다.

@c NOTE scan() from stdin is not parse()able, hence not source()able
@c Hence ./R-intro.R uses c(..)
@example
A <- scan()
79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97
80.05 80.03 80.02 80.00 80.02

B <- scan()
80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97

boxplot(A, B)
@end example
@findex boxplot
@cindex Box plots

@noindent
@c which indicates that the first group tends to give higher results than
@c the second.

첫번째 그룹이 두번째 그룹보다 더 높은 결과를 보여주는 것같습니다.

@iftex
@image{images/ice,7cm}
@end iftex

@c To test for the equality of the means of the two examples, we can use
@c an @emph{unpaired} @math{t}-test by
@cindex Student's @math{t} test
@findex t.test

각각의 데이터의 평균이 같은지를 테스트하기 위해서 아래와 같이 @emph{unpaired} @math{t}-테스트를 수행해 봅니다.

@example
> t.test(A, B)

         Welch Two Sample t-test

data:  A and B
t = 3.2499, df = 12.027, p-value = 0.00694
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 0.01385526 0.07018320
sample estimates:
mean of x mean of y
 80.02077  79.97875
@end example

@noindent
@c which does indicate a significant difference, assuming normality.  By
@c default the @R{} function does not assume equality of variances in the
@c two samples (in contrast to the similar @SPLUS{} @code{t.test}
@c function).  We can use the F test to test for equality in the variances,
@c provided that the two samples are from normal populations.

테스트의 결과는 평균의 차이가 정규분포를 따른다고 가정할때 통계적으로 의미가 있음을 나타내고 있습니다. 
여기에서 한가지 알아야 할 점은 @R{}은 기본적으로 두 데이터의 분산이 같다고 가정하지 않는다는 것입니다. 
이것은 @SPLUS{}에서 제공하는 @code{t.test}와 동일합니다. 
따라서 두 데이터의 분산이 같은지에 대해서 F-테스트를 시행해 보아야 할 것입니다.
이때, 두 데이터는 정규분포로부터 얻어진 샘플이라고 가정합니다.

@example
> var.test(A, B)

         F test to compare two variances

data:  A and B
F = 0.5837, num df = 12, denom df =  7, p-value = 0.3938
alternative hypothesis: true ratio of variances is not equal to 1
95 percent confidence interval:
 0.1251097 2.1052687
sample estimates:
ratio of variances
         0.5837405
@end example
@findex var.test

@noindent
@c which shows no evidence of a significant difference, and so we can use
@c the classical @math{t}-test that assumes equality of the variances.

테스트의 결과는 두 데이터의 분산은 통계학적으로 차이가 없음을 의미하므로, 
두 데이터의 분산이 같다고 가정하는 전형적인 t-테스트를 사용해도 무방합니다.

@example
> t.test(A, B, var.equal=TRUE)

         Two Sample t-test

data:  A and B
t = 3.4722, df = 19, p-value = 0.002551
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 0.01669058 0.06734788
sample estimates:
mean of x mean of y
 80.02077  79.97875
@end example

@c All these tests assume normality of the two samples.  The two-sample
@c Wilcoxon (or Mann-Whitney) test only assumes a common continuous
@c distribution under the null hypothesis.

모든 테스트들이 두 데이터가 정규분포로부터 얻어진 샘플임을 가정하고 있으나, two-sample Wilcoxon 혹은 Mann-Whitney 테스트에 필요한 가정은 분포가 단순히 연속형이어야 한다는 것입니다.

@cindex Wilcoxon test
@findex wilcox.test
@example
> wilcox.test(A, B)

         Wilcoxon rank sum test with continuity correction

data:  A and B
W = 89, p-value = 0.007497
alternative hypothesis: true location shift is not equal to 0

Warning message:
Cannot compute exact p-value with ties in: wilcox.test(A, B)
@end example

@noindent
@c Note the warning: there are several ties in each sample, which suggests
@c strongly that these data are from a discrete distribution (probably due
@c to rounding).

테스트를 수행한 결과에 경고가 있음을 알 수 있습니다. 
이것은 아마도 각각의 샘플안에 동일한 값을 가지는 데이터들이 존재하기 때문일것입니다. 
따라서 연속형 분포를 가정하기 보다는 데이터가 이산형분포로부터 나왔다고 생각하는게 올바를 것입니다
(혹은 이것은 rounding 으로부터 나온 결과일 수 도 있습니다).

@c There are several ways to compare graphically the two samples.  We have
@c already seen a pair of boxplots.  The following

두개의 샘플을 시각적으로 비교해 보는데 여러가지 방법이 있을 수 있습니다. 
그 중에서 두개의 박스플랏을 동시에 비교해보는 것은 이미 해 보았습니다.

@example
> plot(ecdf(A), do.points=FALSE, verticals=TRUE, xlim=range(A, B))
> plot(ecdf(B), do.points=FALSE, verticals=TRUE, add=TRUE)
@end example

@noindent
@c will show the two empirical CDFs, and @code{qqplot} will perform a Q-Q
@c plot of the two samples.  The Kolmogorov-Smirnov test is of the maximal
@c vertical distance between the two ecdf's, assuming a common continuous
@c distribution:

위에서 사용된 코드는 두개의 emprical CDFs (누적확률분포)를 비교할 것입니다. 
또한 @code{qqplot}함수를 이용하여 두 개의 샘플에 대한 Q-Q 플랏을 생성할 수도 있습니다. 
아래의 코드는 두개의 @code{ecdf}의 차이에 대하여 Kolmogorov-Smirnov 테스트를 수행합니다.

@example
> ks.test(A, B)

         Two-sample Kolmogorov-Smirnov test

data:  A and B
D = 0.5962, p-value = 0.05919
alternative hypothesis: two-sided

Warning message:
cannot compute correct p-values with ties in: ks.test(A, B)
@end example


@node Loops and conditional execution, Writing your own functions, Probability distributions, Top
@c @chapter Grouping, loops and conditional execution
@chapter 그룹핑, 반복 그리고 조건적 실행
@cindex Loops and conditional execution

@menu
* Grouped expressions::         
* Control statements::          
@end menu

@node Grouped expressions, Control statements, Loops and conditional execution, Loops and conditional execution
@c @section Grouped expressions
@section 그룹화된 표현들
@cindex Grouped expressions

@c @R{} is an expression language in the sense that its only command type
@c is a function or expression which returns a result.  Even an assignment
@c is an expression whose result is the value assigned, and it may be used
@c wherever any expression may be used; in particular multiple assignments
@c are possible.

@c Commands may be grouped together in braces, @code{@{@var{expr_1};
@c @var{@dots{}}; @var{expr_m}@}}, in which case the value of the group
@c is the result of the last expression in the group evaluated.  Since such
@c a group is also an expression it may, for example, be itself included in
@c parentheses and used a part of an even larger expression, and so on.

@R{}은 명령어 형식으로 결과값을 반환하는 함수 또는 표현을 사용하는 점에서 표현언어(expression language)입니다.
결과값를 재사용할 수 있도록 표현식에 할당하며, 이 표현식을 어느 곳에서든지 재사용할수도 있고 다중할당도 가능합니다.

또한, @code{@{@var{expr_1}; @var{@dots{}}; @var{expr_m}@}}와 같이 여러개의 명령들을 중괄호로 한데 묶어 이것을 또한 표현식으로도 사용할 수 있습니다 
이렇게 중괄호로 묶은 것을 그룹화된 표현식이라고 하고, 이것의 결과는 그룹내의 맨 마지막 명령문이 실행되었을때 얻어지게 됩니다. 
이렇게 그룹화된 표현식 역시 더 큰 표현식의 일부분으로도 사용될 수 있습니다.

@node Control statements,  , Grouped expressions, Loops and conditional execution
@c @section Control statements
@section 조건문
@cindex Control statements

@menu
* Conditional execution::       
* Repetitive execution::        
@end menu

@node Conditional execution, Repetitive execution, Control statements, Control statements
@c @subsection Conditional execution: @code{if} statements
@subsection 조건적 실행: @code{if} 문
@findex if

@c The language has available a conditional construction of the form

조건문은 아래와 같은 형식을 가집니다.

@example
> if (@var{expr_1}) @var{expr_2} else @var{expr_3}
@end example
@findex if
@findex else

@noindent
@c where @var{expr_1} must evaluate to a single logical value and the
@c result of the entire expression is then evident.
@var{expr_1}은 반드시 참 혹은 거짓이라는 단 하나의 논리형 값을 가져야만 합니다.

@findex &&
@findex ||
@c The ``short-circuit'' operators @code{&&} and @code{||} are often used
@c as part of the condition in an @code{if} statement.  Whereas @code{&}
@c and @code{|} apply element-wise to vectors, @code{&&} and @code{||}
@c apply to vectors of length one, and only evaluate their second argument
@c if necessary.

@code{&&}와 @code{||}는 종종 @code{if}이라는 조건문과 함께 쓰이는 ``short-circuit'' 연산자입니다.
@code{&}와 @code{|}가 벡터내 구성요소단위의 연산을 수행하는 반면, @code{&&}와 @code{||}는 길이가 1인 벡터들에만 적용됩니다.

@findex ifelse
@c There is a vectorized version of the @code{if}/@code{else} construct,
@c the @code{ifelse} function.  This has the form @code{ifelse(condition, a,
@c b)} and returns a vector of the length of its longest argument, with
@c elements @code{a[i]} if @code{condition[i]} is true, otherwise
@c @code{b[i]}.

@R{}은 벡터라이즈(vectorized)된 버전의 @code{if}/@code{else} 조건문인 @code{ifelse} 함수를 제공하고 있습니다. 
이것은 @code{ifelse(condition, a, b)}의 형식을 가지고 만약  @code{condition[i]} 이 참이면 @code{a[i]}를, 거짓이면 @code{b[i]}를 결과값으로 가지게 됩니다.

@node Repetitive execution,  , Conditional execution, Control statements
@c @subsection Repetitive execution: @code{for} loops, @code{repeat} and @code{while}
@subsection 반복실행: @code{for} 루프, @code{repeat}와 @code{while}
@findex for

@c There is also a @code{for} loop construction which has the form

다음은 @code{for} 루프를 이용한 반복문에 대한 형식입니다.

@example
> for (@code{@var{name}} in @var{expr_1}) @var{expr_2}
@end example

@noindent
@c where @code{@var{name}} is the loop variable.  @var{expr_1} is a
@c vector expression, (often a sequence like @code{1:20}), and
@c @var{expr_2} is often a grouped expression with its sub-expressions
@c written in terms of the dummy @emph{name}.  @var{expr_2} is repeatedly
@c evaluated as @var{name} ranges through the values in the vector result
@c of @var{expr_1}.

@code{@var{name}}는 벡터 @var{expr_1}의 순서대로서 표현식 @var{expr_2}의 반복을 진행할 수 있도록 지시하는 루프 변수(loop variable) 입니다.
@var{expr_2}은 종종 그룹화된 표현식으로 오는 경우가 있습니다.

@c As an example, suppose @code{ind} is a vector of class indicators and we
@c wish to produce separate plots of @code{y} versus @code{x} within
@c classes.  One possibility here is to use @code{coplot()},@footnote{to be
@c discussed later, or use @code{xyplot} from package @CRANpkg{lattice}.}
@c which will produce an array of plots corresponding to each level of the
@c factor.  Another way to do this, now putting all plots on the one
@c display, is as follows:

예를들어, 만약 @code{ind}가 그룹멤버쉽을 나타낸다면, 각 그룹별로 @code{y}와 @code{x}의 관계를 살펴 볼 수 있는 플랏(plot)을 생성하고자 하는 경우를 가정해 봅니다.
이를 수행하기 위한 한가지 옵션은 어떤 특정 요인이 가지고 있는 수준별로 플랏을 생성해주는 함수 @code{coplot()}
@footnote{또는 @CRANpkg{lattice}에 있는 @code{xyplot}함수를 이용할 수 있습니다.} 을 이용하는 것입니다. 
또 다른 방법으로는 아래와 같이 하는 것입니다.

@example
> xc <- split(x, ind)
> yc <- split(y, ind)
> for (i in 1:length(yc)) @{
    plot(xc[[i]], yc[[i]])
    abline(lsfit(xc[[i]], yc[[i]]))
  @}
@end example

@findex split
@c (Note the function @code{split()} which produces a list of vectors
@c obtained by splitting a larger vector according to the classes specified
@c by a factor.  This is a useful function, mostly used in connection
@c with boxplots.  See the @code{help} facility for further details.)

위에서 사용된 함수 @code{split()}는 주어진 데이터를 특정 요인이 가지는 수준별로 분리한 뒤, 각각의 수준별 데이터를 컴포넌트로 가지는 리스트를 생성합니다.
이것은 박스플랏과 많은 연관이 있는 매우 유용한 함수입니다.
더 자세한 사항은 도움말 @code{help} 기능을 이용하시길 바랍니다.

@c @quotation
@c @strong{Warning}: @code{for()} loops are used in @R{} code much less
@c often than in compiled languages.  Code that takes a `whole object' view
@c is likely to be both clearer and faster in @R{}.
@c @end quotation

@quotation
@strong{Warning}: @R{}에서는 @code{for()}를 이용한 반복문은 다른 컴파일된 언어들에 비하여 자주 사용되지 않습니다. 
그 이유는 전체 데이터 객체를 이용하여 벡터라이징 테크닉을 적절히 활용하는 것이 @R{}에서는 @code{for()}를 이용한 반복문보다도 더 빠른 연산속도를 가지며, 
프로그래머의 입장에서 프로그램을 직관적으로 읽기 쉽고 이해가 빠르게 도와줍니다. 
@end quotation

@c Other looping facilities include the
다른 반복기능들은 

@example
> repeat @var{expr}
@end example
@findex repeat

@noindent
@c statement and the
문과 

@example
> while (@var{condition}) @var{expr}
@end example
@findex while

@noindent
@c statement.
문을 가지고 있습니다.

@c The @code{break} statement can be used to terminate any loop, possibly
@c abnormally.  This is the only way to terminate @code{repeat} loops.
@findex break

@c The @code{next} statement can be used to discontinue one particular
@c cycle and skip to the ``next''.
@findex next

@code{break}와 @code{next}라는 두 명령문은 반복문을 중단할 때 쓰이지만, 중요한 차이가 있습니다.
@code{break}는 반복문을 무조건 중단하고 반복문 이후의 명령들을 실행하고자 할때 쓰입니다. 
따라서 @code{repeat}을 사용하여 @code{expr}를 반복하던 중, 이를 중단하고자 할때는 @code{break} 명령문을 사용하면 됩니다. 
그러나, @code{next}는 현재 진행하고 있는 반복 단계만을 건너뛰고 다음 단계의 반복단계로 넘어가라는 의미입니다.

@c Control statements are most often used in connection with
@c @emph{functions} which are discussed in @ref{Writing your own
@c functions}, and where more examples will emerge.

실제로 프로그램의 흐름을 제어하는 것은 대개 사용자 정의함수를 작성할때 다루어집니다. 
이에 관련된 예제들에 대해서는 다음의 @ref{Writing your own functions} 에서 다룰 것입니다.

@node Writing your own functions, Statistical models in R, Loops and conditional execution, Top
@c @chapter Writing your own functions
@chapter 사용자 정의 함수 작성하기
@cindex Writing functions

@c As we have seen informally along the way, the @R{} language allows the
@c user to create objects of mode @emph{function}.  These are true @R{}
@c functions that are stored in a special internal form and may be used in
@c further expressions and so on.  In the process, the language gains
@c enormously in power, convenience and elegance, and learning to write
@c useful functions is one of the main ways to make your use of @R{}
@c comfortable and productive.

@R{}은 방대한 양의 함수를 지원하고 있으나, 사용자가 직접 @emph{function(함수)}라는 모드를 가진 객체를 생성할 수 있도록 지원합니다. 
@R{}이 사전에 미리 제공하는 함수들은 내장(built-in)함수라고 하며, 사용자가 직접 정의하는 함수를 사용자 정의함수라고 합니다. 
이를 작성하는 것은 사용자가 @R{}을 더 효율적으로, 기능적으로, 그리고 생산적인 통계분석처리를 할 수 있도록 도와줍니다.

@c It should be emphasized that most of the functions supplied as part of
@c the @R{} system, such as @code{mean()}, @code{var()},
@c @code{postscript()} and so on, are themselves written in @R{} and thus
@c do not differ materially from user written functions.

@code{mean()}, @code{var()}, @code{postscript()}와 같이 @R{}시스템에 미리 내장된 많은 함수들 역시 @R{}로 쓰여졌기 때문에, 대다수의 내장함수들이 사용자 정의함수라고 할 수도 있습니다.

@c A function is defined by an assignment of the form

다음은 함수를 정의하는 방법입니다.

@example
> @var{name} <- function(@var{arg_1}, @var{arg_2}, @dots{}) @var{expression}
@end example
@findex function

@noindent
@c The @var{expression} is an @R{} expression, (usually a grouped
@c expression), that uses the arguments, @var{arg_i}, to calculate a value.
@c The value of the expression is the value returned for the function.

@c A call to the function then usually takes the form
@c @code{@var{name}(@var{expr_1}, @var{expr_2}, @dots{})} and may occur
@c anywhere a function call is legitimate.

여기에서 @var{expression} 이란 어떤 값을 계산하기 위해 사용되는 @var{arg_i}를 이용하여 작성되는 @R{}표현식 (일반적으로 그룹화된 표현식)입니다.
그리고, @var{expression}을 수행함으로 얻어진 최종적인 결과를 함수의 반환값이라고 합니다.
이렇게 정의된 함수를 사용하는 방법은 어느 곳에서나 @code{@var{name}(@var{expr_1}, @var{expr_2}, @dots{})}이라고 사용하면 됩니다.

@menu
* Simple examples::             
* Defining new binary operators::  
* Named arguments and defaults::  
* The three dots argument::     
* Assignment within functions::  
* More advanced examples::      
* Scope::                       
* Customizing the environment::  
* Object orientation::          
@end menu

@node Simple examples, Defining new binary operators, Writing your own functions, Writing your own functions
@c @section Simple examples
@section 간단한 예제 

@c As a first example, consider a function to calculate the two sample
@c @math{t}-statistic, showing ``all the steps''.  This is an artificial
@c example, of course, since there are other, simpler ways of achieving the
@c same end.

@c The function is defined as follows:

첫번째 예제를 살펴봅니다.
두개의 샘플로부터 t-통계량을 구하는 함수를 다음과 같이 정의할 수 있습니다.

@example
> twosam <- function(y1, y2) @{
    n1  <- length(y1); n2  <- length(y2)
    yb1 <- mean(y1);   yb2 <- mean(y2)
    s1  <- var(y1);    s2  <- var(y2)
    s <- ((n1-1)*s1 + (n2-1)*s2)/(n1+n2-2)
    tst <- (yb1 - yb2)/sqrt(s*(1/n1 + 1/n2))
    tst
  @}
@end example

@c With this function defined, you could perform two sample @math{t}-tests
@c using a call such as

이렇게 함수를 정의한 뒤, 이 정의한 함수 @code{twosam}을 아래와 같은 방법으로 사용할 수 있습니다.

@example
> tstat <- twosam(data$male, data$female); tstat
@end example

@c As a second example, consider a function to emulate directly the
@c @sc{Matlab} backslash command, which returns the coefficients of the
@c orthogonal projection of the vector @math{y} onto the column space of
@c the matrix, @math{X}.  (This is ordinarily called the least squares
@c estimate of the regression coefficients.)  This would ordinarily be
@c done with the @code{qr()} function; however this is sometimes a bit
@c tricky to use directly and it pays to have a simple function such as the
@c following to use it safely.

두번째 예제는 @sc{Matlab}에서 최소제곱법을 이용하여 회귀모델의 회귀계수를 구해주는 백슬래쉬(backslash)라는 명령어를 구현해보는 것입니다.
본래 이것은 @code{qr()}함수를 이용하여 할 수도 있으나, 어떤 경우에는 직접적으로 활용하기가 곤란한 경우가 있습니다. 
따라서, 다음과 같은 방식을 사용하는 것을 권장합니다.

@c Thus given a @math{n} by @math{1} vector @math{y} and an @math{n} by
@c @math{p} matrix @math{X} then @math{X \ y} is defined as
만약, @math{n}개의 원소를 가지는 열벡터 @math{y}가 있고, 사이즈가 @math{n}행 @math{p}열을 가진 디자인행렬 @math{X}가 있다면 @math{X\y}는 
@ifnottex
(X'X)^@{-@}X'y, where (X'X)^@{-@}
@end ifnottex
@tex
$(X^T X)^{-}X^T y$, where $(X^T X)^{-}$
@end tex
로 정의할 수 있으며, @math{(X'X)^@{-@}}는 @math{X'X}의 역행렬입니다.
@c is a generalized inverse of @math{X'X}.

@example
> bslash <- function(X, y) @{
  X <- qr(X)
  qr.coef(X, y)
@}
@end example

위와 같이 정의된 @code{bslahs} 함수는 아래와 같이 @code{regcoeff}라는 객체에 결과를 저장하게 됩니다.

@c After this object is created it may be used in statements such as
@example
> regcoeff <- bslash(Xmat, yvar)
@end example

@noindent
@c and so on.

@c The classical @R{} function @code{lsfit()} does this job quite well, and
@c more@footnote{See also the methods described in @ref{Statistical models
@c in R}}.  It in turn uses the functions @code{qr()} and @code{qr.coef()}
@c in the slightly counterintuitive way above to do this part of the
@c calculation.  Hence there is probably some value in having just this
@c part isolated in a simple to use function if it is going to be in
@c frequent use.  If so, we may wish to make it a matrix binary operator
@c for even more convenient use.

이러한 기능은 @R{}에서 제공하는 @code{lsfit()} 함수를 통하여 더 잘 수행될 수 있습니다.
@footnote{@ref{Statistical models in R}에 설명된 다른 방법들을 살펴보시길 바랍니다}.
실제로, @code{qr()}과 @code{qr.coef()}의 사용은 회귀계수를 구하는데 있어서 직관적이라고 보기 어려우며, 사용에 번거롭기도 합니다. 
보다 편리한 사용을 위해 사용자가 직접 정의하는 이항연산자(binary operator)라는 기능을 제공합니다.

@node Defining new binary operators, Named arguments and defaults, Simple examples, Writing your own functions
@c @section Defining new binary operators
@section 새로운 이항연산자 정의하기
@cindex Binary operators

@c Had we given the @code{bslash()} function a different name, namely one of
@c the form

위에서 @code{bslash()} 함수를 작성하였습니다. 
그러나 이러한 연산의 수행은 함수를 작성하는 것보다 아래와 같은 연산자의 형태를 지닌다면 훨씬 편리할 것입니다. 

@example
%@var{anything}%
@end example

@noindent
@c it could have been used as a @emph{binary operator} in expressions
@c rather than in function form.  Suppose, for example, we choose @code{!}
@c for the internal character.  The function definition would then start as

예를 들어, @code{anything}이라는 부분에 느낌표(@code{!})를 이용하여 @code{%!%}이라는 새로운 이항연산자를 아래와 같이 큰 따옴표를 이용하여 정의할 수 있습니다.

@example
> "%!%" <- function(X, y) @{ @dots{} @}
@end example

@noindent
@c (Note the use of quote marks.)  The function could then be used as
@c @code{X %!% y}.  (The backslash symbol itself is not a convenient choice
@c as it presents special problems in this context.)

이렇게 새로이 정의된 연산자는 @code{X %!% y}와 같이 사용할 수 있습니다.

@c The matrix multiplication operator, @code{%*%}, and the outer product
@c matrix operator @code{%o%} are other examples of binary operators
@c defined in this way.

행렬의 곱셈을 수행하는 연산자 @code{%*%}, 외적을 수행하는 연산자 @code{%o%}는 이러한 방법으로 정의된 이항연산자의 대표적인 경우입니다.

@node Named arguments and defaults, The three dots argument, Defining new binary operators, Writing your own functions
@c @section Named arguments and defaults
@section 이름을 가진 인자들과 기본값
@cindex Named arguments
@cindex Default values

@c As first noted in @ref{Generating regular sequences}, if arguments to
@c called functions are given in the ``@code{@var{name}=@var{object}}''
@c form, they may be given in any order.  Furthermore the argument sequence
@c may begin in the unnamed, positional form, and specify named arguments
@c after the positional arguments.

@ref{Generating regular sequences}에서 설명했던 것과 같이 함수에 사용되는 인자들은 ``@code{@var{name}=@var{object}}''와 같은 형식을 가지고 있습니다.
이러한 방식으로 함수의 정의시 인자의 이름을 굳이 함께 정의하는 것은 프로그래밍의 논리적 오류를 줄이고자 하는 노력이라고 보시길 바랍니다.

@c Thus if there is a function @code{fun1} defined by

예를들어, 아래와 같이 정의된 함수 @code{fun1}가 있다고 가정한다면,
@example
> fun1 <- function(data, data.frame, graph, limit) @{
    @r{[function body omitted]}
  @}
@end example

@noindent
@c then the function may be invoked in several ways, for example
아래와 같이 세가지 방법으로 사용이 가능하며, 모두 같은 결과를 줍니다.
@example
> ans <- fun1(d, df, TRUE, 20)
> ans <- fun1(d, df, graph=TRUE, limit=20)
> ans <- fun1(data=d, limit=20, graph=TRUE, data.frame=df)
@end example

@noindent
@c are all equivalent.

@c In many cases arguments can be given commonly appropriate default
@c values, in which case they may be omitted altogether from the call when
@c the defaults are appropriate.  For example, if @code{fun1} were defined
@c as

그런데, @R{}에서 제공하는 모든 함수들은 아래에서 보여지는 것과 같이 함수의 인자에 기본값이라는 것이 부여되어 있음을 알 수 있습니다.
@example
> fun1 <- function(data, data.frame, graph=TRUE, limit=20) @{ @dots{} @}
@end example

@noindent
@c it could be called as

따라서, 이 기본값들을 이용하여 함수의 모든 인자를 입력하지 않아도 함수는 연산을 수행하게 됩니다.
아래와 같은 사용은 위의 세가지 다른 방법으로 사용했던것과 동일한 결과를 줍니다.

@example
> ans <- fun1(d, df)
@end example

@noindent
@c which is now equivalent to the three cases above, or as

@code{limit}의 기본값을 20에서 10으로 바꾸어 실행하고자 한다면 아래와 같이 할 수 있습니다.

@example
> ans <- fun1(d, df, limit=10)
@end example

@noindent
@c which changes one of the defaults.

@c It is important to note that defaults may be arbitrary expressions, even
@c involving other arguments to the same function; they are not restricted
@c to be constants as in our simple example here.

인자에 주어지는 기본값들이 본 예제에서 사용된 것과 같이 상수일 필요는 없으며, 임의의 표현식이 될 수 있습니다.

@node The three dots argument, Assignment within functions, Named arguments and defaults, Writing your own functions
@c @section The @samp{@dots{}} argument
@section @samp{@dots{}} 인자

@c The ?Reserved topic links here, so please update it
@c if changing the node name.

@c Another frequent requirement is to allow one function to pass on
@c argument settings to another.  For example many graphics functions use
@c the function @code{par()} and functions like @code{plot()} allow the
@c user to pass on graphical parameters to @code{par()} to control the
@c graphical output.  (@xref{The par() function}, for more details on the
@c @code{par()} function.)  This can be done by including an extra
@c argument, literally @samp{@dots{}}, of the function, which may then be
@c passed on.  An outline example is given below.

함수를 정의할 때 @samp{@dots{}}라는 표현을 알아두면 매우 유용합니다.
이는 한 함수의 인자들에 대한 설정을 다른 함수로 넘겨주는 것을 허용하는 역할을 합니다.
예를들어, @code{plot()}과 같은 그래픽 함수들은 그래픽의 결과물을 정교히 조정하기 위한 방대한 양의 인자들이 포함하고 있는 함수 @code{par()}를 사용합니다.
@code{par()}에 대해서 자세히 알고 싶으시다면 @ref{The par() function}를 살펴보시길 바랍니다.
따라서, 그래픽 함수들은 실제로는 par()라는 함수에 있는 인자를 사용함으로서 결과물의 수정 및 조정을 조정하고, 이러한 역할을 위한 인자를 따로 정의하고 있지 않습니다. 
이렇게 외부에 정의에 되어 있는 함수 및 객체들의 인자들을 정의하고자 하는 함수로 불러들여와 활용하고자할 때, 아래의 코드에서 보이는 것과 같이 @samp{@dots{}}를 함수 선언부에 나열된 인자들의 목록뒤에 붙여주면 됩니다.

@example
fun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) @{
  @r{[omitted statements]}
  if (graph)
    par(pch="*", ...)
  @r{[more omissions]}
@}
@end example

@c Less frequently, a function will need to refer to components of
@c @samp{@dots{}}.  The expression @code{list(...)} evaluates all such
@c arguments and returns them in a named list, while @code{..1},
@c @code{..2}, etc. evaluate them one at a time, with @samp{..n}
@c returning the n'th unmatched argument.

@node Assignment within functions, More advanced examples, The three dots argument, Writing your own functions
@c @section Assignments within functions
@section 함수내 할당

@c Note that @emph{any ordinary assignments done within the function are
@c local and temporary and are lost after exit from the function}.  Thus
@c the assignment @code{X <- qr(X)} does not affect the value of the
@c argument in the calling program.

@c To understand completely the rules governing the scope of @R{} assignments
@c the reader needs to be familiar with the notion of an evaluation
@c @emph{frame}.  This is a somewhat advanced, though hardly difficult,
@c topic and is not covered further here.

@c If global and permanent assignments are intended within a function, then
@c either the ``superassignment'' operator, @code{<<-} or the function
@c @code{assign()} can be used.  See the @code{help} document for details.

@emph{함수 내부에서 이루어진 값에 대한 모든 할당은 함수내부내에서만 유효합니다}. 
따라서, @code{X <- qr(X)}은 호출하는 프로그램에 있는 인자들의 값에 아무런 영향을 미치지 않습니다.
이렇게 변수가 가지는 값이 지정된 함수 내부에서만 사용되는것을 지역할당(local assignment) 이라고 합니다. 

@R{}시스템내에서 할당범위 (the scope of assignment)에 대한 규칙들을 이해하기 위해서는 @emph{프레임(frame)}이 어떻게 평가가 되는지에 대한 개념에 익숙해져야만 합니다.
그러나, 이것은 이 안내서의 수준을 벗어나므로 설명하지 않겠습니다. 

만약, 함수 내부에서 연산된 어떤 값을 함수 외부 및 작성하는 프로그램 전체에서 사용하고 싶다면, 슈퍼할당 (superassignment)이라는 연산자 @code{<<-}를 사용하거나, 함수 @code{assign()}를 이용하시길 바랍니다.
이렇게 변수가 가지는 값이 특정 함수내에서 국한되지 않고 전체에서 활용되는 개념을 전역할당 (global assignment 혹은 permanent assignment) 라고 합니다. 이것에 대한 더 자세한 사항은 도움말 @code{help}을 참조하시길 바랍니다.

@c @SPLUS{} users should be aware that @code{<<-} has different semantics
@c in @R{}.  These are discussed further in @ref{Scope}.

@SPLUS{}사용자는 @code{<<-} 연산자가 @R{}에서 다른 의미로 사용된다는 점을 반드시 알고 있어야 합니다. 
이러한 다른 점들은 @ref{Scope}에서 다루어질 것입니다.

@node More advanced examples, Scope, Assignment within functions, Writing your own functions
@c @section More advanced examples
@section 중급 예제들

@menu
* Efficiency factors in block designs::  
* Dropping all names in a printed array::  
* Recursive numerical integration::  
@end menu

@node Efficiency factors in block designs, Dropping all names in a printed array, More advanced examples, More advanced examples
@c @subsection Efficiency factors in block designs
@subsection 블록디자인에서 효율성 요인

@c As a more complete, if a little pedestrian, example of a function,
@c consider finding the efficiency factors for a block design.  (Some
@c aspects of this problem have already been discussed in @ref{Index
@c matrices}.)

함수에 대해서 좀 더 자세히 다루기 위해서 이번에는 블락 디자인에서 사용되는 효율성요인(efficiency factor)을 찾아보도록 하겠습니다. 
이 문제에 대한 일부 내용은 이미 @ref{Index matrices}에서 다룬바 있습니다.

@c A block design is defined by two factors, say @code{blocks} (@code{b}
@c levels) and @code{varieties} (@code{v} levels).  If @math{R} and
@c @math{K} are the @math{v} by @math{v} and @math{b} by @math{b}
@c @emph{replications} and @emph{block size} matrices, respectively, and
@c @math{N} is the @math{b} by @math{v} incidence matrix, then the
@c efficiency factors are defined as the eigenvalues of the matrix

@code{b}수준을 가진 요인 @code{blocks}와 @code{v}수준을 가진 요인 @code{varieties}을 이용한 블락 디자인을 생각해 봅니다.
그리고, @math{R}과 @code{K}가 각각 @math{v}행 @math{v}열인 행렬 @code{replications}과 @math{b}행 @math{b}열인 행렬 @code{block size}이라고 합니다.
효율성요인(efficiency factor)은 아래와 같은 행렬의 기저값(eigenvalues)을 이용하여, 
@ifnottex
E = I_v - R^@{-1/2@}N'K^@{-1@}NR^@{-1/2@} = I_v - A'A, where
A = K^@{-1/2@}NR^@{-1/2@}.
@end ifnottex
@tex
$$E = I_v - R^{-1/2}N^T K^{-1}NR^{-1/2} = I_v - A^T A,$$
where $A = K^{-1/2}NR^{-1/2}$.
@end tex
로 구할 수 있습니다.
@c One way to write the function is given below.
다음은 이를 산출하는 함수를 작성한 것입니다.

@example
> bdeff <- function(blocks, varieties) @{
    blocks <- as.factor(blocks)             # @r{minor safety move}
    b <- length(levels(blocks))
    varieties <- as.factor(varieties)       # @r{minor safety move}
    v <- length(levels(varieties))
    K <- as.vector(table(blocks))           # @r{remove dim attr}
    R <- as.vector(table(varieties))        # @r{remove dim attr}
    N <- table(blocks, varieties)
    A <- 1/sqrt(K) * N * rep(1/sqrt(R), rep(b, v))
    sv <- svd(A)
    list(eff=1 - sv$d^2, blockcv=sv$u, varietycv=sv$v)
@}
@end example

@c It is numerically slightly better to work with the singular value
@c decomposition on this occasion rather than the eigenvalue routines.

실제로 이경우에는 the singular value decomposition을 이용하는 것이 기저값(eigenvalue)를 이용한 방법보다 보다 나은 연산결과를 줍니다.

@c The result of the function is a list giving not only the efficiency
@c factors as the first component, but also the block and variety canonical
@c contrasts, since sometimes these give additional useful qualitative
@c information.

위에서 작성된 함수는 효율성 요인만을 결과값으로 돌려주는 것만이 아니라 @code{block}과 @code{variety} 정준대비(canonical contrast) 또한 알려줍니다. 
그 이유는 이 두가지 결과값들이 때때로 유용하기 때문입니다.

@node Dropping all names in a printed array, Recursive numerical integration, Efficiency factors in block designs, More advanced examples
@c @subsection Dropping all names in a printed array
@subsection 이름없이 배열출력하기

@c For printing purposes with large matrices or arrays, it is often useful
@c to print them in close block form without the array names or numbers.
@c Removing the @code{dimnames} attribute will not achieve this effect, but
@c rather the array must be given a @code{dimnames} attribute consisting of
@c empty strings.  For example to print a matrix, @code{X}

사이즈가 큰 행렬 혹은 배열의 출력이 주목적인 경우, 행렬과 배열의 구성요소의 위치를 알려주는 행, 열, 혹은 차원에 대한 정보를 나타내지 않고 오로지 데이터값만을 출력하는 것이 유용한 경우가 있습니다. 
이런 경우에는 속성 @code{dimnames}이 가지는 문자열값들을 초기화 시켜주면 됩니다. 
예를 들어 행렬 @code{X}의 행과 열의 정보 없이 데이터만 출력하고자 할 경우, 아래와 같이 할 수 있습니다.

@example
> temp <- X
> dimnames(temp) <- list(rep("", nrow(X)), rep("", ncol(X)))
> temp; rm(temp)
@end example

@c This can be much more conveniently done using a function,
@c @code{no.dimnames()}, shown below, as a ``wrap around'' to achieve the
@c same result.  It also illustrates how some effective and useful user
@c functions can be quite short.

이와 같은 기능을 아래와 같이 @code{no.dimnames()}라는 사용자정의 함수를 작성함으로서 수행할 수 도 있습니다. 
이것은 또한 이렇게 유용한 기능을 위한 사용자정의함수가 꼭 길지 않아도 됨을 잘 보여주고 있습니다.

@example
no.dimnames <- function(a) @{
  ## @r{Remove all dimension names from an array for compact printing.}
  d <- list()
  l <- 0
  for(i in dim(a)) @{
    d[[l <- l + 1]] <- rep("", i)
  @}
  dimnames(a) <- d
  a
@}
@end example

@c With this function defined, an array may be printed in close format
@c using

위와 같이 정의된 함수는 아래와 같이 사용함으로서 배열이 가지는 데이터 값들만 출력해낼수 있습니다.

@example
> no.dimnames(X)
@end example

@c This is particularly useful for large integer arrays, where patterns are
@c the real interest rather than the values.

이번 섹션에서 다룬 내용은 배열 데이터 값 자체 보다 배열의 값들이 가지는 패턴을 분석하고자 할때 더 유용하므로 주로 사이즈가 큰 정수형 배열을 다룰때 사용됩니다

@node Recursive numerical integration,  , Dropping all names in a printed array, More advanced examples
@c @subsection Recursive numerical integration
@subsection 재귀용법을 이용하여 적분하기

@c Functions may be recursive, and may themselves define functions within
@c themselves.  Note, however, that such functions, or indeed variables,
@c are not inherited by called functions in higher evaluation frames as
@c they would be if they were on the search path.

함수는 재귀적일 수 있으며, 함수 자신이 함수 자신내에 함수를 정의할 수도 있습니다.
그러나, 이러한 함수들 (또는 실제로 변수들)은 마치 탐색경로(serach path)에 존재했던 것같은 상위평가프레임 (higer evaluation frames)내에서 불려진 함수에 의해 존재하는 것이 아니라는 점을 알고 있어야 합니다.

@c The example below shows a naive way of performing one-dimensional
@c numerical integration.  The integrand is evaluated at the end points of
@c the range and in the middle.  If the one-panel trapezium rule answer is
@c close enough to the two panel, then the latter is returned as the value.
@c Otherwise the same process is recursively applied to each panel.  The
@c result is an adaptive integration process that concentrates function
@c evaluations in regions where the integrand is farthest from linear.
@c There is, however, a heavy overhead, and the function is only
@c competitive with other algorithms when the integrand is both smooth and
@c very difficult to evaluate.

아래의 예제는 1개의 변수만을 가지는 함수를 적분하는 기초적인 방법에 대해서 다루고 있습니다. 
적분을 하는 기본 개념은 먼저 적분하고자 하는 범위의 양쪽 끝점과 그 중간점에 해당하는 함수들의 값을 얻어낸 후, 사다리꼴 공식을 이용하여 단일 패널에서 얻어진 결과가 이중패널에서 얻어진 결과와 매우 유사할 경우 이중패널로부터 얻어진 결과를 적분값으로 결정합니다. 
만약, 그렇지 않다면 각각의 패널에 위에서 묘사한 프로세스를 다시 적용하되 값의 변화가 없을때까지 반복합니다.

@c The example is also given partly as a little puzzle in @R{} programming.

이 예제는 @R{} 프로그래밍을 하는데 있어서 다소 복잡한 부분에 해당하므로 이해가 어려울 수 도 있습니다.

@example
area <- function(f, a, b, eps = 1.0e-06, lim = 10) @{
  fun1 <- function(f, a, b, fa, fb, a0, eps, lim, fun) @{
    ## @r{function `fun1' is only visible inside `area'}
    d <- (a + b)/2
    h <- (b - a)/4
    fd <- f(d)
    a1 <- h * (fa + fd)
    a2 <- h * (fd + fb)
    if(abs(a0 - a1 - a2) < eps || lim == 0)
      return(a1 + a2)
    else @{
      return(fun(f, a, d, fa, fd, a1, eps, lim - 1, fun) +
             fun(f, d, b, fd, fb, a2, eps, lim - 1, fun))
    @}
  @}
  fa <- f(a)
  fb <- f(b)
  a0 <- ((fa + fb) * (b - a))/2
  fun1(f, a, b, fa, fb, a0, eps, lim, fun1)
@}
@end example

@menu
* Scope::
* Object orientation::
@end menu

@node Scope, Customizing the environment, More advanced examples, Writing your own functions
@c @section Scope
@section 스코프
@cindex Scope

@c The discussion in this section is somewhat more technical than in other
@c parts of this document.  However, it details one of the major differences
@c between @SPLUS{} and @R{}.

이번 섹션에서 다루어질 내용은 이 문서의 다른 부분들보다는 다소 어려운 기술적인 부분에 해당합니다. 
그러나, 이 부분은 @R{}과 @SPLUS{}간의 다른 점들 중 함수와 관련된 부분입니다.

@c The symbols which occur in the body of a function can be divided into
@c three classes; formal parameters, local variables and free variables.
@c The formal parameters of a function are those occurring in the argument
@c list of the function.  Their values are determined by the process of
@c @emph{binding} the actual function arguments to the formal parameters.
@c Local variables are those whose values are determined by the evaluation
@c of expressions in the body of the functions.  Variables which are not
@c formal parameters or local variables are called free variables.  Free
@c variables become local variables if they are assigned to.  Consider the
@c following function definition.

먼저 함수의 본체에 사용되는 기호는 형식인자 (formal parameters), 지역변수 (local variables), 그리고 자유변수 (free variables) 라는 세가지가 있습니다.
형식인자 (formal parameters)라는 것은 함수 선언시 아직 값이 부여되지 않은 인자들의 목록을 의미합니다. 
따라서 형식인자 (formal parameters)는 실제로 함수가 사용될 때 함수가 받아들이는 인자의 값을 가지게 됩니다. 
이에 반해, 지역변수라는 것은 함수 본체에서 사용된 표현식의 결과값들을 가지게 됩니다. 
만약, 어떤 변수가 형식인자 (formal parameters)도 아니고 지역변수도 아닌 경우, 이러한 변수를 바로 자유변수라고 합니다. 
그러나, 상황에 따라서 자유변수에 값이 부여될 경우 이는 지역변수가 되기도 합니다. 
더 정확한 개념의 이해를 위해서 다음의 예제를 살펴봅시다.

@example
f <- function(x) @{
  y <- 2*x
  print(x)
  print(y)
  print(z)
@}
@end example

@c In this function, @code{x} is a formal parameter, @code{y} is a local
@c variable and @code{z} is a free variable.

여기 정의되어 있는 함수 @code{f}는 @code{x}라는 형식인자 (formal parameter)를 가지며, @code{y}라는 지역변수를 가지는데 반해, 자유변수 @code{z}를 가지고 있습니다.

@c In @R{} the free variable bindings are resolved by first looking in the
@c environment in which the function was created.  This is called
@c @emph{lexical scope}.  First we define a function called @code{cube}.

@R{}에서 자유변수에 대한 값의 할당은 변수가 관리가 되고 있는 함수에 우선권이 부여되며, 이것을 렉시컬 스코프 (lexical scope)라고 합니다. 
이해를 돕기 위해서 아래와 같이 정의된 함수 @code{cube}를 살펴봅니다.

@example
cube <- function(n) @{
  sq <- function() n*n
  n*sq()
@}
@end example

@c The variable @code{n} in the function @code{sq} is not an argument to that
@c function.  Therefore it is a free variable and the scoping rules must be
@c used to ascertain the value that is to be associated with it.  Under static
@c scope (@SPLUS{}) the value is that associated with a global variable named
@c @code{n}.  Under lexical scope (@R{}) it is the parameter to the function
@c @code{cube} since that is the active binding for the variable @code{n} at
@c the time the function @code{sq} was defined.  The difference between
@c evaluation in @R{} and evaluation in @SPLUS{} is that @SPLUS{} looks for a
@c global variable called @code{n} while @R{} first looks for a variable
@c called @code{n} in the environment created when @code{cube} was invoked.

함수 @code{sq}내에 있는 변수 @code{n}은 형식인자가 아닌 자유변수입니다.
이 자유변수가 어떠한 값을 가져야 하는가에 대해서 스코핑 규칙 (scoping rules)이 적용됩니다. 
정적 스코핑 규칙(static scoping rule)을 가지는 @SPLUS{}에서는 자유변수가 가지는 값은 @code{n}이라는 이름을 가진 전역변수 (global variable)에 의해서 그 값이 결정됩니다. 
이에 반해, 렉시컬 스코핑 규칙을 가지는 @R{}은 자유변수에 함수 @code{cube}라는 실행될 때 가지는 인자의 값을 할당 합니다. 
그 이유는 @code{n}은 함수 @code{sq}가 정의되기 '바로 이전에' 함수 @code{cube} 내부에서 정의되어 관리되는 변수이기 때문입니다. 
이러한 스코핑 규칙의 차이는 @R{}과 @SPLUS{}를 구분짓는 큰 특징들 중의 하나 입니다. 
즉, @R{}의 기본적인 스코핑 규칙은 전역변수에 의한 관리가 아닌 지역에 촛점을 맞춘 렉시컬 스코핑을 따르는 것입니다.

@example
## @r{first evaluation in S}
S> cube(2)
Error in sq(): Object "n" not found
Dumped
S> n <- 3
S> cube(2)
[1] 18
## @r{then the same function evaluated in R}
R> cube(2)
[1] 8
@end example

@c Lexical scope can also be used to give functions @emph{mutable state}.

@c In the following example we show how @R{} can be used to mimic a bank
@c account.  A functioning bank account needs to have a balance or total, a
@c function for making withdrawals, a function for making deposits and a
@c function for stating the current balance.  We achieve this by creating
@c the three functions within @code{account} and then returning a list
@c containing them.  When @code{account} is invoked it takes a numerical
@c argument @code{total} and returns a list containing the three functions.
@c Because these functions are defined in an environment which contains
@c @code{total}, they will have access to its value.

다음의 예제는 @R{}의 렉시컬 스코핑이 얼마나 효율적으로 은행계좌를 구현할 수 있는가를 보여줍니다. 
은행계좌를 구현하기 위해서는 총계 (balance 혹은 total), 출금 (withdrawal), 입금 (deposits), 그리고 현재잔고(current balance)이 필요합니다. 
먼저, 출급, 입금, 그리고 잔고에 대한 함수를 먼저 만든 뒤, 이를 리스트형식으로 한데 묶어 함수 @code{account}를 정의합니다. 
함수 @code{account}가 실제적으로 실행되었을때 @code{total}이라는 인자는 특정한 값을 가진 인자가 되어 리스트에 정의되어 있는 출금, 입금, 그리고 잔고라는 함수에 그 값을 전달하게 됩니다. 
그 이유는 바로 @code{total}이라는 인자가 함수 @code{account}에 의해서 정의되어 관리되는 변수이기 때문입니다.

@c The special assignment operator, @code{<<-},
@findex <<-
@c is used to change the value associated with @code{total}.  This operator
@c looks back in enclosing environments for an environment that contains
@c the symbol @code{total} and when it finds such an environment it
@c replaces the value, in that environment, with the value of right hand
@c side.  If the global or top-level environment is reached without finding
@c the symbol @code{total} then that variable is created and assigned to
@c there.  For most users @code{<<-} creates a global variable and assigns
@c the value of the right hand side to it@footnote{In some sense this
@c mimics the behavior in @SPLUS{} since in @SPLUS{} this operator always
@c creates or assigns to a global variable.}.  Only when @code{<<-} has
@c been used in a function that was returned as the value of another
@c function will the special behavior described here occur.

아래에서 보이는 것과 같이 @code{total}이라는 변수의 값을 변경하기 위해서 특별한 할당 연산자인 @code{<<-}를 사용하였습니다.
이 연산자는 기호 @code{total}이 존재하는 환경(environment)을 둘러싼 환경 (enclosing enviornment)을 살펴보고, 그러한 환경이 찾아졌을때 해당 환경에 존재하는 값으로 대체하게 됩니다. 
만약, 기호 @code{total}을 프로그램 전역 또는 최상위 환경 (top-level environment)에 도달할때까지도 찾을 수 없었다면, 기호 @code{total}이 새로이 생성이 되고 그 값이 할당되게 됩니다.
@footnote{어떤한 의미로는 이것은 @SPLUS{}의 기능을 흉내낸 것처럼 보일 수도 있습니다. 그 이유는 @SPLUS{}의 연산이 항상 전역변수를 생성하고 이에 값을 할당하기 때문입니다}

@example
open.account <- function(total) @{
  list(
    deposit = function(amount) @{
      if(amount <= 0)
        stop("Deposits must be positive!\n")
      total <<- total + amount
      cat(amount, "deposited.  Your balance is", total, "\n\n")
    @},
    withdraw = function(amount) @{
      if(amount > total)
        stop("You don't have that much money!\n")
      total <<- total - amount
      cat(amount, "withdrawn.  Your balance is", total, "\n\n")
    @},
    balance = function() @{
      cat("Your balance is", total, "\n\n")
    @}
  )
@}

ross <- open.account(100)
robert <- open.account(200)

ross$withdraw(30)
ross$balance()
robert$balance()

ross$deposit(50)
ross$balance()
ross$withdraw(500)
@end example

@node Customizing the environment, Object orientation, Scope, Writing your own functions
@c @section Customizing the environment
@section 환경설정하기
@cindex Customizing the environment

@c Users can customize their environment in several different ways.  There
@c is a site initialization file and every directory can have its own
@c special initialization file.  Finally, the special functions
@c @code{.First} and @code{.Last} can be used.

사용자는 사용자의 환경설정을 여러가지 방법으로 변경할 수 있습니다.
먼저, 사이트 초기화 파일(site initialization file)이라는 것이 있고, 각각의 디렉토리마다 특정역할을 하는 초기화 파일(special initialization file)이 있습니다. 
그리고, @code{.First}와 @code{.Last}이라는 특수한 함수들이 있습니다.

@c The location of the site initialization file is taken from the value of
@c the @env{R_PROFILE} environment variable.  If that variable is unset,
@c the file @file{Rprofile.site} in the @R{} home subdirectory @file{etc} is
@c used.  This file should contain the commands that you want to execute
@c every time @R{} is started under your system.  A second, personal,
@c profile file named @file{.Rprofile}@footnote{So it is hidden under
@c UNIX.} can be placed in any directory.  If @R{} is invoked in that
@c directory then that file will be sourced.  This file gives individual
@c users control over their workspace and allows for different startup
@c procedures in different working directories.  If no @file{.Rprofile}
@c file is found in the startup directory, then @R{} looks for a
@c @file{.Rprofile} file in the user's home directory and uses that (if it
@c exists).  If the environment variable @env{R_PROFILE_USER} is set, the
@c file it points to is used instead of the @file{.Rprofile} files.

사이트 초기화 파일의 위치는 @env{R_PROFILE}이라는 환경변수의 값에 의해 정해집니다.
만약, 이 환경변수의 값이 정해지지 않았다면 @R{}의 홈에 있는 @file{etc}라는 하위디렉토리에 있는 @file{Rprofile.site}의 값이 사용되게 됩니다.
이 파일은 사용자의 시스템에서 @R{}이 실행될때마다 반드시 실행되어야 할 명령어들을 포함하고 있습니다.
두번째로 @file{.Rprofile}@footnote{UNIX에서는 숨겨진 파일입니다.}이라는 개인프로파일이라는 파일은 어느 디렉토리에나 놓일 수 있습니다.
만약, @R{}이 해당 디렉토리에서 실행된다면 이 파일은 소스될(sourced, 즉 불러들어 읽힘) 것입니다.
이 파일은 해당 작업공간에 대한 개인사용자 설정이며, 다른 디렉토리마다 다른 스타트업(startup) 절차를 수행할 수 있게 해줍니다.
만약, @file{.Rprofile}이라는 파일을 스타트업 디렉토리에 없다면, @R{}은 사용자의 홈디렉토리에 있는 (만약 있다면) @file{.Rprofile}을 사용하게 됩니다.
만약, 환경설정변수 @env{R_PROFILE_USER}가 지정되어 있다면, @file{.Rprofile}파일대신에 사용될 것입니다.

@c Any function named @code{.First()} in either of the two profile files or
@c in the @file{.RData} image has a special status.  It is automatically
@c performed at the beginning of an @R{} session and may be used to
@c initialize the environment.  For example, the definition in the example
@c below alters the prompt to @code{$} and sets up various other useful
@c things that can then be taken for granted in the rest of the session.

사이트 프로파일, 사용자 프로파일, 그리고 @file{.RData}라는 이미지 내부에 @code{.First()}라고 이름이 붙은 함수들은 특정한 상태를 가지고 있습니다. 
이것들은 @R{}세션이 시작할 때 자동으로 작업환경을 초기화할 때 사용되게 됩니다. 
아래의 코드를 살펴 보신다면 더 빠른 이해를 가지실 수 있습니다. 
예를들어, 함수 @code{.First}의 정의중 @code{prompt}라는 인자 @code{$}를 다른 기호로 변경하여 @R{}세션내내 사용자가 변경한 기호로 프롬프트를 사용할 수 있습니다.

@c Thus, the sequence in which files are executed is, @file{Rprofile.site},
@c the user profile, @file{.RData} and then @code{.First()}.  A definition
@c in later files will mask definitions in earlier files.

일반적으로 사용자의 환경설정을 위한 파일의 실행순서는 @file{Rprofiles.site}, 그리고 사용자 프로파일, @file{.RData}, 그리고 @code{.First()} 순입니다.

@example
> .First <- function() @{
  options(prompt="$ ", continue="+\t")  # @r{@code{$} is the prompt}
  options(digits=5, length=999)         # @r{custom numbers and printout}
  x11()                                 # @r{for graphics}
  par(pch = "+")                        # @r{plotting character}
  source(file.path(Sys.getenv("HOME"), "R", "mystuff.R"))
                                        # @r{my personal functions}
  library(MASS)                         # @r{attach a package}
@}
@end example
@findex .First

@c Similarly a function @code{.Last()}, if defined, is (normally) executed
@c at the very end of the session.  An example is given below.

위에서 정의된 @code{.First()}와 유사하게 함수 @code{.Last()}를 아래와 같이 정의할 수 있습니다.
이는 보통 세션 종료시 사용됩니다.

@example
> .Last <- function() @{
  graphics.off()                        # @r{a small safety measure.}
  cat(paste(date(),"\nAdios\n"))        # @r{Is it time for lunch?}
@}
@end example
@findex .Last

@node Object orientation,  , Customizing the environment, Writing your own functions
@c @section Classes, generic functions and object orientation
@section 클래스, 제네릭 함수, 그리고 객체지향 프로그래밍
@cindex Classes
@cindex Generic functions
@cindex Object orientation

@c The class of an object determines how it will be treated by what are
@c known as @emph{generic} functions.  Put the other way round, a generic
@c function performs a task or action on its arguments @emph{specific to
@c the class of the argument itself}.  If the argument lacks any @code{class}
@c attribute, or has a class not catered for specifically by the generic
@c function in question, there is always a @emph{default action} provided.

객체의 클래스라는 것은 @emph{제네릭 함수 (generic function)}가 어떻게 그 객체를 처리할 것인지 대한 정보를 제공합니다. 
즉, 제네릭 함수라는 것은 객체의 클래스정보를 인자로 가지기 때문에 만약 클래스 정보가 없거나, 제네릭 함수내에서 해당 클래스에 대한 처리방법이 정의되지 않았다면 @emph{기본행동 (default action)}을 수행하게 됩니다.

@c An example makes things clearer.  The class mechanism offers the user
@c the facility of designing and writing generic functions for special
@c purposes.  Among the other generic functions are @code{plot()} for
@c displaying objects graphically, @code{summary()} for summarizing
@c analyses of various types, and @code{anova()} for comparing statistical
@c models.

예를 들면 더욱 수월하게 이해가 가실 것입니다.
클래스 메커니즘 (작동하는 방법)은 사용자가 제네릭 함수를 디자인하고 새로 정의할 수 있도록 도와줍니다. 
단편적인 예로 @code{plot()}이라는 제네릭 함수는 여러가지 객체의 종류 (즉, 클래스)에 따른 다양한 시각화 방법을 제공합니다.
또 다른 제네릭함수 @code{summary()}는 다양한 종류의 객체에 대한 통계분석의 결과를 요약해 주며, @code{anova()}는 여러개의 통계 모델들을 비교할 때 사용됩니다.

@c The number of generic functions that can treat a class in a specific way
@c can be quite large.  For example, the functions that can accommodate in
@c some fashion objects of class @code{"data.frame"} include

클래스를 특정한 방법으로 처리하는 제네릭 함수의 수는 매우 많습니다. 
예를 들어, 클래스 @code{"data.frame"}의 객체를 처리하는 방법들에 대해서는 아래와 같은 내용들이 있습니다.

@example
[     [[<-    any    as.matrix
[<-   mean    plot   summary
@end example

@findex methods
@c A currently complete list can be got by using the @code{methods()}
@c function:

이와 같이 어떤 처리 방법들이 제네릭 함수안에 구현이 되어 있는지 확인하고 싶다면 아래와 같이 @code{methods()}를 사용해보세요.

@example
> methods(class="data.frame")
@end example

@c Conversely the number of classes a generic function can handle can also
@c be quite large.  For example the @code{plot()} function has a default
@c method and variants for objects of classes @code{"data.frame"},
@c @code{"density"}, @code{"factor"}, and more.  A complete list can be got
@c again by using the @code{methods()} function:

이와 반대로, 제네릭 함수가 처리해 낼 수 있는 클래스의 종류 또한 많습니다. 
예를 들어, 함수 @code{plot()}는 기본처리방법(default method)을 가지고 있고, @code{"data.frame"}, @code{"density"}, @code{"factor"}, 그 밖의 클래스들로부터 파생되어진 다양한 종류의 객체들을 처리할 수 있습니다. 
만약, 어떠한 종류의 객체들을 처리할 수 있는지 확인해 보고 싶으시다면 아래와 같이 @code{methods()}를 함수의 이름과 함께 사용하시면 됩니다.

@example
> methods(plot)
@end example

@c For many generic functions the function body is quite short, for example

일반적으로 제네릭 함수의 본체는 아래에서 보는 것과 같이 매우 짧습니다. 

@example
> coef
function (object, ...)
UseMethod("coef")
@end example

@noindent
@c The presence of @code{UseMethod} indicates this is a generic function.
@c To see what methods are available we can use @code{methods()}

여기에서 @code{UseMethod}라는 @code{coef}라는 함수가 제네릭 함수임을 의미하는 것입니다.
따라서 @code{coef}라는 제네릭 함수에 대한 처리방식에 대한 내용을 확인하고 싶으시다면 @code{methods()}를 사용하시면 됩니다.

@example
> methods(coef)
[1] coef.aov*         coef.Arima*       coef.default*     coef.listof*
[5] coef.nls*         coef.summary.nls*

   Non-visible functions are asterisked
@end example

@noindent
@c In this example there are six methods, none of which can be seen by
@c typing its name.  We can read these by either of

위의 예제는 6가지의 처리방식이 있으나, 위에서 보는 바와 같이 메소드들이 어떻게 작성되었는지에 대해서는 보여지지 않는다고 *를 이용하여 표기하고 있습니다. 그러나, 아래와 같은 방법으로 이러한 메소드들에 대한 알고리즘의 구현방법을 확인할 수 있습니다.

@findex getAnywhere
@findex getS3method
@example
> getAnywhere("coef.aov")
A single object matching 'coef.aov' was found
It was found in the following places
  registered S3 method for coef from namespace stats
  namespace:stats
with value

function (object, ...)
@{
    z <- object$coef
    z[!is.na(z)]
@}

> getS3method("coef", "aov")
function (object, ...)
@{
    z <- object$coef
    z[!is.na(z)]
@}
@end example


@c The reader is referred to the @emph{R Language Definition} for a more
@c complete discussion of this mechanism.

이 섹션의 내용을 더 정확히 이해하기 위해서는 @emph{R Language Definition}라는 문서를 참고하셔야 합니다.

@node Statistical models in R, Graphics, Writing your own functions, Top
@c @chapter Statistical models in R
@chapter @R{}에서 사용되는 통계모델들
@cindex Statistical models

@c This section presumes the reader has some familiarity with statistical
@c methodology, in particular with regression analysis and the analysis of
@c variance.  Later we make some rather more ambitious presumptions, namely
@c that something is known about generalized linear models and nonlinear
@c regression.

@c The requirements for fitting statistical models are sufficiently well
@c defined to make it possible to construct general tools that apply in a
@c broad spectrum of problems.

@c @R{} provides an interlocking suite of facilities that make fitting
@c statistical models very simple.  As we mention in the introduction, the
@c basic output is minimal, and one needs to ask for the details by calling
@c extractor functions.

이번 세션에서 다루어지는 내용은 독자가 이미 회귀분석(regression analysis) 또는 분산분석(analysis of variance)에 대해서 어느 정도 알고 있다고 가정한 상태에서 작성한 것입니다.
그리고, 본 섹션의 후반부에서 다루어지게 될 일반 선형화 모델(generalised linear model)과 비선형 모델(nonlinear model)에 대해서도 개략적인 내용을 이미 알고 계신다고 가정하였습니다.

@R{}은 통계모델을 적합하는데 필요한 사항들을 잘 정리하여 다양한 문제에 적용할 수 있도록 보다 일반화된 도구로서 제작해 두었고, 통계모델의 모델들의 적합을 매우 단순하게 처리할 수 있도록 도와주는 기능들을 잘 연결하여 놓은 하나의 묶음을 제공합니다.
본 문서의 서두에서 언급한 것과 같이, @R{}은 분석을 수행시 최소한의 결과물만을 보여주기 때문에 중간절차에 대한 상세한 내용을 알아보고자 한다면 이를 확인해 볼 수 있는 기능을 가진 추출계열의 함수(extractor functions)들을 이용하셔야 합니다. 

@menu
* Formulae for statistical models::  
* Linear models::               
* Generic functions for extracting model information::  
* Analysis of variance and model comparison::  
* Updating fitted models::      
* Generalized linear models::   
* Nonlinear least squares and maximum likelihood models::  
* Some non-standard models::    
@end menu

@node Formulae for statistical models, Linear models, Statistical models in R, Statistical models in R
@c @section Defining statistical models; formulae
@section 통계적 모델 정의하기; 통계식
@cindex Formulae

@c The template for a statistical model is a linear regression model with
@c independent, homoscedastic errors

선형 회귀 모델(linear regression model)은 다음과 같은 일반적인 형식을 가집니다.
@code{y}는 종속변수이고, @code{x}는 설명변수입니다. 
@code{p}개의 설명변수가 있고, 이들은 @code{j}라는 첨자를 통해 구분됩니다.
따라서, @code{x_j}란 @code{j}번째 설명변수를 의미합니다. 
또한, @code{n}개의 관측대상이 존재하며, 각 관측대상은 첨자 @code{i}를 통해 구분됩니다.
따라서, @code{y_i}란 @code{i}번째 관측대상으로부터 얻은 종속변수의 값을 의미합니다.
마지막으로 @code{e_i}란 @code{i}번째 관측대상의 에러항을 의미합니다. 

@ifnottex
@display
y_i = sum_@{j=0@}^p beta_j x_@{ij@} + e_i, @ @ @ @ i = 1, @dots{}, n,
@end display
@noindent
여기에서 e_i은 NID(0, sigma^2)을 따릅니다.  
이 말의 의미는 오차항(error term)의 평균이 @math{0}이고, 분산이 @code{sigma^2}인 정규분포를 따르는데 각 관측치는 독립(independent)이며 동질적(homoscedastic)이라는 것입니다.
독립이란 말의 의미는 @code{i}번째 관측치와 @code{i}번째 관측치가 아닌 다른 관측치들과 관계없이 값이 얻어졌으며,
동질적이라는 말의 의미는 모든 관측치들에 가정되는 분포가 동일하다는 것을 말합니다.
@end ifnottex
@tex
$$ y_i = \sum_{j=0}^p \beta_j x_{ij} + e_i,
   \qquad e_i \sim {\rm NID}(0,\sigma^2),
   \qquad i = 1, @dots{}, n
$$
@end tex

@c In matrix terms this would be written

위에서 표현된 회귀분석의 일반식이 개별 관측치를 기준으로 쓰여졌다면, 아래와 같이 행렬의 형식으로 표현할 수도 있습니다.
@math{y}는 모든 관측치를 열벡터의 형식을 가진 하나의 종속변수(response variable 혹은 outcome variable) 이라고 하고, 
@math{X}는 @emph{모델 행렬(model matrix)} 혹은 @emph{디자인 행렬 (design matrix)}이라고 합니다.
이 디자인 행렬은 크기가 @math{n}행 @math{p}열로 정의되고, 각 열은 설명변수 (explanatory variable)의 값을 가진 열벡터로서 @math{x_0, x_1, ..., x_p} 와 같이 묶여있는 형태입니다.
일반적으로 @math{x_0}은 @emph{절편항 (intercept term)}으로서 열 벡터의 모든 구성요소의 값이 1로 되어 있는 것을 의미합니다.

@ifnottex
@display
y = X @ beta + e
@end display
@end ifnottex
@tex
$$ y = X \beta + e $$
@end tex

@c @noindent
@c where the @math{y} is the response vector, @math{X} is the @emph{model
@c matrix} or @emph{design matrix} and has columns
@c @math{x_0, x_1, @dots{}, x_p},
@c the determining variables.  Very often @math{x_0}
@c will be a column of ones defining an @emph{intercept} term.


@c @subsubheading Examples
@subsubheading 예제들

@c Before giving a formal specification, a few examples may usefully set
@c the picture.

@c Suppose @code{y}, @code{x}, @code{x0}, @code{x1}, @code{x2}, @dots{} are
@c numeric variables, @code{X} is a matrix and @code{A}, @code{B},
@c @code{C}, @dots{} are factors.  The following formulae on the left
@c side below specify statistical models as described on the right.

몇 가지 예를 들어봄으로서 이해를 돕도록 하겠습니다.
먼저 @code{y}, @code{x}, @code{x0}, @code{x1}, @code{x2}, @dots{}가 모두 수치형 벡터라고 가정합니다.
@code{X}는 행렬이고 @code{A}, @code{B}, @code{C}, @dots{}는 요인들을 나타낸다고 가정합니다.
그럼, 이제부터 통계모델을 @R{}에서 어떻게 지정하는지 알아보도록 하겠습니다.

@table @code
@item y ~ x
@itemx y ~ 1 + x
@c Both imply the same simple linear regression model of @math{y} on
@c @math{x}.  The first has an implicit intercept term, and the second an
@c explicit one.

이 두가지 표현 모두 주어진 설명변수 @code{x}를 이용한 @code{y}의 단순선형회귀모델 (simple linear regression model)을 의미합니다.
여기에서 단순이라는 말의 의미는 설명변수의 개수가 1개임을 의미합니다.
첫번째 식은 절편항을 명시하지 않았으나, 두번째 식은 절편항을 명시하였습니다.
절편항에 대한 특별한 명시가 없다면 @R{}은 기본적으로 디자인행렬에 절편항을 포함시킵니다.

@item y ~ 0 + x
@itemx y ~ -1 + x
@itemx y ~ x - 1
@c Simple linear regression of @math{y} on @math{x} through the origin
@c (that is, without an intercept term).

위와 동일한 @code{x}를 이용한 @code{y}의 단순선형회귀모델이지만, 이는 절편항을 포함하지 않는 경우를 표현하는 세가지 방법입니다.

@item log(y) ~ x1 + x2
@c Multiple regression of the transformed variable,

이는 두개의 설명변수 @code{x1}과 @code{x2}를 이용하여
@code{y}가 
@ifnottex
log(y),
@end ifnottex
@tex
$\log(y)$,
@end tex
로 변환된 종속변수에 대한 다중회귀모델 (multiple regression)입니다.
@c on @math{x1} and @math{x2} (with an implicit intercept term).

@item y ~ poly(x,2)
@itemx y ~ 1 + x + I(x^2)
@c Polynomial regression of @math{y} on @math{x} of degree 2.  The first
@c form uses orthogonal polynomials, and the second uses explicit powers,
@c as basis.

이 모델식은 @math{x}의 2차 다항식을 이용한 다항회귀 (polynomial regression)을 수행하는 것입니다.
@math{x}의 이차항이라는 것은 @math{x^2}를 의미합니다.
첫번째 식은 직교다항모형(orthogonal polynomials)이며, 
두번째 식은 @math{x}의 0차, 1차, 2차인 @math{x^0, x^1, x^2}가 기저 (basis)를 형성하는 다항모형을 의미합니다.

@item y ~ X + poly(x,2)
@c Multiple regression @math{y} with model matrix consisting of the matrix
@c @math{X} as well as polynomial terms in @math{x} to degree 2.

이 모델식은 @math{X} 행렬과 @math{x}의 2차항으로 구성된 다중회귀분석을 수행함을 의미합니다.

@item y ~ A
@c Single classification analysis of variance model of @math{y}, with
@c classes determined by @math{A}.

이 모델식은 여러개의 수준을 가지고 있는 요인 @math{A}를 이용하여 @math{y}에 대한 single classification analysis of variance model을 의미합니다. 

@item y ~ A + x
@c Single classification analysis of covariance model of @math{y}, with
@c classes determined by @math{A}, and with covariate @math{x}.

이 모델식은 여러개의 수준을 가지고 있는 요인 @math{A}와 설명변수 @math{x}를 이용하여 @math{y}에 대한 single classification analysis of covariance를 수행함을 의미합니다.

@item y ~ A*B
@itemx y ~ A + B + A:B
@itemx y ~ B %in% A
@itemx y ~ A/B
Two factor non-additive model of @math{y} on @math{A} and @math{B}.  The
first two specify the same crossed classification and the second two
specify the same nested classification.  In abstract terms all four
specify the same model subspace.


@item y ~ (A + B + C)^2
@itemx y ~ A*B*C - A:B:C
Three factor experiment but with a model containing main effects and two
factor interactions only.  Both formulae specify the same model.

@item y ~ A * x
@itemx y ~ A/x
@itemx y ~ A/(1 + x) - 1
Separate simple linear regression models of @math{y} on @math{x} within
the levels of @math{A}, with different codings.  The last form produces
explicit estimates of as many different intercepts and slopes as there
are levels in @math{A}.

@item y ~ A*B + Error(C)
An experiment with two treatment factors, @math{A} and @math{B}, and
error strata determined by factor @math{C}.  For example a split plot
experiment, with whole plots (and hence also subplots), determined by
factor @math{C}.
@end table

@findex ~
@c The operator @code{~} is used to define a @emph{model formula} in @R{}.
@c The form, for an ordinary linear model, is

그전에 모델식(model formula)에 이용되는 @code{~}(틸다)라는 연산자는 통계학적 의미로 연관시킨다는 의미를 가집니다.  
그 이유는 수학과 같이 우변의 식이 좌변의 값과 @code{=}(같음)이라는 등식이 성립되는 수학과 같은 정확한 함수관계는 아니기 때문입니다.
따라서, @R{}에서 모델식을 작성할때는 @code{~}를 이용하여 아래와 같은 형식으로 작성해주시면 됩니다.

@example
@var{response} ~ @var{op_1} @var{term_1} @var{op_2} @var{term_2} @var{op_3} @var{term_3} @var{@dots{}}
@end example

@noindent
@c where
이 모델식에서 
@table @var
@item response (종속변수)
@c is a vector or matrix, (or expression evaluating to a vector or matrix)
@c defining the response variable(s).
는 벡터 또는 행렬이 될 수 있습니다.
(또는 벡터 또는 행렬의 형식을 산출해내는 표현식일 수도 있습니다).

@item op_i (i 번째 연산자)
@c is an operator, either @code{+} or @code{-}, implying the inclusion or
@c exclusion of a term in the model, (the first is optional).
는 @code{+} 또는 @code{-} 부호를 가지는 연산자인데, 이 부호의 의미는 모델식에서 i 번째 항을 추가하거나 빼라는 의미입니다. 
산술연산과 혼돈하지 말아야 합니다.

@item term_i (i 번째 항목)
@c is either
은 다음의 것들중에 한가지가 될 수 있습니다. 
@itemize @bullet
@item
@c a vector or matrix expression, or @code{1},
벡터 혹은 행렬, 또는 @code{1}
@item
@c a factor, or
요인 (factor), 또는 
@item
@c a @emph{formula expression} consisting of factors, vectors or matrices
@c connected by @emph{formula operators}.
요인, 벡터, 또는 행렬 등을 @emph{모델식 연산자(formula operator)}에 의하여 연결되어 이루어진 @emph{모델 표현식(formula expression)}입니다.
@end itemize
@c In all cases each term defines a collection of columns either to be
@c added to or removed from the model matrix.  A @code{1} stands for an
@c intercept column and is by default included in the model matrix unless
@c explicitly removed.
이렇게 작성되는 모델식을 통하여 각 항이 모델행렬(model matrix)에서 추가되어질지 혹은 빠질지를 결정하게 됩니다.
@code{1}이라는 열벡터는 절편을 의미하는데 특별히 지정하지 않아도 항상 모델행렬에 포함되어 있다는 것을 기억하시길 바랍니다.
@end table

@c The @emph{formula operators} are similar in effect to the Wilkinson and
@c Rogers notation used by such programs as Glim and Genstat.  One
@c inevitable change is that the operator @samp{@code{.}} becomes
@c @samp{@code{:}} since the period is a valid name character in @R{}.
@emph{모델식 연산자(formula operator)}는 Glim 혹은 Genstat 이라는 프로그램에서 사용되는 Wilkinson과 Rogers 기호들과 유사한 기능입니다.
다른 점이 있다면, GLIM이나 Genstat에서는 @samp{@code{.}}라는 연산자를 사용하지만 이것은 @R{}에서는 @samp{@code{:}}라는 기호를 사용합니다. 
그 이유는 @samp{@code{.}}라는 기호는 @R{}에서 변수이름을 사용하는 하나의 문자로 사용되기 때문입니다.

@c The notation is summarized below (based on Chambers & Hastie, 1992, 
@c p.29):

다음은 Chambers & Hastie (1991, p.29)의 내용을 기초로 모델식(model formula)내에서 사용되는 모델 연산자(formula operators)들에 대해서 정리한 것입니다.

@table @code
@item @var{Y} ~ @var{M}
@c @var{Y} is modeled as @var{M}.

@code{~}(틸다)는 @var{Y}를 @var{M} 부분에서 정의된 식을 관계시킨다는 의미입니다. 
여기에서 @var{M}이라는 것을 정의하고자 하는 모델식(model formula)을 나타내는 기호라고 생각하시는 것이 좋습니다.

@item @var{M_1} + @var{M_2}
@c Include @var{M_1} and @var{M_2}.

@var{M_1}와 @var{M_2} 모두 포함합니다.

@item @var{M_1} - @var{M_2}
@c Include @var{M_1} leaving out terms of @var{M_2}.

@var{M_1}은 포함하되 @var{M_2}는 포함시키지 않습니다.

@item @var{M_1} : @var{M_2}
@c The tensor product of @var{M_1} and @var{M_2}.  If both terms are
@c factors, then the ``subclasses'' factor.

@var{M_1}과 @var{M_2}의 텐서 프라닥트(tensor product)을 이용합니다.
만약, 두 개의 항 모두 요인이라면 tensor product의 결과는 M_1과 M_2가 가지는 모든 레벨들의 조합으로 만들어진 모든 서브클래스들(``subclasses'')입니다.

@item @var{M_1} %in% @var{M_2}
@c Similar to @code{@var{M_1}:@var{M_2}}, but with a different coding.

@code{@var{M_1}:@var{M_2}}와 유사하지만 다른 표현 코딩법입니다.

@item @var{M_1} * @var{M_2}
@code{@var{M_1} + @var{M_2} + @var{M_1}:@var{M_2}}.

@item @var{M_1} / @var{M_2}
@code{@var{M_1} + @var{M_2} %in% @var{M_1}}.

@item @var{M}^@var{n}
@c All terms in @var{M} together with ``interactions'' up to order @var{n}

@var{M}의 모든 항들이 @var{n}차의 상호작용항(``interactions'')들과 함께 사용되었다는 의미입니다.  

@item I(@var{M})
@c Insulate @var{M}.  Inside @var{M} all operators have their normal
@c arithmetic meaning, and that term appears in the model matrix.
@code{I()} 라는 연산자는 insulate (즉, 따로 보관함)의 약자로서 모델식(model formula)정의시, 괄호안에 작성되는 표현식의 결과를 하나의 변수로서 사용한다는 의미입니다. 일반적으로 @R{}은 괄호안에서 사용되는 표현식에 포함된 연산자들이 그 수학적 의미를 그대로 가질 수 있도록 하였습니다. 
따라서, 모델식 정의시 사용되는 @code{+} 혹은 @code{-}라는 기호는 모형연산자(model operators)로서 설명변수를 모델식(model formula)에서 포함할 것인지 말 것인지를 결정하는데 사용되지만, 모델식를 구성하는 한개의 항에 사용된 @code{I(M_1+M_2)}이라는 것은 @code{M_1}과 @code{M_2}을 활용하여 그 수학적 결과를 하나의 변수로서 모델식에 이용하겠다는 의미입니다. 
@end table

@c Note that inside the parentheses that usually enclose function arguments
@c all operators have their normal arithmetic meaning.  The function
@c @code{I()} is an identity function used to allow terms in model formulae
@c to be defined using arithmetic operators.

@c Note particularly that the model formulae specify the @emph{columns
@c of the model matrix}, the specification of the parameters being
@c implicit.  This is not the case in other contexts, for example in
@c specifying nonlinear models.

모델식(model formula)은 디자인 매트릭의 열을 지정하는 것과 동일하며, 각각의 열에 부응하는 모형의 모수들이 존재한다고 가정해야 합니다. 
그리고 우리는 이 모형의 모수들을 구하는데 @R{}을 사용하는 것입니다. 
그러나 비선형 모델에서는 이러한 규칙들이 동일하게 적용되지 않으므로 주의해야 합니다.

@menu
* Contrasts::                   
@end menu

@node Contrasts,  , Formulae for statistical models, Formulae for statistical models
@c @subsection Contrasts
@subsection 대조 (Contrasts)
@cindex Contrasts

@c We need at least some idea how the model formulae specify the columns of
@c the model matrix.  This is easy if we have continuous variables, as each
@c provides one column of the model matrix (and the intercept will provide
@c a column of ones if included in the model).

우리는 model formula가 포함하는 항들이 디자인 매트릭스가 가지고 있는 열과 어떠한 관계를 가지고 있는지에 대한 최소한의 지식을 가지고 있어야만 합니다. 
만약, 연속형 데이터를 가지는 변수들만 있을 경우 이 관계에 대해서 생각하는것은 단순히 개개의 항들이 각각의 열들에 상응하기 때문에 어렵지 않습니다.

@cindex Factors
@cindex Ordered factors
@c What about a @math{k}-level factor @code{A}?  The answer differs for
@c unordered and ordered factors.  For @emph{unordered} factors @math{k -
@c 1} columns are generated for the indicators of the second, @dots{},
@c @math{k}th levels of the factor. (Thus the implicit parameterization is
@c to contrast the response at each level with that at the first.)  For
@c @emph{ordered} factors the @math{k - 1} columns are the orthogonal
@c polynomials on @math{1, @dots{}, k}, omitting the constant term.

그러나, @math{k}-개의 수준을 가지고 있는 요인 @code{A}의 경우에는 이 관계가 순서형인지 비순서형인지에 따라 달라지게 됩니다.
만약 @emph{비순서형 (unordered factor)}인 경우, 디자인 행렬의 각 열은 요인의 수준에 해당하게 됩니다.
따라서 두번째 열부터 마지막 @math{k}번째 열까지는 요인의 수준을 나타내는 지시자(indicator)로서 모델을 표현하게 됩니다.
만약, 이 표현이 익숙하지 않다면 더비변수를 생성하는 것으로 생각해보세요.
(따라서, 이러한 관계로부터 통계결과분석시에는 각 수준에 해당하는 통계치가 첫번째 수준에 해당하는 통계치와 비교를 하게 되는 상대적 해석을 하게 합니다). 
이와 다르게, @emph{순서형 요인(ordered factor)}인 경우에는 @math{k-1}개의 열들은 상수항을 제외한 @math{1, @dots{}, k}에 해당하는 직교다항식(orthogonal polynomials)을 의미하게 됩니다.

@c Although the answer is already complicated, it is not the whole story.
@c First, if the intercept is omitted in a model that contains a factor
@c term, the first such term is encoded into @math{k} columns giving the
@c indicators for all the levels.  Second, the whole behavior can be
@c changed by the @code{options} setting for @code{contrasts}.  The default
@c setting in @R{} is

그러나 우리는 모델식과 모델행렬의 관계에 대해서 모두 다룬 것은 아닙니다. 
첫번째로 요인을 포함하고 있지만 인터셉트가 없는 모델을 생각해 볼 수가 있습니다. 
이 경우 첫번째 항은 @math{k}개의 열들이 요인의 레벨을 나타낼수 있도록 변형되어져야 합니다. 
두번째는 @code{options}에 의해서 대조(@code{contrasts})의 방식을 변경할 수 있습니다.
@R{}에서는 이용하는 기본방법은 아래와 같습니다.

@example
options(contrasts = c("contr.treatment", "contr.poly"))
@end example

@noindent
@c The main reason for mentioning this is that @R{} and @Sl{} have
@c different defaults for unordered factors, @Sl{} using Helmert
@c contrasts.  So if you need to compare your results to those of a textbook
@c or paper which used @SPLUS{}, you will need to set

또 다른 경우는 비순서형 요소를 사용할 경우, @R{}과 @Sl{}의 기본동작이 서로 다르다는 것입니다.
@Sl{}의 경우는 @code{Helmert}이라는 대조방식을 이용합니다.
만약, 독자가 @SPLUS{}를 기초로 하여 쓰여진 책이나 논문을 토대로 @R{}에서 확인해 보고자 한다면 @code{contrast}에 대한 옵션을 아래와 같이 설정해주어야 합니다.
@R{}에서 @code{treatment} 대조법을 사용하는 이유는 이를 처음다루는 독자들이 해석하기 보다고 생각하기 때문입니다.

@example
options(contrasts = c("contr.helmert", "contr.poly"))
@end example

@noindent
@c This is a deliberate difference, as treatment contrasts (@R{}'s default)
@c are thought easier for newcomers to interpret.

@c We have still not finished, as the contrast scheme to be used can be set
@c for each term in the model using the functions @code{contrasts} and
@c @code{C}.
@findex contrasts
@findex C

@c We have not yet considered interaction terms: these generate the
@c products of the columns introduced for their component terms.

@c Although the details are complicated, model formulae in @R{} will
@c normally generate the models that an expert statistician would expect,
@c provided that marginality is preserved.  Fitting, for example, a model
@c with an interaction but not the corresponding main effects will in
@c general lead to surprising results, and is for experts only.

또한, 디자인 행렬의 선형변환을 수행하는 @code{contrasts}라는 함수와 @code{C}라는 함수를 다루지 않았으며, 각 구성항들에 의해 사용되는 열들의 곱으로 표현되는 교차항 (interaction terms)에 대해서도 다루지 않았습니다. 
이러한 세부사항들은 너무 복잡하기 때문에 본 문서에서 다루기는 적합하지 않습니다.
그러나, @R{}에서 제공하는 모델식은 일반적으로 통계전문가들이 기대하는 다양한 모델을 지정할 수 있또록 많은 기능적 요소를 제공합니다.
예를들면, 교호작용(interaction)은 존재하나 이에 상응하는 주요인이 없는 모델에 대한 적합은 일반적으로 놀라운 결과를 주는데 이는 전문가들에게만 흥미롭습니다.

@node Linear models, Generic functions for extracting model information, Formulae for statistical models, Statistical models in R
@c @section Linear models
@section 선형모델
@cindex Linear models

@c The basic function for fitting ordinary multiple models is @code{lm()},
@c and a streamlined version of the call is as follows:

여러개의 설명변수를 가지는 일반적인 다중모델을 적합하기 위한 간편한 방법은 아래와 같이 @code{lm()}이라는 함수를 이용하는 것입니다.

@findex lm

@example
> @var{fitted.model} <- lm(@var{formula}, data = @var{data.frame})
@end example

@c For example

예를 들면, 아래의 코드는 종속변수 @math{y}를 설명변수 @math{x1}과 @math{x2}로 설명하고자 하는 다중회귀모형(multiple regression model)입니다. 
이때 상수항(intercept term)이 포함되어 있다는 점에 대해서 명심하세요. 
또한 @code{lm()} 함수에 사용되는 인자들 중 @code{data=production}이라는 인자는 데이터셋을 의미하며, 이 @code{production}이라는 데이터셋은 선형모형을 모델하는데 필요한 모든 변수들을 포함하고 반드시 @emph{data frame}(데이터 프레임)이어야 합니다.
이 지정은 데이터프레임 @code{production}이 탐색경로(search path)에 연결이 되어 있는가와는 관계없이 @code{lm()} 함수 이용시에 반드시 입력해주어야 합니다.

@example
> fm2 <- lm(y ~ x1 + x2, data = production)
@end example

@noindent
@c would fit a multiple regression model of @math{y} on @math{x1} and
@c @math{x2} (with implicit intercept term).

@c The important (but technically optional) parameter @code{data =
@c production} specifies that any variables needed to construct the model
@c should come first from the @code{production} @emph{data frame}.
@c @emph{This is the case regardless of whether data frame
@c @code{production} has been attached on the search path or not}.

@node Generic functions for extracting model information, Analysis of variance and model comparison, Linear models, Statistical models in R
@c @section Generic functions for extracting model information
@section 모델의 정보를 추출하는 제네릭 함수들

@c The value of @code{lm()} is a fitted model object; technically a list of
@c results of class @code{"lm"}.  Information about the fitted model can
@c then be displayed, extracted, plotted and so on by using generic
@c functions that orient themselves to objects of class @code{"lm"}.  These
@c include

@code{lm()}을 사용하여 얻는 것은 적합된 선형모형 객체인데, 이는 클래스 @code{"lm"}라는 결과물들이 한데 묶인 리스트의 형식을 가집니다.
일반적으로 클래스명은 사용된 함수명을 따릅니다.
이렇게 @code{lm()}함수에 의해서 적합된 모델은 클래스 @code{"lm"}의 객체들을 다루는 제네릭 함수들을 통하여 결과물을 보여주거나, 일부의 정보만을 추출하거나, 또는 시각화에 이용하는 등 다양한 방법으로 사용이 될 수 있습니다.
적합된 객체는 아래와 같은 정보를 포함하고 있습니다.

@example
add1    deviance   formula      predict  step
alias   drop1      kappa        print    summary
anova   effects    labels       proj     vcov
coef    family     plot         residuals
@end example

@c A brief description of the most commonly used ones is given below.

이 중에서 가장 많이 사용되는 것들에 대해서 아래와 같이 정리해 보았습니다.

@table @code
@findex anova
@item anova(@var{object_1}, @var{object_2})
@c Compare a submodel with an outer model and produce an analysis of
@c variance table.

이것은 두개의 적합된 모델을 비교하는데 사용되며, 분산분석표를 제공합니다. 
@c 조금 더 자세히 설명하면, model formula 1을 이용하여 lm()을 수행하여 얻은 객체를 object_1 이라고 하고, model formula 2를 이용하여 얻은 객체 object_2라고 합시다. 
@c 이때 model formula 1 과 2는 반드시 동일한 데이터에 적용되어야 합니다. 
@c anova(object_1)이라고 하면 model formula 1을 이용하여 적합된 선형모형의 분산분석표를 보여줍니다. 
@c 그리고 anova(object_1, object_2)라고 하면 두 모델의 비교에 대한 분석분석표를 제공합니다.

@findex coefficients
@findex coef
@item coef(@var{object})
@c Extract the regression coefficient (matrix).
@c Long form: @code{coefficients(@var{object})}.

선형계수를 행렬의 형식으로 추출합니다.
여기에서 @code{coef()}는 @code{coefficients()}라는 함수의 약어로 표현된 함수명입니다.
따라서 @code{coefficients(object)}라고 써도 무방합니다.

@findex deviance
@item deviance(@var{object})
@c Residual sum of squares, weighted if appropriate.

잔차(residual)를 제곱하여 이를 모두 더한 값을 의미합니다. 

@findex formula
@item formula(@var{object})
@c Extract the model formula.

모형적합에 사용된 모델식을 추출합니다.

@findex plot
@item plot(@var{object})
@c Produce four plots, showing residuals, fitted values and some
@c diagnostics.

잔차와 적합된 값, 그리고 모델진단을 위한 4가지 종류의 플랏을 제공합니다.

@findex predict
@item predict(@var{object}, newdata=@var{data.frame})
@c The data frame supplied must have variables specified with the same
@c labels as the original.  The value is a vector or matrix of predicted
@c values corresponding to the determining variable values in
@c @var{data.frame}.

적합한 모델을 새로운 데이터에 적용하여 그 예측값을 구합니다.
이때 적용되는 새로운 데이터는 모델 적합에 사용된 데이터와 같은 변수명들을 가지고 있어야 합니다.

@c  @item @code{predict.gam(@var{object},}
@c  @item @w{@ @ @ @code{newdata=@var{data.frame})}}
@c  @tab @code{predict.gam()} is a safe alternative to @code{predict()} that
@c  can be used for @code{lm}, @code{glm} and @code{gam} fitted objects.  It
@c  must be used, for example, in cases where orthogonal polynomials are
@c  used as the original basis functions, and the addition of new data
@c  implies different basis functions to the original.

@findex print
@item print(@var{object})
@c Print a concise version of the object.  Most often used implicitly.

객체를 보기 좋은 형식으로 출력합니다.

@findex residuals
@findex resid
@item residuals(@var{object})
@c Extract the (matrix of) residuals, weighted as appropriate.

@c Short form: @code{resid(@var{object})}.

적합된 모형에 대한 잔차를 추출합니다.
@code{residuals()} 함수의 짧은 형식인 @code{resid(@var{object})}라고 하셔도 동일한 값을 얻을 수 있습니다.

@findex step
@item step(@var{object})
@c Select a suitable model by adding or dropping terms and preserving
@c hierarchies.  The model with the smallest value of AIC (Akaike's An
@c Information Criterion) discovered in the stepwise search is returned.

@c 이것은 단계적조사(stepwise search)라는 방법으로서 
항을 추가하거나 제거함으로서 다양하게 구성된 모델식들로부터 가장 작은 AIC(Akaike's Information Criterion)값을 근거로 데이터에 가장 적절한 모델을 찾는 것입니다.

@findex summary
@item summary(@var{object})
@c Print a comprehensive summary of the results of the regression analysis.

회귀분석의 결과를 간결한 형태로 요약하여 보여줍니다.

@findex vcov
@item vcov(@var{object})
@c Returns the variance-covariance matrix of the main parameters of a
@c fitted model object.
적합된 회귀계수에 대한 분산-공분산 (variance-covariance) 행렬을 출력해 줍니다.
@end table



@node Analysis of variance and model comparison, Updating fitted models, Generic functions for extracting model information, Statistical models in R
@c @section Analysis of variance and model comparison
@section 분산분석과 모델비교
@cindex Analysis of variance

@c The model fitting function @code{aov(@code{formula},
@c data=@var{data.frame})}
@c @findex aov
@c operates at the simplest level in a very similar way to the function
@c @code{lm()}, and most of the generic functions listed in the table in
@c @ref{Generic functions for extracting model information} apply.

@c It should be noted that in addition @code{aov()} allows an analysis of
@c models with multiple error strata such as split plot experiments, or
@c balanced incomplete block designs with recovery of inter-block
@c information.  The model formula

@code{lm()}이라는 함수의 사용방법과 그 작동원리가 비슷하나, 분산분석 (analysis of variance)을 수행하는 @code{aov(@code{formula}, data=@var{data.frame})}이라는 함수가 있습니다. 
이 함수로부터 반환되는 리스트형식의 결과는 @ref{Generic functions for extracting model information}에서 설명한 것과 같이 제네릭 함수(generic functions)들을 그대로 적용하여 추출할 수 있습니다.
그러나, @code{aov()}라는 함수에 대해서 반드시 강조해야할 장점이 있습니다. 
그것은 split plot experiment 또는 블럭간(inter-block)의 정보를 활용해야 하는 balanced incomplete block design와 같이 에러항이 다중구조(multiple error strata)를 가지는 모델을 사용할 수 있다는 것입니다.

@example
@var{response} ~ @var{mean.formula} + Error(@var{strata.formula})
@end example
@findex Error

@noindent
@c specifies a multi-stratum experiment with error strata defined by the
@c @var{strata.formula}.  In the simplest case, @var{strata.formula} is
@c simply a factor, when it defines a two strata experiment, namely between
@c and within the levels of the factor.

위의 모델식은 @var{strata.formula}에 의해서 정의된 error strata 와 함께 사용되는 multi-stratum experiement를 정의합니다.
가장 간단한 예로, 요인의 수준간(between)와 수준내(within)분석을 하는 two strata experiment를 정의할 때 @var{strata.formula}는 단순히 요인을 사용하면 됩니다.

@c For example, with all determining variables factors, a model formula such
@c as that in:

예를들어, 아래와 같은 모형은 @code{v + n*p*k}이라는 mean model과 ``between farms'', ``within farms'', 그리고 ``within block''이라는 세가지 error strata를 묘사할 때 사용됩니다.

@example
> fm <- aov(yield ~ v + n*p*k + Error(farms/blocks), data=farm.data)
@end example

@noindent
@c would typically be used to describe an experiment with mean model
@c @code{v + n*p*k} and three error strata, namely ``between farms'',
@c ``within farms, between blocks'' and ``within blocks''.

@menu
* ANOVA tables::                
@end menu

@node ANOVA tables,  , Analysis of variance and model comparison, Analysis of variance and model comparison
@c @subsection ANOVA tables
@subsection ANOVA 테이블

@c Note also that the analysis of variance table (or tables) are for a
@c sequence of fitted models.  The sums of squares shown are the decrease
@c in the residual sums of squares resulting from an inclusion of
@c @emph{that term} in the model at @emph{that place} in the sequence.
@c Hence only for orthogonal experiments will the order of inclusion be
@c inconsequential.

@c For multistratum experiments the procedure is first to project the
@c response onto the error strata, again in sequence, and to fit the mean
@c model to each projection.  For further details, see Chambers & Hastie
@c (1992).

@c A more flexible alternative to the default full ANOVA table is to
@c compare two or more models directly using the @code{anova()} function.
@c @findex anova

@code{aov()}란 함수는 적합된 일련의 모델에 대한 분산분석표 (analysis of variance table)를 제공해 줍니다. 
일반적으로 Sum of Squares (SS)은 주어진 일련의 모델들에서 적합에 사용된 항들이 모델에 유지된다고 할때 새로운 항이 하나씩 추가될 때마다 감소됩니다.

특히, orthogonal experiment의 경우에는 항을 추가하는 순서가 중요하지 않습니다. 
Multistratum experiments 경우 역시 종속변수의 값을 오차항이 가지는 계층에 순차적으로 mean model 을 영사시켜 나감으로서 분산분석이 가능해집니다. 
이에 대한 자세한 사항은 Chambers & Hastie (1992)의 책을 참고하시길 바랍니다. 

이렇게 두 개이상의 모델들을 비교해야 할 경우 하나의 모델에 대한 적합결과를 완전한 분산분석표를 따로따로 비교하는 것보다는 종합적으로 한 번에 볼 수 있다면 매우 편리할 것입니다.
이러한 방법으로 @code{anova()}함수를 이용하면 적합된 모델간의 차이를 보여주는 표를 생성해줍니다.
이때 적합의 방법은 hierarchical sequence를 가집니다.
그러나 이러한 방법은 단순히 모형에 대한 이해를 구조화함으로서 적합한 모델을 손쉽게 찾기 위한 방법일뿐 다른 목적은 없습니다.

@example
> anova(@var{fitted.model.1}, @var{fitted.model.2}, @dots{})
@end example

@c The display is then an ANOVA table showing the differences between the
@c fitted models when fitted in sequence.  The fitted models being compared
@c would usually be an hierarchical sequence, of course.  This does not
@c give different information to the default, but rather makes it easier to
@c comprehend and control.

@node Updating fitted models, Generalized linear models, Analysis of variance and model comparison, Statistical models in R
@c @section Updating fitted models
@section 적합된 모델들을 업데이트하기
@cindex Updating fitted models

@c The @code{update()} function is largely a convenience function that
@c allows a model to be fitted that differs from one previously fitted
@c usually by just a few additional or removed terms.  Its form is
@c @findex update

아래에 예제에서 사용된 @code{update()}이라는 함수는 이전에 적합된 모델에 몇 개의 항의 추가 혹은 제거를 통하여 새로운 모형으로서 적합시키고자 할 때 매우 유용한 함수입니다.

@example
> @var{new.model} <- update(@var{old.model}, @var{new.formula})
@end example

@c In the @var{new.formula} the special name consisting of a period,
@c @samp{@code{.}},
@c @findex .
@c only, can be used to stand for ``the corresponding part of the old model
@c formula''.  For example,

@R{}은 변수명에 @samp{@code{.}}을 사용하는 것을 허용하므로 위의 예제와 같이 new.model이라는 변수명을 사용함에 아무런 문제가 없습니다. 
그러나, 함수 @code{update()}를 사용함에 있어서 @samp{@code{.}}은 이전 적합에서 사용한 모델의 동일한 부분을 다시 사용함을 @R{} 시스템에게 인식하도록 하는 역할을 합니다. 
좀 더 확실한 이해를 이해서 아래의 예제를 살펴봅니다.
먼저 @code{production}라는 데이터 내의 @code{x1, x2, x3, x4, x5}이라는 5개의 설명변수를 이용하여  종속변수 @code{y}를 설명하고자 적합한 모델의 객체를 @code{fm05}에 저장합니다.
이렇게 이미 적합에 사용된 모형에 새로운 6번째 설명변수를 추가하여 모형을 재적합하고 싶을 때, @samp{@code{.}}를 사용합니다. 
그리고, @code{update()} 함수가 이미 @code{production} 데이터를 재적합을 위해서 홀딩하고 있기 때문에 @code{data=production}를 다시 입력할 필요는 없습니다.  
위의 코드의 맨 마지막라인은 square root를 통해 변환된 종속변수 @code{y}를 6개의 설명변수로 설명하고자 하는 모델을 재적합한다는 의미입니다.


@example
> fm05 <- lm(y ~ x1 + x2 + x3 + x4 + x5, data = production)
> fm6  <- update(fm05, . ~ . + x6)
> smf6 <- update(fm6, sqrt(.) ~ .)
@end example

@c @noindent
@c would fit a five variate multiple regression with variables (presumably)
@c from the data frame @code{production}, fit an additional model including
@c a sixth regressor variable, and fit a variant on the model where the
@c response had a square root transform applied.

@c Note especially that if the @code{data=} argument is specified on the
@c original call to the model fitting function, this information is passed on
@c through the fitted model object to @code{update()} and its allies.

@c The name @samp{.} can also be used in other contexts, but with slightly
@c different meaning.  For example

그러나, @samp{@code{.}}는 아래의 코드에서 보여지는 것과 같이 다른 용도로도 사용될 수 있기 때문에 @samp{@code{.}}를 사용함에 있어서 주의가 요구됩니다.
여기에서의 @samp{@code{.}}은 종속변수 @code{y}를 설명함에 있어서 @code{production} 데이터안에 있는 @emph{모든 변수를 다 이용}하여 모형을 적합하겠다는 의미입니다.

@example
> fmfull <- lm(y ~ . , data = production)
@end example

@noindent
@c would fit a model with response @code{y} and regressor variables
@c @emph{all other variables in the data frame @code{production}}.

@c Other functions for exploring incremental sequences of models are
@c @code{add1()}, @code{drop1()} and @code{step()}.
@c @findex add1
@c @findex drop1
@c @findex step
@c The names of these give a good clue to their purpose, but for full
@c details see the on-line help.

순차적으로 증가하는 형식의 여러가지 모델을 비교하기 위해서 @code{add1()}, @code{drop1()} 그리고 @code{step()}와 같은 함수들을 살펴보시는 것은 많은 도움이 될 것입니다.
이 함수들은 이름 그대로의 목적을 가지고 있는데, 자세한 사항은 각 함수의 도움말을 살펴보시길 바랍니다.

@node Generalized linear models, Nonlinear least squares and maximum likelihood models, Updating fitted models, Statistical models in R
@c @section Generalized linear models
@section 일반선형모델
@cindex Generalized linear models

@c Generalized linear modeling is a development of linear models to
@c accommodate both non-normal response distributions and transformations
@c to linearity in a clean and straightforward way.  A generalized linear
@c model may be described in terms of the following sequence of
@c assumptions:

일반선형모델(generalized linear model)이란 정규분포를 따르지 않는 종속변수(non-normal response distributions)의 변수변환(transformation)이라는 과정을 통하여 모형의 선형성 (linearity)를 찾는 방법으로 선형모델(linear model)의 일반화라고 생각하시면 됩니다.
일반선형모델은 아래와 같은 내용들을 가정하고 있습니다.

@itemize @bullet
@item
@c There is a response, @math{y}, of interest and stimulus variables
종속변수 @math{y}가 있고, 이 반응변수의 분포 (distribution of response variable)에 영향을 미치는 여러개의 설명변수 (또는 자극변수, stimulus variables) 
@ifnottex
x_1, x_2, @dots{},
@end ifnottex
@tex
$x_1$, $x_2$, @dots{},
@end tex
@c whose values influence the distribution of the response.
가 있습니다.

@item
@c The stimulus variables influence the distribution of @math{y} through
@c @emph{a single linear function, only}.  This linear function is called
@c the @emph{linear predictor}, and is usually written

설명변수들이 종속변수 @math{y}의 분포에 영향을 미칠때, 이 영향은 반드시 아래와 같이 정의된 설명변수들의 선형관계로부터 얻어진 linear predictor를 통하여 영향을 줍니다. 

@ifnottex
@display
eta = beta_1 x_1 + beta_2 x_2 + @dots{} + beta_p x_p,
@end display
@c hence x_i has no influence on the distribution of @math{y} if and only if
@c beta_i is zero.
따라서, i번째의 설명변수 x_i의 선형계수 beta_i가 0이라면 @math{y}의 분포에 어떠한 영향을 미치지 않는다는 점을 알 수 있습니다.
@end ifnottex
@tex
$$ \eta = \beta_1 x_1 + \beta_2 x_2 + \cdots + \beta_p x_p, $$
hence $x_i$ has no influence on the distribution of @math{y} if and only
if $\beta_i=0$.
@end tex

@item
@c The distribution of @math{y} is of the form
종속변수 @math{y}의 분포는 아래와 같은 형식을 가지고 있습니다.
@ifnottex
@display
f_Y(y; mu, phi)
  = exp((A/phi) * (y lambda(mu) - gamma(lambda(mu))) + tau(y, phi))
@end display
@c where phi is a @emph{scale parameter} (possibly known), and is constant
@c for all observations, @math{A} represents a prior weight, assumed known
@c but possibly varying with the observations, and $\mu$ is the mean of
@c @math{y}.
여기에서 phi는 @emph{스케일 파라미터 (scale parameter)}이며, 이 값은 아마도 사전에 알고 있거나 미리 주어짐으로서 상수로서 역할을 하게 됩니다.
@math{A}는 사전가중치(prior weight)인데, 이는 관측치마다 모두 다른 값을 가질 수도 있습니다.
$\mu$라는 것은 @math{y}의 평균값입니다.
@end ifnottex

@tex
$$
f_Y(y;\mu,\varphi)
= \exp\left[{A \over \varphi}\left\{y\lambda(\mu) -
\gamma\left(\lambda(\mu)\right)\right\} + \tau(y,\varphi)\right]
$$
where $\varphi$ is a @emph{scale parameter} (possibly known), and is
constant for all observations, $A$ represents a prior weight, assumed
known but possibly varying with the observations, and $\mu$ is the mean
of $y$.
@end tex
@c So it is assumed that the distribution of @math{y} is determined by its
@c mean and possibly a scale parameter as well.
따라서, @math{y}의 분포는 평균과 스케일 파라미터들로 결정되어집니다.

@item
@ifnottex
@c The mean, mu, is a smooth invertible function of the linear predictor:
아래에서 보이는 바와 같이 @math{y}의 평균 mu와 linear predictor가 역함수 관계로서 표현됩니다.
@display
mu = m(eta),    eta = m^@{-1@}(mu) = ell(mu)
@end display
@c and this inverse function, ell(), is called the @emph{link function}.
이 역함수를 ell()로 표기하고 @emph{링크함수(link function)}이라고 합니다.
@end ifnottex
@tex
The mean, $\mu$, is a smooth invertible function of the linear predictor:
$$ \mu = m(\eta),\qquad \eta = m^{-1}(\mu) = \ell(\mu) $$
and this inverse function, $\ell()$, is called the @emph{link function}.
@end tex
@end itemize

@c These assumptions are loose enough to encompass a wide class of models
@c useful in statistical practice, but tight enough to allow the
@c development of a unified methodology of estimation and inference, at
@c least approximately.  The reader is referred to any of the current
@c reference works on the subject for full details, such as McCullagh &
@c Nelder (1989) or Dobson (1990).

위에서 언급된 가정들은 매우 많아 보이지만, 실제로 이것들은 통계실무에서 사용되는 광범위한 범위의 모델을 모두 포괄할 수 있는 최소한의 가정입니다. 
일반선형모델은 이러한 최소한의 가정들을 가지고 추정(estimation)과 추론(inference)을 위한 하나의 통일된 방법을 개발할 수 있도록 도와줍니다. 
만약, 일반선형모델에 관심이 있는 독자라면 McCullagh & Nelder (1989)에 의해서 쓰여진 책과 Dobson (1990)이 저술한 책을 참고하시길 바랍니다.
이 두 권의 책은 일반선형모델에 대한 거의 모든 내용을 다루고 있습니다.

@menu
* Families::                    
* The glm() function::          
@end menu

@node Families, The glm() function, Generalized linear models, Generalized linear models
@c @subsection Families
@subsection 페밀리
@cindex Families

@c The class of generalized linear models handled by facilities supplied in
@c @R{} includes @emph{gaussian}, @emph{binomial}, @emph{poisson},
@c @emph{inverse gaussian} and @emph{gamma} response distributions and also
@c @emph{quasi-likelihood} models where the response distribution is not
@c explicitly specified.  In the latter case the @emph{variance function}
@c must be specified as a function of the mean, but in other cases this
@c function is implied by the response distribution.

@R{}은 일반선형모델에서 사용되는 종속변수 y의 분포가 @emph{가우시안(gaussian = 정규분포)}, @emph{이항 (binomial)}, @emph{포아송 (poisson)}, @emph{역가우시안 (inverse gaussian)}, 그리고 @emph{감마 (gamma)}인 경우를 모두 다룰 수 있는 기능을 제공하고 있습니다.
또한, 종속변수의 분포를 함수식으로 정확히 쓸 수 없는 경우에 적용되는 @emph{쿼시-라이클리후드 (quasi-likelihood)} 모델 역시 지원합니다.
일반적으로 일반선형모델을 적합하기 위해서는 @emph{variance function}을 알고 있어야 합니다. 
쿼시-라이클리후드 모델이 아닌 경우에는 종속변수의 분포로부터 variance function를 알 수 있으나, 쿼시-라이클리후드 모델의 경우에는 variance function가 반드시 종속변수의 평균에 관한 함수로서 표현되어져야만 합니다.

@c Each response distribution admits a variety of link functions to connect
@c the mean with the linear predictor.  Those automatically available are
@c shown in the following table:

종속변수에 대한 각각의 분포들은 아래의 표에서 보이는 것과 같이 다양한 링크함수를 통하여 linear predictor와 함수적 관계를 표현하게 됩니다.

@quotation
@multitable @columnfractions 0.25 0.55
@headitem 분포명 @tab 연결 함수들
@item @code{binomial} @tab @code{logit}, @code{probit}, @code{log}, @code{cloglog}
@item @code{gaussian} @tab @code{identity}, @code{log}, @code{inverse}
@item @code{Gamma} @tab @code{identity}, @code{inverse}, @code{log}
@item @code{inverse.gaussian} @tab @code{1/mu^2}, @code{identity}, @code{inverse}, @code{log}
@item @code{poisson} @tab @code{identity}, @code{log}, @code{sqrt}
@item @code{quasi} @tab @code{logit}, @code{probit}, @code{cloglog},
@code{identity}, @code{inverse}, @code{log}, @code{1/mu^2}, @code{sqrt}
@end multitable
@end quotation

@c The combination of a response distribution, a link function and various
@c other pieces of information that are needed to carry out the modeling
@c exercise is called the @emph{family} of the generalized linear model.

위에서 보여지는 표의 내용과 같이 종속변수의 분포, 링크함수, 그리고 모델에 필요한 다른 정보들과 조합은 일반선형모델의 @emph{페밀리(family)}를 결정하게 됩니다. 

@node The glm() function,  , Families, Generalized linear models
@c @subsection The @code{glm()} function
@subsection 함수 @code{glm()}
@findex glm

@c Since the distribution of the response depends on the stimulus variables
@c through a single linear function @emph{only}, the same mechanism as was
@c used for linear models can still be used to specify the linear part of a
@c generalized model.  The family has to be specified in a different way.

@c The @R{} function to fit a generalized linear model is @code{glm()}
@c which uses the form

일반선형모델은 종속변수의 분포를 오로지 설명변수에 대한 선형관계로 설명하므로, 선형회귀분석에서 모델을 적합하는데 사용된 방식이 일반선형모델에서도 선형관계를 설명하는데 이용될 수 있습니다.
그러나, 특정한 방법으로 페밀리를 지정해 주어야 합니다. 
일반선형모델을 적합하는데 사용되는 @R{}함수는 @code{glm()}이라고 하고, 아래와 같은 사용법을 가집니다.

@example
> @var{fitted.model} <- glm(@var{formula}, family=@var{family.generator}, data=@var{data.frame})
@end example

@c The only new feature is the @var{family.generator}, which is the
@c instrument by which the family is described.  It is the name of a
@c function that generates a list of functions and expressions that
@c together define and control the model and estimation process.  Although
@c this may seem a little complicated at first sight, its use is quite
@c simple.

@c The names of the standard, supplied family generators are given under
@c ``Family Name'' in the table in @ref{Families}.  Where there is a choice
@c of links, the name of the link may also be supplied with the family
@c name, in parentheses as a parameter.  In the case of the @code{quasi}
@c family, the variance function may also be specified in this way.

함수의 이용방법은 @code{family}를 지정하는 것을 제외하고는 @code{lm()}함수의 사용과 동일합니다.
단지 새로운 부분은 어떤 페밀리가 사용되는지 알려주는 @code{family.generator}이라는 부분인데, 이는 함수들의 목록을 생성해주고 일반선형모형을 정의하고 추정하는데 필요한 프로세스를 표현하는 함수의 이름입니다.
매우 복잡한 것같이 생각되지만, 실제로는 매우 쉽습니다.

@code{family.generator}가 가질 수 있는 이름은 @ref{Families}라는 섹션에서 페리밀에 대해 정리한 표를 살펴보시면 됩니다.
이 표에서 페밀리명(family name) 열에 있는 이름을 사용하게 됩니다.
또한 페밀리에서 사용이 가능한 함수들의 이름을 나열하고 있는데, 이는 @code{glm()}함수를 사용시 @code{family.generator}의 이름 바로 뒤에 괄호와 함께 사용하시면 됩니다. 
@code{쿼시페밀리(quasi family)}의 사용경우 역시 이와 같은 방식으로 variance function가 지정될 수 있습니다.

@c Some examples make the process clear.

아래의 예제는 여러분이 glm()함수를 이용하여 GLM 을 수행하는 방법을 보다 쉽게 이해할 수 있도록 도와줄 것입니다.

@c @subsubheading The @code{gaussian} family
@subsubheading 가우시안 (@code{gaussian}) 페밀리

@c A call such as

아래에서 보이는 것과 같이 @code{glm()} 함수를 이용하여 가우시안 (gaussian, 정규분포) 페밀리에 해당하는 문제를 해결하는 것은 @code{lm()}를 이용하여 문제를 해결하는 것과 수치적으로는 아무런 차이가 없으나 비효율적입니다.
그 이유는 @code{family.generator}에 어떤 특정한 링크함수를 사용할 것인가를 알려주지 않았기 때문입니다. 
만약, 가우시안 페밀리에서 비표준 (nonstandard) 링크함수를 이용하여 문제를 풀고자 할 경우, 이는 쿼시패밀리를 통하여 해결해야 합니다. 
이 방법은 쿼시페밀리를 소개할때 설명하도록 하겠습니다.

@example
> fm <- glm(y ~ x1 + x2, family = gaussian, data = sales)
@end example

@c @noindent
@c achieves the same result as

@example
> fm <- lm(y ~ x1+x2, data=sales)
@end example

@c @noindent
@c but much less efficiently.  Note how the gaussian family is not
@c automatically provided with a choice of links, so no parameter is
@c allowed.  If a problem requires a gaussian family with a nonstandard
@c link, this can usually be achieved through the @code{quasi} family, as
@c we shall see later.

@c @subsubheading The @code{binomial} family
@subsubheading 이항 (@code{binomial})분포 페밀리

@c Consider a small, artificial example, from Silvey (1970).

Silvey (1970)에서 사용되어진 간단한 예를 보도록 하겠습니다.

@c On the Aegean island of Kalythos the male inhabitants suffer from a
@c congenital eye disease, the effects of which become more marked with
@c increasing age.  Samples of islander males of various ages were tested
@c for blindness and the results recorded.  The data is shown below:

Kalythos라는 에게해에 있는 한 섬에는 남성들이 선천성 안질환을 가지고 있습니다. 
이 안질환은 주로 나이가 들어감에 따라서 진행되어집니다. 
아래의 데이터는 이 섬에 거주하는 다양한 연령대의 남성들의 실명여부를 검사한 결과를 기록한 것입니다.

@iftex
@quotation
@multitable {No.@: tested::} {50} {50} {50} {50} {50}
@item Age:          @tab  20 @tab  35 @tab  45 @tab  55 @tab  70
@item No.@: tested: @tab  50 @tab  50 @tab  50 @tab  50 @tab  50
@item No.@: blind:  @tab  @w{ 6} @tab  17 @tab  26 @tab  37 @tab  44
@end multitable
@end quotation
@end iftex
@ifnottex
@multitable {No.@: tested::} {50} {50} {50} {50} {50}
@item Age:          @tab  20 @tab  35 @tab  45 @tab  55 @tab  70
@item No.@: tested: @tab  50 @tab  50 @tab  50 @tab  50 @tab  50
@item No.@: blind:  @tab  @w{ 6} @tab  17 @tab  26 @tab  37 @tab  44
@end multitable
@end ifnottex

@c The problem we consider is to fit both logistic and probit models to
@c this data, and to estimate for each model the LD50, that is the age at
@c which the chance of blindness for a male inhabitant is 50%.

우리는 이 데이터에 로지스틱(logistic)과 프로빗(probit)이라는 두가지 모델을 적합시키고 각각의 모형으로부터 남성거주자의 실명확률이 50%가 되는 나이(LD50)를 추정하고자 합니다.

@c If @math{y} is the number of blind at age @math{x} and @math{n} the
@c number tested, both models have the form
만약 @math{y}가 연령 @math{x}에서 테스트로부터 확인된 실명한 사람들의 수이고, @math{n}은 테스트를 받은 사람들이라면,
@ifnottex
y ~ B(n, F(beta_0 + beta_1 x))
@end ifnottex
@tex
$$ y \sim {\rm B}(n, F(\beta_0 + \beta_1 x)) $$
@end tex
이라고 할 수 있습니다.
@c where for the probit case,
프로빗의 경우에는 
@eqn{F(z) = \Phi(z), F(z) = Phi(z)}
@c is the standard normal distribution function, and in the logit case
이 정규분포 함수이며, 로짓의 경우에는 
@c (the default),
@eqn{F(z) = e^z/(1+e^z),F(z) = e^z/(1+e^z)}
입니다.
@c In both cases the LD50 is
두 경우 모두 LD50은 
@ifnottex
LD50 = - beta_0/beta_1
@end ifnottex
@tex
$$ \hbox{LD50} = -\beta_0/\beta_1 $$
@end tex
@c that is, the point at which the argument of the distribution function is
@c zero.
이 되며, 이것은 분포함수 @code{F(z)}의 값을 @math{0}으로 만들어 주는 @code{z}에 해당하게 됩니다.


@c The first step is to set the data up as a data frame
이 문제를 접근하는 가장 첫번째 단계는 모형에서 다룰 데이터를 아래와 같이 데이터프레임의 형식을 갖도록 하는 것입니다.

@example
> kalythos <- data.frame(x = c(20,35,45,55,70), n = rep(50,5),
                         y = c(6,17,26,37,44))
@end example

@c To fit a binomial model using @code{glm()} there are three possibilities
@c for the response:

@code{glm()}함수를 이용하여 이항모델(binomial model)을 적합하고자 한다면 아래의 세가지 경우 중 한 가지에 해당될 것입니다.

@itemize @bullet
@item
@c If the response is a @emph{vector} it is assumed to hold @emph{binary}
@c data, and so must be a @math{0/1} vector.
종속변수가 @math{0}과 @math{1}만을 데이터값으로 가지는 @emph{열벡터}인 경우입니다. 

@item
@c If the response is a @emph{two-column matrix} it is assumed that the
@c first column holds the number of successes for the trial and the second
@c holds the number of failures.
종속변수가 @emph{두개의 열을 가지는 행렬}인데, 첫번째 열은 모든 시행에 대한 성공회수 그리고 두번째 열은 실패회수의 정보를 가진 경우입니다.

@item
@c If the response is a @emph{factor}, its first level is taken as failure
@c (0) and all other levels as `success' (1).
종속변수는 @emph{요인}일 수 있는데, 첫번째 수준이 실패를 의미하는 @math{0}의 값을 가지고, 두번째 레벨은 성공을 의미하는 @math{1}의 값을 가지는 경우입니다.
@end itemize

@c Here we need the second of these conventions, so we add a matrix to our
@c data frame:

여기에서는 두번째의 경우를 다룰 것이므로, 아래와 같은 작업을 통하여 데이터프레임에 실패의 정보를 포함하고 있는 열을 추가합니다.

@example
> kalythos$Ymat <- cbind(kalythos$y, kalythos$n - kalythos$y)
@end example

@c To fit the models we use

모형을 적합하는 방법은 아래와 같습니다.

@example
> fmp <- glm(Ymat ~ x, family = binomial(link=probit), data = kalythos)
> fml <- glm(Ymat ~ x, family = binomial, data = kalythos)
@end example

@c Since the logit link is the default the parameter may be omitted on the
@c second call.  To see the results of each fit we could use

만약 아무런 링크함수를 지정하지 않는다면 @R{}은 기본적으로 @code{logit}링크함수를 이용합니다.
적합된 모형의 결과를 보기 위해서 아래와 같이 실행합니다.

@example
> summary(fmp)
> summary(fml)
@end example

@c Both models fit (all too) well.  To find the LD50 estimate we can use a
@c simple function:

두 모형 모두 적합결과가 좋습니다. 
LD50을 추정하기 위해서 우리는 다음과 같은 간단한 함수를 작성합니다.

@example
> ld50 <- function(b) -b[1]/b[2]
> ldp <- ld50(coef(fmp)); ldl <- ld50(coef(fml)); c(ldp, ldl)
@end example

@c The actual estimates from this data are 43.663 years and 43.601 years
@c respectively.

이 데이터로부터의 추정치는 각각 43.663 과 43.601 입니다.

@c @subsubheading Poisson models
@subsubheading 포아송 (Poisson) 모델들

@c With the Poisson family the default link is the @code{log}, and in
@c practice the major use of this family is to fit surrogate Poisson
@c log-linear models to frequency data, whose actual distribution is often
@c multinomial.  This is a large and important subject we will not discuss
@c further here.  It even forms a major part of the use of non-gaussian
@c generalized models overall.

포아송 페밀리 (Poisson family)의 경우 @code{log}를 기본링크함수로 사용하며, 주로 포아송 로그선형모델 (Poisson log-linear model)을 이용하여 빈도데이터 (frequency data)를 적합하는데 사용됩니다. 
이런 종류의 데이터는 종종 멀티노미얼 분포(multinomial distribution)을 따르는데, 이것은 매우 중요하고도 방대한 주제이므로 본 문서에서는 다루지 않을 것입니다. 
포이송 페밀리를 이용하는 것은 가우시안페밀리에 해당하지 않는 거의 모든 경우의 일반선형모형에 해당하므로 매우 중요합니다.

@c Occasionally genuinely Poisson data arises in practice and in the past
@c it was often analyzed as gaussian data after either a log or a
@c square-root transformation.  As a graceful alternative to the latter, a
@c Poisson generalized linear model may be fitted as in the following
@c example:

과거에는 실무에서 가끔 포이송데이터를 로그 혹은 스퀘어루트를 이용하여 변환된 데이터를 가우시안 분포를 따르는 데이터와 같이 분석을 수행하기도 했었지만, 현재는 아래와 같이 포이송 페밀리를 이용한 일반선형모형을 수행합니다.

@example
> fmod <- glm(y ~ A + B + x, family = poisson(link=sqrt),
              data = worm.counts)
@end example

@c @subsubheading Quasi-likelihood models
@subsubheading 쿼시-라이클리후드 모델들

@c For all families the variance of the response will depend on the mean
@c and will have the scale parameter as a multiplier.  The form of
@c dependence of the variance on the mean is a characteristic of the
@c response distribution; for example for the poisson distribution
@c @eqn{\hbox{Var}[y] = \mu,Var(y) = mu}.

일반선형모델의 모든 페밀리들이 종속변수의 분산은 평균에 대한 함수이며, 스케일파라미터는 계수(multiplier)라는 공통점이 있습니다.
분산과 평균과의 상관관계는 종속변수분포의 특징이기도 합니다. 
예를 들어, 포아송 분포는 평균과 분산이 일치합니다. (즉, @eqn{\hbox{Var}[y] = \mu,Var(y) = mu}).


@c For quasi-likelihood estimation and inference the precise response
@c distribution is not specified, but rather only a link function and the
@c form of the variance function as it depends on the mean.  Since
@c quasi-likelihood estimation uses formally identical techniques to those
@c for the gaussian distribution, this family provides a way of fitting
@c gaussian models with non-standard link functions or variance functions,
@c incidentally.

쿼시-라이클리후드(Quasi-likelihood)를 이용한 추정과 추론은 정확한 종속변수의 분포가 지정되지 않았으나 링크함수와 variance function이 평균과 어떤 관계를 가지고 있는지와 관련이 있습니다. 
쿼시-라이클리후드(Quasi-likelihood)를 이용한 추정은 가우시안 분포를 사용하는 경우와 동일한 방법을 사용하므로, 비표준링크함수 혹은 분산함수(variance funtion)를 이용하여 가우시안 모형의 적합을 가능하게 해줍니다.

@c For example, consider fitting the non-linear regression
예를들어, 아래와 같은 비선형회귀모델을 적합한다고 가정합니다.
@ifnottex
y = theta_1 z_1 / (z_2 - theta_2) + e
@end ifnottex
@tex
$$ y = {\theta_1z_1 \over z_2 - \theta_2} + e $$
@end tex
@c which may be written alternatively as
이 모형은 다시 아래와 같이 쓸 수 있습니다.
@ifnottex
y = 1 / (beta_1 x_1 + beta_2 x_2) + e
@end ifnottex
@tex
$$ y = {1 \over \beta_1x_1 + \beta_2x_2} + e $$
@end tex
@c where
이때, 
@ifnottex
x_1 = z_2/z_1, x_2 = -1/z_1, beta_1 = 1/theta_1, and beta_2 =
theta_2/theta_1.
@end ifnottex
@tex
$x_1 = z_2/z_1$, $x_2=-1/z_1$, $\beta_1=1/\theta_1$ and
$\beta_2=\theta_2/\theta_1$.
@end tex
입니다.

@c Supposing a suitable data frame to be set up we could fit this
@c non-linear regression as

만약, 사용자가 이 모델에 대응하는 데이터 프레임을 가지고 있다면, 위에서 정의한 비선형회귀 모형은 아래와 같이 적합될 수 있습니다.

@example
> nlfit <- glm(y ~ x1 + x2 - 1,
               family = quasi(link=inverse, variance=constant),
               data = biochem)
@end example

@c The reader is referred to the manual and the help document for further
@c information, as needed.

만약, 더 자세한 설명이 필요하다면 매뉴얼과 도움말을 이용하시길 바랍니다.

@node Nonlinear least squares and maximum likelihood models, Some non-standard models, Generalized linear models, Statistical models in R
@c @section Nonlinear least squares and maximum likelihood models
@section 비선형 최소제곱 및 최우추정 모델들
@cindex Nonlinear least squares

@c Certain forms of nonlinear model can be fitted by Generalized Linear
@c Models (@code{glm()}).  But in the majority of cases we have to approach
@c the nonlinear curve fitting problem as one of nonlinear optimization.
@c @R{}'s nonlinear optimization routines are @code{optim()}, @code{nlm()}
@c and (from @R{} 2.2.0) @code{nlminb()},
@c @findex nlm
@c @findex optim
@c @findex nlminb
@c which provide the functionality (and more) of @SPLUS{}'s @code{ms()} and
@c @code{nlminb()}.  We seek the parameter values that minimize some index
@c of lack-of-fit, and they do this by trying out various parameter values
@c iteratively.  Unlike linear regression for example, there is no
@c guarantee that the procedure will converge on satisfactory estimates.
@c All the methods require initial guesses about what parameter values to
@c try, and convergence may depend critically upon the quality of the
@c starting values.

특정한 형식을 가지고 있는 비선형모델은 일반선형모델의 @code{glm()}에 의하여 적합될 수 있습니다. 
그러나, 대부분의 비선형 모델의 경우 적합이란 문제는 수치해석측면의 최적화 문제로서 접근해야만 합니다. 
@R{}은 이런 비선형 최적화 문제를 위해서 @code{optim()}, @code{nlm()}, @code{nlminb()}의 기능을 제공하고 있습니다. 
특히, @code{nlminb()}는 @R{} 2.2.0 부터는  @SPLUS{}에서 사용할 수 있었던 @code{ms()}와 @code{nlminb()}과 같거나 더 많은 기능을 제공합니다.
이러한 함수들의 기본 동작원리는 여러가지 모수의 값을 반복적으로 적용하여 적합결여지표 (the index of lack-of-fit)의 값을 최소화하는 모수의 값을 추정하는 것입니다. 
그러나, 선형회귀에서 사용되는 모수의 추정과는 달리 비선형최적화 방법을 통한 모수의 추정은 만족스러운 수준의 추정치에 수렴하지 않을 수도 있습니다. 
그 이유는 여기에 사용되는 수치해석법이 모수에 대한 초기값을 지정해야 하고, 추정치에 대한 수렴이라는 과정은 시작점의 선택에 따라서 크게 달라질 수 있기 때문입니다.

@menu
* Least squares::               
* Maximum likelihood::          
@end menu

@node Least squares, Maximum likelihood, Nonlinear least squares and maximum likelihood models, Nonlinear least squares and maximum likelihood models
@c @subsection Least squares
@subsection 최소제곱법

@c One way to fit a nonlinear model is by minimizing the sum of the squared
@c errors (SSE) or residuals.  This method makes sense if the observed
@c errors could have plausibly arisen from a normal distribution.

비선형 모형을 적합하는 한가지 방법은 오차 혹은 잔차들의 제곱합 (the sum of the squared errors or residuals)을 최소화시키는 것입니다. 
이러한 최소제곱법은 관측된 오차들이 정규분포와 유사할 경우 권장됩니다.

@c Here is an example from Bates & Watts (1988), page 51.  The data are:

여기에서는 Bates & Watts (1988), page 51에 수록된 예제를 하나 살펴보도록 하겠습니다 . 
주어진 데이터는 아래와 같습니다.

@example
> x <- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56,
         1.10, 1.10)
> y <- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)
@end example

@c The fit criterion to be minimized is:

최소화 시켜야 할 적합기준을 아래와 같이 정의합니다.

@example
> fn <- function(p) sum((y - (p[1] * x)/(p[2] + x))^2)
@end example

@c In order to do the fit we need initial estimates of the parameters.  One
@c way to find sensible starting values is to plot the data, guess some
@c parameter values, and superimpose the model curve using those values.

적합을 위해서 모수에 대한 초기값이 필요합니다. 
이러한 초기값을 결정하는 한가지 방법은 데이터를 플랏시켜보아 데이터와 비슷한 유사한 패턴을 생성해주는 분포의 모수를 추측해 보는 것입니다.

@example
> plot(x, y)
> xfit <- seq(.02, 1.1, .05)
> yfit <- 200 * xfit/(0.1 + xfit)
> lines(spline(xfit, yfit))
@end example

@c We could do better, but these starting values of 200 and 0.1 seem
@c adequate.  Now do the fit:

초기값에 대해서 물론 더 나은 추측값들이 있겠지만 200 과 0.1 이 적당하다고 생각하므로 이들을 이용하여 모형을 적합시켜 보았습니다.

@example
> out <- nlm(fn, p = c(200, 0.1), hessian = TRUE)
@end example
@findex nlm

@c After the fitting, @code{out$minimum} is the SSE, and
@c @code{out$estimate} are the least squares estimates of the parameters.
@c To obtain the approximate standard errors (SE) of the estimates we do:

적합된 모형으로부터 @code{out$minimum}는 SSE를, @code{out$estimate}는 최소제곱법을 이용하여 추정된 모수의 값을 확인할 수 있습니다. 
추정된 모수의 표준오차(standard error, SE)는 아래와 같이 근사되어집니다.

@example
> sqrt(diag(2*out$minimum/(length(y) - 2) * solve(out$hessian)))
@end example

@c The 2 in the line above represents the number of parameters.  A 95%
@c confidence interval would be the parameter estimate @eqn{\pm, +/-} 1.96
@c SE.  We can superimpose the least squares fit on a new plot:

위의 공식에서 사용된 숫자 2는 모수의 개수를 의미합니다. 
모수의 추정치에 대한 95%의 신뢰구간을 구하기 위해서 @eqn{\pm, +/-} 1.96를 계산합니다. 
최소제곱법으로 적합된 모형을 이용하여 새로운 플랏을 생성하여 데이터와 비교해봅니다.

@example
> plot(x, y)
> xfit <- seq(.02, 1.1, .05)
> yfit <- 212.68384222 * xfit/(0.06412146 + xfit)
> lines(spline(xfit, yfit))
@end example

@c The standard package @pkg{stats} provides much more extensive facilities
@c for fitting non-linear models by least squares.  The model we have just
@c fitted is the Michaelis-Menten model, so we can use

표준패키지인 @pkg{stats}는 최소제곱방식을 이용하여 비선형모형을 적합하는 방대한 양의 함수들을 제공하고 있습니다. 
위에서는 Michaelis-Menten 모델을 이용하여 모델을 적합하였으나, 다음과 같은 방법으로도 가능합니다

@example
> df <- data.frame(x=x, y=y)
> fit <- nls(y ~ SSmicmen(x, Vm, K), df)
> fit
Nonlinear regression model
  model:  y ~ SSmicmen(x, Vm, K)
   data:  df
          Vm            K
212.68370711   0.06412123
 residual sum-of-squares:  1195.449
> summary(fit)

Formula: y ~ SSmicmen(x, Vm, K)

Parameters:
    Estimate Std. Error t value Pr(>|t|)
Vm 2.127e+02  6.947e+00  30.615 3.24e-11
K  6.412e-02  8.281e-03   7.743 1.57e-05

Residual standard error: 10.93 on 10 degrees of freedom

Correlation of Parameter Estimates:
      Vm
K 0.7651
@end example

@node Maximum likelihood,  , Least squares, Nonlinear least squares and maximum likelihood models
@c @subsection Maximum likelihood
@subsection 최우추정법
@cindex Maximum likelihood

@c Maximum likelihood is a method of nonlinear model fitting that applies
@c even if the errors are not normal.  The method finds the parameter values
@c which maximize the log likelihood, or equivalently which minimize the
@c negative log-likelihood.  Here is an example from Dobson (1990), pp.@:
@c 108--111.  This example fits a logistic model to dose-response data,
@c which clearly could also be fit by @code{glm()}.  The data are:

최우추정(Maximum likelihood)법 또한 비선형모델을 적합하는데 쓰이며, 오차항이 정규분포를 따르지 않을 경우에도 이용될 수 있습니다. 
이 방법의 핵심은 로그-우도(log-likelihood) 함수를 최대화 시켜주는 모수를 찾는것이며, 이것은 네가티브 로그-우도(negative log-likelihood)를 최소화 시켜주는 것과 동일합니다. 
여기에서는 Dobson(1990), pp.108–111 에 나오는 예제를 살펴보도록 하겠습니다. 
이 예제는 dose-response 데이터에 로지스틱 모형을 적합하는 것이며 @code{glm()}함수를 활용할 수 있습니다. 
주어진 데이터는 아래와 같습니다.

@example
> x <- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113,
         1.8369, 1.8610, 1.8839)
> y <- c( 6, 13, 18, 28, 52, 53, 61, 60)
> n <- c(59, 60, 62, 56, 63, 59, 62, 60)
@end example

@c The negative log-likelihood to minimize is:

아래와 같이 정의된 네가티브 로그-우도 함수를 최소화 하고자 합니다.

@example
> fn <- function(p)
   sum( - (y*(p[1]+p[2]*x) - n*log(1+exp(p[1]+p[2]*x))
           + log(choose(n, y)) ))
@end example

@c @noindent
@c We pick sensible starting values and do the fit:

이를 수행하기 위해서 그럴듯한 시작값 (starting values)를 지정합니다.

@example
> out <- nlm(fn, p = c(-50,20), hessian = TRUE)
@end example
@findex nlm

@c @noindent
@c After the fitting, @code{out$minimum} is the negative log-likelihood,
@c and @code{out$estimate} are the maximum likelihood estimates of the
@c parameters.  To obtain the approximate SEs of the estimates we do:

적합된 모형으로부터 최소화 된 음수인 우도함수 (negative log-likelihood) 값은 @code{out$minimum}로부터 얻을 수 있고, 모수의 최우추정치는 @code{out$estimate}을 통하여 얻을 수 있습니다. 
추정치에 대한 표준오차는 아래와 같이 근사되어집니다.

@example
> sqrt(diag(solve(out$hessian)))
@end example

@c A 95% confidence interval would be the parameter estimate @eqn{\pm, +/-}
@c 1.96 SE.

95% 신뢰구간은 추정된 모수값에 @eqn{\pm, +/-}SE 를 계산하시면 됩니다.

@node Some non-standard models,  , Nonlinear least squares and maximum likelihood models, Statistical models in R
@c @section Some non-standard models
@section 그외의 비선형 모델들 

@c We conclude this chapter with just a brief mention of some of the other
@c facilities available in @R{} for special regression and data analysis
@c problems.

이번 장을 마무리 하기 위해서 @R{}이 특별한 회귀모형 및 데이터 분석에 어떠한 기능들을 사용가능한지 간단히 정리해 보았습니다.

@itemize @bullet
@item
@cindex Mixed models
@c @strong{Mixed models.}  The recommended @CRANpkg{nlme} package provides
@c functions @code{lme()} and @code{nlme()}
@findex lme
@findex nlme
@c for linear and non-linear mixed-effects models, that is linear and
@c non-linear regressions in which some of the coefficients correspond to
@c random effects.  These functions make heavy use of formulae to specify
@c the models.
@strong{Mixed models}이란 선형 및 비선형 회귀모형의 회귀계수 일부가 random effect을 가지는 모델입니다. 
이러한 선형 및 비선형 mixed models을 적합하기 위해서 @CRANpkg{nlme}이라는 권장패키지에서 제공되는 @code{lme()}와 @code{nlme()}를 이용할 수 있습니다.

@item
@cindex Local approximating regressions
@c @strong{Local approximating regressions.}  The @code{loess()}
@findex loess
@c function fits a nonparametric regression by using a locally weighted
@c regression.  Such regressions are useful for highlighting a trend in
@c messy data or for data reduction to give some insight into a large data
@c set.

@c Function @code{loess} is in the standard package @pkg{stats}, together
@c with code for projection pursuit regression.
@findex loess

@strong{Local approximating regressions}는 @code{loess()} 함수가 locally weighted regression을 이용하여 비모수회귀(nonparametric regression)모델의 적합에 사용됩니다. 
이러한 회귀분석은 메시데이터(messy data)에 대한 특정 추세를 파악하거나, 사이즈가 큰 데이터에 대해서 데이터 리덕션(data reduction)을 하고자 할 때 이용될 수 있습니다. 
@code{loess()}라는 함수는 표준패키지인 @pkg{stats}에 포함되어 있습니다.

@item
@cindex Robust regression
@c @strong{Robust regression.} There are several functions available for
@c fitting regression models in a way resistant to the influence of extreme
@c outliers in the data.  Function @code{lqs}
@findex lqs
@c in the recommended package @CRANpkg{MASS} provides state-of-art algorithms
@c for highly-resistant fits.  Less resistant but statistically more
@c efficient methods are available in packages, for example function
@c @code{rlm}
@findex rlm
@c in package @CRANpkg{MASS}.

@strong{Robust regression}은 데이터에 포함된 이상치(extreme outliers)들의 영향력을 줄여 안정적인 회귀모형을 적합한 것이데, 이를 수행하기 위해 몇가지 함수를 제공하고 있습니다.
현재로서는 추천패키지 @pkg{MASS}에 포함되어 있는 @code{lqs}라는 함수가 다른 함수들에 비하여 이상치들의 영향을 상대적으로 적게 받는 다소 안정적으로 모델을 적합해주는 것으로 알려져 있습니다. 
또한 이 @pkg{MASS}에는 이상치에 대한 모형적합의 안정성이 @code{lqs}보다 다소 불안정하나, 통계적으로 좀 더 효율적인 결과를 제공하는 @code{rlm}이라는 함수도 있습니다.

@item
@cindex Additive models
@c @strong{Additive models.} This technique aims to construct a regression
@c function from smooth additive functions of the determining variables,
@c usually one for each determining variable.  Functions @code{avas} and
@c @code{ace}
@findex avas
@findex ace
@c in package @CRANpkg{acepack} and functions @code{bruto} and @code{mars}
@findex bruto
@findex mars
@c in package @CRANpkg{mda} provide some examples of these techniques in
@c user-contributed packages to @R{}.  An extension is @strong{Generalized
@c Additive Models}, implemented in user-contributed packages @CRANpkg{gam} and
@c @CRANpkg{mgcv}.

@strong{Additive models}는 aims to construct a regression function from smooth additive functions of the determining variables, usually one for each determining variable. 
사용자개발패키지인 @CRANpkg{acepack}내의 @code{avas}와 @code{ace}, 그리고 @CRANpkg{mda} 패키지내의 @code{bruto}와 @code{mars} 함수들로부터 이 회귀모형에 대한 예제를 찾아 볼 수 있습니다.
@strong{Generalized Additive Models}에 대해서 보다 더 일반적인 사용자개발패키지는 @CRANpkg{gam}과 @CRANpkg{mgcv}이 있습니다.  

@c function from smooth additive functions of the determining variables,
@c usually one for each determining variable.

@item
@cindex Tree-based models
@c @strong{Tree-based models.} Rather than seek an explicit global linear
@c model for prediction or interpretation, tree-based models seek to
@c bifurcate the data, recursively, at critical points of the determining
@c variables in order to partition the data ultimately into groups that are
@c as homogeneous as possible within, and as heterogeneous as possible
@c between.  The results often lead to insights that other data analysis
@c methods tend not to yield.

@c Models are again specified in the ordinary linear model form.  The model
@c fitting function is @code{tree()},
@findex tree
@c but many other generic functions such as @code{plot()} and @code{text()}
@c are well adapted to displaying the results of a tree-based model fit in
@c a graphical way.

@c Tree models are available in @R{} @emph{via} the user-contributed
@c packages @CRANpkg{rpart} and @CRANpkg{tree}.
@strong{Tree-based models}은 데이터 파티션에 주 목적이 있습니다.  
이는 일반적인 선형모델방법이 전체적인 데이터의 특징을 설명하고 예측할 수 있는 선형모델을 찾는것과는 다릅니다.
데이터파티셔닝의 기본원리는 주어진 데이터를 여러개의 동질적인 그룹들로 나누어 주되, 각 그룹간의 이질성은 최대화 시켜주는 방법을 말합니다. 
이것은 그룹간의 차이를 가장 잘 구분할 수 있는 모형을 찾아 그 모형대로 데이터를 반복적으로 이분화함으로 이루어집니다. 
그런데, 이러한 데이터 파티셔닝은 종종 다른 데이터 분석법으로부터는 찾을 수 없었던 데이터가 가지고 있는 특징을 발견해 내기도 합니다. 
이러한 @strong{Tree-based models}에 의한 데이터 파티셔닝은 @code{tree()}라는 함수를 통하여 이루어집니다. 
또한 이 분석법에 의한 결과는 효율적인 시각화를 위하여 @code{plot()}와 @code{text()}와 같은 제네릭함수와도 잘 호환되도록 설계되었습니다.

이러한 트리모델(tree models)는 @CRANpkg{rpart}과 @CRANpkg{tree}과 같은 사용자기여패키지(user contributed package)를 통해 이용가능합니다.
@end itemize


@node Graphics, Packages, Statistical models in R, Top
@c @chapter Graphical procedures
@chapter 그래픽 프로시져

@c Graphical facilities are an important and extremely versatile component
@c of the @R{} environment.  It is possible to use the facilities to
@c display a wide variety of statistical graphs and also to build entirely
@c new types of graph.

@R{}(개발)환경의 중요하고도 매우 다양한 역할을 수행하는 요소는 바로 그래픽 기능입니다. 
이를 통해 다양한 종류의 통계 그래프를 보여줄 수 있으며, 완전히 새로운 종류의 그래프를 만들어 낼 수도 있습니다.

@c The graphics facilities can be used in both interactive and batch modes, but in
@c most cases, interactive use is more productive.  Interactive use is also
@c easy because at startup time @R{} initiates a graphics @emph{device
@c driver} which opens a special @emph{graphics window} for the display of
@c interactive graphics.  Although this is done automatically, it is useful
@c to know that the command used is @code{X11()} under UNIX,
@c @code{windows()} under Windows and @code{quartz()} under Mac OS X.

그래픽 기능들은 대화식(interactive)처리방식과 배치(batch)처리방식이 있습니다.
대부분의 경우에는 대화식 처리방식을 이용하는 것이 더욱 효과적이며 사용하기 쉽습니다.
그 이유는 @R{}이 시작할때 대화식 그래픽처리를 위한 특수한 @emph{graphics window}(그래픽 윈도우)를 열어주는 @emph{device driver}(장치드라이버)를 자동으로 초기화 시켜주기 때문입니다.  
물론 그래픽 장치드라이버가 자동 초기화되기는 하지만, 이러한 기능을 수행하는 명령어를 알아두면 더욱 편리한 사용을 할 수 있습니다.
UNIX에서는 @code{X11()}, 윈도우즈에서는 @code{windows()}, 그리고 Mac OS X에서는 @code{quartz()}입니다.

@c Once the device driver is running, @R{} plotting commands can be used to
@c produce a variety of graphical displays and to create entirely new kinds
@c of display.

장치드라이버가 실행이 되면, @R{} 플랏팅 명령어들은 다양한 종류의 그래픽처리 및 새로운 종류의 그래프를 생성하기 위해서 사용될 수 있습니다.

@c Plotting commands are divided into three basic groups:
플랏팅 명령어들은 다음과 같이 크게 세 영역으로 나뉘어 집니다:

@itemize @bullet
@item
@c @strong{High-level} plotting functions create a new plot on the graphics
@c device, possibly with axes, labels, titles and so on.
@strong{High-level}(하이레벨) 플랏팅 함수들은 그래픽 장치에 축, 라벨, 제목등과 함께 새로운 플랏을 생성합니다. 
@item
@c @strong{Low-level} plotting functions add more information to an
@c existing plot, such as extra points, lines and labels.
@strong{Low-level}(로우레벨) 플랏팅 함수들은 이미 존재하는 플랏에 점, 선, 라벨들을 추가하여 좀 더 많은 정보들을 표현할 수 있도록 합니다. 
@item
@c @strong{Interactive} graphics functions allow you interactively add
@c information to, or extract information from, an existing plot, using a
@c pointing device such as a mouse.
@strong{Interactive}(대화형) 그래픽 함수들은 마우스와 같은 포인팅 장치(pointing device)를 이용하여 이미 생성된 플랏에 정보를 추가하거나 또는 추출해 냅니다.
@end itemize

@c In addition, @R{} maintains a list of @emph{graphical parameters} which
@c can be manipulated to customize your plots.

또한, @R{}은 사용자가 원하는대로 플랏을 수정 및 변경할 수 있도록 @emph{graphical parameters}(그래픽 파라미터)들의 목록을 제공해주고 있습니다.

@c This manual only describes what are known as `base' graphics.  A
@c separate graphics sub-system in package @pkg{grid} coexists with base --
@c it is more powerful but harder to use.  There is a recommended package
@c @CRANpkg{lattice} which builds on @pkg{grid} and provides ways to produce
@c multi-panel plots akin to those in the @emph{Trellis} system in @Sl{}.

이 안내서에서는 `base' 그래픽이라고 알려진 것들에 대해서만 다룹니다.
base 그래픽와는 별개로 @pkg{grid} 패키지 내에 있는 별도의 그래픽 서브-시스템이 존재합니다. 
이 시스템은 좀 더 강력한 그래픽 기능들을 제공하지만, 사용에 다소 어려움이 있습니다.
또한, @pkg{grid}를 기반으로 하는 @CRANpkg{lattice}라는 추천패키지도 있는데, 이는 @Sl{}에서 @emph{Trellis}(트렐리스)라는 시스템이 제공하는 다중패널 플랏과 같은 고급 그래픽처리가 가능한 함수들을 포함하고 있습니다.


@menu
* High-level plotting commands::  
* Low-level plotting commands::  
* Interacting with graphics::   
* Using graphics parameters::   
* Graphics parameters::         
* Device drivers::              
* Dynamic graphics::            
@end menu

@node High-level plotting commands, Low-level plotting commands, Graphics, Graphics
@c @section High-level plotting commands
@section 하이레벨 플랏팅 명령어들

@c High-level plotting functions are designed to generate a complete plot
@c of the data passed as arguments to the function.  Where appropriate,
@c axes, labels and titles are automatically generated (unless you request
@c otherwise.) High-level plotting commands always start a new plot,
@c erasing the current plot if necessary.

하이레벨 플랏 함수들은 함수에 전달된 인자만을 가지고도 특별한 설정없이도 적절한 위치에 축, 레이블, 그리고 제목들이 놓이며 데이터에 대한 완전한 시각화 처리를 할 수 있도록 작성되었습니다. 
하이레벨 플랏 명령어들은 항상 현재 존재하는 그래픽 디바이스에 출력되어 있는 플랏을 지우고, 항상 새로운 플랏을 생성합니다.

@menu
* The plot() function::         
* Displaying multivariate data::  
* Display graphics::            
* Arguments to high-level plotting functions::  
@end menu

@node The plot() function, Displaying multivariate data, High-level plotting commands, High-level plotting commands
@c @subsection The @code{plot()} function
@subsection @code{plot()} 함수
@findex plot

@c One of the most frequently used plotting functions in @R{} is the
@c @code{plot()} function.  This is a @emph{generic} function: the type of
@c plot produced is dependent on the type or @emph{class} of the first
@c argument.

@R{}에서 가장 많이 사용되는 플랏팅 함수는 @code{plot()}입니다. 
이는 @emph{제네릭 (generic)} 함수이며, 생성되는 플랏의 종류는 함수의 첫번째 인자로서 입력받는 객체의 @emph{클래스(class)}에 의해서 결정됩니다.

@table @code

@item plot(@var{x}, @var{y})
@itemx plot(@var{xy})
@c If @var{x} and @var{y} are vectors, @code{plot(@var{x}, @var{y})}
@c produces a scatterplot of @var{y} against @var{x}.  The same effect can
@c be produced by supplying one argument (second form) as either a list
@c containing two elements @var{x} and @var{y} or a two-column matrix.

만약, @var{x}와 @var{y} 두개 모두 벡터이면 @code{plot(@var{x}, @var{y})}은 @var{x}와 @var{y}의 관계를 살펴볼 수 있는 산점도(scatter plot)를 생성합니다.
두 번째의 표현 역시 역시 동일한 산점도를 출력하지만, 인자 @var{xy}가 입력받는 데이터 형식에 주의해야합니다. 
@var{x}와 @var{y}를 컴포넌트로서 가지고 있는 리스트형이거나, 혹은 두 개의 열을 가지는 행렬의 형식을 의미합니다.

@item plot(@var{x})
@c If @var{x} is a time series, this produces a time-series plot. If
@c @var{x} is a numeric vector, it produces a plot of the values in the
@c vector against their index in the vector.  If @var{x} is a complex
@c vector, it produces a plot of imaginary versus real parts of the vector
@c elements.

만약, @var{x}가 시계열 (time-series) 데이터인 경우, 자동으로 시계열 플랏(time-series plot)을 생성합니다. 
만약 @var{x}가 수치형 벡터인 경우, @var{x}의 인덱스를 @code{x}축에 @var{x}의 값을 @code{y}축으로 하는 플랏을 생성하게 됩니다.
만약, @var{x}가 복소수라면 이것은 실수부분와 허수부분에 대한 값들의 관계를 살펴볼 수 있는 산점도의 형식으로 플랏이 생성됩니다.

@item plot(@var{f})
@itemx plot(@var{f}, @var{y})
@c @var{f} is a factor object, @var{y} is a numeric vector.  The first form
@c generates a bar plot of @var{f}; the second form produces boxplots of
@c @var{y} for each level of @var{f}.

여기에서 @var{f}가 요인이고, @var{y}가 수치형 벡터라고 가정을 한다면, 첫번째 표현은 @var{f}의 바플랏 (bar plot)을 생성하고 두번째 표현은 @var{f}의 수준별 @var{y}의 박스플랏 (boxplot)을 생성해줍니다.

@item plot(@var{df})
@itemx plot(~ @var{expr})
@itemx plot(@var{y} ~ @var{expr})
@c @var{df} is a data frame, @var{y} is any object, @var{expr} is a list
@c of object names separated by `@code{+}' (e.g., @code{a + b + c}).  The
@c first two forms produce distributional plots of the variables in a data
@c frame (first form) or of a number of named objects (second form).  The
@c third form plots @var{y} against every object named in @var{expr}.
여기에서 @var{df}는 데이터 프레임, @var{y}는 임의의 객체, @var{expr}는 @code{a+b+c}와 같이 @code{+}로 구분할 수 있는 객체의 이름들에 대한 목록이라고 가정한다면, 첫번째 표현은 데이터프레임의 각 변수에 대해서 다른 변수들간의 분포도를 생성하고, 두번째 표현은 @code{expr}내에 사용된 변수들만을 이용한 분포를 보여줍니다. 
그리고, 마지막 표현은 @var{expr}에 사용된 모든 변수에 대한 @var{y}의 분포를 보여줍니다.
@end table


@node Displaying multivariate data, Display graphics, The plot() function, High-level plotting commands
@c @subsection Displaying multivariate data
@subsection 다변량 데이터의 시각화

@c @R{} provides two very useful functions for representing multivariate
@c data.  If @code{X} is a numeric matrix or data frame, the command

@R{}은 다변량 데이터의 시각화를 위해 두 가지 매우 유용한 함수들을 제공합니다. 
만약, @code{X}가 수치형 행렬 혹은 데이터 프레임이라면, 아래와 같은 방법으로 각각의 모든 열에 대한 산점도 (scatterplot)를 생성할 수 있습니다.
이것은 @code{X}의 한 열 혹은 변수에 대해서 다른 열들에 대한 플랏을 생성하므로, 한 화면에 총 @math{n(n-1)}개의 플랏들이 동일한 형식을 가진 행렬의 형태로 출력되게 됩니다.

@example
> pairs(X)
@end example
@findex pairs

@c @noindent
@c produces a pairwise scatterplot matrix of the variables defined by the
@c columns of @code{X}, that is, every column of @code{X} is plotted
@c against every other column of @code{X} and the resulting @math{n(n-1)}
@c plots are arranged in a matrix with plot scales constant over the rows
@c and columns of the matrix.

@c When three or four variables are involved a @emph{coplot} may be more
@c enlightening.  If @code{a} and @code{b} are numeric vectors and @code{c}
@c is a numeric vector or factor object (all of the same length), then
@c the command

만약, 사용자가 세개 혹은 네 개의 변수만을 이용하여 분석을 수행하는 경우 @emph{coplot}의 사용이 보다 효과적일 수 있습니다. 
예를들어, @code{a}와 @code{b}는 수치형 벡터이고, @code{c}는 수치형 벡터 혹은 @code{a}와 @code{b}와 같은 길이를 가지는 요인벡터라면 아래와 같은 방법으로 @code{c}에 주어진 값에 대하여 @code{a}와 @code{b}의 관계를 보여주는 산점도를 생성할 수 있습니다.
즉, @code{c}가 요인이라면 이 함수는 @code{c}의 수준별 @code{a}와 @code{b} 간의 산점도를 생성합니다.
더 나아가, @code{c}가 수치형 벡터일 경우 @code{c}를 구간화하여 각 구간별 @code{a}와 @code{b}간의 산점도 생성이 가능합니다.
구간에 대한 조정은 인자 @code{given.values=}를 통하여 이루어집니다.
함수 @code{co.intervals()}와 병행하여 사용하면 구간선택시 매우 유용합니다.

@example
> coplot(a ~ b | c)
@end example
@findex coplot

@noindent
@c produces a number of scatterplots of @code{a} against @code{b} for given
@c values of @code{c}.  If @code{c} is a factor, this simply means that
@c @code{a} is plotted against @code{b} for every level of @code{c}.  When
@c @code{c} is numeric, it is divided into a number of @emph{conditioning
@c intervals} and for each interval @code{a} is plotted against @code{b}
@c for values of @code{c} within the interval.  The number and position of
@c intervals can be controlled with @code{given.values=} argument to
@c @code{coplot()}---the function @code{co.intervals()} is useful for
@c selecting intervals.  You can also use two @emph{given} variables with a
@c command like

아래와 같은 방법으로 각각의 변수 @code{c}와 @code{d}가 가지는 값들의 조합으로부터, 각 조합의 수준별 @code{a}와 @code{b}간의 산점도 역시 생성이 가능합니다.

@example
> coplot(a ~ b | c + d)
@end example

@noindent
@c which produces scatterplots of @code{a} against @code{b} for every joint
@c conditioning interval of @code{c} and @code{d}.

@c The @code{coplot()} and @code{pairs()} function both take an argument
@c @code{panel=} which can be used to customize the type of plot which
@c appears in each panel.  The default is @code{points()} to produce a
@c scatterplot but by supplying some other low-level graphics function of
@c two vectors @code{x} and @code{y} as the value of @code{panel=} you can
@c produce any type of plot you wish.  An example panel function useful for
@c coplots is @code{panel.smooth()}.

@code{coplot()}과 @code{pairs()}는 함수 모두 @code{panel=}이라는 인자를 가지고 있습니다. 
이 인자는 각각의 패널에 어떤 종류의 플랏을 생성할 것인지를 결정하며, 산점도를 생성하는데 사용되는 @code{points()}라는 함수가 기본으로 설정되어 있습니다.
만약, 산점도외의 다른 종류의 플랏을 생성하고자 한다면, @code{x}와 @code{y} 벡터를 이용하는 로우레벨의 그래픽 함수를 이용하면 됩니다. 
예를 들어, @code{coplot()}과 함께 사용될 수 있는 유용한 패널함수는 @code{panel.smooth()}입니다.

@node Display graphics, Arguments to high-level plotting functions, Displaying multivariate data, High-level plotting commands
@c @subsection Display graphics
@subsection 그래픽 표현하기

@c Other high-level graphics functions produce different types of plots.
@c Some examples are:
다른 하이레벨 그래픽 함수들은 다른 종류의 플랏들을 생성합니다.
아래는 그 일부를 정리해두었습니다.

@table @code
@item tsplot(x_1, x_2, @dots{})
@findex tsplot
@c  Plots any number of time series on the same scale.  This automatic
@c  simultaneous scaling feature is also useful when the @code{x@var{_i}}'s
@c  are ordinary numeric vectors, in which case they are plotted against the
@c  numbers @math{1, 2, 3, @dots{}}.

임의의 개수에 대한 시계열 데이터들을 같은 스케일 (또는 척도)로 보여줍니다.
이 기능은 @code{x@var{_i}}가 시계열이 아닌 일반 수치형 벡터일때도 유용하게 사용될 수 있습니다.
단, 이경우에는 @math{1, 2, 3, @dots{}}를 기준으로 표현됩니다.

@item qqnorm(x)
@itemx qqline(x)
@itemx qqplot(x, y)
@findex qqnorm
@findex qqline
@findex qqplot
@c Distribution-comparison plots.  The first form plots the numeric vector
@c @code{x} against the expected Normal order scores (a normal scores plot)
@c and the second adds a straight line to such a plot by drawing a line
@c through the distribution and data quartiles.  The third form plots the
@c quantiles of @code{x} against those of @code{y} to compare their
@c respective distributions.
분포에 대한 비교를 위한 플랏을 생성합니다.
첫번째 표현은 수치형 벡터 @code{x}와 expected Normal order score간의 관계를 보여주는 표준스코어 플랏 (Normal scores plot)을 생성합니다.
두번째 표현은 첫번째 표현을 통해 얻은 플랏에 레퍼런스 라인을 추가해줍니다.
세번째 표현은 @code{x}의 퀀타일과 @code{y}의 퀀타일을 서로 비교할 수 있는 플랏을 생성해줍니다.

@item hist(x)
@itemx hist(x, nclass=@var{n})
@itemx hist(x, breaks=@var{b}, @dots{})
@findex hist
@c Produces a histogram of the numeric vector @code{x}.  A sensible number
@c of classes is usually chosen, but a recommendation can be given with the
@c @code{nclass=} argument.  Alternatively, the breakpoints can be
@c specified exactly with the @code{breaks=} argument.  If the
@c @code{probability=TRUE} argument is given, the bars represent relative
@c frequencies divided by bin width instead of counts.
수치형 벡터 @code{x}에 대한 히스토그램을 생성합니다. 
구간의 개수는 인자 @code{nclass=}를 통해 변경될 수 있습니다.
또한, breakpoint (브레이크 포인트 = 구간의 끝점들)은 인자 @code{breaks=}를 통해 정해질 수도 있습니다.
만약, @code{probability=TRUE}가 주어진다면, 세로축이 도수로 표현되지 않고 상대도수로서 나타내어 집니다.

@item dotchart(x, @dots{})
@findex dotchart
@c Constructs a dotchart of the data in @code{x}.  In a dotchart the
@c @math{y}-axis gives a labelling of the data in @code{x} and the
@c @math{x}-axis gives its value.  For example it allows easy visual
@c selection of all data entries with values lying in specified ranges.
@code{x}의 데이터에 대한 닷챠트 (dotchart)를 생성합니다.
닷챠트란 @math{y}-축에 @code{x}의 데이터에 대한 레이블 정보를 표기하고, @math{x}축에는 해당 레이블에 상응하는 값을 표시한 것입니다.
예를들면, 모든 데이터 항목들을 정해진 구간내에 놓인 값과 함께 볼 수 있게 해줍니다.

@item image(x, y, z, @dots{})
@itemx contour(x, y, z, @dots{})
@itemx persp(x, y, z, @dots{})
@findex image
@findex contour
@findex persp
@c Plots of three variables.  The @code{image} plot draws a grid of rectangles
@c using different colours to represent the value of @code{z}, the @code{contour}
@c plot draws contour lines to represent the value of @code{z}, and the
@c @code{persp} plot draws a 3D surface.
3차원 데이터를 시각화 하는데 사용되는 플랏을 제공합니다.
@code{image} 플랏은 @code{z}의 값의 높낮이를 표현하기 위해서 사용된 여러가지 색상을 직사각형으로 구성된 그리드를 생성합니다.
@code{contour}는 @code{z}의 값에 상응하는 컨투어라인 (또는 고등선)을 그려줍니다.
그리고, @code{persp}은 3차원 표면도 (surface plot)을 생성합니다. 
@end table

@node Arguments to high-level plotting functions,  , Display graphics, High-level plotting commands
@c @subsection Arguments to high-level plotting functions
@subsection 하이레벨 플랏 함수에 사용되는 인자들

@c There are a number of arguments which may be passed to high-level
@c graphics functions, as follows:
하이레벨 그래픽 함수에 자주 사용되는 주요인자들을 아래와 같이 정리하였습니다.

@table @code
@item add=TRUE
@c Forces the function to act as a low-level graphics function,
@c superimposing the plot on the current plot (some functions only).
함수가 로우레벨 그래픽 함수와 같이 작동하도록 하여 현재의 플랏을 이전의 플랏위에 겹쳐 놓을 수 있도록 합니다.

@item axes=FALSE
@c Suppresses generation of axes---useful for adding your own custom axes
@c with the @code{axis()} function.  The default, @code{axes=TRUE}, means
@c include axes.
축의 정보를 표시 않도록 하여, 사용자가 직접 @code{axis()}함수를 이용하여 축의 내용을 설정하는데 유용하게 사용됩니다.
하이레벨 플랏에서는 이 인자의 값은 @code{axes=TRUE}로 주어져 있어 그래픽 생성시 자동으로 축의 정보가 포함되어 있습니다.

@item log="x"
@itemx log="y"
@itemx log="xy"
@c Causes the @math{x}, @math{y} or both axes to be logarithmic.  This will
@c work for many, but not all, types of plot.
@math{x}, @math{y} 또는 양쪽 축 모두 @math{log}(로그)의 값을 가지도록 변형합니다.
이것은 플랏의 종류에 따라 많이 사용되기도 하지만 전부 사용되는 것은 아닙니다.

@item type=
@c The @code{type=} argument controls the type of plot produced, as
@c follows:
@code{type=}인자는 생성되는 플랏의 종류를 조절하며 아래와 같습니다.

@table @code
@item type="p"
@c Plot individual points (the default)
기본값으로서 포인트 (즉, 점)을 표시합니다.

@item type="l"
@c Plot lines
라인으로서 표시합니다. 

@item type="b"
@c Plot points connected by lines (@emph{both})
@emph{양쪽 (both)}간을 서로 점으로 연결하여 표시합니다.

@item type="o"
@c Plot points overlaid by lines
라인위에 @code{"o"}라는 기호를 찍어줍니다.

@item type="h"
@c Plot vertical lines from points to the zero axis (@emph{high-density})
@math{0}의 값으로부터 해당 점의 위치까지 높이를 알수 있는 수직선을 그려줍니다. 

@item type="s"
@itemx type="S"
@c Step-function plots.  In the first form, the top of the vertical defines
@c the point; in the second, the bottom.
스텝함수 (step-function, 즉 계단형) 플랏을 생성해줍니다.
첫번째 표현은 점핑포인트에서 수직선을 그리는 계단식 플랏을, 두번째 표현은 점핑포인트에서 수평선을 그리는 계단식 플랏을 생성합니다.
 
@item type="n"
@c No plotting at all.  However axes are still drawn (by default) and the
@c coordinate system is set up according to the data.  Ideal for creating
@c plots with subsequent low-level graphics functions.
이것은 아무것도 생성하지 않습니다.
그러나, 축과 좌표시스템은 데이터에 맞춰서 보여줍니다.
이것은 로우레벨 그래픽 함수를 이용하여 플랏을 생성하는데 유용합니다.
@end table

@item xlab=@var{string}
@itemx ylab=@var{string}
@c Axis labels for the @math{x} and @math{y} axes.  Use these arguments to
@c change the default labels, usually the names of the objects used in the
@c call to the high-level plotting function.
@math{x}축과 @math{y}축에 대한 레이블을 표기합니다.
이 인자들을 이용하여 하이레벨 플랏함수에서 기본적으로 사용하는 레이블의 이름 (즉, 객체의이름)을 변경하도록 해줍니다.

@item main=@var{string}
@c Figure title, placed at the top of the plot in a large font.
플랏의 가장 위치에 가장 큰 글자크기를 가진 주제목을 변경하도록 해줍니다.

@item sub=@var{string}
@c Sub-title, placed just below the @math{x}-axis in a smaller font.
@math{x}-축 바로 밑에 주제목보다는 다소 작은 글자크기로 부제목을 표시합니다.
@end table

@node Low-level plotting commands, Interacting with graphics, High-level plotting commands, Graphics
@c @section Low-level plotting commands
@section 로우레벨 플랏팅 명령어들

@c Sometimes the high-level plotting functions don't produce exactly the
@c kind of plot you desire.  In this case, low-level plotting commands can
@c be used to add extra information (such as points, lines or text) to the
@c current plot.

하이레벨(high-level) 그래픽 함수를 이용하여 정확히 원하는 형태의 플랏을 그리는 것이 불가능한 경우들이 있습니다.
이러한 경우에 로우레벨 (low-level) 함수들을 이용하여 포인트, 선 또는 문자와 같은 추가적인 정보를 표현하는 것이 가능합니다.
즉, 하이레벨 그래픽을 커스터마이징 할 수 있습니다. 

@c Some of the more useful low-level plotting functions are:

유용하게 사용될 수 있는 로우레벨 플랏팅 함수들은 아래와 같습니다. 

@table @code
@item points(x, y)
@itemx lines(x, y)
@findex points
@findex lines
@c Adds points or connected lines to the current plot.  @code{plot()}'s
@c @code{type=} argument can also be passed to these functions (and
@c defaults to @code{"p"} for @code{points()} and @code{"l"} for
@c @code{lines()}.)

현재 그려진 플랏에 포인트 또는 이들을 서로 연결한 선을 추가합니다.
이러한 기능들은 @code{plot()}함수에 정의된 @code{type=}이라는 입력인자를 이용하여 수행할 수도 있습니다.
(이 입력인자에 대한 기본값은 @code{"p"}는 @code{points()}을 의미하고, 
@code{"l"}은 @code{lines()}를 의미합니다.)

@item text(x, y, labels, @dots{})
@findex text
@c Add text to a plot at points given by @code{x, y}.  Normally
@c @code{labels} is an integer or character vector in which case
@c @code{labels[i]} is plotted at point @code{(x[i], y[i])}.  The default
@c is @code{1:length(x)}.

@code{x,y}의 위치에 놓인 점들에 텍스트를 추가합니다.
일반적으로 @code{labels} (레이블)은 정수 또는 문자형 벡터로서 주어지면, 
@code{labels[i]}는 @code{(x[i], y[i])}의 위치에 놓이게 됩니다. 
기본적으로 레이블은 @code{1:length(x)}으로 정해져 있습니다.

@c @strong{Note}: This function is often used in the sequence
@strong{주의}: 이 함수는 다음과 같은 순서로 사용되는 경우가 많습니다.

@example
> plot(x, y, type="n"); text(x, y, names)
@end example

@noindent
@c The graphics parameter @code{type="n"} suppresses the points but sets up
@c the axes, and the @code{text()} function supplies special characters, as
@c specified by the character vector @code{names} for the points.

그래픽 파라미터인 @code{type="n"}은 포인트를 보여지지 않게 하지만, 이는 좌표축 (axes)들을 설정하고, 
@code{text()}함수는 문자형 벡터 @code{names}를 이용하여 포인트의 위치에 특수한 문자들을 표현합니다. 

@item abline(a, b)
@itemx abline(h=@var{y})
@itemx abline(v=@var{x})
@itemx abline(@var{lm.obj})
@findex abline
@c Adds a line of slope @code{b} and intercept @code{a} to the current
@c plot.  @code{h=@var{y}} may be used to specify @math{y}-coordinates for
@c the heights of horizontal lines to go across a plot, and
@c @code{v=@var{x}} similarly for the @math{x}-coordinates for vertical
@c lines.  Also @var{lm.obj} may be list with a @code{coefficients}
@c component of length 2 (such as the result of model-fitting functions,)
@c which are taken as an intercept and slope, in that order.

기울기 b 이고 y 절편 a인 선을 현재의 플롯에 첨가합니다. h=y 는 y좌표값을 높이로 하는 가로선이 이 그래프를 가로질러 그리며, 마찬가지로 v=x 은 x 좌표값을 시작점으로 하는 세로선을 그립니다. 또, lm.obj 는 (모형적함 함수의 결과로 얻어진) 길이 2의 coefficient 성분들을 표시하는데, 이 경우에는 순서대로 y절편과 기울기 값에 해당합니다.

@item polygon(x, y, @dots{})
@findex polygon
@c Draws a polygon defined by the ordered vertices in (@code{x}, @code{y})
@c and (optionally) shade it in with hatch lines, or fill it if the
@c graphics device allows the filling of figures.

(x,y)에 의해 정의된 꼭지점들을 순서대로 연결해서 만든 다각형을 그린다. 해당 그래픽 장치가 기능을 지원하면, (옵션을 사용해서) 그려진 다각형의 내부에 음영을 주거나 색을 채우는 것이 가능합니다.

@item legend(x, y, legend, @dots{})
@findex legend
@c Adds a legend to the current plot at the specified position.  Plotting
@c characters, line styles, colors etc., are identified with the labels in
@c the character vector @code{legend}.  At least one other argument @var{v}
@c (a vector the same length as @code{legend}) with the corresponding
@c values of the plotting unit must also be given, as follows:

특정한 위치에 현재 플롯의 범례를 첨가합니다. 플롯에 사용된 문자나 선의 종류 혹은 색 등이 범례에 포함된 문자 레이블을 통해 구분 가능해집니다. 다음과 같이 플롯 구성 단위가 가질 수 있는 값들 중 최소한 한 개 이상의 v (범례와 같은 길이를 가진 벡터를 사용하여) 선언이 필요합니다:

@table @code
@item legend( , fill=@var{v})
@c Colors for filled boxes

상자에 칠해진 색상들

@item legend( , col=@var{v})
@c Colors in which points or lines will be drawn

포인트나 선에 사용될 색상들

@item legend( , lty=@var{v})
@c Line styles

선의 종류

@item legend( , lwd=@var{v})
@c Line widths

선의 굵기

@item legend( , pch=@var{v})
@c Plotting characters (character vector)

문자표시를 포함할 것 (문자 벡터 형태)

@end table

@item title(main, sub)
@findex title
@c Adds a title @code{main} to the top of the current plot in a large font
@c and (optionally) a sub-title @code{sub} at the bottom in a smaller font.

현재 플롯의 윗부분에 큰 글시로 주요(main) 제목을 첨가하고 (선택에 의해) 좀 더 작은 크기의 클씨로 부(sub)제목을 아랫 부분에 표시합니다.

@item axis(side, @dots{})
@findex axis
@c Adds an axis to the current plot on the side given by the first argument
@c (1 to 4, counting clockwise from the bottom.)  Other arguments control
@c the positioning of the axis within or beside the plot, and tick
@c positions and labels.  Useful for adding custom axes after calling
@c @code{plot()} with the @code{axes=FALSE} argument.
@end table

현재 플롯에 첫번째 인수(1부터 4까지의 숫자로 나타나며, 바닥에서부터 시계 방향으로 해당 사면을 의미함)에 의해 주어진 면에 새로운 축을 첨가합니다. 다른 인수들로 플롯 안에 포함되거나 플롯 옆에 나타나는 축을 조절할 수도 있고, 위치나 레이블에 대한 v 선언을 하기도 합니다. 사용자 정의로 축을 사용하기 위해서는 plot() 함수 안에 axes=FALSE 인수를 지정하는 편이 좋을 것입이다.

@c Low-level plotting functions usually require some positioning
@c information (e.g., @math{x} and @math{y} coordinates) to determine where
@c to place the new plot elements.  Coordinates are given in terms of
@c @emph{user coordinates} which are defined by the previous high-level
@c graphics command and are chosen based on the supplied data.

Low-level 그래픽 함수들은 대체로 새로운 플롯 구성 요소를 어디에 배치할지 결정하기 위해 위치에 관한 (x, y좌표 같은) 정보를 요구합니다. 이런 좌표들은 이전의 high-level 그래픽 함수 명령문에 의해 정의된 사용자 좌표에 의해 표현되며, 이것은 주어진 데이터에 따라 결정됩니다.

@c Where @code{x} and @code{y} arguments are required, it is also
@c sufficient to supply a single argument being a list with elements named
@c @code{x} and @code{y}.  Similarly a matrix with two columns is also
@c valid input.  In this way functions such as @code{locator()} (see below)
@c may be used to specify positions on a plot interactively.

X와 y인수값이 필요한 경우, x 와 y로 명명된 성분들을 연결해서 표현한 하나의 인수로 표현하는 것 역시 가능합니다. 마찬가지로 두개의 열을 가진 행렬을 사용하는 것도 역시 유효한 방법입니다. 이 방법을 사용할 때는 locator() (아래 참조) 같은 함수를 사용해서 플롯을 표현하기 위한 여러 위치들을 interactive하게 조정하는 것이 가능합니다.

@menu
* Mathematical annotation::     
* Hershey vector fonts::        
@end menu

@node Mathematical annotation, Hershey vector fonts, Low-level plotting commands, Low-level plotting commands
@c @subsection Mathematical annotation
@subsection

@c In some cases, it is useful to add mathematical symbols and formulae to a
@c plot.  This can be achieved in @R{} by specifying an @emph{expression} rather
@c than a character string in any one of @code{text}, @code{mtext}, @code{axis},
@c or @code{title}.   For example, the following code draws the formula for
@c the Binomial probability function:

어떤 경우에는, 수학적 기호나 공식을 플롯에 첨가하는 것이 유용합니다. R에서는 이런 작업을 text, mtext, axis 또는 title 같은 함수를 사용해서 하나의 문자열을 입력하는 것 보다는 하나의 표현(expression)을 사용해서 해결합니다. 예를 들면, 다음의 코드는 이항분포 함수(binomial probability function)의 공식을 표현되도록 합니다:

@example
> text(x, y, expression(paste(bgroup("(", atop(n, x), ")"), p^x, q^@{n-x@})))
@end example

@c More information, including a full listing of the features available can
@c obtained from within @R{} using the commands:

이 함수에서 사용할 수 있는 모든 기능들을 포함해서 좀 더 많은 정보를 얻을 수 있는 R 명령문들은 다음과 같습니다:

@example
> help(plotmath)
> example(plotmath)
> demo(plotmath)
@end example

@node Hershey vector fonts,  , Mathematical annotation, Low-level plotting commands
@c @subsection Hershey vector fonts
@subsection Hershey

@c It is possible to specify Hershey vector fonts for rendering text when using
@c the @code{text} and @code{contour} functions.  There are three reasons for
@c using the Hershey fonts:

Text 와 contour 함수를 사용할 때, text 를 조절하기 위해 Hershey폰트를 사용하는 것이 가능합니다. Hershey폰트를 사용하는 것은 다음의 세가지 이유에서 때문입니다:

@itemize @bullet
@item
@c Hershey fonts can produce better
@c output, especially on a computer screen, for rotated and/or small text.

Hershey폰트는 컴퓨터 스크린에서 text 를 회전시키거나 작은 text 를 사용할 때 특히 효과적입니다.

@item
@c Hershey fonts
@c provide certain symbols that may not be available
@c in the standard fonts.  In particular, there are zodiac signs, cartographic
@c symbols and astronomical symbols.

Hershey 폰트는 일판 폰트에서는 제공하지 않는 몇몇 심볼들을 제공합니다. 특히, 조디악 기호 (zodiac sign)나 지도 제작용 (cartographic) 심볼 그리고 천문학(astronomical) 심볼 등을 제공합니다.

@item
@c Hershey fonts provide cyrillic and japanese (Kana and Kanji) characters.

Hershey 폰트는 키릴(Cyrillic)과 일본어(Kana 와 Kanji 포함) 문자들을 제공합니다.

@end itemize

@c More information, including tables of Hershey characters can be obtained from
@c within @R{} using the commands:

Hershey 문자표를 포함한 좀 더 많은 정보를 찾기 위해 R에서 사용할 수 있는 명령문은 다음과 같습니다:

@example
> help(Hershey)
> demo(Hershey)
> help(Japanese)
> demo(Japanese)
@end example

@node Interacting with graphics, Using graphics parameters, Low-level plotting commands, Graphics
@c @section Interacting with graphics
@section

@c @R{} also provides functions which allow users to extract or add
@c information to a plot using a mouse.  The simplest of these is the
@c @code{locator()} function:

@R{}에서는 마우스를 사용하여 플롯에 관련된 정보를 빼거나 더하는 작업을 하는 것도 가
능합니다. 이런 방식으로 작동하는 함수 중 중 가장 간단한 것은 @code{locator()} 함수 입니다:

@table @code
@item locator(n, type)
@findex locator
@c Waits for the user to select locations on the current plot using the
@c left mouse button.  This continues until @code{n} (default 512) points
@c have been selected, or another mouse button is pressed.  The
@c @code{type} argument allows for plotting at the selected points and has
@c the same effect as for high-level graphics commands; the default is no
@c plotting.  @code{locator()} returns the locations of the points selected
@c as a list with two components @code{x} and @code{y}.
@end table

마우스 왼쪽 버튼을 사용하여 현재 플롯에 관련된 위치에 관련된 값들을 선택할 수 있도록 기다리는 함수. 이 함수는 n (디폴트는 512)개의 점들이 모두 선택될 까지 또는 다음 번 마우스 버튼을 누를 때까지 계속 작동합니다. Type 인수는 선택된 포인들을 어떤 플롯으로 그릴지 결정하며 high-level 그래픽 함수에서와 같은 기능으로 사용됩니다; 디폴트로는 플롯을 표시하지 않는 것이 지정되어 있습니다. locator()는 선택된 포인트드의 위치들이 두 개의 x 와 y의 성분으로 이루어진 하나의 리스트 값을 출력합니다.

@c @code{locator()} is usually called with no arguments.  It is
@c particularly useful for interactively selecting positions for graphic
@c elements such as legends or labels when it is difficult to calculate in
@c advance where the graphic should be placed.  For example, to place some
@c informative text near an outlying point, the command

하지만 locator()함수는 인수들을 입력하지 않은 채 그대로 사용되는 경우가 더 많습니다. 이 함수는 범례나 레이블 같은 그래픽 요소들의 위치를 정할 때 interactive하게 사용되는데, 특히 이러한 요소들을 사전에 해당 그래픽의 어느 곳에 배치해야할지 결정하기 어려운 경우에 유용하게 사용될 수 있습니다. 예를 들면, Outlier와 같은 포인트에 해당 포인트에 대한 정보를 입력하기 위해 다음 명령문을 사용할 수 있습니다.

@example
> text(locator(1), "Outlier", adj=0)
@end example

@noindent
@c may be useful.  (@code{locator()} will be ignored if the current device,
@c such as @code{postscript} does not support interactive pointing.)

(@code{locator()} 함수는 현재 디바이스가 postscript 와 같이 interactive pointing 기능을 제공하지 않는 경우에는 그냥 무시되어 버립니다.)

@table @code
@item identify(x, y, labels)
@findex identify
@c Allow the user to highlight any of the points defined by @code{x} and
@c @code{y} (using the left mouse button) by plotting the corresponding
@c component of @code{labels} nearby (or the index number of the point if
@c @code{labels} is absent).  Returns the indices of the selected points
@c when another button is pressed.

x 와 y 에 의해 정의된 어떤 포인트라도 (마우스의 왼쪽 버튼을 사용해서) 그 근처에 해당 포인트에 대응되는 레이블을 표기함으로써 그 포인트를 확인할 수 있도록 하는 함수.(레이블 정보가 없는 경우, 해당 포인트의 인덱스 번호를 사용) 버튼을 한 번 더 누르면 선택된 포인트들의 인덱스들을 출력합니다.

@end table

@c Sometimes we want to identify particular @emph{points} on a plot, rather
@c than their positions.  For example, we may wish the user to select some
@c observation of interest from a graphical display and then manipulate
@c that observation in some way.  Given a number of @math{(x, y)}
@c coordinates in two numeric vectors @code{x} and @code{y}, we could use
@c the @code{identify()} function as follows:

때때로 우리는 플롯에서 특별한 몇 개의 포인트들의 위치를 보기 보다는 해당 포인트에 대한 정보를 확인하고 싶어집니다. 예를 들면, 그래픽으로 표현된 데이터 중 관심 있는 몇 개의 관측치만 선택해서 그 관측치들만 따로 처리하고 싶은 경우가 있습니다. 포인트들을 두 개의 숫자 벡터인 x 와 y 에 의해 표현된 (x, y) 좌표 쌍들로 표현하면, identify()를 다음과 같이 사용할 수 있습니다:

@example
> plot(x, y)
> identify(x, y)
@end example

@c The @code{identify()} functions performs no plotting itself, but simply
@c allows the user to move the mouse pointer and click the left mouse
@c button near a point.  If there is a point near the mouse pointer it will
@c be marked with its index number (that is, its position in the
@c @code{x}/@code{y} vectors) plotted nearby.  Alternatively, you could use
@c some informative string (such as a case name) as a highlight by using
@c the @code{labels} argument to @code{identify()}, or disable marking
@c altogether with the @code{plot = FALSE} argument.  When the process is
@c terminated (see above), @code{identify()} returns the indices of the
@c selected points; you can use these indices to extract the selected
@c points from the original vectors @code{x} and @code{y}.

identify() 함수는 그 자체로 플롯을 그리지는 않지만, 사용자들이 마우스 포인터를 움직이다 어떤 포인트에서는 마우스 왼쪽 버튼을 클릭할 수 있는 기능을 제공합니다. 어떤 포인트 근처에 마우스 포인터가 있는 경우, 해당 포인트는 인덱스 번호로 표시될 것 입니다. (이것은, 그 포인트의 위치가 x/y vector로 되어 있음을 의미하는 것입니다.) 또한, identify()함수 내에 labels 인수를 사용하여 포인트들이 좀 더 informative하게(해당 케이스의 이름 등) 표현되도록 할 수도 있으며, plot = FALSE인수를 사용하면 포인트를 선택해도 아무런 표시가 남지 않도록 할 수도 있습니다. 해당 프로세스가 끝나고 나면(위 참조), identify()는 선택되었던 포인트들의 인덱스를 출력합니다; 이러한 인덱스 정보를 바탕으로 원래 x, y의 벡터 형태로 되어 있는 선택된 포인트들의 정보를 따로 추출해내는 것도 가능할 것입니다.

@node Using graphics parameters, Graphics parameters, Interacting with graphics, Graphics
@c @section Using graphics parameters
@section 그래픽 파라미터들을 사용하기

@c When creating graphics, particularly for presentation or publication
@c purposes, @R{}'s defaults do not always produce exactly that which is
@c required.  You can, however, customize almost every aspect of the
@c display using @emph{graphics parameters}.  @R{} maintains a list of a
@c large number of graphics parameters which control things such as line
@c style, colors, figure arrangement and text justification among many
@c others.  Every graphics parameter has a name (such as `@code{col}',
@c which controls colors,) and a value (a color number, for example.)

그래픽을 만들어 낼 때, 특히 그것이 프리젠테이션이나 다른 공공 목적을 위한 것이라면, R 의 디폴트만으로는 항상 원하는 형태를 얻을 수 없을 것입니다. 그렇지만, 그래픽 모수(graphics parameters)를 이용하여 거의 모든 표현 방식을 사용자 임의대로 정의할 수 있습니다. R에는 선의 형태, 색, 그림 배열 그리고 문자 정의 등에 이르기까지 굉장히 다양한 그래픽 모수들이 포함되어 있습니다. 모든 그래픽 모수는 이름(e.g.색을 결정하는 ‘col’)과 값(특정색을 의미하는 숫자)으로 구성 됩니다.

@c A separate list of graphics parameters is maintained for each active
@c device, and each device has a default set of parameters when
@c initialized.  Graphics parameters can be set in two ways: either
@c permanently, affecting all graphics functions which access the current
@c device; or temporarily, affecting only a single graphics function call.

각각의 디바이스를 위해 그래픽 모수의 리스트들을 따로 정의하는 것이 가능하고, 각 디바스들은 모수들의 디폴트 값을 가진 채 초기화 됩니다. 그래픽 모수들은 크게 두 가지 방법으로 사용될 수 있습니다: 하나는 현재 디바이스를 사용할 때마다 모든 그래픽 함수들에 영향을 주는 “영구적” 방법이고 다른 방법은 오직 하나의 그래픽 함수를 사용할 때에만 영향을 주는 “임시적” 방법입니다.

@menu
* The par() function::          
* Arguments to graphics functions::  
@end menu

@node The par() function, Arguments to graphics functions, Using graphics parameters, Using graphics parameters
@subsection @code{par()} 함수를 이용한 그래픽 파라미터들의 영구적 변환 
@c @subsection Permanent changes: The @code{par()} function
@findex par
@cindex Graphics parameters

@c The @code{par()} function is used to access and modify the list of
@c graphics parameters for the current graphics device.

par()함수는 현재의 그래픽 디바이스의 그래픽 모수 리스트를 조정하기 위해 사용됩니다.

@table @code
@item par()
@c Without arguments, returns a list of all graphics parameters and their
@c values for the current device.

아무런 인수가 없는 경우, 현재 디바스에 저장되어 있는 모든 그래픽 모수와 그 모수들 해당 값의 리스트를 출력합니다.

@item par(c("col", "lty"))
@c With a character vector argument, returns only the named graphics
@c parameters (again, as a list.)

문자 벡터 인수를 사용하면, 오직 따로 지정된 그래픽 모수들에 대해서만 (이 경우도 리스트의 형태로) 출력합니다.

@item par(col=4, lty=2)
@c With named arguments (or a single list argument), sets the values of
@c the named graphics parameters, and returns the original values of the
@c parameters as a list.

그래픽 모수와 해당 모수의 값들을 따로 인수(하나의 인수도 가능)로 지정하면, 지정된 값이 리스트로 출려됩니다.

@end table

@c Setting graphics parameters with the @code{par()} function changes the
@c value of the parameters @emph{permanently}, in the sense that all future
@c calls to graphics functions (on the current device) will be affected by
@c the new value.  You can think of setting graphics parameters in this way
@c as setting ``default'' values for the parameters, which will be used by
@c all graphics functions unless an alternative value is given.

par()함수를 사용해서 그래픽 모수를 지정하면 해당 모수와 그 값은 “영구적”으로 바뀝니다. 즉 미래에 해당 그래픽 함수를 (현재 디바이스에서) 사용하면 새로 지정된 값이 반영되어 출력되는 것 입니다. 따라서 이 방법을 사용해서 그래픽 모수를 지정하는 것은 일종의 “디폴트” 값을 지정하는 것과 같다고 생각할 수 있을 겁니다. 즉, 다른 값이 다시 지정되지 않는 한, 모든 그래픽 함수가 이 지정값에 영향을 받게 되는 것입니다.

@c Note that calls to @code{par()} @emph{always} affect the global values
@c of graphics parameters, even when @code{par()} is called from within a
@c function.  This is often undesirable behavior---usually we want to set
@c some graphics parameters, do some plotting, and then restore the
@c original values so as not to affect the user's @R{} session.  You can
@c restore the initial values by saving the result of @code{par()} when
@c making changes, and restoring the initial values when plotting is
@c complete.

par()를 사용하면, 항상, 심지어 par()가 다른 함수 안에서 사용된 경우라도 전체적으로 모든 그래픽 모수들의 값이 영향을 받게 된다는 점을 주의하시기 바랍니다. 이것은 많은 경우 그다지 바람직하지 않다고 볼 수 있습니다 . 우리가 몇 개의 그래픽 모수를 따로 지정하는 것은 대체로 몇 개의 플롯을 그린 후, 현재의 R 세션이 이 값에 영향 받기 전 상태인 원래의 모수값으로 돌아가고 싶기 때문입니다. 특별히 모수를 바꾸는 작업이 필요할 때 par()의 결과를 따로 저장하고 플롯 작업이 끝난 후에는 초기 값을 다시 사용함으로써 초기값을 계속 유지하는 것이 가능합니다.

@example
> oldpar <- par(col=4, lty=2)
  @r{@dots{} plotting commands @dots{}}
> par(oldpar)
@end example

@noindent
@c To save and restore @emph{all} settable@footnote{Some graphics
@c parameters such as the size of the current device are for information
@c only.} graphical parameters use

조정 가능한 모든 그래픽 모수값을 저장해서 다시 사용하기 위해서는

@example
> oldpar <- par(no.readonly=TRUE)
  @r{@dots{} plotting commands @dots{}}
> par(oldpar)
@end example

@node Arguments to graphics functions,  , The par() function, Using graphics parameters
@c @subsection Temporary changes: Arguments to graphics functions
@subsection 그래픽 함수에 인자로 전달하는 방식의 임시적 변환

@c Graphics parameters may also be passed to (almost) any graphics function
@c as named arguments.  This has the same effect as passing the arguments
@c to the @code{par()} function, except that the changes only last for the
@c duration of the function call.  For example:

그래픽 모수들은 (거의 모든) 그래픽 함수에서 인수처럼 사용될 수도 있습니다. 이러한 방법은 인수로 사용되었을 때의 변화가 오직 해당 함수가 사용되는 동안만 지속된다는 점을 제외하고는, par()함수에 인수들을 사용하는 것과 같은 효과를 줍니다. 예를 들면:

@example
> plot(x, y, pch="+")
@end example

@noindent
@c produces a scatterplot using a plus sign as the plotting character,
@c without changing the default plotting character for future plots.

이 경우, 더하기 표시를 플롯 문자로 사용한 산점도를 그리게 되는데, 이 때 사용된 플롯 문자는 앞으로 사용하게 될 플롯의 디폴트에는 영향을 주지 않습니다.

@c Unfortunately, this is not implemented entirely consistently and it is
@c sometimes necessary to set and reset graphics parameters using
@c @code{par()}.

안타깝지만, 항상 이와 같은 형태로만 실행되는 것이 아니므로 경우에 따라 par()를 사용해서 그래픽 모수들을 지정하고 다시 되돌리는 작업이 필요하기도 합니다.


@node Graphics parameters, Device drivers, Using graphics parameters, Graphics
@c @section Graphics parameters list
@section 그래픽 파라미터들의 목록


@c The following sections detail many of the commonly-used graphical
@c parameters.  The @R{} help documentation for the @code{par()} function
@c provides a more concise summary; this is provided as a somewhat more
@c detailed alternative.

다음의 섹션들에서는 일반적으로 사용되는 그래픽 파라미터들에 대해 자세히 설명합니다. @code{par()} 함수에 대한 @R{} 도움말 문서는 보다 간결한 요약을 제공합니다; 이것은 다소 보다 세밀한 대안으로 제공됩니다.

@c Graphics parameters will be presented in the following form:

그래픽 파라미터들은 다음의 형태로 제공될 것입니다:

@table @code
@item @var{name}=@var{value}
@c A description of the parameter's effect.  @var{name} is the name of the
@c parameter, that is, the argument name to use in calls to @code{par()} or
@c a graphics function.  @var{value} is a typical value you might use when
@c setting the parameter.

파라미터의 효과 설명

@var{name}은 파라미터의 이름을 말합니다. 즉 @code{par()} 또는 그래픽 함수를 호출함에 있어서 사용할 인수명이 됩니다. @var{value}는 파라미터를 세팅할 때 여러분이 사용하게 될 전형적인 값입니다.

@end table

@c Note that @code{axes} is @strong{not} a graphics parameter but an
@c argument to a few @code{plot} methods: see @code{xaxt} and @code{yaxt}.

@code{axes}는 그래픽 파라미터가 아니라 소수의 @code{plot} 방법에 대한 인수 중의 하나입니다. 이에 관해서는 @code{xaxt}와 @code{yaxt}를 참고하십시오.

@menu
* Graphical elements::          
* Axes and tick marks::         
* Figure margins::              
* Multiple figure environment::  
@end menu

@node Graphical elements, Axes and tick marks, Graphics parameters, Graphics parameters
@c @subsection Graphical elements
@subsection 그래픽 구성요소들의 활용

@c @R{} plots are made up of points, lines, text and polygons (filled
@c regions.) Graphical parameters exist which control how these
@c @emph{graphical elements} are drawn, as follows:

@R{}의 플롯은 점, 선, 텍스트 그리고 (영역이 채워진) 다각형으로 구성되어 있습니다. 
@emph{그래픽 요소}들이 그려지는 방법을 제어하는 그래픽 파라미터들은 다음과 같습니다.

@table @code
@item pch="+"
@c Character to be used for plotting points.  The default varies with
@c graphics drivers, but it is usually

플롯팅할 점들을 어떤 모양(symbol)으로 출력할지 문자로 지정하는 옵션. 
기본값은 그래픽 장치(device)에따라 차이가 있지만 일반적으로는 (속이 빈) 원의 형태입니다. 

@ifnottex
@c a circle.
원
@end ifnottex
@tex
`$\circ$'.
@end tex
@c Plotted points tend to appear slightly above or below the appropriate
@c position unless you use @code{"."} as the plotting character, which
@c produces centered points.

선택한 점의 모양에 따라 자동적으로 점의 위치가 위아래로 적절하게 조정되며, 
예를 들면, @code{"."}의 경우 점이 가운데로 정렬니다.

@item pch=4
@c When @code{pch} is given as an integer between 0 and 25 inclusive, a
@c specialized plotting symbol is produced.  To see what the symbols are,
@c use the command

@code{pch}가 0과 25사이의 정수로 주어진 경우 각 번호 별로 다른 모양의 점을 출력 합니다.
각 번호에 해당하는 모양이 무엇인지 확인하기 위해 다음과 명령어를 사용하면 도움이 될 것입니다.

@example
> legend(locator(1), as.character(0:25), pch = 0:25)
@end example

@noindent
@c Those from 21 to 25 may appear to duplicate earlier symbols, but can be
@c coloured in different ways: see the help on @code{points} and its
@c examples.

특히 21에서 25까지의 숫자를 선택할 경우, 0에서 20 사이에 이미 사용되었던 모양이 다른 크기와 색으로 나타날 수 있습니다 (@code{points} 에 관한 도움말과 예제 참조).

@c In addition, @code{pch} can be a character or a number in the range
@c @code{32:255} representing a character in the current font.

또한 @code{pch}는  32:255에 해당하는 숫자를 선택할 경우, 현재 폰트에서의 문자 캐릭터에 해당하는 문자 또는 숫자를 출력하는 것도 가능합니다.

@item lty=2
@c Line types.  Alternative line styles are not supported on all graphics
@c devices (and vary on those that do) but line type 1 is always a solid
@c line, line type 0 is always invisible, and line types 2 and onwards are
@c dotted or dashed lines, or some combination of both.

선의 형태를 지정하는 옵션. 이 옵션에서 지정한 값이 모든 그래픽 디바이스에서 다 출력 가능한 것은 아니며 또한 디바이스의 종류에 따라 출력된 선의 모양이 다를 수도 있습니다. 그러나 lty =1은 항상 실선을, 0 은 항상 선을 보이지 않게, 2 와 그 이상의 번호는 점선과 파선, 그리고 다양한 형태의 점선과 파선의 조합을 출력합니다. 

@item lwd=2
@c Line widths.  Desired width of lines, in multiples of the ``standard''
@c line width.  Affects axis lines as well as lines drawn with
@c @code{lines()}, etc.  Not all devices support this, and some have
@c restrictions on the widths that can be used.

선의 굵기를 지정하는 옵션. 선의 굵기를 원하는 대로 조정할 수 있으며, 다양한 “표준 (standard)” 두께를 지정해 여러 번에 걸처 적용하는 것도 가능합니다. lines() 문으로 그려진 선은 물론이고 플롯의 축의 굵기를 조정하는 것도 가능합니다. 모든 그래픽 디바이스가 이 옵션을 지원하는 것이 아니며 몇몇 장치의 경우 출력 가능한 선의 굵기에 제약이 있을 수 있습니다.

@item col=2
@c Colors to be used for points, lines, text, filled regions and images.
@c A number from the current palette (see @code{?palette}) or a named colour.

색을 지정하는 옵션. 점, 선, 덱스트, 그리고 색으로 채워진 영역과 이미지 모두에 적용 가능한 모수입니다. 현재 사용 중인 파레트 (palette, 자세한 사용은 @code{?palette} 부분 참조)에서 색을 선택하거나 색 이름을 직접 입력하는 것도 가능 합니다. 비슷한 기능을 하는 아래와 같은 옵션들도 있습니다. 위에서부터 순서대로 축의 주석 (annotation)[1], x와 y 축 레이블 (label), 주 (main) 타이틀과 서브 (sub) 타이틀에 각각 사용 가능 합니다.

@item col.axis
@itemx col.lab
@itemx col.main
@itemx col.sub
@c The color to be used for axis annotation, @math{x} and @math{y} labels,
@c main and sub-titles, respectively.

축 주석, @math{x}와 @math{y} 축 이름, 주된 타이틀과 부수적 타이틀 각각에 사용하기 위한 색 

@item font=2
@c An integer which specifies which font to use for text.  If possible,
@c device drivers arrange so that @code{1} corresponds to plain text,
@c @code{2} to bold face, @code{3} to italic, @code{4} to bold italic
@c and @code{5} to a symbol font (which include Greek letters).

폰트/글자체 (font) 지정하는 옵션. 각 정수 값에 해당하는 폰트로 텍스트(text)를 출력합니다. 만약 장치 드라이버가 이 옵션을 실행시키는 것이 가능하다면, 1은 기본형 텍스트 (plain text), 2는 볼드체 (굸은 글씨, bold face), 3은 이탤릭체 (italic), 4는 볼드 이탤릭 그리고 5는 그리스 문자 등을 포함하는 심벌 (symbol) 폰트로 출력한다. 폰트 역시 비슷한 기능을 하는 아래와 같은 옵션들이 있습니다. 
@item font.axis
@itemx font.lab
@itemx font.main
@itemx font.sub
@c The font to be used for axis annotation, @math{x} and @math{y} labels,
@c main and sub-titles, respectively.

위에서부터 순서대로 축의 주석 (annotation), x와 y 축 레이블 (label), 주 (main) 타이틀과 서브 (sub) 타이틀의 폰트에 각각 적용 가능합니다.

@item adj=-0.1
@c Justification of text relative to the plotting position.  @code{0} means
@c left justify, @code{1} means right justify and @code{0.5} means to
@c center horizontally about the plotting position.  The actual value is
@c the proportion of text that appears to the left of the plotting
@c position, so a value of @code{-0.1} leaves a gap of 10% of the text width
@c between the text and the plotting position.

플롯의 위치에 따라 텍스트의 상대적 위치를 지정하는 옵션. 0은 문자의 좌측 정렬, 1은 우측 정렬, 그리고 0.5는 플롯이 그려진 위치에서 부터 수평 가운데로 문자를 정렬 시킵니다. 즉, 지정된 숫자는 실제 플롯의 왼쪽 끝을 기준으로 텍스트가 나타나게 될 위치의 상대적 비율을 의미하게 됩니다. 즉, 위와 같이 -0.1로 지정할 경우, 플롯과 텍스트 사이에 문자 너비의 10% 만큼의 간격을 두고 출력하게 됩니다. 

@item cex=1.5
@c Character expansion.  The value is the desired size of text characters
@c (including plotting characters) relative to the default text size.

문자 (character)의 확대 비율을 지정하는 옵션. 이 옵션의 숫자 값은 텍스트 문자 (플로팅 캐릭터 포함, pch 참고)의 크기를 텍스트 크기의 초기값(default)을 기준으로 한 상대적 크기를 출력합니다. 

@item cex.axis
@itemx cex.lab
@itemx cex.main
@itemx cex.sub
@c The character expansion to be used for axis annotation, @math{x} and
@c @math{y} labels, main and sub-titles, respectively.
cex 역시 비슷한 기능을 하는 아래와 같은 옵션들이 있습니다. 위에서부터 순서대로 축의 주석 (annotation), x와 y 축 레이 (label), 주 (main) 타이틀과 서브 (sub) 타이틀에 각각 사용 가능합니.
@end table


@node Axes and tick marks, Figure margins, Graphical elements, Graphics parameters
@c @subsection Axes and tick marks
@subsection 축과 틱마크 (단위표시자) 이용하기

@c Many of @R{}'s high-level plots have axes, and you can construct axes
@c yourself with the low-level @code{axis()} graphics function.  Axes have
@c three main components: the @emph{axis line} (line style controlled by the
@c @code{lty} graphics parameter), the @emph{tick marks} (which mark off unit
@c divisions along the axis line) and the @emph{tick labels} (which mark the
@c units.) These components can be customized with the following graphics
@c parameters.

R의 하이 레벨에 플롯 (high-level plots)에는 많은 경우 축이 이미 포함되어 있지만, 로 레벨 (low-level) 그래픽 함수인 axis() 등을 사용하여 원하는 대로 축을 지정하는 것 역시 가능합니다. 축은 세 가지 요소에 의해 결정 됩니다: 축선 (선의 종류는 lty 그래픽 모수에 의해 지정 가능), 틱 마크 (축선을 따라 단위 별로 선을 분할 표기) 그리고 틱의 레이블 (틱 마크의 단위 표기)이 그것 입니다. 이러한 요소들은 다음과 같은 그래픽 모수들에 의해 조정 가능합니다.    


@table @code
@item lab=c(5, 7, 12)
@c The first two numbers are the desired number of tick intervals on the
@c @math{x} and @math{y} axes respectively.  The third number is the
@c desired length of axis labels, in characters (including the decimal
@c point.)  Choosing a too-small value for this parameter may result in all
@c tick labels being rounded to the same number!

처음의 두 숫자는 각각 x 축과 y 축에 해당하는 틱의 간격을 지정 합니다. 세번째 숫자는 축 레이블의 길이(소수점 아래 길이 포함)를 캐릭터 문자의 길이로 지정합니. 이 모수를 너무 작은 값으로 선택할 경우, 모든 틱 레이블들이 반올림 되어져 같은 숫자가 되어버리는 문제가 발생할 수 있습니다.

@item las=1
@c Orientation of axis labels.  @code{0} means always parallel to axis,
@c @code{1} means always horizontal, and @code{2} means always
@c perpendicular to the axis.

축 레이블의 방향 지정. 0은 축에 평행하게, 1은 수평으로, 그리고 2는 축에 수직 방향으로 레이블이 나타나도록 출력합니다.

@item mgp=c(3, 1, 0)
@c Positions of axis components.  The first component is the distance from
@c the axis label to the axis position, in text lines.  The second
@c component is the distance to the tick labels, and the final component is
@c the distance from the axis position to the axis line (usually zero).
@c Positive numbers measure outside the plot region, negative numbers
@c inside.

축 요소들의 위치 지정. 첫번째 숫자는 축의 레이블에서 부터 축까지의 길이를 지정하며 텍스트의 줄 간격이 길이의 단위 입니다. 두 번째 값은 틱 마크들까지의 길이를 지정하며, 마지막 값은 축의 위치에서부터 실제 축선까지의 거리(보통은 0)를 지정합니다. 양수 값을 지정할 경우 플롯의 영역의 바깥쪽에 해당 요소들을 나타나게 하며, 음수의 경우는 안쪽에 나타냅니다.

@item tck=0.01
Length of tick marks, as a fraction of the size of the plotting region.
When @code{tck} is small (less than 0.5) the tick marks on the @math{x}
and @math{y} axes are forced to be the same size.  A value of 1 gives
grid lines.  Negative values give tick marks outside the plotting
region.  Use @code{tck=0.01} and @code{mgp=c(1,-1.5,0)} for internal
tick marks.

@item xaxs="r"
@itemx yaxs="i"
@c Axis styles for the @math{x} and @math{y} axes, respectively.   With
@c styles @code{"i"} (internal) and @code{"r"} (the default) tick marks
@c always fall within the range of the data, however style @code{"r"}
@c leaves a small amount of space at the edges.  (@Sl{} has other styles
@c not implemented in @R{}.)

x 축과 y 축의 스타일을 각각 지정.  "i" (internal) 와"r" (the default)의 경우, 틱 마크가 항상 데이타 범위 내에서만 나타나지만, "r" 의 경우 각 모서리에서 약간의 공백을 남기고 출력합니다. (S의 경우, R과는 다른 스타일을 사용 합니다.) 

@c Setting this parameter to @code{"d"} (direct axis) @emph{locks in} the
@c current axis and uses it for all future plots (or until the parameter is
@c set to one of the other values above, at least.) Useful for generating
@c series of fixed-scale plots.
@end table

@node Figure margins, Multiple figure environment, Axes and tick marks, Graphics parameters
@c @subsection Figure margins
@subsection 그림(figure)의 여백 조절하기


@c A single plot in @R{} is known as a @code{figure} and comprises a
@c @emph{plot region} surrounded by margins (possibly containing axis
@c labels, titles, etc.) and (usually) bounded by the axes themselves.

R에서는 하나의 플롯이 하나의 그림(figure)처럼 나타나고 이 그림은 플롯 뿐 아니라 여백으로 둘러싸인 플롯 영역 (축 레이틀, 타이틀 등을 포함)을 포함하며, (많은 경우) 축에 의해 영역이 구분 됩니다. 

@iftex
A typical figure is
@c @image{images/fig11,7cm} @c deleted by Chel Hee Lee
@end iftex

@c Graphics parameters controlling figure layout include:
이러한 그림의 레이아웃 (구성 요소의 배열)은 다음과 같은 그래픽 모수들에 의해 결정 됩니다:

@table @code
@item mai=c(1, 0.5, 0.5, 0)
@c Widths of the bottom, left, top and right margins, respectively,
@c measured in inches.
순서대로 아래, 왼쪽, 위 그리고 오른쪽 여백(margin)의 너비를 조정합니다. 단위는 인치 입니다.

@item mar=c(4, 2, 2, 1)
@c Similar to @code{mai}, except the measurement unit is text lines.
위의 mai 와 같은 기능을 하지만, 유일한 차이는 텍스트의 줄 간격을 단위로 한다는 점입니다.  
@end table

@c @code{mar} and @code{mai} are equivalent in the sense that setting one
@c changes the value of the other.  The default values chosen for this
@c parameter are often too large; the right-hand margin is rarely needed,
@c and neither is the top margin if no title is being used.  The bottom and
@c left margins must be large enough to accommodate the axis and tick
@c labels.  Furthermore, the default is chosen without regard to the size
@c of the device surface: for example, using the @code{postscript()} driver
@c with the @code{height=4} argument will result in a plot which is about
@c 50% margin unless @code{mar} or @code{mai} are set explicitly.  When
@c multiple figures are in use (see below) the margins are reduced, however
@c this may not be enough when many figures share the same page.

mai 와 mar 두 가지 중 하나만 사용하더라도, 다른 쪽에도 영향을 미친다는 점에서 두 함수는 동일한 기능을 한다고 볼 수 있습니다. 초기값 (default)으로 지정된 모수(parameter) 값이 약간 큰 경향이 있으므로 조정이 필요할 것 입니다; 오른쪽 여백 (margin)을 조정할 일은 거의 없다고 할 수 있으며, 윗 부분의 여백 역시 거의 사용할 일이 없을 것 입니다. 하지만, 아래와 왼쪽의 경우, 축이나 틱 레이블을 출력할 수 있을 만큼의 여백이 필요합니다. 무엇보다 초기값은 디바이스가 어느 정도의 크기로 출력하는지를 전혀 고려하지 않은 채 임의로 설정되어져 있습니다: 예를 들면, postscript() 드라이버 경우,  따로 mar 나 mai 옵션을 구체적으로 지정하지 않은 채 height=4 만 사용할 경우, 플롯 크기의 반 정도에 해당하는 여백을 포함하게 됩니다.  또 여러 그래프를 중첩해서 사용할 경우 (아래 multiple figure environment 참조) 자동적으로 여백은 줄어들지만, 이렇게 줄어든 여백도 여러 개의 그래프를 한 페이지에 모두 출력하기에 충분하지 않을 수 있습니다.


@node Multiple figure environment,  , Figure margins, Graphics parameters
@subsection Multiple figure environment

@c @R{} allows you to create an @math{n} by @math{m} array of figures on a
@c single page.  Each figure has its own margins, and the array of figures
@c is optionally surrounded by an @emph{outer margin}, as shown in the
@c following figure.

R에서 n 개의 행과 m 개의 열로 배열된 그래프들을 한 페이지에 출력하는 것이 가능합니다. 각각의 그래프는 각자의 여백을 포함하고 있으며, 그래프의 배열은 외부 여백 (outer margin)을 포함하는 것이 가능합니다.  (아래 그래프 참조).

@iftex
@c @image{images/fig12,6cm} @c deleted by Chel Hee Lee 
@end iftex

@c The graphical parameters relating to multiple figures are as follows:
그래프의 중첩과 관련된 그래픽 모수에는 다음과 같은 것들이 있습니다:

@table @code
@item mfcol=c(3, 2)
@itemx mfrow=c(2, 4)
@c Set the size of a multiple figure array.  The first value is the number of
@c rows; the second is the number of columns.  The only difference between
@c these two parameters is that setting @code{mfcol} causes figures to be
@c filled by column; @code{mfrow} fills by rows.

이 두 모수의 경우, 여러 개 그래프를 배열하는 크기를 정합니다. 각 모수의 첫 번째 값은 행의 수를 지정하고, 두번째 값은 열의 수를 지정합니다. 두 모수의 유일한 차이는 지정된 틀에 그래프를 출력하는 순서인데, mfcol의 경우 플롯을 그리는 순서대로 열 별로 그래프를 채워나가고 mfrow의 경우 행 별로 그래프를 채워서 출력합니다.  

@c The layout in the Figure could have been created by setting
@c @code{mfrow=c(3,2)}; the figure shows the page after four plots have
@c been drawn.

즉, 그림의 레이 아웃을 mfrow=c(3,2)으로 지정하면, 이 그림의 경우 6개의 플롯이 모두 그려진 다음에 해당 페이지를 출력하게 됩니다.


@c Setting either of these can reduce the base size of symbols and text
@c (controlled by @code{par("cex")} and the pointsize of the device).  In a
@c layout with exactly two rows and columns the base size is reduced by a
@c factor of 0.83: if there are three or more of either rows or columns,
@c the reduction factor is 0.66.

이 두 모수 중 어느 하나를 사용할 경우, (par ("cex") 와 현재 디바이스의 기본 폰트에 영향을 받는) 그래프의 심벌과 텍스트의 크기가 줄어들 수 있습니다. 두 개의 행과 두 개의 열로 구성된 레이아웃의 경우, 이들에 포함된 텍스트의 기본 크기가 처음의 0.83 배가 되며, 만약 세 개나 그 이상의 행이나 열이 한 레이아웃에 포함될 경우에는 텍스트가 처음 크기의 0.66배가 됩니다.

@item mfg=c(2, 2, 3, 2)
@c Position of the current figure in a multiple figure environment.  The first
@c two numbers are the row and column of the current figure; the last two
@c are the number of rows and columns in the multiple figure array.  Set
@c this parameter to jump between figures in the array.  You can even use
@c different values for the last two numbers than the @emph{true} values
@c for unequally-sized figures on the same page.

그래프 중첩 시의 현재 그림의 위치를 조정 합니다. 처음 두 개의 숫자는 해당 그림의 행과 열의 위치를 표시하며, 나중의 두 숫자는 여러 그림의 배열에서의 행과 열의 위치를 표시합다. 이미 배열이 된 그림들 사이의 간격을 띄우기 위해 이 문장을 사용할 수도 있습니다. 또한 한 페이지 상에 출력된 크기가 다른 두 그림을 조정하기 위해 이 그래픽 모수의 마지막 두 숫자를 실제 위치와는 다른 값으로 지정하는 것도 가능합니다.

@item fig=c(4, 9, 1, 4)/10
@c Position of the current figure on the page.  Values are the positions of
@c the left, right, bottom and top edges respectively, as a percentage of
@c the page measured from the bottom left corner.  The example value would
@c be for a figure in the bottom right of the page.  Set this parameter for
@c arbitrary positioning of figures within a page.  If you want to add a
@c figure to a current page, use @code{new=TRUE} as well (unlike S).

해당 페이지에서 현재 그림의 위치를 조정하는 모수. 각각의 숫자들은 각각 그림의 왼쪽, 오른쪽 아래 그리고 위 모서리의 위치를 나타내며 해당 페이지를 왼쪽 아래 모서리에서부터 재었을 때의 비율로 나타냅니다.

예제에서 보여진 값은 해당 페이지의 오른쪽 아래에 있는 그림으로 출력됩니다. 

이 모수를 사용하면 한 페이지 안의 어떤 위치에라도 그래프를 출력하는 것이 가능해집니다. 만약 현재 페이지에 그래프를 하나 더 추가하고 싶다면, new=TRUE 라는 옵션을 함께 사용해야 합니다. (이 점이 S와 다릅니다.)


@item oma=c(2, 0, 3, 0)
@itemx omi=c(0, 0, 0.8, 0)
@c Size of outer margins.  Like @code{mar} and @code{mai}, the first
@c measures in text lines and the second in inches, starting with the
@c bottom margin and working clockwise.

외부 여백의 크기를 조정하는 그래픽 모수들. mai 와 mar의 경우처럼, oma는 텍스트 줄 간격으로 여백의 크기를 지정하고, omi는 인치를 단위로 하며, 여백의 크기를 나타내는 네 숫자는 아래 여백부터 시작해서 시계 방향 순으로 표기됩니다.
@end table

@c Outer margins are particularly useful for page-wise titles, etc.  Text
@c can be added to the outer margins with the @code{mtext()} function with
@c argument @code{outer=TRUE}.  There are no outer margins by default,
@c however, so you must create them explicitly using @code{oma} or
@code{omi}.

외부 여백은 페이지 별로 표기되는 타이틀 등을 제대로 출력하기 위해 지정되어야 합니다. 외부 여백에 텍스트를 출력하고 싶을 경우, mtext() 함수에서 outer=TRUE 옵션을 사용하면 됩니다. 외부 여백은 디폴트로 지정된 기능이 아니므로, oma 와 omi 를 사용해서 따로 지정해야 그림에 여백이 포함됩니다.

@c More complicated arrangements of multiple figures can be produced by the
@c @code{split.screen()} and @code{layout()} functions, as well as by the
@c @pkg{grid} and @CRANpkg{lattice} packages.

좀 더 복잡한 형태의 그래픽 중첩을 사용하고 싶다면, split.screen() 이나 layout() 같은 함수들을 사용할 수 있으며, grid나 lattice 같은 팩키지를 사용하는 것도 가능합니다.


@node Device drivers, Dynamic graphics, Graphics parameters, Graphics
@c @section Device drivers
@section 장치 드라이버
@cindex Graphics device drivers

@c @R{} can generate graphics (of varying levels of quality) on almost any
@c type of display or printing device.  Before this can begin, however,
@c @R{} needs to be informed what type of device it is dealing with.  This
@c is done by starting a @emph{device driver}.  The purpose of a device
@c driver is to convert graphical instructions from @R{} (``draw a line,''
@c for example) into a form that the particular device can understand.

R은 거의 모든 종류의 디스플레이나 프린팅 디바이스에서의 (다양한 수준의) 그래픽 출력을 지원할 수 있습니다. 하지만, 이러한 출력 작업 전 R에 어떤 종류의 디바이스를 사용할 것인지를 미리 지정해줘야 합니다. 이러한 디바이스 지정 작업은 디바이스 드라이버를 작동시키는 것 입니다. 이렇게 디바이스 드라이버를 작동시키는 이유는 R에서 사용한 그래픽 관련 명령문(예를 들면, “선을 그어라” 같은)을 본인이 사용하고자 하는 디바이스가 이해할 수 있도록 전환하기 위해서입니다.      

@c Device drivers are started by calling a device driver function.  There
@c is one such function for every device driver: type @code{help(Devices)}
@c for a list of them all.  For example, issuing the command

디바이스 드라이는 디바이스 드라이버 함수를 사용해서 작동시킵니다. 모든 종류의 디바이스 드라이버에는 이러한 기능을 하는 함수가 하나씩 있습니다: help(Devices)를 입력하면 사용가능한 모든 디바이스와 디바이스를 시작하게 하는 함수의 리스트가 보여집니다. 예를 들면, 다음과 같은 명령문을 입력하면

@example
> postscript()
@end example

@noindent
@c causes all future graphics output to be sent to the printer in
@c PostScript format.  Some commonly-used device drivers are:

앞으로 생성하게 될 모든 그래픽 결과물들이 PostScript 포맷으로 프린터로 보내지게 됩니다. 자주 자용되는 디바이스 드라이버에는 다음과 같은 것들이 있습니다:



@table @code
@item X11()
@findex X11
@c For use with the X11 window system on Unix-alikes
Unix와 같은 X11 윈도우 시스템을 사용하기 위한 함수

@item windows()
@findex windows
@c For use on Windows
윈도우를 사용하기 위한 함수

@item quartz()
@findex quartz
@c For use on Mac OS X
Mac OS X 를 사용하기 위한 함수

@item postscript()
@findex postscript
@c For printing on PostScript printers, or creating PostScript graphics
@c files.
PostScript 프린터를 사용하거나, 또는 PostScript 포맷으로 된 그래픽 파일을 생성하기 위한 함수.

@item pdf()
@findex pdf
@c Produces a PDF file, which can also be included into PDF files.
PDF 파일을 생성하는 함수. 이 파일을 다른PDF 파일의 일부분으로 포함 가능

@item png()
@findex png
@c Produces a bitmap PNG file. (Not always available: see its help page.)
비트맵 PNG 파일을 생성하는 함수 (언제나 실행 가능한 것은 아닙니다: help 참조)

@item jpeg()
@findex jpeg
@c Produces a bitmap JPEG file, best used for @code{image} plots.
@c (Not always available: see its help page.)
비트맵 JPEG 파일을 생성하는 함수로 이미지 플롯을 저장하기에 최적화된 방법 (언제나 실행 가능한 것은 아닙니다: help 참조)
@end table

@c When you have finished with a device, be sure to terminate the device
@c driver by issuing the command
하나의 디바이스의 사용이 끝나면, 다음과 같은 명령어를 사용해서 해당 디바이스를 종료시키는 것을 잊지 마십시오.

@example
> dev.off()
@end example

@c This ensures that the device finishes cleanly; for example in the case
@c of hardcopy devices this ensures that every page is completed and has
@c been sent to the printer.  (This will happen automatically at the normal
@c end of a session.)

이 문장을 사용하면 현재 사용 중인 디바이스를 좀 더 확실하게 종료시킬 수 있습니다. 예를 들면, 하드 카피로 출력하기 위한 디바이스를 사용 중인 경우, 이 명령문을 사용하면 각 페이지를 프린터로 보낼 때마다 종료되도록 합니다. (원래 페이지의 종료는 R에서 하나의 세션이 종료될 때 자동적으로 이루어지게 됩니다.)

@menu
* PostScript diagrams for typeset documents::  
* Multiple graphics devices::   
@end menu

@node PostScript diagrams for typeset documents, Multiple graphics devices, Device drivers, Device drivers
@c @subsection PostScript diagrams for typeset documents
@subsection 조판 문서를 위한 포스트스크립트 다이어그램 생성하기

@c By passing the @code{file} argument to the @code{postscript()} device
@c driver function, you may store the graphics in PostScript format in a
@c file of your choice.  The plot will be in landscape orientation unless
@c the @code{horizontal=FALSE} argument is given, and you can control the
@c size of the graphic with the @code{width} and @code{height} arguments
@c (the plot will be scaled as appropriate to fit these dimensions.) For
@c example, the command

postscript() 디바이스 드라이버 함수를 사용해서 파일을 작업할 경우, 작업된 그래픽을 지정된 파일 안에 PostScript 포맷으로 저장하는 것이 가능합니다. 플롯은 따로horizontal=FALSE 라는 문장을 사용하지 않는다면, 가로 방향으로 정렬된 페이지에 그려지며, 그래픽의 크기는 width와 height 문장을 사용해서 조정 가능합니다 (플롯은 지정된 페이즈의 크기에 맞게 크기가 자동적으로 조정됩니다).

예를 들면, 다음과 같은 명령문을 사용할 경우

@example
> postscript("file.ps", horizontal=FALSE, height=5, pointsize=10)
@end example

@noindent
@c will produce a file containing PostScript code for a figure five inches
@c high, perhaps for inclusion in a document.  It is important to note that
@c if the file named in the command already exists, it will be overwritten.
@c This is the case even if the file was only created earlier in the same
@c @R{} session.
PostScript 코드로 된 높이가 5인치인 그림 파일이 하나 생성되며, 이 파일은 아마도 하나의 문서 안에서 생성되었을 것 입니다. 만약 명령문에 사용된 파일의 이름이 이미 존재하는 파일의 이름과 같다면, 이 문장으로 실행하면 덮어쓰기가 되어버립니다. 이러한 덮어쓰기는 설사 해당 파일이 같은 R 세선 내에서 방금 전에 생성된 것이라고 하더라도 발생하게 됩니다.

@c Many usages of PostScript output will be to incorporate the figure in
@c another document.  This works best when @emph{encapsulated} PostScript
@c is produced: @R{} always produces conformant output, but only marks the
@c output as such when the @code{onefile=FALSE} argument is supplied.  This
@c unusual notation stems from @Sl{}-compatibility: it really means that
@c the output will be a single page (which is part of the EPSF
@c specification).  Thus to produce a plot for inclusion use something like

PostScript 포맷을 사용하는 가장 흔한 이유는 작업한 그림을 다른 문서에 포함시키기 위해서일 것 입니다. 이러한 작업을 최적하하는 것이 파일을 PostScript 포맷으로 작업하는 것입니다: R은 따로 onefile=FALSE 과 같은 옵션을 지정하는 경우가 아니라면, 계속해서 일정한 형태로 결과를 출력합니다. 이러한 흔치 않은 출력 형태는 S와 R의 상호 호환성에서 기인합니다: 다시 말해, 모든 결과물이 (EPSF 기준을 따르는 결과로 인해) 한 페이지에 출력된다는 의미입니다. 따라서, 다른 문서에 포함되는 플롯을 그리기 위해서는 다음과 같은 문장을 사용해야 합니다.

@example
> postscript("plot1.eps", horizontal=FALSE, onefile=FALSE,
             height=8, width=6, pointsize=10)
@end example

@node Multiple graphics devices,  , PostScript diagrams for typeset documents, Device drivers
@c @subsection Multiple graphics devices
@subsection 다중 그래픽 장치 이용하기

@c In advanced use of @R{} it is often useful to have several graphics
@c devices in use at the same time.  Of course only one graphics device can
@c accept graphics commands at any one time, and this is known as the
@c @emph{current device}.  When multiple devices are open, they form a
@c numbered sequence with names giving the kind of device at any position.

@c The main commands used for operating with multiple devices, and their
@c meanings are as follows:

R의 중상급 이상의 사용자라면 종종 여러 개의 그래픽 디바이스를 동시에 사용해야 할 필요가 생길 것입니다. 물론, 한 번에 하나의 명령문을 실행할 수 있는 것은 오직 하나의 디바이스이며, 우리는 이 사용 중인 디바이스를 현재 디바이스라고 부릅니다. 여러 개의 디바이스가 사용 중일 경우, 디바이스들이 순서대로 디바이스 종류 별 이름으로 리스트 상에 표기되어 하나의 위치에 할당 됩니다.   

여러 개의 디바이스들을 열어서 작동시키기 위한 주요 명령문과 그 의미는 아래와 같습니다:

@table @code
@item X11()
[UNIX]
@item windows()
@itemx win.printer()
@itemx win.metafile()
[Windows]
@item quartz()
[Mac OS X]
@item postscript()
@itemx pdf()
@item png()
@item jpeg()
@item tiff()
@item bitmap()
@itemx @dots{}
@c Each new call to a device driver function opens a new graphics device,
@c thus extending by one the device list.  This device becomes the current
@c device, to which graphics output will be sent.
각각의 디바이스 드라이버 함수를 입력할 때마다 새로운 그래픽 디바이스를  작동되며, 따라서 디바이스 리스트도 그 사용된 함수의 숫자 만큼 길어지게 됩니다. 이렇게 작동된 디바이스가 현재 디바이스가 되며, 그래픽 결과물의 출력시 이 현재 디바이스가 결과를 보여주게 됩니다.

@item dev.list()
@findex dev.list
@c Returns the number and name of all active devices.  The device at
@c position 1 on the list is always the @emph{null device} which does not
@c accept graphics commands at all.
현재 열려 있는 모든 디바이스들의 숫자와 이름을 보여주는 명령문. 이 리스트 상의 첫 번째 위치에는 항상 null device가 위치하는데 사실 이 디바이스는 그랙픽 명령문을 전혀 실행하지 않습니다.

@item dev.next()
@itemx dev.prev()
@findex dev.next
@findex dev.prev
@c Returns the number and name of the graphics device next to, or previous
@c to the current device, respectively.
리스트 상에서 현재 디바이스 보다 순서상 각각 앞이나 또는 뒤에 위치한 그래픽 디바이스의 숫와 이름을 보여주는 명령문들.

@item dev.set(which=@var{k})
@findex dev.set
@c Can be used to change the current graphics device to the one at position
@c @var{k} of the device list.  Returns the number and label of the device.

디바이스 리스트 상의 k 번째에 위치한 그래픽 디바이스를 현재 디바이스로 지정하기 위해 사용하는 명령문. 지정된 디바이스의 숫자와 이름을 출력합니다.

@item dev.off(@var{k})
@findex dev.off
@c Terminate the graphics device at point @var{k} of the device list.  For
@c some devices, such as @code{postscript} devices, this will either print
@c the file immediately or correctly complete the file for later printing,
@c depending on how the device was initiated.
디바이스 리스트 상의 k 번째 그래픽 디바이스를 종료시킵니다. Postscript 와 같은 몇몇 디바이스의 경우, 이 명령문은 디바이스의 종류에 따라 해당 파일을 즉시 출력하는 식으로 실행되며 또는 나중에 출력하기 위해 해당 파일을 제대로 종료하는 식으로 실행되기도 합니다.



@item dev.copy(device, @dots{}, which=@var{k})
@itemx dev.print(device, @dots{}, which=@var{k})
@c Make a copy of the device @var{k}.  Here @code{device} is a device
@c function, such as @code{postscript}, with extra arguments, if needed,
@c specified by @samp{@dots{}}.  @code{dev.print} is similar, but the
@c copied device is immediately closed, so that end actions, such as
@c printing hardcopies, are immediately performed.

k 번째 디바이스를 카피하는 명령문. 여기서 디바이스는 포스트 스크립트와 같은 하나의 디바이스 함수를 의미하며, 필요할 경우 ‘...’ 부분에 좀 더 구체적으로 지정할 수도 있습니다. dev.print 도 비슷한 기능을 하지만, 디바이스를 카피 한 후 바로 종료시키므로 하드 카피로 출력하는 것과 같은 명령을 즉시 실행합니다.

@item graphics.off()
@c Terminate all graphics devices on the list, except the null device.
기본 장치(null device)를 제외한 리스트 상에 나열된 모든 그래픽 장치를 종료합니다.

@end table

@node Dynamic graphics,  , Device drivers, Graphics
@c @section Dynamic graphics
@section 다이나믹한 그래픽 생성하기
@cindex Dynamic graphics

@c @R{} does not have builtin capabilities for dynamic or
@c interactive graphics, e.g.@ rotating point clouds or to ``brushing''
@c (interactively highlighting) points. However, extensive dynamic graphics
@c facilities are available in the system GGobi by Swayne, Cook and Buja
@c available from

Dynamic 또는 interactive 한 그래픽 built-in기능을 제공하지 않습니다. (e.g. rotating point clouds or to “brushing” (interactively highlighting) points) 그렇지만, Swayne, Cook과 Buja 에 의해 개발된 GGobi 시스템

@quotation
@uref{http://www.ggobi.org/}
@end quotation

@noindent
@c and these can be accessed from @R{} via the package @CRANpkg{rggobi}, described at

을 통해 충분한 dynamic 그래픽 기능들을 사용하는 것이 가능합니다. 이러한 GGobi 기능들을 이용하기 위해서는 R의 팩키지 중의 하나인 rggobi를 사용해야 합니다. (사용법:

@uref{http://www.ggobi.org/rggobi}).

@c Also, package @CRANpkg{rgl} provides ways to interact with 3D plots, for example
@c of surfaces.

또한, rgl 팩키지는 3D plot 을 사용하여 이러한 plot 의 표면(surface) 등에서 interactive 하게 작업할 수 있도록 해 줍니다.

@node Packages, A sample session, Graphics, Top
@c @chapter Packages
@chapter 패키지들
@cindex Packages

@c All @R{} functions and datasets are stored in @emph{packages}.  Only
@c when a package is loaded are its contents available.  This is done both
@c for efficiency (the full list would take more memory and would take
@c longer to search than a subset), and to aid package developers, who are
@c protected from name clashes with other code.  The process of developing
@c packages is described in @ref{Creating R packages, , Creating R
@c packages, R-exts, Writing R Extensions}.  Here, we will describe them
@c from a user's point of view.

모든 @R{} 함수들과 데이터셋들은 @emph{packages}(패키지)안에 저장되어 있습니다. 
따라서, 패키지가 로드되었을때만 패키지 안의 내용들을 사용할 수 있습니다.
이러한 패키지 시스템은 전체리스트를 사용하지 않으므로 메모리의 사용량이 적고 필요시 검색에도 훨씬 적은 시간이 걸리므로 메모리사용에서 효율적이라고 할 수 있습니다. 
또한, 이러한 시스템은 다른 코드들과 이름이 충돌이 나는 것을 자연스레 방지해 줌으로서 패키지 개발자의 편의를 고려했다고 볼 수 있습니다. 
패키지를 개발하는 과정에 대해서는 @ref{Creating R packages, , Creating R packages, R-exts, Writing R Extensions}를 살펴보시길 바랍니다.
여기에서 우리는 사용자 측면에 대해서만 이야기 할 것입니다.

@c To see which packages are installed at your site, issue the command
어떤 패키지들이 사용자의 사이트(site)에 설치되어 있는지 알고 싶다면 다음의 명령어를 아무런 인자없이 입력해보세요.

@example
> library()
@end example

@noindent
@c with no arguments.  To load a particular package (e.g., the @CRANpkg{boot}
@c package containing functions from Davison & Hinkley (1997)), use a
@c command like

Davison & Hinkley (1997)가 작성한 함수들을 포함하고 있는 @CRANpkg{boot}와 같은 어떤 특정한 패키지를 설치하고자 한다면, 아래와 같이 명령어를 입력하면 됩니다. 
@example
> library(boot)
@end example

@c Users connected to the Internet can use the @code{install.packages()}
@c and @code{update.packages()} functions (available through the
@c @code{Packages} menu in the Windows and RAqua GUIs, @pxref{Installing
@c packages, , , R-admin, R Installation and Administration}) to install and
@c update packages.

인터넷에 연결되어 있는 사용자라면 @code{install.packages()}와 @code{update.packages()} 함수들을 이용하여 패키지를 설치하거나 업데이트 할 수 있습니다. 
윈도우즈와 RAqua GUI에서는 @code{Packages} 메뉴를 통하여 위의 기능들을 이용할 수 있습니다. 
@pxref{Installing packages, , , R-admin, R Installation and Administration})를 참고하시길 바랍니다.

@c To see which packages are currently loaded, use
현재 로드되어 있는 패키지들을 확인하고 싶다면 아래의 명령어를 이용해보세요.

@example
> search()
@end example

@noindent
@c to display the search list.  Some packages may be loaded but not
@c available on the search list (@pxref{Namespaces}): these will be
@c included in the list given by

이것은 검색리스트(search list)를 보여줄 것입니다.
일부 패키지들은 아마도 로드되었지만 검색리스트에서 보여지지 않을 수 도 있습니다.
이에 대해서는 @pxref{Namespaces}를 참고하시길 바랍니다.
이들은 다음의 명령어를 통해서 확인이 가능합니다.

@example
> loadedNamespaces()
@end example

@c To see a list of all available help topics in an installed package,
@c use

설치된 패키지에 있는 이용이 가능한 모든 도움말 주제들의 목록을 확인해 보고 싶다면 아래의 명령어를 이용하세요.

@example
> help.start()
@end example

@noindent
@c to start the @HTML{} help system, and then navigate to the package
@c listing in the @code{Reference} section.

이 명령어는 @HTML{} 도움말 시스템을 시작할 것이고, @code{Reference}섹션에서 패키지 목록들을 탐색하시면 됩니다.

@menu
* Standard packages::           
* Contributed packages and CRAN::  
* Namespaces::                  
@end menu

@node Standard packages, Contributed packages and CRAN, Packages, Packages
@c @section Standard packages
@section 표준 패키지들

@c The standard (or @emph{base}) packages are considered part of the @R{}
@c source code.  They contain the basic functions that allow @R{} to work,
@c and the datasets and standard statistical and graphical functions that
@c are described in this manual.  They should be automatically available in
@c any @R{} installation.  @xref{Which add-on packages exist for R?, , R
@c packages, R-FAQ, R FAQ}, for a complete list.

표준 (또는 @emph{base}) 패키지들은 @R{} 소스코드의 중요한 부분입니다.
이들은 @R{}이 작업을 할 수 있도록 해주는 기본 함수들과 데이터셋, 그리고 표준 통계분석 및 이 문서에서 설명된 그래픽 함수들이 포함되어 있습니다.
이러한 표준 패키지들은 @R{} 설치시에 자동으로 사용이 가능합니다.
모든 표준패키지 목록을 알고 싶으시다면 다음을 참조하세요 @xref{Which add-on packages exist for R?, , R packages, R-FAQ, R FAQ}.

@node Contributed packages and CRAN, Namespaces, Standard packages, Packages
@c @section Contributed packages and @acronym{CRAN}
@section 사용자개발 패키지들과 @acronym{CRAN}
@cindex CRAN

@c There are thousands of contributed packages for @R{}, written by many
@c different authors.  Some of these packages implement specialized
@c statistical methods, others give access to data or hardware, and others
@c are designed to complement textbooks.  Some (the @emph{recommended}
@c packages) are distributed with every binary distribution of @R{}.  Most
@c are available for download from @acronym{CRAN}
@c (@uref{http://CRAN.R-project.org/} and its mirrors) and other
@c repositories such as Bioconductor (@uref{http://www.bioconductor.org/})
@c and Omegahat (@uref{http://www.omegahat.org/}).  The @emph{R FAQ}
@c contains a list of CRAN packages current at the time of release, but the
@c collection of available packages changes very frequently.

@R{}은 무수히 많은 개발자들에 의해 작성된 매우 방대한 양의 기여된 패키지(contributed package)들이 있습니다. 
이들 중 일부는 특수한 통계방법들을 구현하였고, 또다른 일부는 데이터 또는 하드웨어에 대한 접근과 관련이 있으며, 그 외의 다른 패키지들은 어떤 참고서 혹은 교과서의 부록이기도 합니다.
일부 @emph{recommended} (권장)패키지들은 @R{}의 바이너리 배포판과 함께 배포됩니다.
대부분은 @acronym{CRAN}(@uref{http://CRAN.R-project.org/}과 미러)와 Bioconductor (@uref{http://www.bioconductor.org/}) 그리고 Omegahat (@uref{http://www.omegahat.org/})과 같은 저장소들을 통해서 얻을 수 있습니다.
@emph{R FAQ}는 가장 최근에 릴리즈된 CRAN 패키지들의 목록을 포함하고 있지만, 이용가능한 패키지들의 목록이 매우 자주 변경됩니다.

@node Namespaces,  , Contributed packages and CRAN, Packages
@c @section Namespaces
@section 네임스페이스
@cindex Namespace
@findex ::
@findex :::

@c Packages can have @emph{namespaces}, and currently all of the base and
@c recommended packages do except the @code{datasets} package.  Namespaces
@c do three things: they allow the package writer to hide functions and
@c data that are meant only for internal use, they prevent functions from
@c breaking when a user (or other package writer) picks a name that clashes
@c with one in the package, and they provide a way to refer to an object
@c within a particular package.

패키지들은 @emph{namespaces}(네임스페이스)를 가질 수 있으며, 현재 @code{datasets} 패키지를 제외한 base와 권장 패키지들 모두가 네임스페이스를 가지고 있습니다. 
네임스페이스는 주로 다음의 세가지 역할을 수행합니다.
첫째는 패키지 작성자가 내부적 사용만을 목적으로 개발하고자 하는 함수들과 데이터들을 숨길 수 있도록 합니다. 
둘째는 사용자 혹은 다른 패키지 작성자가 @R{}의 함수명과 동일한 이름을 가지는 함수명을 사용하고자 할때 동일한 함수명으로 인한 충돌로 인하여 사용자가 사용하고자 하는 함수의 작동이 중단되는 것을 방지할 수 있도록 해줍니다.
마지막으로 특정패키지 내의 객체를 지칭하는데 사용될 수 있습니다.

@c For example, @code{t()} is the transpose function in @R{}, but users
@c might define their own function named @code{t}.  Namespaces prevent
@c the user's definition from taking precedence, and breaking every
@c function that tries to transpose a matrix.

예를 들면, @code{t()}라는 함수는 @R{}에서 행렬을 전치하는데 사용되어 집니다.  
그러나, 사용자는 아마도 @code{t}라는 동일한 이름을 가진 자신만의 고유한 함수를 만들었을수도 있습니다.
네임스페이스는 사용자가 작성한 함수가 우선권을 가지는 것을 막아주고, 행렬을 전치하고자 하는 모든 함수를 중단하게 합니다.

@c There are two operators that work with namespaces.  The double-colon
@c operator @code{::} selects definitions from a particular namespace.
@c In the example above, the transpose function will always be available
@c as @code{base::t}, because it is defined in the @code{base} package.
@c Only functions that are exported from the package can be retrieved in
@c this way.

네임스페이스와 함께 사용되는 두개의 연산자들이 있습니다. 
하나는 더블콜론(double-colon) 연산자 @code{::}이며, 이는 특정한 네임스페이스로부터 정의되어 있는 함수를 불러옵니다.
위의 예제를 다시 살펴보면, 전치함수는 @code{base}패키지 안에 정의되어 있기 때문에 항상 @code{base::t}를 이용하여 사용이 가능합니다.
용할 수 있습니다.
패키지에서 내보내어진 함수들만이 이러한 방법으로 검색되어 질 수 있습니다.

@c The triple-colon operator @code{:::} may be seen in a few places in R
@c code: it acts like the double-colon operator but also allows access to
@c hidden objects.  Users are more likely to use the @code{getAnywhere()}
@c function, which searches multiple packages.

트리플-콜론(triple-colon) 연산자 @code{:::}가 @R 코드내에서 여러 곳에서 사용된 것을 보았을 것입니다.
이것은 더블-콜론 연산자와 비슷하게 기능을 수행하며 또한 숨겨진 객체에 대한 접근을 허락합니다.
그퍼나, 여러개의 패키지들을 검색할 수 있는 특징때문에 사용자는 @code{getAnywhere()} 함수를 더 자주 이용할 것입니다.

@c Packages are often inter-dependent, and loading one may cause others to
@c be automatically loaded.  The colon operators described above will also
@c cause automatic loading of the associated package.  When packages with
@c namespaces are loaded automatically they are not added to the search
@c list.

패키지들은 서로 상호의존적(inter-dependent)이며, 하나를 로딩할 때 자동으로 다른 것들을 함께 로딩될 수 있습니다.
위에서 설명한 콜론연산자들은 또한 연관된 자동패키지들을 로딩하기도 합니다.
네임스페이스가 있는 패키지들이 자동으로 로드될때 이들은 검색목록에 추가되지 않습니다.

@node A sample session, Invoking R, Packages, Top
@c @appendix A sample session
@appendix 샘플 세션 

@c The following session is intended to introduce to you some features of
@c the @R{} environment by using them.  Many features of the system will be
@c unfamiliar and puzzling at first, but this puzzlement will soon
@c disappear.

다음 세션은 @R{} (개발)환경의 일부 기능을 독자가 따라해 봄으로서 쉽게 알 수 있도록 준비한 섹션입니다.
시스템의 많은 기능들이 처음에는 익숙하지 않고 혼잡스러울 수 있으나, 이러한 어려움들은 차차 사라지게 될 것입니다.
@c This is written for the UNIX user.  Those using Windows will
@c need to adapt the discussion slightly.

@table @code
@item
@c Start @R{} appropriately for your platform (@pxref{Invoking R}).
@R{}을 실행시켜보세요 (사용자의 플랫폼별로 다를 수 있으니 @pxref{Invoking R}를 참조하시길 바랍니다).

@c The @R{} program begins, with a banner.
@R{} 프로그램이 시작되면 배너가 보일 것입니다.

@c (Within @R{} code, the prompt on the left hand side will not be shown to
@c avoid confusion.)
@R{} 코드를 표시할 때는 독자들의 혼돈을 피하기 위해서 왼쪽에 있는 프롬프트는 표시하지 않습니다.

@item help.start()
@c Start the @HTML{} interface to on-line help (using a web browser
@c available at your machine).  You should briefly explore the features of
@c this facility with the mouse.

이 명령어를 치면 온라인 도움말을 사용자의 환경에서 사용이 가능한 인터넷 브라우저를 이용하여 @HTML{}인터페이스를 시작하게 됩니다. 
마우스를 이용하여 단순히 어떻게 운영하는 것인지 간단히 살펴보시길 바랍니다.

@c Iconify the help window and move on to the next part.
다음으로 넘어가기 위해서 도움말 창을 작게 만듭니다.

@item x <- rnorm(50)
@itemx y <- rnorm(x)
@c Generate two pseudo-random normal vectors of @math{x}- and
@c @math{y}-coordinates.
이것은 @math{x}와 @math{y}라는 두개의 벡터를 생성하는 것을 의미하는데, 이것은 추후에 플랏을 그리는데 사용할 좌표의 정보입니다. 
@math{x}는 표준정규분포로부터 발생시킨 50개의 난수들을 열벡터의 형식으로 가지고 있으며, @math{y} 역시 @math{x}와 같은 길이만큼의 난수를 표준정규분포로부터 가지게 됩니다.

@item plot(x, y)
@c Plot the points in the plane.  A graphics window will appear automatically.
@math{x}와 @math{y}로 이루어진 좌표들을 평면공간에 플랏하도록 합니다.
그래픽 창이 자동으로 보여질 것입니다.

@item ls()
@c See which @R{} objects are now in the @R{} workspace.
@R{} 워크스페이스 (즉, 작업공간)에 어떠한 @R{} 객체들이 있는지 확인해 보도록 합니다.

@item rm(x, y)
@c Remove objects no longer needed. (Clean up).
더 이상 필요가 없는 객체들을 삭제하도록 합니다.

@item x <- 1:20
@c Make @math{x = (1, 2, @dots{}, 20)}.
@math{x = (1, 2, @dots{}, 20)}를 생성합니다.

@item w <- 1 + sqrt(x)/2
@c A `weight' vector of standard deviations.
표준편차를 이용한 `가중치'벡터를 생성합니다.

@item dummy <- data.frame(x=x, y= x + rnorm(x)*w)
@itemx dummy
@c Make a @emph{data frame} of two columns, @math{x} and @math{y}, and look
@c at it.
@math{x}와 @math{y}의 두개의 열로 이루어진 @emph{data frame}(데이터프레임)을 생성합니다.
그리고 나서 이를 살펴볼 수 있습니다.

@item fm <- lm(y ~ x, data=dummy)
@itemx summary(fm)
@c Fit a simple linear regression and look at the
@c analysis.  With @code{y} to the left of the tilde,
@c we are modelling @math{y} dependent on @math{x}.

단순선형회귀분석을 실행하고 그 분석결과를 살펴봅니다.
틸데표시 좌측에 있는 @code{y}를 우리는 @math{x}를 이용하여 모델한 것입니다.
 
@item fm1 <- lm(y ~ x, data=dummy, weight=1/w^2)
@itemx summary(fm1)
@c Since we know the standard deviations, we can do a weighted regression.
우리는 표준편차를 알고 있기 때문에, 가중회귀분석을 수행합니다.
그리고 그 결과를 봅니다

@item attach(dummy)
@c Make the columns in the data frame visible as variables.
데이터프레임내에 있는 열들을 일반적인 변수와 같이 접근할 수 있도록 해줍니다.

@item lrf <- lowess(x, y)
@c Make a nonparametric local regression function.
비모수 국지회귀함수를 수행합니다.

@item plot(x, y)
@c Standard point plot.
표준적 방법으로 @math{x}와 @math{y} 포인트들을 플랏합니다.

@item lines(x, lrf$y)
@c Add in the local regression.
포인트를 플랏한 그래픽에 회귀분석으로부터 나온 결과를 이용하여 회귀곡선을 그립니다.

@item abline(0, 1, lty=3)
@c The true regression line: (intercept 0, slope 1).
그래픽에 기울기가 1이고 절편이 0인 실제 회귀분석곡선을 추가적으로 그려넣습니다.

@item abline(coef(fm))
@c Unweighted regression line.
위에서 단순선형회귀분석을 한 결과가 저장된 @math{fm}로부터 기울기와 절편에 해당하는 회귀계수들을 이용하여 회귀곡선을 그리도록 합니다.

@item abline(coef(fm1), col = "red")
@c Weighted regression line.
위에서 가중회귀분석을 한 결과가 저장된 @math{fm1}로부터 기울기와 절편에 해당하는 회귀계수들을 이용하여 회귀곡선을 빨간색으로 그려넣습니다.

@item detach()
@c Remove data frame from the search path.
검색경로(search path)로부터 데이터프레임을 제거합니다.

@item plot(fitted(fm), resid(fm),
@itemx @w{@ @ @ @ @ xlab="Fitted values"},
@itemx @w{@ @ @ @ @ ylab="Residuals"},
@itemx @w{@ @ @ @ @ main="Residuals vs Fitted")}
@c A standard regression diagnostic plot to check for heteroscedasticity.
@c Can you see it?
이분산성(heteroscedasticity)을 확인하기 위해서 표준회귀 진단플랏을 그립니다.
보입니까? 

@item qqnorm(resid(fm), main="Residuals Rankit Plot")
@c A normal scores plot to check for skewness, kurtosis and outliers.  (Not
@c very useful here.)
비대칭도(skewness), 첨도(kurtosis), 그리고 이상치(outliers)를 찾기 위해서 정규스코어플랏(normal score plot)을 생성합니다.
(실제로 여기에서는 별로 유용하지 않습니다).

@item rm(fm, fm1, lrf, x, dummy)
@c Clean up again.
다시 불필요한 객체들을 삭제합니다.
@end table

@c The next section will look at data from the classical experiment of
@c Michelson to measure the speed of light.  This dataset is available in
@c the @code{morley} object, but we will read it to illustrate the
@c @code{read.table} function.

다음 섹션에서는 Michelson이 빛의 속도를 측정하기 위해서 사용했던 실험으로부터 모은 데이터를 살펴보도록 하겠습니다.
이 데이터셋은 @code{morley} 객체에서 이용이 가능하지만, 여기에서는 @code{read.table}함수를 어떻게 사용하는가를 보여주기 위해서 데이터를 불러 오도록 해보겠습니다.

@table @code
@item filepath <- system.file("data", "morley.tab" , package="datasets")
@itemx filepath

데이터 파일이 들어있는 경로에 대한 정보를 먼저 얻습니다.

@item file.show(filepath)
@c Optional.  Look at the file.
(선택적 사항) 파일의 내용을 봅니다

@item mm <- read.table(filepath)
@itemx mm
@c Read in the Michelson data as a data frame, and look at it.
@c There are five experiments (column @code{Expt}) and each has 20 runs
@c (column @code{Run}) and @code{sl} is the recorded speed of light,
@c suitably coded.

Michelson의 데이터를 데이터프레임으로서 읽어들이고, 이를 확인해 봅니다.
이 데이터셋은 @code{Expt}라는 열로부터 5번의 실험들이 있었으며, @code{Run}이라는 열로부터 각각 20번씩 수행되었음을 알 수 있습니다.
그리고 @code{sl}에는 빛의 속도가 입력되어 있습니다.

@item mm$Expt <- factor(mm$Expt)
@itemx mm$Run <- factor(mm$Run)
@c Change @code{Expt} and @code{Run} into factors.
@code{Expt}와 @code{Run}에 있는 데이터의 종류를 요인(factor)으로 변경합니다.

@item attach(mm)
@c Make the data frame visible at position 3 (the default).
데이터프레임을 포지션 3 (기본값)에서 볼 수 있도록 합니다. 

@item plot(Expt, Speed, main="Speed of Light Data", xlab="Experiment No.")
@c Compare the five experiments with simple boxplots.
박스플랏(boxplot)을 이용하여 5개의 실험들을 비교해보도록 합니다.

@item fm <- aov(Speed ~ Run + Expt, data=mm)
@itemx summary(fm)
@c Analyze as a randomized block, with `runs' and `experiments' as factors.
`runs'와 `experiments'를 요인으로 놓은 상태에서 랜덤마이즈된 블락(randomized block)으로서 분석을 합니다.

@item fm0 <- update(fm, . ~ . - Run)
@itemx anova(fm0, fm)
@c Fit the sub-model omitting `runs', and compare using a formal analysis
@c of variance.
`runs'를 삭제한 서브모델을 적합한 다음에 이전의 분산분석(analysis of variance)와 비교를 해봅니다.

@item detach()
@itemx rm(fm, fm0)
@c Clean up before moving on.
다음 분석으로 넘어가기 전에 불필요한 객체들을 삭제합니다.

@end table

@c We now look at some more graphical features: contour and image plots.
우리는 이제 contour(컨투어 또는 등고선)와 image(이미지) 플랏이라는 그래픽 기능에 대해서 좀 더 알아보도록 할 것입니다.

@table @code
@item x <- seq(-pi, pi, len=50)
@itemx y <- x
@c @math{x} is a vector of 50 equally spaced values in
@math{x}는 

@ifnottex
@c the interval [-pi\, pi].
[-pi\, pi] 구간을 50등분한 값을 가지고 있는 벡터입니다.
@end ifnottex
@iftex
@tex
$-\pi\leq x \leq \pi$ 구간을 50등분한 값을 가지고 있는 벡터입니다.
@end tex
@end iftex

@c @math{y} is the same.
@math{y}는 @math{x}와 동일한 벡터입니다.

@item f <- outer(x, y, function(x, y) cos(y)/(1 + x^2))
@c @math{f} is a square matrix, with rows and columns indexed by @math{x}
@c and @math{y} respectively, of values of the function
@c @eqn{\cos(y)/(1 + x^2),cos(y)/(1 + x^2)}.
@math{f}는 @math{x}와 @math{y}를 각각 행과 열로 가지는 정방행렬이며, 이 행렬의 원소는 @math{x}의 원소와 @math{y}의 원소의 쌍을 이용하여 함수 @eqn{\cos(y)/(1 + x^2),cos(y)/(1 + x^2)}를 통해 얻어집니다.

@item oldpar <- par(no.readonly = TRUE)
@itemx par(pty="s")
@c Save the plotting parameters and set the plotting region to ``square''.
현재의 플랏팅 파라미터들을 저장하고 플랏팅지역 (plotting region)을 ``square''로 정합니다.

@item contour(x, y, f)
@itemx contour(x, y, f, nlevels=15, add=TRUE)
@c Make a contour map of @math{f}; add in more lines for more detail.
@math{f}의 컨투어 맵(contour map)을 생성하고, 15개의 컨투어 레벨을 보여지도록 합니다.

@item fa <- (f-t(f))/2
@c @code{fa} is the ``asymmetric part'' of @math{f}.  (@code{t()} is
@c transpose).
@code{fa}는 @math{f}의 ``asymmetric part''(비대칭 부분)입니다 (여기에서 @code{t()}는 행렬의 전치를 의미합니다).

@item contour(x, y, fa, nlevels=15)
@c Make a contour plot, @dots{}
컨투어 플랏을 생성합니다.

@item par(oldpar)
@c @dots{} and restore the old graphics parameters.
이전의 그래픽 파라미터들을 원상태로 되돌립니다.

@item image(x, y, f)
@itemx image(x, y, fa)
@c Make some high density image plots, (of which you can get
@c hardcopies if you wish), @dots{}

이미지 플랏을 생성합니다.

@item objects(); rm(x, y, f, fa)
@c @dots{} and clean up before moving on.
어떤 객체들이 워크스페이스에 있는지 확인한 뒤, 다음 분석을 수행하기 전에 불필요한 객체들을 제거합니다.

@end table

@c @R{} can do complex arithmetic, also.
@R{}은 또한 복소수 연산을 수행할 수 있습니다.

@table @code
@item th <- seq(-pi, pi, len=100)
@itemx z <- exp(1i*th)
@c @code{1i} is used for the complex number @math{i}.
@code{1i}는 복소수 @math{i}를 나타내는데 사용됩니다.

@item par(pty="s")
@itemx plot(z, type="l")
@c Plotting complex arguments means plot imaginary versus real parts.  This
@c should be a circle.

허수와 실수부분을 플랏하도록 합니다.  
이것은 반드시 원의 모양이 나와야 합니다.

@item w <- rnorm(100) + rnorm(100)*1i
@c Suppose we want to sample points within the unit circle.  One method
@c would be to take complex numbers with standard normal real and imaginary
@c parts @dots{}
단위 원(unit circle)내에서 어떤 포인트들을 샘플링해야 한다고 가정해 봅니다. 
이를 위한 한 가지 방법은 아마도 실수와 허수부분에 각각 표준정규분포로부터 난수를 생성하는 것입니다.

@item w <- ifelse(Mod(w) > 1, 1/w, w)
@c @dots{} and to map any outside the circle onto their reciprocal.
원 밖에 놓인 값들만을 골라 그들의 역수에 맵핑시키도록 합니다.

@item plot(w, xlim=c(-1,1), ylim=c(-1,1), pch="+",xlab="x", ylab="y")
@itemx lines(z)
@itemx
@c All points are inside the unit circle, but the distribution is not
@c uniform.
단위원(unit circle)내에 모든 점들이 있지만, 균일분포(uniform distribution)가 아님을 알 수 있습니다.

@item w <- sqrt(runif(100))*exp(2*pi*runif(100)*1i)
@itemx plot(w, xlim=c(-1,1), ylim=c(-1,1), pch="+", xlab="x", ylab="y")
@itemx lines(z)
@itemx
@c The second method uses the uniform distribution.  The points should now
@c look more evenly spaced over the disc.
두번째 방법으로는 균일분포를 이용하는 것입니다.
이 점들은 반드시 디스크에 균등하게 퍼져 있어 보여야 합니다.

@item rm(th, w, z)
@c Clean up again.
다시 불필요한 객체들을 제거 하도록 합니다.

@item q()
@c Quit the @R{} program.  You will be asked if you want to save the @R{}
@c workspace, and for an exploratory session like this, you probably do not
@c want to save it.
@R{} 프로그램을 종료합니다.
이때,  @R{} 작업공간 (또는 워크스페이스)를 저장하고 싶은지에 대해서 물어보게 될 것입니다.
그리고, 기초사용에 대한 설명을 목적으로 하는 세션이므로 꼭 저장하실 필요는 없습니다.
@end table











@node Invoking R, The command-line editor, A sample session, Top
@c @appendix Invoking R
@appendix R 실행하기

@c Users of @R{} on Windows or Mac OS X should read the OS-specific section
@c first, but command-line use is also supported.

Windows 또는 Mac OS X에서 @R{}을 이용하는 사용자들은 특정 운영체제에 관한 설명이 되어 있는 섹션을 먼저 읽어보시길 바랍니다. 
그러나, 명령어를 이용한 사용 또한 지원되고 있습니다. 

@menu
* Invoking R from the command line::  
* Invoking R under Windows::    
* Invoking R under Mac OS X::   
* Scripting with R::            
@end menu

@node Invoking R from the command line, Invoking R under Windows, Invoking R, Invoking R
@c @appendixsec Invoking R from the command line
@appendixsec 명령어를 이용하여 R 사용하기

@c When working at a command line on UNIX or Windows, the command @samp{R}
@c can be used both for starting the main @R{} program in the form
UNIX 또는 Windows 환경에서 명령어를 이용하여 작업을 할때, 명령어 @samp{R}은 아래와 같은 형식으로 @R{} 프로그램을 실행하는데 사용될 수 있습니다. 

@display
@code{R} [@var{options}] [@code{<}@var{infile}] [@code{>}@var{outfile}],
@end display

@noindent
@c or, via the @code{R CMD} interface, as a wrapper to various @R{} tools
@c (e.g., for processing files in @R{} documentation format or manipulating
@c add-on packages) which are not intended to be called ``directly''.
또한, @R{} 문서형식 또는 애드온(add-on)패키지들을 다루는데 필요한 다양한 @R{}도구들을 사용하도록 해주는 @code{R CMD}를 이용하여 직접적으로 호출되지 않고도 사용할 수 있습니다. 

@c At the Windows command-line, @command{Rterm.exe} is preferred to
@c @command{R}.
Windows 상에서는 명령어 @command{Rterm.exe}를 이용하는 것이 @command{R}을 이용하는 것보다 선호됩니다.

@c You need to ensure that either the environment variable @env{TMPDIR} is
@c unset or it points to a valid place to create temporary files and
@c directories.

환경 변수 @env{TMPDIR}이 지정되지 않았거나, 임시 파일과 디렉토리 생성을 하는데 사용되는 공간을 올바르게 지정을 했는지에 대해서 확인을 해야합니다.

@c Most options control what happens at the beginning and at the end of an
@c @R{} session.  The startup mechanism is as follows (see also the on-line
@c help for topic @samp{Startup} for more information, and the section below
@c for some Windows-specific details).

대부분의 옵션들은 @R{} 세션의 시작과 끝에서 무엇이 일어나는가를 제어하는데 사용됩니다. 
이러한 스타트업 메카니즘 (startup mechanism)은 다음과 같습니다 (이에 대해서 더 많은 정보를 @samp{Startup}이라는 주제에 대한 온라인 도움말을 참고하시길 바랍니다.  또한, 일부 Windows와 관련된 내용들은 아래에 설명이 되어있습니다).

@itemize @bullet
@item
@c Unless @option{--no-environ} was given, @R{} searches for user and site
@c files to process for setting environment variables.  The name of the
@c site file is the one pointed to by the environment variable
@c @env{R_ENVIRON}; if this is unset, @file{@var{R_HOME}/etc/Renviron.site}
@c is used (if it exists).  The user file is the one pointed to by the
@c environment variable @env{R_ENVIRON_USER} if this is set; otherwise,
@c files @file{.Renviron} in the current or in the user's home directory
@c (in that order) are searched for.  These files should contain lines of
@c the form @samp{@var{name}=@var{value}}.  (See @code{help("Startup")} for
@c a precise description.)  Variables you might want to set include
@c @env{R_PAPERSIZE} (the default paper size), @env{R_PRINTCMD} (the
@c default print command) and @env{R_LIBS} (specifies the list of @R{}
@c library trees searched for add-on packages).

@option{--no-environ}이라는 옵션이 주어지지 않는다면, @R{}은 환경변수들을 설정하기 위한 작업을 진행하기 위해서 사용자와 사이트 파일들(user and site files)을 찾습니다.
사이트 파일의 이름은 환경변수 @env{R_ENVIRON}에 의해 지정됩니다. 
만약, 이것이 설정되어 있지 않다면, @file{@var{R_HOME}/etc/Renviron.site}이 이용됩니다 (만약 존재할 경우에 한합니다).
사용자 파일은 @env{R_ENVIRON_USER}라는 환경변수가 설정되어 있다면 이 파일에 의해서 지정됩니다. 
그렇지 않다면 현재 또는 사용자의 홈디렉토리내에 있는 @file{.Renviron}이라는 파일을 찾습니다. 
이러한 파일들은 @samp{@var{name}=@var{value}}이라는 형식을 가진 라인들을 포함해야 합니다.
(구체적인 이해를 위해서 @code{help("Startup")}을 살펴보시길 바랍니다)
설정하고 싶은 변수들은 아마도 기본 페이퍼의 크기를 정하는 @env{R_PAPERSIZE}, 기본 프린터 명령을 정해주는 @env{R_PRINTCMD}, 그리고 애드온 패키지들을 찾는데 사용된 @R{} 라이브러리 트리(library tree)들의 목록을 지정하는 @env{R_LIBS}가 있습니다. 

@item
@c Then @R{} searches for the site-wide startup profile unless the command
@c line option @option{--no-site-file} was given.  The name of this file is
@c taken from the value of the @env{R_PROFILE} environment variable.  If
@c that variable is unset, the default
@c @file{@var{R_HOME}/etc/Rprofile.site} is used if this exists.

명령어 옵션 @option{--no-site-file}이 주어지지 않았다면, @R{}은 사이트-와이드 스타트업 프로파일(site-wide startup profile)을 찾습니다. 
이 파일의 이름은 @env{R_PROFILE} 환경 변수의 값으로부터 얻을 수 있습니다. 
만약 이 변수가 지정되지 않았다면 기본적으로 @file{@var{R_HOME}/etc/Rprofile.site}이 이용됩니다 (만약 존재한다면).

@item
@c Then, unless @option{--no-init-file} was given, @R{} searches for a user
@c profile and sources it.  The name of this file is taken from the
@c environment variable @env{R_PROFILE_USER}; if unset, a file called
@c @file{.Rprofile} in the current directory or in the user's home
@c directory (in that order) is searched for.

만약 @option{--no-init-file}이 주어지지 않았다면 @R{}은 사용자 프로파일(user profile)을 탐색 후 이를 읽어들이게 됩니다. 
이 파일의 이름은 환경변수 @env{R_PROFILE_USER}로 부터 얻을 수 있습니다.
이것이 설정되지 않았다면, 현재 디렉토리에 있거나 사용자의 홈 디렉토리에 있는 @file{.Rprofile} 파일을 찾을 것입니다. 

@item
@c It also loads a saved workspace from file @file{.RData} in the current
@c directory if there is one (unless @option{--no-restore} or
@c @option{--no-restore-data} was specified).
또한, (@option{--no-restore} 또는 @option{--no-restore-data} 옵션이 지정되지 않았다면) 현재의 디렉토리에 @file{.RData} 파일로부터 저장된 작업공간을 불러올 수 있습니다. 

@item
@c Finally, if a function @code{.First()} exists, it is executed.  This
@c function (as well as @code{.Last()} which is executed at the end of the
@c @R{} session) can be defined in the appropriate startup profiles, or
@c reside in @file{.RData}.
마지막으로 @code{.First()} 함수가 존재한다면, 이것은 실행될 것입니다.
(@R{} 세션의 끝부분에서 실행된 @code{.Last()}함수와 같이) 이 함수는 적절한 스타트업 프로파일들 내에 정의될 수 있습니다. 
또는 @file{.RData}에 위치할 수도 있습니다. 
@end itemize

@c In addition, there are options for controlling the memory available to
@c the @R{} process (see the on-line help for topic @samp{Memory} for more
@c information).  Users will not normally need to use these unless they
@c are trying to limit the amount of memory used by @R{}.

추가적으로 @R{} 처리과정에 이용되는 메모리를 조절하는 옵션들이 있습니다. 
(더 많은 정보를 원하신다면 @samp{Memory}와 관련된 온라인 도움말을 살펴보시길 바랍니다).
@R{}에 의하여 사용되는 메모리를 크기를 조절하고자 하지 않는다면 사용자는 이들을 사용해야 할 필요는 없습니다. 

@c @R{} accepts the following command-line options.
@R{}은 다음과 같은 명령어 옵션들을 제공합니다. 

@table @option
@item --help
@itemx -h
@c Print short help message to standard output and exit successfully.
표준 출력(standard output)으로 짧은 도움말 메시지를 보여주고 종료합니다. 

@item --version
@c Print version information to standard output and exit successfully.
표준 출력(standard output)으로 버전정보를 표시해주고 종료합니다.

@item --encoding=@var{enc}
@c Specify the encoding to be assumed for input from the console or
@c @code{stdin}.  This needs to be an encoding known to @code{iconv}: see
@c its help page.  (@code{--encoding @var{enc}} is also accepted.)
@code{stdin} 또는 콘솔로부터의 입력에 사용될 인코딩(encoding)을 지정합니다.
이것은 @code{iconv}에서 사용될 수 있는 알려진 인코딩이어야 합니다. 
도움말 페이지를 참고하시길 바랍니다.
(@code{--encoding @var{enc}}) 또한 사용될 수 있습니다. 

@item RHOME
@c Print the path to the @R{} ``home directory'' to standard output and
@c exit successfully.  Apart from the front-end shell script and the man
@c page, @R{} installation puts everything (executables, packages, etc.)
@c into this directory.
표준출력에 @R{} ``home directory'' (홈디렉토리)의 경로를 보여주고 종료합니다.
사용자가 직접 작성하는 쉘 스크립트(shell script)와 도움말 페이지(man page)를 제외하고 실행이 가능한 파일들, 패키지 등 모두가 @R{}이 설치되어 집니다. 

@item --save
@itemx --no-save
@c Control whether data sets should be saved or not at the end of the @R{}
@c session.  If neither is given in an interactive session, the user is
@c asked for the desired behavior when ending the session with @kbd{q()};
@c in non-interactive use one of these must be specified or implied by some
@c other option (see below).
@R{}세션을 종료할때 데이터 셋들을 저장할 것인지에 대한 여부를 조절합니다. 

@item --no-environ
@c Do not read any user file to set environment variables.
환결변수를 설정하기 위한 어떠한 유저파일(user file)을 읽어들이지 않습니다.

@item --no-site-file
@c Do not read the site-wide profile at startup.
스타트업(startup)에서 사이트-와이드 프로파일 (site-wide profile)을 읽어들이지 않습니다. 

@item --no-init-file
@c Do not read the user's profile at startup.
스타트업(startup)에서 사용자의 프로파일을 읽어들이지 않습니다. 

@item --restore
@itemx --no-restore
@itemx --no-restore-data
@c Control whether saved images (file @file{.RData} in the directory where
@c @R{} was started) should be restored at startup or not.  The default is
@c to restore. (@option{--no-restore} implies all the specific
@c @option{--no-restore-*} options.)
스타트업(startup)할때 @R{}이 시작된 디렉토리내에서 @file{.RData}의 형식으로 저장되어진 이미지들 복구할 것인지를 조절합니다.
기본값은 복구하는 것입니다.
(@option{--no-restore}는 좀 더 세부적인 @option{--no-restore-*}과 같은 옵션들 모두를 의미합니다)

@item --no-restore-history
@c Control whether the history file (normally file @file{.Rhistory} in the
@c directory where @R{} was started, but can be set by the environment
@c variable @env{R_HISTFILE}) should be restored at startup or not.  The
@c default is to restore.
@R{}이 시작된 디렉토리내에 일반적으로 @file{.Rhistory}로 되어 있는 작업기록파일 (history file)을 스타트업 (startup)할때 복구할 것인지를 조절합니다.
이 파일은 환경변수 @env{R_HISTFILE}에 의해서 지정될 수도 있습니다. 
기본값은 복구하는 것입니다. 

@item --no-Rconsole
@c (Windows only) Prevent loading the @file{Rconsole} file at startup.
(Windows에만 적용되는 옵션입니다).
이는 스타트업시에 @file{Rconsole} 파일을 로딩하지 못하게 합니다. 

@item --vanilla
@c Combine @option{--no-save}, @option{--no-environ},
@c @option{--no-site-file}, @option{--no-init-file} and
@c @option{--no-restore}.  Under Windows, this also includes
@c @option{--no-Rconsole}.
@option{--no-save}, @option{--no-environ}, @option{--no-site-file}, @option{--no-init-file}, @option{--no-restore}를 모두 한데 묶은 것입니다.
Windows상에서는 이 옵션은 또한 @option{--no-Rconsole}을 포함합니다.

@item -f @var{file}
@itemx --file=@var{file}
@c (not @command{Rgui.exe}) Take input from @var{file}: @samp{-} means
@c @code{stdin}.  Implies @option{--no-save} unless @option{--save} has
@c been set.  On a Unix-alike, shell metacharacters should be avoided in
@c @var{file} (but as from @R{} 2.14.0 spaces are allowed).
(@command{Rgui.exe}에 적용되지 않습니다).
@var{file}로부터 입력을 가져옵니다:
@samp{-}은 @code{stdin}을 의미합니다.
@option{--save}가 지정되지 않았다면 @option{--no-save}를 의미하게 됩니다.
Unix와 같은 환경에서는 쉡 메타문자(shell metacharacters)는 @var{file}내에서 사용을 피해야 합니다.
(그러나, @R{} 2.14.0 부터 공백(spaces)들이 허용됩니다).

@item -e @var{expression}
@c (not @command{Rgui.exe}) Use @var{expression} as an input line.  One or
@c more @option{-e} options can be used, but not together with @option{-f}
@c or @option{--file}.  Implies @option{--no-save} unless @option{--save}
@c has been set.  (There is a limit of 10,000 bytes on the total length of
@c expressions used in this way.  Expressions containing spaces or shell
@c metacharacters will need to be quoted.)
(@command{Rgui.exe}에서는 사용할 수 없습니다). 
@var{expression}을 한줄의 입력라인 (input line)으로 이용하세요.
하나 또는 그 이상의 @option{-e} 옵션들이 사용될 수 있으나, @option{-f} 또는 @option{--file}과는 함께 사용할 수 없습니다. 
@option{--save}가 지정되어 있지 않다면 @option{--no-svae}을 의미하게 됩니다.
(이러한 방식으로 expression 부분에 들어갈 수 있는 최대 길이는 10,000 바이트 입니다.
공백 또는 쉘 메타문자들을 포함하는 expressions들은 따옴표를 사용해야 할 필요가 있습니다)

@item --no-readline
@c (UNIX only) Turn off command-line editing via @strong{readline}.  This
@c is useful when running @R{} from within Emacs using the @acronym{ESS}
@c (``Emacs Speaks Statistics'') package.  @xref{The command-line editor},
@c for more information.  Command-line editing is enabled by default
@c interactive use (see @option{--interactive}).  This option also affects
@c tilde-expansion: see the help for @code{path.expand}.
(UNIX에서만 사용됩니다).
@strong{readline}을 통해서 명령어줄(command-line)을 편집하는 것을 끕니다.
이것은 @acronym{ESS}(``Emacs Speaks Statistics'') 패키지를 이용하여 Emacs상에서 @R{}을 실행할 때 유용합니다. 
더 많은 정보를 원하시면 @ref{The command-line editor}를 살펴보시길 바랍니다.
명령어라인 편집은 기본적으로 대화식으로 사용합니다.
(@option{--interactive}를 살펴보세요).
이 옵션은 또한 틸데확장(tilde-expansion)에 영향을 미칩니다.
이것에 대해서는 @code{path.expand}에 대한 도움말을 살펴보시길 바랍니다.

@item --min-vsize=@var{N}
@itemx --min-nsize=@var{N}
@c For expert use only: set the initial trigger sizes for garbage
@c collection of vector heap (in bytes) and @emph{cons cells} (number)
@c respectively.  Suffix @samp{M} specifies megabytes or millions of cells
@c respectively.  The defaults are 6Mb and 350k respectively.
고급사용자들에게만 권장됩니다. 
바이트단위의 벡터 힙(vector heap)과 @emph{cons cells} (numbers)에 대한 가비지 컬렉션 (garbage collection)에 대한 초기 트리거 크기 (initial trigger sizes)를 설정합니다. 
접미사 @samp{M}은 메가바이트 (megabytes)또는 수백만개의 셀 (millions of cells)을 지정합니다.
기본값은 6Mb 와 350k 입니다. 


@item --max-ppsize=@var{N}
@c Specify the maximum size of the pointer protection stack as @var{N}
@c locations.  This defaults to 10000, but can be increased to allow
@c large and complicated calculations to be done.  Currently the maximum
@c value accepted is 100000.
@var{N}위치만큼 해당하는 포인터 프로텍션 스택(pointer protection stack)의 최대 크기를 지정합니다.
기본값은 10000이지만, 대규모의 복잡한 연산을 위하여 증가될 수 있습니다.
현재의 최대값은 100000입니다.

@item --max-mem-size=@var{N}
@c (Windows only) Specify a limit for the amount of memory to be used both
@c for @R{} objects and working areas.  This is set by default to the
@c smaller of the amount of physical RAM in the machine and for 32-bit
@c @R{}, 1.5Gb@footnote{2.5Gb on versions of Windows that support 3Gb per
@c process and have the support enabled: see the @file{rw-FAQ} Q2.9; 3.5Gb
@c on some 64-bit versions of Windows.}, and must be between 32Mb and the
@c maximum allowed on that version of Windows.
(Windows에만 해당합니다) @R{}객체들과 작업영역을 위해 사용되는 메모리의 양의 한계를 지정합니다.
기본적으로 이는 @R{} 32-비트를 기준으로 물리적인 RAM의 크기보다 작은 1.5Gb@footnote{프로세스당 3Gb를 지원하는 Windows에서는 2.5Gb이며, 이는 @file{rw-FAQ} Q2.9를 살펴보세요; 일부 64 비트의 Windows는 3.5Gb입니다}로 지정되어 있습니다. 
이는 반드시 32Mb와 Windows의 해당버전에서 허용하는 최고치 사이어야 합니다. 

@item --quiet
@itemx --silent
@itemx -q
@c Do not print out the initial copyright and welcome messages.
실행 초기에 보여지는 카피라이트(copyright)와 환영 메시지를 보여주지 않습니다.

@item --slave
@c Make @R{} run as quietly as possible.  This option is intended to
@c support programs which use @R{} to compute results for them.  It implies
@c @option{--quiet} and @option{--no-save}.
@R{}를 가능한 조용히 실행합니다.
이 옵션은 @R{}을 이용하여 연산을 수행하는 프로그램을 지원하기 위한 목적으로 존재합니다.
@option{--quiet}와 @option{--no-save}를 의미합니다.

@item --interactive
@c (UNIX only) Assert that @R{} really is being run interactively even if
@c input has been redirected: use if input is from a FIFO or pipe and fed
@c from an interactive program.  (The default is to deduce that @R{} is
@c being run interactively if and only if @file{stdin} is connected to a
@c terminal or @code{pty}.)  Using @option{-e}, @option{-f} or
@c @option{--file} asserts non-interactive use even if
@c @option{--interactive} is given.
(UNIX에서만 사용가능합니다) 입력의 방향이 설정되어 있을지라도 @R{}이 대화식으로 사용되도록 하게 합니다.
(기본적으로 @file{stdin}이 터미널(terminal) 또는 @code{pty}에 연결되어 있을 때 @R{}은 대화식으로 실행되도록 되어 있습니다).
만약 @option{--interactive}이 주어져 있을지라도, @option{-e}, @option{-f}, 또는  @option{--file}은 비대화식 모드로 사용하게 됩니다. 

@item --ess
@c (Windows only) Set @code{Rterm} up for use by @code{R-inferior-mode} in
@c @acronym{ESS}, including asserting interactive use without the
@c command-line editor.
(Windows만 가능합니다) 명령어를 이용한 에디터 사용없이 대화식으로 사용할 수 있는 기능을 포함하여 @acronym{ESS} 내에서 @code{R-inferior-mode}에 의해서 사용할 수 있도록 @code{Rterm}을 지정합니다. 

@item --verbose
@c Print more information about progress, and in particular set @R{}'s
@c option @code{verbose} to @code{TRUE}.  @R{} code uses this option to
@c control the printing of diagnostic messages.
진행과정에 대한 정보를 출력하고, 특히 @R{}의 옵션 @code{verbose}를 @code{TRUE}로 지정합니다.
@R{} 코드는 이 옵션을 이용하여 진단 메시지 (diagnostic message)의 출력을 조정하게 됩니다. 

@item --debugger=@var{name}
@itemx -d @var{name}
@c (UNIX only) Run @R{} through debugger @var{name}.  For most debuggers
@c (the exceptions are @command{valgrind} and recent versions of
@c @command{gdb}), further command line options are disregarded, and should
@c instead be given when starting the @R{} executable from inside the
@c debugger.
(UNIX에서만 이용이 가능합니다).
@var{name}이라는 이름의 디버거(debugger)를 통해 @R{}을 실행합니다.
@command{valgrind}와 최신버전의 @command{gdb}를 제외한 대부분의 디버거들에서, 추가적인 명령어 라인 옵션 (command line options)들이 무시되는 대신에 @R{}이 실행될 때 디버거 내에서 실행이 가능합니다. 


@item --gui=@var{type}
@itemx -g @var{type}
@c (UNIX only) Use @var{type} as graphical user interface (note that this
@c also includes interactive graphics).  Currently, possible values for
@c @var{type} are @samp{X11} (the default) and, provided that @samp{Tcl/Tk}
@c support is available, @samp{Tk}. (For back-compatibility, @samp{x11} and
@c @samp{tk} are accepted.)
(UNIX에서만 이용가능합니다) 그래픽 사용자 환경으로서 @var{type}을 이용합니다 (이것은 대화식 기능의 그래픽 또한 포함합니다).
현재 @var{type}에서 사용가능한 값들은 기본적으로 @samp{X11}이며, @samp{Tcl/Tk}가 지원된다는 가정하에 @samp{Tk}입니다. 
(back-compatibility를 위해서 @samp{x11}과 @samp{tk}도 사용될 수 있습니다).

@item --arch=@var{name}
@c (UNIX only) Run the specified sub-architecture.  Most commonly used on
@c Mac OS X, where the possible values are @samp{i386}, @samp{x86_64} and
@c @samp{ppc}.
(UNIX에서만 사용가능합니다)  지정된 서브 아키텍쳐 (sub-architecture)을 실행합니다.
@samp{i386}, @samp{x86_64}, @samp{ppc}을 가능한 값들로 가지는 Mac OS X에서 가장 일반적으로 사용됩니다. 

@item --args
@c This flag does nothing except cause the rest of the command line to be
@c skipped: this can be useful to retrieve values from it with
@c @code{commandArgs(TRUE)}.
이 플래그(flag)는 커맨드라인의 남은 부분을 건너뛰도록 유도하는 것을 제외하면 다른 기능은 없습니다. 
@code{commandArgs(TRUE)}와 함께 값을 검색 또는 다시 불러오는데 유용합니다. 
@end table

@c Note that input and output can be redirected in the usual way (using
@c @samp{<} and @samp{>}), but the line length limit of 4095 bytes still
@c applies.  Warning and error messages are sent to the error channel
@c (@code{stderr}).
@samp{<}와 @samp{>}를 이용하여 일반적인 방법으로 입력과 출력의 방향을 조절할 수 있으나, 라인의 길인에 대한 4095 바이트의 제한은 여전히 적용되게 됩니다. 
경고와 에러메시들이 에러 채널인 @code{stderr}로 보내어지게 됩니다. 

@c The command @code{R CMD} allows the invocation of various tools which
@c are useful in conjunction with @R{}, but not intended to be called
@c ``directly''.  The general form is
명령어 @code{R CMD}는 @R{}과 함께 사용될 수 있는 유용한 도구들을 실행시키도록 해줍니다.
그러나 이것은 직접적으로 실행시키기 보다는 다음과 같은 일반적인 형식을 가집니다. 

@example
R CMD @var{command} @var{args}
@end example

@noindent
@c where @var{command} is the name of the tool and @var{args} the arguments
@c passed on to it.
여기에서 @var{command}는 도구의 이름이고 @var{args}는 그 도구에 넘겨지게 될 입력인자들을 의미합니다. 

@c Currently, the following tools are available.
현재, 다음과 같은 도구들을 사용할 수 있습니다. 

@table @code
@item BATCH
@c Run @R{} in batch mode.  Runs @command{R --restore --save} with possibly
@c further options (see @code{?BATCH}).
@R{}을 배치모드(batch mode)에서 실행시킵니다.
@command{R --restore --save}와 추가적인 옵션들을 이용할 수 있습니다. 
(@code{?BATCH}를 참조하기 바랍니다).

@item COMPILE
@c (UNIX only) Compile C, C++, Fortran @dots{} files for use with @R{}.
(UNIX에서만 사용할 수 있습니다) @R{}과 함께 사용할 수 있는 C, C++, Fortran @dots{} 파일들을 컴파일합니다. 

@item SHLIB
@c Build shared library for dynamic loading.
다이나믹 로딩을 위하여 공유된 라이브러리 (shared library)를 빌드(build)합니다. 

@item INSTALL
@c Install add-on packages.
애드온(add-on) 패키지들을 설치합니다.

@item REMOVE
@c Remove add-on packages.
애드온(add-on) 패키지들을 제거합니다.

@item build
@c Build (that is, package) add-on packages.
애드온(add-on) 패키지들을 빌드(build)합니다.

@item check
@c Check add-on packages.
애드온(add-on) 패키지들을 체크(check)합니다.

@item LINK
@c (UNIX only) Front-end for creating executable programs.
(UNIX에서만 사용가능합니다) 실행가능한 프로그램을 생성하기 위하여 전처리 (front-end)입니다. 

@item Rprof
Post-process @R{} profiling files.

@item Rdconv
@itemx Rd2txt
@c Convert Rd format to various other formats, including @HTML{}, @LaTeX{},
@c plain text, and extracting the examples.  @code{Rd2txt} can be used as
@c shorthand for @code{Rd2conv -t txt}.
Rd 포맷을 @HTML{}, LaTex, 일반 텍스트, 그리고 예제들을 추출하는 등 다양한 포맷으로 전환합니다. 
@code{Rd2txt}는 @code{Rd2conv -t txt}의 약식 표기입니다.

@itemx Rd2pdf
@c Convert Rd format to PDF.
Rd 포맷을 PDF로 전환합니다.

@item Stangle
@c Extract S/R code from Sweave documentation
Sweave 문서로부터 S/R 코드를 추출합니다. 

@item Sweave
@c Process Sweave documentation
Sweave 문서를 프로세스 합니다.

@item Rdiff
Diff @R{} output ignoring headers etc

@item config
@c Obtain configuration information
환경설정에 대한 정보 (configuration information)을 가져옵니다.

@item javareconf
@c (Unix only) Update the Java configuration variables
(UNIX에서만 사용가능합니다) Java 설정 변수들을 업데이트 합니다. 

@item rtags
@c (Unix only) Create Emacs-style tag files from C, R, and Rd files
(UNIX에서만 사용가능합니다) C, R, 그리고 Rd 파일들로부터 이맥스 (Emacs)스타일의 태그 파일들을 생성합니다.

@item open
@c (Windows only) Open a file via Windows' file associations
(Windows에서만 사용가능합니다)  Windows의 파일연결(file association)을 이용하여 파일을 엽니다.

@item texify
@c (Windows only) Process (La)TeX files with R's style files
(Windows에서만 사용가능합니다)  R 스타일 파일을 사용하는 (La)TeX 파일들을 프로세싱합니다.
@end table

@c Use

@code{R CMD}를 통하여 사용이 가능한 도구들의 각각에 대한 사용방법을 알고 싶을 때는 다음과 같이 입력하세요. 
@example
R CMD @var{command} --help
@end example

@noindent
@c to obtain usage information for each of the tools accessible via the
@c @code{R CMD} interface.

@c In addition, you can use@footnote{as from @R{} 2.13.0.}  options
@c @option{--arch=}, @option{--no-environ}, @option{--no-init-file},
@c @option{--no-site-file} and @option{--vanilla} between @command{R} and
@c @command{CMD}: these affect any @R{} processes run by the tools.  (Here
@c @option{--vanilla} is equivalent to @option{--no-environ --no-site-file
@c --no-init-file}.)  However, note that @command{R CMD} does not of itself
@c use any @R{} startup files (in particular, neither user nor site
@c @file{Renviron} files), and all of the @R{} processes run by these tools
@c (except @command{BATCH}) use @option{--no-restore}.  Most use
@c @option{--vanilla} and so invoke no @R{} startup files: the current
@c exceptions are @command{INSTALL}, @command{REMOVE}, @command{Sweave} and
@c @command{SHLIB} (which uses @option{--no-site-file --no-init-file}).

추가적으로 도구들에 의해 실행되는 어떠한 @R{} 프로세스들에 영향을 미칠 수 있는 @option{--arch=}, @option{--no-environ}, @option{--no-init-file}, @option{--no-site-file} 그리고 @option{--vanilla} 옵션들을 @command{R}과 @command{CMD} 사이에 사용@footnote{@R{} 2.13.0부터}할 수 있습니다.  
(여기에서 @option{--vanilla}는 @option{--no-environ --no-site-file --no-init-file}과 동일합니다.)
그러나, @command{R CMD} 이 자체로는 어떠한 @R{} 스타드업 파일들을 사용하지 않는다는 것을 알고 계셔야 합니다 (특히, 사용자 또는 사이트 @file{Renviron} 파일 모두 이용하지 않습니다). 
그리고, @command{BATCH}를 제외한 이러한 도구들에 의해서 실행되는 @R{} 프로세스들의 모두는 @option{--no-restore}를 사용합니다. 
대부분은 @option{--vanilla}를 사용하고 @R{} 스타트업 파일들을 작동시키지 않습니다. 
현재 예외라고 할 수 있는 것들은 @command{INSTALL}, @command{REMOVE}, @command{Sweave} 그리고 (@option{--no-site-file --no-init-file}을 이용하고 있는) @command{SHLIB} 입니다. 


절대경로 (absolute filepath)에 의해서 주어진 또는 해당경로상에 있는 어떠한 다른 실행가능한 @command{@var{cmd}}을 사용하기 위해서는 아래와 같이 사용합니다. 
 
@example
R CMD @var{cmd} @var{args}
@end example

@noindent
@c for any other executable @command{@var{cmd}} on the path or given by an
@c absolute filepath: this is useful to have the same environment as @R{}
@c or the specific commands run under, for example to run @command{ldd} or
@c @command{pdflatex}.  Under Windows @var{cmd} can be an executable or a
@c batch file, or if it has extension @code{.sh} or @code{.pl} the
@c appropriate interpreter (if available) is called to run it.
이렇게 하는 것은 @R{} 또는 @command{ldd} 또는  @command{pdflatex}와 같은 어떤 특정한 명령어가 수행되어져야 하는 환경을 동일하게 해주는데 유용합니다.
Windows 상에서 @var{cmd}는 실행이 가능할 수도 있고 배치파일 (batch file)일수도 있으며, 만약 @code{.sh} 또는 @code{.pl}과 같은 확장자를 가진다면 적합한 인터프리터(interpreter)가 이들을 실행시키기 위해서 호출되어집니다.

@node Invoking R under Windows, Invoking R under Mac OS X, Invoking R from the command line, Invoking R
@c @appendixsec Invoking R under Windows
@appendixsec 윈도우즈에서 R을 사용하기 

@c There are two ways to run @R{} under Windows.  Within a terminal window
@c (e.g.@ @code{cmd.exe} or a more capable shell), the methods described in
@c the previous section may be used, invoking by @code{R.exe} or more
@c directly by @code{Rterm.exe}.  For interactive use, there is a
@c console-based GUI (@code{Rgui.exe}).
Windows에서 @R{}을 실행하는 방법은 두 가지가 있습니다. 
@code{cmd.exe} 또는 이보다 좀 더 많은 기능들을 가지고 있는 쉘과 같은 터미널을 보여주는 윈도우 내에서는 이전 섹션에서 설명한 방법들이 사용될 수 있는데, 이는 @code{R.exe} 또는 @code{Rterm.exe}를 실행하는 것입니다. 
대화식으로 사용하기 위해서는 콘솔기반의 그래픽 사용자 환경인 @code{Rgui.exe}가 있습니다. 

@c The startup procedure under Windows is very similar to that under
@c UNIX, but references to the `home directory' need to be clarified, as
@c this is not always defined on Windows.  If the environment variable
@c @env{R_USER} is defined, that gives the home directory.  Next, if the
@c environment variable @env{HOME} is defined, that gives the home
@c directory.  After those two user-controllable settings, @R{} tries to
@c find system defined home directories.  It first tries to use the
@c Windows "personal" directory (typically @code{C:\Documents and
@c Settings\username\My Documents} in Windows XP).  If that fails, and
@c environment variables @env{HOMEDRIVE} and @env{HOMEPATH} are defined
@c (and they normally are) these define the home directory.  Failing all
@c those, the home directory is taken to be the starting directory.

Windows 상에서 스타트업 방식은 UNIX와 유사하지만, 'home directory' (홈디렉토리)에 대한 참조는 Windows상에서 항상 정의되는 것이 아니기 때문에 좀 더 명확히 정해줘야 합니다.
환경변수(environment variable) @env{R_USER}을 정의하는 것은 홈디렉토리를 지정하는 것입니다.
또한, 환경변수 @env{HOME}을 정의하는 것 역시 홈디렉토리를 정하는 것입니다.
사용자가 조절할 수 있는 이 두 변수들이 설정되면, @R{}은 홈디렉토리를 지정하는 시스템을 찾으려고 합니다. 
제일먼저, Windows 개인 디렉토리 (일반적으로 Windows XP의 경우에는 @code{C:\Documents and Settings\username\My Documents}를 의미합니다)를 지정합니다.
실패시에는 환경변수 @env{HOMEDRIVE}와 @env{HOMEPATH}가 지정하는 홈디렉토리를 사용하게 됩니다. 
이 모든 과정이 실패할 경우에 홈디렉토리는 스타팅 디렉토리로 정해지게 됩니다. 

@c You need to ensure that either the environment variables @env{TMPDIR},
@c @env{TMP} and @env{TEMP} are either unset or one of them points to a
@c valid place to create temporary files and directories.

환경변수 @env{TMPDIR}, @env{TMP} 혹은 @env{TEMP}가 결정되지 않거나, 이 둘 중 하나가 일시적인 파일 혹은 디렉토리 생성을 위한 유효한 공간을 지정하게 끔 설정해야 합니다.

@c Environment variables can be supplied as @samp{@var{name}=@var{value}}
@c pairs on the command line.

환경변수들은 명령어 라인에서 @samp{@var{name}=@var{value}}와 같은 형식으로 제공됩니다.

@c If there is an argument ending @file{.RData} (in any case) it is
@c interpreted as the path to the workspace to be restored: it implies
@c @option{--restore} and sets the working directory to the parent of the
@c named file.  (This mechanism is used for drag-and-drop and file
@c association with @code{RGui.exe}, but also works for @code{Rterm.exe}.
@c If the named file does not exist it sets the working directory
@c if the parent directory exists.)
만약 어떠한 경우에라도 @file{.RData}로 끝나는 인자가 있다면, 이것은 불러오게 될 작업공간에 대한 경로로서 인식되어집니다.
이것은 @option{--restore}를 의미하는 것이고, 주어진 이름을 가진 파일의 상위디렉토리에 대한 작업 디렉토리를 지정하는 것이기 때문입니다.
(이러한 메카니즘은 드래그-앤-드랍(drag-and-drop)과 @code{RGui.exe}와 사용되는 파일연결(file association)을 위해 사용됩니다.  
그러나, 또한 @code{Rterm.exe}를 위해 사용되기도 합니다. 
만약 주어진 이름을 가진 파일이 존재하지 않는다면 이것은 작업디렉토리를 부모디렉토리가 있을경우에 지정하게 됩니다).

@c The following additional command-line options are available when
@c invoking @code{RGui.exe}.
@code{RGui.exe}를 작동시킬때 다음과 같은 추가적인 명령어 옵션들이 이용가능합니다. 

@table @option
@item --mdi
@itemx --sdi
@itemx --no-mdi
@c Control whether @code{Rgui} will operate as an MDI program 
@c (with multiple child windows within one main window) or an SDI application
@c (with multiple top-level windows for the console, graphics and pager).  The 
@c command-line setting overrides the setting in the user's @file{Rconsole} file.

@code{Rgui}가 하나의 주 윈도우 상에 여러 개의 작은 윈도우 창을 이용하는 MDI 프로그램 혹은 콘솔, 그래픽, 또는 페이저를 위한 다수의 최상의 윈도우들을 가진 SDI 어플리케이션으로 사용할 것인지를 조절합니다. 
명령어라인을 이용한 설정은 사용자의 @file{Rconsole} 파일에 있는 설정을 덮어쓰게 됩니다. 

@item --debug
@c Enable the ``Break to debugger'' menu item in @code{Rgui}, and trigger
@c a break to the debugger during command line processing.
@code{Rgui}내에서 ``Break to debugger''라는 메뉴 항목을 이용할 수 있게 해주고, 커맨드 라인이 프로세싱되는 동안 디버거에게 브레이크를 작동시켜줍니다. 
@end table

@c Under Windows with @code{R CMD} you may also specify your own
@c @file{.bat}, @file{.exe}, @file{.sh} or @file{.pl} file.  It will be run
@c under the appropriate interpreter (Perl for @file{.pl}) with several
@c environment variables set appropriately, including @env{R_HOME},
@c @env{R_OSTYPE}, @env{PATH}, @env{BSTINPUTS} and @env{TEXINPUTS}.  For
@c example, if you already have @file{latex.exe} on your path, then
Windows에서 @code{R CMD}를 이용할 때 당신이 소유한  @file{.bat}, @file{.exe}, @file{.sh} 또는 @file{.pl} 파일들 또한 지정할 수 있습니다. 
이것은 적합한 인터프리터 (즉, @file{.pl}파일은 Perl을 이용합니다)와 @env{R_HOME}, @env{R_OSTYPE}, @env{PATH}, @env{BSTINPUTS}, 그리고 @env{TEXINPUTS}를 포함하여 올바르게 지정된 여러가지의 환경변수들과 함께 실행될 것입니다. 
예를들면, 당신의 경로에 @file{latex.exe}파일을 이미 가지고 있다면 아래와 같이 방법으로 @env{TEXINPUTS}에 추가되어 있는 @R{}의 @file{share/texmf} 매크로를 이용하여 @file{mydoc.tex}에 대해서 @LaTeX{}를  실행시킬 수 있습니다. 

@example
R CMD latex.exe mydoc
@end example
@noindent
@c will run @LaTeX{} on @file{mydoc.tex}, with the path to @R{}'s
@c @file{share/texmf} macros appended to @env{TEXINPUTS}.  (Unfortunately,
@c this does not help with the MiKTeX build of @LaTeX{}, but
@c @command{R CMD texify mydoc} will work in that case.)
(안타깝게도, MiKTex @LaTeX{}에서는 적용되지 않습니다. 
그러나, @command{R CMD texify mydoc}은 작동할 것입니다.)

@node Invoking R under Mac OS X, Scripting with R, Invoking R under Windows, Invoking R
@appendixsec Invoking R under Mac OS X

@c There are two ways to run @R{} under Mac OS X.  Within a @code{Terminal.app}
@c window by invoking @code{R}, the methods described in the first
@c subsection apply.  There is also console-based GUI (@code{R.app}) that by
@c default is installed in the @code{Applications} folder on your
@c system.  It is a standard double-clickable Mac OS X application.

Mac OS X 상에서 @R{}을 실행하는 방법에는 두가지가 있습니다.
첫 번째 서브섹션에서 설명된 방법처럼 @code{Terminal.app} 창을 이용하여 @code{R}을 작동하는 것입니다. 
또 다른 방법은 당신의 시스템에 있는 @code{Applications} 폴더에 기본적으로 설치된 콘솔기반의 GUI (@code{R.app})을 이용하는것입니다. 
이것은 더블클릭이 가능한 Mac OS X 응용프로그램입니다.

@c The startup procedure under Mac OS X is very similar to that under UNIX.
@c The `home directory' is the one inside the R.framework, but the startup
@c and current working directory are set as the user's home directory
@c unless a different startup directory is given in the Preferences window
@c accessible from within the GUI.

Mac OS X에 있는 스타트업 프로시져는 유닉스의 것과 유사합니다.
`home directory' 는 R.framework 내부에 있지만, GUI내로부터 접근이 가능한 Preference 창에 있는 스타트업 디렉토이와 다르지 않다면 스타트업과 현재 작업디렉토리는 사용자의 홈디렉토리와 같이 지정됩니다. 


@node Scripting with R,  , Invoking R under Mac OS X, Invoking R
@c @appendixsec Scripting with R
@appendixsec R 스크립트 작성하기

@c If you just want to run a file @file{foo.R} of @R{} commands, the
@c recommended way is to use @command{R CMD BATCH foo.R}.  If you want to
@c run this in the background or as a batch job use OS-specific facilities
@c to do so: for example in most shells on Unix-alike OSes @command{R CMD
@c BATCH foo.R &} runs a background job.

만약에 @R{} 명령어들로 이루어진 @file{foo.R}라는 파일을 실행시키고자 한다면,
@command{R CMD BATCH foo.R}를 사용하길 권장합니다. 
만약 당신이 이를 일괄처리 (batch job) 작업으로서 또는 후순위 작업 (background job, 백그라운드 작업)를 하고자 한다면,
당신의 운영체제에 맞는 기능을 사용하길 바랍니다. 
예를들면, 유닉스와 같은 운영체제들은 쉘상에서 @command{R CMD BATCH foo.R&}라고 입력하게 되면 후순위작업 (background job)이 실행되게 됩니다. 

@c You can pass parameters to scripts via additional arguments on the
@c command line: for example (where the exact quoting needed will depend on
@c the shell in use)

명령어 라인을 사용할때 추가적인 인자들을 이용하여 스크립트에 파미미터 (또는 입력해야 할 인자들)에 값을 넣어줄 수 있습니다.
예를들면 (어떤 쉘을 이용하는가에 따라 다르지만, 아래와 같이 큰 따옴표의 사용이 필요합니다).

@example
R CMD BATCH "--args arg1 arg2" foo.R &
@end example

@noindent
@c will pass arguments to a script which can be retrieved as a character
@c vector by

위에서 사용된 명령어 라인은 아래와 같은 방법으로 다시 확인할 수 있는 문자형 벡터로서 스크립트에 인자들을 넘겨줄 수 있습니다. 

@example
args <- commandArgs(TRUE)
@end example

@c This is made simpler by the alternative front-end @command{Rscript},
@c which can be invoked by

이렇게 하는 것은 사용자가 직접 아래와 같이 @command{Rscript}에 인자들을 전달할 수 있는 더 간단한 방법입니다. 

@example
Rscript foo.R arg1 arg2
@end example

@noindent
@c and this can also be used to write executable script files like (at
@c least on Unix-alikes, and in some Windows shells)

그리고 이렇게 하는 것은 (적어도 유닉스와 같은 환경 및 일부 Windows의 쉘상에서) 실행가능한 스크립트를 작성하는데 사용될 수 있습니다.  
예를들면, 아래와 같습니다. 

@example
#! /path/to/Rscript
args <- commandArgs(TRUE)
...
q(status=<exit status code>)
@end example

@noindent
@c If this is entered into a text file @file{runfoo} and this is made
@c executable (by @command{chmod 755 runfoo}), it can be invoked for
@c different arguments by

만약에 @file{runfoo}라는 텍스트 파일에 입력하고, 이것을 @command{chmod 755 runfoo}라는 명령어를 이용하여 실행가능하게 만들어 준다면, 아래와 같이 실행도 가능합니다. 

@example
runfoo arg1 arg2
@end example

@noindent
@c For further options see @command{help("Rscript")}.  This writes @R{}
@c output to @file{stdout} and @file{stderr}, and this can be redirected in
@c the usual way for the shell running the command.

더 많은 옵션들을 알아보고 싶으시다면 @command{help("Rscript")}를 살펴보시길 바랍니다.
이것은 @R{}의 결과물을 @file{stdout}과 @file{stderr}에 작성합니다.
그리고 이것은 명령어를 실행시키는 쉘상에서 일반적인 방법으로 다른 방향으로 전환이 가능합니다. 

@c If you do not wish to hardcode the path to @command{Rscript} but have it
@c in your path (which is normally the case for an installed @R{} except on
@c Windows, but e.g.@: Mac OS X users may need to add @file{/usr/local/bin}
@c to their path), use

만약 당신이 @command{Rscript}에 경로를 쉽게 변경하고자 하면, 이를 아래와 같이 경로를 적어두어야 합니다.
(Windows를 제외한 경우 설치된 @R{}의 일반적인 경우이지만 @: Mac OS X 사용자들은 아마도 @file{/usr/local/bin} 이라고 할 수도 있습니다).

@example
#! /usr/bin/env Rscript
...
@end example

@noindent
@c At least in Bourne and bash shells, the @code{#!} mechanism does
@c @strong{not} allow extra arguments like 
@c @code{#! /usr/bin/env Rscript --vanilla}.

본(Bourne)과 bash(배쉬) 쉘상에서는 @code{#!} 메카니즘은 @code{#! /usr/bin/env Rscript --vanilla}와 같은 추가적인 인자의 사용을 허용하지 않습니다. 

@c One thing to consider is what @code{stdin()} refers to.  It is
@c commonplace to write @R{} scripts with segments like
한 가지 고려해야 할 점은 @code{stdin()}이 무엇을 의미하는지 알아야 합니다.
@R{} 스크립트를 아래와 같이 작성하는 것은 매우 흔한일입니다.

@example
chem <- scan(n=24)
2.90 3.10 3.40 3.40 3.70 3.70 2.80 2.50 2.40 2.40 2.70 2.20
5.28 3.37 3.03 3.03 28.95 3.77 3.40 2.20 3.50 3.60 3.70 3.70
@end example

@noindent
@c and @code{stdin()} refers to the script file to allow such traditional
@c usage.  If you want to refer to the process's @file{stdin}, use
@c @code{"stdin"} as a @code{file} connection, e.g.@: @code{scan("stdin", ...)}.

여기에서 @code{stdin()}이란 기존의 사용방법을 허용하는 스크립트 파일 자체를 의미합니다. 
프로세스의 @file{stdin}을 참조하고 싶다면, @code{"stdin"}을 @code{file} 커넥션과 같이 사용하시면 됩니다. 
즉, @: @code{scan("stdin", ...)}.

@c Another way to write executable script files (suggested by Fran@,{c}ois
@c Pinard) is to use a @emph{here document} like
또다른 방법으로 실행가능한 스크립트 파일들을 만드는 방법들은 (Fran@,{c}ois Pinard에 의해 제안된) @emph{이곳의 문서}와 같이 사용하는 것입니다. 

@example
#!/bin/sh
[environment variables can be set here]
R --slave [other options] <<EOF

   R program goes here...

EOF
@end example

@noindent
@c but here @code{stdin()} refers to the program source and
@c @code{"stdin"} will not be usable.
그러나, 여기에서 @code{stdin()}은 프로그램 소스를 가리키며 @code{"stdin"}은 사용가능하지 않을 것입니다. 

@c Very short scripts can be passed to @command{Rscript} on the
@c command-line via the @option{-e} flag.

매우 짧은 길이의 스크립트는 @option{-e} 플래그를 이용하여 @command{Rscript}에 보낼 수도 있습니다. 

@c Note that on a Unix-alike the input filename (such as @file{foo.R})
@c should not contain spaces nor shell metacharacters.

유닉스와 같은 환경에서 @file{foo.R}와 같은 입력파일명은 반드시 공간을 포함해서도 안되며, 쉘의 메타문자 역시 포함해서는 안됩니다. 


@node The command-line editor, Function and variable index, Invoking R, Top
@c @appendix The command-line editor
@appendix 명령어 기반의 에디터

@appendixsection Preliminaries

@c When the @acronym{GNU} @strong{readline} library is available at the
@c time @R{} is configured for compilation under UNIX, an inbuilt command
@c line editor allowing recall, editing and re-submission of prior commands
@c is used.  Note that other versions of @strong{readline} exist and may be
@c used by the inbuilt command line editor: this used to happen on Mac OS X.
UNIX 상에서 컴파일을 위하여 @R{}의 환경설정을 할때 @acronym{GNU} @strong{readline} 라이브러리가 사용가능 할 때, 이전 명령어들의 기억기능(recall), 편집(editing), 그리고 재입력(resubmission) 기능을 허용하는 내재된 커맨드기반의 에디터가 이용됩니다. 
다른 버전의 @strong{readline}이 존재 할 수 있고, 이들이 내재된 커맨드 기반의 명령어에 의해서 사용될 수도 있습니다.
보통 Mac OS X에서 이러합니다 

@c It can be disabled (useful for usage with @acronym{ESS} @footnote{The
@c `Emacs Speaks Statistics' package; see the @acronym{URL}
@c @uref{http://ESS.R-project.org}}) using the startup option
@c @option{--no-readline}.
스타트업 옵션 @option{--no-readline}을 이용하여 사용되지 않도록 할 수도 있습니다.
(이렇게 하는 것은 @acronym{ESS}@footnote{`Emacs Speaks Statistics'패키지를 말하며, @acronym{URL} @uref{http://ESS.R-project.org}를 살펴보시길 바랍니다}를 사용할 때 유용합니다).

@c Windows versions of @R{} have somewhat simpler command-line editing: see
@c @samp{Console} under the @samp{Help} menu of the @acronym{GUI}, and the
@c file @file{README.Rterm} for command-line editing under
@c @code{Rterm.exe}.
Windows 버전에서 @R{}은 다소 간단한 형식의 커맨드라인 편집기능을 가지고 있습니다.
@acronym{GUI}에서 @samp{Help} 메뉴에 있는 @samp{Console}을 살펴보시고, @code{Rterm.exe}내에 있는 커맨드라인을 위한 파일 @file{README.Rterm}을 살펴보시길 바랍니다. 

@c When using @R{} with @strong{readline} capabilities, the functions
@c described below are available, as well as others (probably) documented
@c in @command{man readline} or @command{info readline} on your system.
@strong{readline}의 기능과 함께 @R{}을 사용할 때, (아마도) 당신의 시스템에 있는 @command{man readline} 또는 @command{info readline}에 기술되어 있는 함수들과 아래에 기술된 함수들을 이용할 수 있습니다.

@c Many of these use either Control or Meta characters.  Control
@c characters, such as @kbd{Control-m}, are obtained by holding the
@c @key{CTRL} down while you press the @key{m} key, and are written as
@c @kbd{C-m} below.  Meta characters, such as @kbd{Meta-b}, are typed by
@c holding down @key{META}@footnote{On a PC keyboard this is usually the
@c Alt key, occasionally the `Windows' key.  On a Mac keyboard normally no
@c meta key is available.} and pressing @key{b}, and written as @kbd{M-b}
@c in the following.  If your terminal does not have a @key{META} key
@c enabled, you can still type Meta characters using two-character
@c sequences starting with @kbd{ESC}.  Thus, to enter @kbd{M-b}, you could
@c type @key{ESC}@key{b}.  The @kbd{ESC} character sequences are also
@c allowed on terminals with real Meta keys.  Note that case is significant
@c for Meta characters.
이들중의 많은 것들이 컨트롤 (Control)과 메타(Meta) 문자들을 사용합니다.
@kbd{Control-m}과 같은 형식으로 컨트롤 문자들은 @key{CTRL}키를 누른 상태에서 @key{m}키를 누르는 것입니다.
그리고 이것을 @kbd{C-m}이라고 표시합니다.
@kbd{Meta-b}와 같이 메타문자들은 @key{META}@footnote{PC 키보드에서는 이것은 일반적으로 Alt 키이거나 가끔 `Windows'키이기도 합니다. Mac 키보드에서는 일반적으로 사용가능한 메타키가 없습니다}를 누른 상태에서 @key{b}를 누르는 것이며, 이는 @kbd{M-b}라고 씁니다.
만약에 당신의 터미널이 활성화된 @key{META}키를 가지고 있지 않다면, 당신은 @kbd{ESC}를 사용하여 메타문자들을 입력할 수 있습니다.
그러므로, @kbd{M-b}를 입력하기 위해서는, 당신은 @key{ESC}@key{b}라고 입력합니다.
다음은 중요한 메타 문자들을 정리한 것입니다. 

@c @appendixsection Editing actions
@appendixsection 편집하기 

@c The @R{} program keeps a history of the command lines you type,
@c including the erroneous lines, and commands in your history may be
@c recalled, changed if necessary, and re-submitted as new commands.  In
@c Emacs-style command-line editing any straight typing you do while in
@c this editing phase causes the characters to be inserted in the command
@c you are editing, displacing any characters to the right of the cursor.
@c In @emph{vi} mode character insertion mode is started by @kbd{M-i} or
@c @kbd{M-a}, characters are typed and insertion mode is finished by typing
@c a further @key{ESC}.  (The default is Emacs-style, and only that is
@c described here: for @emph{vi} mode see the @strong{readline}
@c documentation.)

@R{} 프로그램은 당신이 입력한 명령어 라인들에 대한 기록을 보관합니다. 
이때 잘못 입력한 명령어도 보관이 되며, 기록상에 보관된 명령어들은 다시 불러올 수 있고, 필요하다면 변경하여, 새로운 명령어처럼 다시 사용될 수 있습니다. 
이맥스 스타일(Emacs-style)의 명령어라인 편집환경에서는 당신이 입력하는 것들이 편집하는 명령어 속에 삽입되거나, 커서의 오른쪽에 있는 문자들을 변경하하기도 합니다. 
@emph{vi} 모드에서는 @key{ESC}를 입력함으로서 문자가 입력되거나 삽입모드를 종료할 수 있습니다. 
(기본적으로는 이맥스 스타일이 사용되며, @emph{vi} 모드에 대해서는 @strong{readline} 문서를 확인하시길 바랍니다).

@c Pressing the @key{RET} command at any time causes the command to be
@c re-submitted.
어떤 상황이던지 간에 @key{RET}키를 누르는 것은 명령어를 실행하도록 전달하는 것과 같습니다. 

@c Other editing actions are summarized in the following table.
다른 편집 기능들은 아래의 표에 정리되어 있습니다. 

@c @appendixsection Command-line editor summary
@appendixsection 커맨드라인 에디터에 대한 요약 

@c @subheading Command recall and vertical motion
@subheading 커서의 상하이동을 통하여 명령어를 되부르기

@table @kbd
@item C-p
@c Go to the previous command (backwards in the history).
이전에 사용한 명령어로 이동합니다 (히스토리 상에서 한 단계 뒤로 이동하는 것입니다).

@item C-n
@c Go to the next command (forwards in the history).
다음 명령어로 이동합니다 (히스토리상에서 한 단계 다음으로 이동하는 것입니다).

@item C-r @var{text}
@c Find the last command with the @var{text} string in it.
@var{text}를 포함하는 마지막 명령어를 찾습니다. 
@end table

@c On most terminals, you can also use the up and down arrow keys instead
@c of @kbd{C-p} and @kbd{C-n}, respectively.
대부분의 터미널에서 @kbd{C-p}와 @kbd{C-n}를 이용하는 대신에 당신은 위쪽 또는 아래쪽 방향의 화살표를 이용하여 이를 이용할 수 있습니다. 

@c @subheading Horizontal motion of the cursor
@subheading 커서를 좌우로 이동하여 할 수 있는 명령어들

@table @kbd
@item C-a
@c Go to the beginning of the command.
명령어의 가장 처음으로 이동합니다. 

@item C-e
@c Go to the end of the line.
라인의 끝으로 이동합니다. 

@item M-b
@c Go back one word.
한 단어 뒤로 이동합니다. 

@item M-f
@c Go forward one word.
한 단어 앞으로 이동합니다. 

@item C-b
@c Go back one character.
한 문자 뒤로 이동합니다. 

@item C-f
@c Go forward one character.
한 문자 앞으로 이동합니다. 
@end table

@c On most terminals, you can also use the left and right arrow keys
@c instead of @kbd{C-b} and @kbd{C-f}, respectively.
대부분의 터미널에서는 당신은 @kbd{C-b}와 @kbd{C-f}를 이용하는 대신에 좌측 또는 우측 화살표를 이용할 수 있습니다. 

@c @subheading Editing and re-submission
@subheading 편집 후 재실행하기 

@table @kbd
@item @var{text}
@c Insert @var{text} at the cursor.
커서의 위치에 @var{text} 삽입합니다.

@item C-f @var{text}
@c Append @var{text} after the cursor.
커서의 위치 다음부분 부터 @var{text}를 추가합니다.

@item @key{DEL}
@c Delete the previous character (left of the cursor).
커서의 왼쪽에 위한 문자를 삭제합니다. 

@item C-d
@c Delete the character under the cursor.
커서의 바로 아래 있는 문자를 삭제합니다. 

@item M-d
@c Delete the rest of the word under the cursor, and ``save'' it.
커서의 아래에 있는 위치하는 문자 이후의 모든 것을 삭제하고 ``저장'' 합니다. 

@item C-k
@c Delete from cursor to end of command, and ``save'' it.
커서의 위치로부터 명령어의 끝 부분까지 삭제한 뒤, ``저장'' 합니다. 

@item C-y
@c Insert (yank) the last ``saved'' text here.
마지막으로 저장된 텍스트를 이곳에 삽입니다. 

@item C-t
@c Transpose the character under the cursor with the next.
다음 문자를 커서 아래에 있는 문자와 전치합니다. 

@item M-l
@c Change the rest of the word to lower case.
단어의 남겨진 부분들을 소문자로 변경합니다. 

@item M-c
@c Change the rest of the word to upper case.
단어의 남겨진 부분들을 대문자로 변경합니다. 

@item @key{RET}
@c Re-submit the command to @R{}.
@R{}에 명령어를 다시 전달합니다.
@end table

@c The final @key{RET} terminates the command line editing sequence.
마지막 @key{RET} 키는 명령어 라인의 편집 시퀀스를 종료하는 것입니다.

@c The @strong{readline} key bindings can be customized in the usual way
@c @emph{via} a @file{~/.inputrc} file.  As from @R{} 2.12.0, these
@c customizations can be conditioned on application @code{R}, that is
@c by including a section like
@strong{Readline} 키바인딩 (key binding)은  @file{~/.inputrc} 파일을 @emph{통해서} 일반적인 방법으로 조정될 수 있습니다. 
@R{} 2.12.0 부터는 이러한 개인설정 (customization)은 @code{R}에 따라 조건적일 수 있습니다. 

@example
$if R
  "\C-xd": "q('no')\n"
$endif
@end example

@node Function and variable index, Concept index, The command-line editor, Top
@appendix Function and variable index

@printindex vr

@node Concept index, References, Function and variable index, Top
@c @appendix Concept index
@appendix 주요 개념 인덱스 

@printindex cp

@node References,  , Concept index, Top
@c @appendix References
@appendix 참고문헌 

D.@: M.@: Bates and  D.@: G.@: Watts (1988), @emph{Nonlinear Regression
Analysis and Its Applications.} John Wiley & Sons, New York.

@noindent
Richard A.@: Becker, John M.@: Chambers and Allan R.@: Wilks (1988),
@emph{The New S Language.} Chapman & Hall, New York.
This book is often called the ``@emph{Blue Book}''.

@noindent
John M.@: Chambers and Trevor J.@: Hastie eds. (1992),
@emph{Statistical Models in S.} Chapman & Hall, New York.
This is also called the ``@emph{White Book}''.

@noindent
John M.@: Chambers (1998)
@emph{Programming with Data}. Springer, New York.
This is also called the ``@emph{Green Book}''.

@noindent
A.@: C.@: Davison and D.@: V.@: Hinkley (1997), @emph{Bootstrap Methods
and Their Applications}, Cambridge University Press.

@noindent
Annette J.@: Dobson (1990), @emph{An Introduction to Generalized Linear
Models}, Chapman and Hall, London.

@noindent
Peter McCullagh and John A.@: Nelder (1989), @emph{Generalized Linear
Models.} Second edition, Chapman and Hall, London.

@noindent
John A.@ Rice (1995), @emph{Mathematical Statistics and Data Analysis.}
Second edition.  Duxbury Press, Belmont, CA.

@noindent
S.@: D.@: Silvey (1970), @emph{Statistical Inference.} Penguin, London.

@bye
