;; This buffer is for notes you don't want to save, and for Lisp evaluation.
;; If you want to create a file, visit that file with C-x C-f,
;; then enter the text in that file's own buffer.

ststitical computing, data mining, machine lernings in R

운영체제가 Unix가 아니라면 특히 윈도우의 경우 먼저 윈도우 환경에 대한 정보를 필요로 합니다. 
이러한 정보는 최소한 특정 파일의 경로에 접근하는데에도 사용될 것이기 때문입니다.

.Platform
do.call(rbind, .Platform)

두 가지 코드를 실행하고 난 출력 결과를 비교해 보시기 바랍니다.

          [,1]    
OS.type    "unix"  
file.sep   "/"     
dynlib.ext ".so"   
GUI        "X11"   
endian     "little"
pkgType    "source"
path.sep   ":"     
r_arch     ""      

패키지 설치 종류

이름 출처 개발자명 설명
arm
ggplot2
glmnet
igraph
lme4
lubridate
RCurl
reshape
RJSONIO
tm
XML

본 문서에서 사용된 ufo_awesome.tsv 파일을 획득하기 위해서는 아래의 링크를 참고하사기 바랍니다.

http://www.infochimps.com/datasets/60000-documented-ufo-sightings-with-text-descriptions-and-metada

이 외에도 다양한 데이터가 많이 공객되어 있습니다.

http://thedatahub.kr/


> ufo <- read.delim("ufo_awesome.tsv", sep="\t", stringsAsFactors=FALSE, header=FALSE, na.strings="")
> str(ufo)
'data.frame':   61870 obs. of  6 variables:
 $ V1: chr  "19951009" "19951010" "19950101" "19950510" ...
 $ V2: chr  "19951009" "19951011" "19950103" "19950510" ...
 $ V3: chr  " Iowa City, IA" " Milwaukee, WI" " Shelton, WA" " Columbia, MO" ...
 $ V4: chr  NA NA NA NA ...
 $ V5: chr  NA "2 min." NA "2 min." ...
 $ V6: chr  "Man repts. witnessing &quot;flash, followed by a classic UFO, w/ a tailfin at back.&quot

# 인자(또는 인수) stringsAsFacors의 default는 TRUE 입니다.
 
> ufo1 <- read.delim("ufo_awesome.tsv", sep="\t", header=FALSE, na.strings="")

> str(ufo1)
'data.frame':   61870 obs. of  6 variables:
 $ DateOccurred    : Factor w/ 9608 levels "-0.4","-1.6",..: 4015 4016 3747 3869 3900 4031 3852 3988 3761 3992 ...
 $ DateReported    : Factor w/ 5567 levels "- thank you for reading",..: 304 306 63 176 207 315 161 276 101 280 ...
 $ Location        : Factor w/ 22120 levels "-1.2","-1.4",..: 9212 12592 17908 4170 17680 2543 6282 10654 12971 16343 ...
 $ ShortDescription: Factor w/ 192 levels " ","      445",..: NA NA NA NA NA NA NA NA NA NA ...
 $ Duration        : Factor w/ 9637 levels "-","--","-------------------------",..: NA 2967 NA 2967 NA 4443 2967 NA NA 6116 ...
 $ LongDescription : Factor w/ 61470 levels "-----Mensagem Original----- De: Flavio Mori Para: felicio-sp Enviada em: domingo,

# > ufo1 <- read.delim(file="C:\\Users\\Eugene\\Documents\\testdatasets\\
# ufo_awesome.tsv", sep="\t", header=FALSE, na.strings="", stringsAsFactors=FALSE)

read.delim에 대한 도움말은 

> ?read.delim
> ??read.delim

으로 찾을 수 있습니다.

획득한 데이터를 읽어들이는데에는 다음의 링크를 참고하시기 바랍니다.
http://127.0.0.1:19602/library/utils/html/read.table.html

> head(ufo); tail(ufo)

데이터셋에 변수명이 없으므로 다음과 같은 명령어를 이용합니다.

> names(ufo)<-c("DateOccurred","DateReported","Location","ShortDescription",
+ "Duration","LongDescription")

날짜의 경우 다른 프로그램과 마찬가지로 특별한 유형으로 저장해 놓는 것이 좋습니다.

> ufo$DateOccurred <- as.Date(ufo$DateOccurred, format="%Y%m%d")
> ufo$DateReported <- as.Date(ufo$DateReported, format="%Y%m%d")

위와 같은 명령어는 일반적으로 사용되고 있으나 이 경우에는 다음과 같은 에러가 나타날 것입니다.

"다음에 오류가 있습니다strptime(x, format, tz = "GMT") : 입력문자열이 너무 깁니다."

head() 이용하여 파악한 결과 DateOccurred는 8자리 YYYYMMDD의 형태를 가지고 있습니다.
DateOccurred와 DateReported에서 문자열이 몇 자리인지 그리고 이들이 어디에 위치하는지를 알고 싶을 것입니다. 왜냐하면 8자리가 아니어서 "입력문자열이 너무 깁니다."라는 에러 메세지가 나타났기 때문입니다. 

> good.rows <- ifelse(nchar(ufo$DateOccurred)>=8 & nchar(ufo$DateOccurred)!= 8 | nchar(ufo$DateReported)!=8,FALSE,TRUE)
> length(which(!good.rows))
[1] 454
> ufo <- ufo[good.rows,]

## ifelse(): http://127.0.0.1:25210/library/base/html/ifelse.html
Usage: ifelse(test, yes, no)
기본적 설명: ifelse 함수의 test 인자는 논리벡터나 논리벡터로 강제 변환될 수 있는 표현식을 사용하고 yes 인자와 no 인자는 벡터나 연산의 결과가 벡터인 표현식을 사용합니다. ifelse 함수는 test 인자의 결과가 같은 길이의 벡터를 반환합니다. 반환하는 값은 논리벡터에서 원소의 값이 TRUE이면 yes 벡터에서 같은 인덱스(위치)를 갖는 값을, FALSE이면 no 벡터에서 같은 인테스를 갖는 값을 반환합니다.

## nchar(): http://127.0.0.1:25210/library/base/html/nchar.html
기본적 설명: 문자벡터의 각 원소가 몇 개의 문자열로 구성되어 있는지 알 수 있습니다. 이것은 다른 의미로 문자벡터의 원소가 non-empty strings인지를 발견해 내는데 가장 빠른 방법을 제공하는 것입니다.

## which(): http://127.0.0.1:25210/library/base/html/which.html
기본적 설명: 특정 조건을 만족하는 원소의 index를 구할 수 있습니다.

== location 데이터 다루기 ==

location 데이터를 다루기 위해 다음과 같이 get.location() 함수를 스스로 만들어 봅니다.

get.location<-function(l) {
	split.location<-tryCatch(strsplit(l,",")[[1]], error= function(e) return(c(NA, NA)))
	clean.location<-gsub("^ ","",split.location)
	if (length(clean.location)>2) {
		return(c(NA,NA))
	}
	else {
		return(clean.location)
	}
}

## strsplit(): http://127.0.0.1:25210/library/base/html/strsplit.html
기본적 설명: 문자 벡터의 요소를 특정 조건에 맞추어 분할합니다.


## tryCatch(): http://127.0.0.1:25210/library/base/html/conditions.html
기본적 설명: 예외처리 구문으로서 예기치 않은 오류가 발생하였을 때, 프로그램이 강제 종료되지 않고 안정하게 종료시킬 수 있습니다.


