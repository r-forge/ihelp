statistical computing, data mining, machine learning in R

운영체제가 Unix가 아니라면 특히 윈도우의 경우 먼저 윈도우 환경에 대한 정보를 필요로 합니다. 
이러한 정보는 최소한 특정 파일의 경로에 접근하는데에도 사용될 것이기 때문입니다.

> .Platform
> do.call(rbind, .Platform)

두 가지 코드를 실행하고 난 출력 결과를 비교해 보시기 바랍니다.

## do.call(): 
## Usage:
## do.call(what, args, quote = FALSE, envir = parent.frame())
## 기본적 설명: 

이 문서에서 필요한 패키지들은 아래와 같습니다. 먼저 패키지들을 설치해 주시기 바랍니다.

이름 출처 개발자명 설명
arm
ggplot2
glmnet
igraph
lme4
lubridate
RCurl
reshape
RJSONIO
tm
XML

본 문서에서 사용된 ufo_awesome.tsv 파일을 획득하기 위해서는 아래의 링크를 참고하사기 바랍니다.

http://www.infochimps.com/datasets/60000-documented-ufo-sightings-with-text-descriptions-and-metada

이 외에도 다양한 데이터가 많이 공객되어 있습니다.

http://thedatahub.kr/

> ufo <- read.delim("ufo_awesome.tsv", sep="\t", stringsAsFactors=FALSE, header=FALSE, na.strings="")
> str(ufo)
'data.frame':   61870 obs. of  6 variables:
 $ V1: chr  "19951009" "19951010" "19950101" "19950510" ...
 $ V2: chr  "19951009" "19951011" "19950103" "19950510" ...
 $ V3: chr  " Iowa City, IA" " Milwaukee, WI" " Shelton, WA" " Columbia, MO" ...
 $ V4: chr  NA NA NA NA ...
 $ V5: chr  NA "2 min." NA "2 min." ...
 $ V6: chr  "Man repts. witnessing &quot;flash, followed by a classic UFO, w/ a tailfin at back.&quot

stringsAsFacors 인자의 기본값은 TRUE 입니다.
 
> ufo1 <- read.delim("ufo_awesome.tsv", sep="\t", header=FALSE, na.strings="")

> str(ufo1)
'data.frame':   61870 obs. of  6 variables:
 $ DateOccurred    : Factor w/ 9608 levels "-0.4","-1.6",..: 4015 4016 3747 3869 3900 4031 3852 3988 3761 3992 ...
 $ DateReported    : Factor w/ 5567 levels "- thank you for reading",..: 304 306 63 176 207 315 161 276 101 280 ...
 $ Location        : Factor w/ 22120 levels "-1.2","-1.4",..: 9212 12592 17908 4170 17680 2543 6282 10654 12971 16343 ...
 $ ShortDescription: Factor w/ 192 levels " ","      445",..: NA NA NA NA NA NA NA NA NA NA ...
 $ Duration        : Factor w/ 9637 levels "-","--","-------------------------",..: NA 2967 NA 2967 NA 4443 2967 NA NA 6116 ...
 $ LongDescription : Factor w/ 61470 levels "-----Mensagem Original----- De: Flavio Mori Para: felicio-sp Enviada em: domingo,

> ufo2 <- read.delim(file="C:\\Users\\Eugene\\Documents\\testdatasets\\ufo_awesome.tsv", 
+ sep="\t", header=FALSE, na.strings="", stringsAsFactors=FALSE)

read.delim에 대한 도움말은 

> ?read.delim
> ??read.delim

으로 찾을 수 있습니다.

불러들여온 데이터의 개략적인 형태를 확인하기 위해 head()와 tail() 함수를 이용해 봅니다.

> head(ufo); tail(ufo)

확인해 보니 데이터셋에 변수명이 없습니다. 데이터세트에 변수명을 부여하기 위해 다음과 같은 명령어를 이용합니다.

> names(ufo)<-c("DateOccurred","DateReported","Location","ShortDescription",
+ "Duration","LongDescription")

날짜의 경우 다른 프로그램과 마찬가지로 특별한 유형으로 저장해 놓는 것이 좋습니다.

> ufo$DateOccurred <- as.Date(ufo$DateOccurred, format="%Y%m%d")
> ufo$DateReported <- as.Date(ufo$DateReported, format="%Y%m%d")

위와 같은 명령어는 일반적으로 사용되고 있으나 이 경우에는 다음과 같은 에러가 나타날 것입니다.

"다음에 오류가 있습니다strptime(x, format, tz = "GMT") : 입력문자열이 너무 깁니다."

head() 이용하여 파악한 결과 DateOccurred는 8자리 YYYYMMDD의 형태를 가지고 있습니다. DateOccurred와 DateReported에서 문자열이 몇 자리인지 그리고 이들이 어디에 위치하는지를 알고 싶을 것입니다. 왜냐하면 8자리가 아니어서 "입력문자열이 너무 깁니다."라는 에러 메세지가 나타났기 때문입니다. 

> good.rows <- ifelse(nchar(ufo$DateOccurred)>=8 & nchar(ufo$DateOccurred)!= 8 | nchar(ufo$DateReported)!=8,FALSE,TRUE)
> length(which(!good.rows))
[1] 454
> ufo <- ufo[good.rows,]

## ifelse(): 
## Usage: ifelse(test, yes, no)
## 기본적 설명: ifelse 함수의 test 인자는 논리벡터나 논리벡터로 강제 변환될 수 있는 표현식을 사용하고 yes 인자와 no 인자는 벡터나 연산의 결과가 벡터인 표현식을 사용합니다. ifelse 함수는 test 인자의 결과가 같은 길이의 벡터를 반환합니다. 반환하는 값은 논리벡터에서 원소의 값이 TRUE이면 yes 벡터에서 같은 인덱스(위치)를 갖는 값을, FALSE이면 no 벡터에서 같은 인테스를 갖는 값을 반환합니다.

## nchar(): 
기본적 설명: 문자벡터의 각 원소가 몇 개의 문자열로 구성되어 있는지 알 수 있습니다. 이것은 다른 의미로 문자벡터의 원소가 non-empty strings인지를 발견해 내는데 가장 빠른 방법을 제공합니다.

## which(): 
기본적 설명: 특정 조건을 만족하는 원소의 index를 구할 수 있습니다.

> ufo$DateOccurred <- as.Date(ufo$DateOccurred, format="%Y%m%d")
> ufo$DateReported <- as.Date(ufo$DateReported, format="%Y%m%d")

############################
## location 데이터 다루기 ##
############################

location 데이터를 다루기 위해 다음과 같이 get.location() 함수를 스스로 만들어 봅니다.

get.location <- function(l) {
	split.location <- tryCatch(strsplit(l,",")[[1]], error=function(e) return(c(NA, NA)))
	clean.location <- gsub("^ ","",split.location)
	if (length(clean.location) > 2) {
		return(c(NA,NA))
	}
	else {
		return(clean.location)
	}
}

## function(): 
## 기본적 설명: 사용자 함수를 정의합니다.
## Usage:
## function( arglist ) expr
## return(value)
## Arguments:
## arglist - Empty or one or more name or name=expression terms.
## expr - An expression.
## value - An expression.

## 정규표현식(regular expression):
## 기본적 설명: R의 확장 정규표현식은 POSIX 1003.2 표준을 기반으로 이식되었습니다. grep(), regexpr(), gregexpr(), sub(), gsub(), strsplit() 등의 함수의 기본 모드에서 허용하는 정규표현식은 확장 정규표현식을 따릅니다. 정규표현식은 작은 단위의 표현식을 결합하는 다양한 연산자를 사용하는 산술 연산과 비슥하고 이 표현식은 0개 또는 하나 이상의 문자와 매치됩니다.

## gsub():
## 기본적 설명: 패턴 매치된 모든 문자를 치환합니다.

## grep(): 

## agrep():

## grepRaw(): 

## strsplit():
## 기본적 설명: 문자열의 요소를 문자열 내의 하위 문자열로 분할합니다.
## Usage:
## strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)
## Arguments:
## x - 분할될 문자 벡터, 다른 형태의 입력은 에러가 발생합니다.
## split - character vector (or object which can be coerced to such) containing regular expression(s) (unless fixed = TRUE) to use for splitting. If empty matches occur, in particular if split has length 0, x is split into single characters. If split has length greater than 1, it is re-cycled along x. 
## fixed - logical. If TRUE match split exactly, otherwise use regular expressions. Has priority over perl. 
## perl - logical. Should perl-compatible regexps be used?
## useBytes - logical. If TRUE the matching is done byte-by-byte rather than character-by-character, and inputs with marked encodings are not converted. This is forced (with a warning) if any input is found which is marked as "bytes".


## tryCatch(): 
## 기본적 설명: 예외처리 구문으로서 예기치 않은 오류가 발생하였을 때, 프로그램이 강제 종료되지 않고 안전하게 종료시킬 수 있습니다. 일반적으로 stop() 함수나 warning() 함수는 사용자가 에러나 논리적 오류가 발생하는 사례를 알고 작성하지만 tryCatch() 함수는 이것이 불명확할 경우에 사용하는 것입니다. 또한 이 함수는 다른 사람이 만들어 놓은 함수를 사용자 정의함수로 사용할 때 사용됩니다.

## apply() 함수군: 데이터 객체의 각 차원에 대해서 함수를 적용한 후 이의 결과를 집계하여 반환하는 기능을 가집니다.
## apply(): 
## 기본적 설명: 행렬이나 배열의 주변값에 특정 함수를 적용하여 그 적용결과를 반환하는 함수입니다.
## Usage:
## apply(X, MARGIN, FUN, ...)
## Arguments:
## X - an array, including a matrix.
## MARGIN - a vector giving the subscripts which the function will be applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows and columns. Where X has named dimnames, it can be a character vector selecting dimension names.
## FUN - the function to be applied: see ‘Details’. In the case of functions like +, %*%, etc., the function name must be backquoted or quoted.
## ... - optional arguments to FUN.
## Example:
## mat <- matrix(1:15, nrow=5)
## mat_na <- mat
## mat_na[5, 3] <- NA
## apply(mat_na, 1, sum)
## apply(mat_na, 1, sum, na.rm=TRUE)
## sum() 대신 sort() 그리고 sort()의 인자(arguements)를 활용하여 사용해 보시기 바랍니다. FUN 인자에 함수가 아닌 연산자를 사용하는 경우 연산자를 " "(따옴표: quotation) 안에 넣어 기술해야 합니다. 단항연산자(예를 들어, "!")와는 달리 다항연산자("/": 나누기)를 사용하는 경우에는 두 번째 피연산자를 FUN 인자값 뒤에 기술해야 합니다.

## eapply():

## lapplu():

## mapply():

## rapply():

## tapply():
  
> city.state <- lapply(ufo$Location, get.location)
> head(city.state)

리스트를 이용해 매트릭스를 만들기 위해 do.call() 함수를 사용해 봅니다. apply() 함수와 같이, do.call() 함수는 리스트에 대해 함수 호출을 실행합니다.

> location.matrix <- do.call(rbind, city.state)
> ufo <- transform(ufo, USCity=location.matrix[,1], USState=tolower(location.matrix[,2]), stringsAsFactors=FALSE)

## transform():
## Usage:
## transform(`_data`, ...)
## 기본적 설명: 데이터 프레임을 변형시키는 함수입니다. '_data' 인자는 변형할 대상의 데이터 객체를 지정하고 두 번째 인자 ...는 tag=value의 형태로 사용하는데 tag는 새롭게 추가될 변수명을 지정하고 value는 변경할 변수의 표현식을 지정합니다.
## Examples:
## transform(airquality, Ozone = -Ozone)
## transform(airquality, new = -Ozone, Temp = (Temp-32)/1.8)

## tolower(): 
## Usage
## chartr(old, new, x)
## tolower(x)
## toupper(x)
## casefold(x, upper = FALSE)
## 기본적 설명: tolower and toupper 인자는 문자 벡터에서 대품자로 표기되어 있는 문자를 소문자로 변환하거나 그 반대로 변화시킵니다. 알파벳이 아닌 문자는 변경되지 않은 채로 남겨둡니다. 

ufo 데이터 객체에는 미국과 캐나다의 지역이 같이 포함되어 있는 것을 알 수 있습니다. 이 중 미국의 데이터만 선택하여 분석하고자 합니다. 데이터를 선택 분할 하기 위해 다음과 같은 코드를 사용해 봅니다. 여기에서는 NA가 어디에 위치하는 지가 관심 대상입니다.

> us.states <- c("ak","al","ar","az","ca","co","ct","de","fl","ga","hi","ia","id","il", "in","ks","ky","la","ma","md","me",
+ "mi","mn","mo","ms","mt","nc","nd","ne","nh", "nj","nm","nv","ny","oh","ok","or","pa","ri","sc","sd","tn","tx","ut","va",
+ "vt", "wa","wi","wv","wy")
> ufo$USState <- us.states[match(ufo$USState,us.states)]
> ufo$USCity[is.na(ufo$USState)] <- NA
> ufo.us <- subset(ufo, !is.na(USState))
> head(ufo.us)

## match():
## Usage:
## match(x, table, nomatch = NA_integer_, incomparables = NULL)
## 기본적 설명: match() 함수는 첫 번째 인자의 원소가 두 번째 인자에 있는지를 비교하여 두 번째 인자에서 해당 위치의 index 값을 반환하고 매치되는 것이 없으면 nomatch 인자에서 지정한 값을 반환합니다.




