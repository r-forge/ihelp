%  File tutorial-dev/Parts/part1-ch02.tex
%  Part of the iHELP project at http://ihelp.r-forge.r-project.org
%
%  Copyright (C) 2013- The iHELP Working Group 
%                                in the Korean R Translation Team
%
%  This program is free software; you can redistribute it and/or modify
%  it under the terms of the GNU General Public License as published by
%  the Free Software Foundation; either version 2 of the License, or
%  (at your option) any later version.
%
%  This program is distributed in the hope that it will be useful,
%  but WITHOUT ANY WARRANTY; without even the implied warranty of
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%  GNU General Public License for more details.
%
%  A copy of the GNU General Public License is available at
%  http://www.r-project.org/Licenses/
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[../tutorial.tex]{subfiles}
\begin{document}


\part{R과 통계}

\chapter{수학연산 - 중급}

% http://nsaunders.wordpress.com/2010/08/20/a-brief-introduction-to-apply-in-r/
% http://www.biostat.jhsph.edu/~hji/courses/statcomputing/WriteProgram3.pdf
% http://www.endmemo.com/program/R/apply.php
\section{수학연산에 도움이 되는 함수들}

\paragraph{행렬값 구하기: }  아마도 행렬과 연관하여 자주 쓰이는 연산은 행렬값을 구하는 것일 것입니다. 
위에서 언급한 M 이라는 행렬값은 $1\times 4 - 3\times 2 = -2$ 일 것입니다. 
R은 이것의 계산을 det()이라는 함수를 이용합니다. 

\begin{Schunk}
\begin{Soutput}
> M <- matrix(c(1,2,3,4), ncol=2)
> val <- det(M)
> M
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> val
[1] -2
> 1*4-3*2
[1] -2
\end{Soutput}
\end{Schunk}


\paragraph{역행렬 찾기:} 역행렬은 \texttt{solve()}라는 함수를 통해 얻을 수 있는데, 수학적인 의미가 $M M^{-1} = I$ 입니다.

\begin{Schunk}
\begin{Soutput}
> solve(M)
     [,1] [,2]
[1,]   -2  1.5
[2,]    1 -0.5
>
\end{Soutput}
\end{Schunk}


\paragraph{연립방정식의 해찾기:} 역행렬을 이용하는 예는 아마도 선형방정식의 해를 구하는 것입니다. 
아래와 같은 선형방정식을 살펴봅니다. 
\begin{eqnarray}
3x + 4y - 2z & = & 5 \\
-4x + 3y - z & = & 22 \\
x + y + z & = & 6
\end{eqnarray}

이는 수학적으로 아래와 같이 쓸 수 있습니다. 

\begin{equation}
	\begin{bmatrix}
		3 & 4 & -2 \\
		-4 & 3 & -1 \\
		1 & 1 & 1 
	\end{bmatrix}
\begin{bmatrix}
	x \\
	y \\
	z 
\end{bmatrix}
= 
\begin{bmatrix}
	5 \\
	-1 \\
	6 
\end{bmatrix}
\end{equation}

이렇게 선형방정식이 $AX=b$라는 형식으로 표현 할 수 있다면 \texttt{solve(M)}의 결과는 \texttt{x}의 해를 의미합니다.
이 선형방정식을 손으로 풀면 $x=1$, $y=2$, $z=3$ 이라는 값이 나오게 됩니다. 
이를 R로 하기위해서는 다음과 같이 할 수 있습니다. 

\begin{Schunk}
\begin{Soutput}
> A <- matrix(c(3,-4,1,4,3,1,-2,-1,1), ncol=3)
> b <- c(5,-1,6)
> solve(A,b)
[1] 1 2 3
> 
\end{Soutput}
\end{Schunk}

\paragraph{텐서 프로닥트}  tensor product (혹은 Kronecker product)란 아래와 같이 행렬의 연산을 수행합니다. 
이를 수행하기 위한 R 함수는 아래와 같습니다. 

\begin{Schunk}
\begin{Soutput}
> A1 <- matrix(c(1,2,3,4), ncol=2)
> A2 <- matrix(1:9, ncol=3)
> kronecker(A1, A2)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    4    7    3   12   21
[2,]    2    5    8    6   15   24
[3,]    3    6    9    9   18   27
[4,]    2    8   14    4   16   28
[5,]    4   10   16    8   20   32
[6,]    6   12   18   12   24   36
> 	
\end{Soutput}
\end{Schunk}

\paragraph{외적과 내적}  그런데, 크로넥커 프로닥트는 본래 벡터의 외적을 이용하여 계산합니다. 
외적의 연산에 대한 이해는 아래를 살펴보시길 바랍니다.
\begin{Schunk}
\begin{Soutput}
> x <- 1:9
> names(x) <- x
> x %o% x
  1  2  3  4  5  6  7  8  9
1 1  2  3  4  5  6  7  8  9
2 2  4  6  8 10 12 14 16 18
3 3  6  9 12 15 18 21 24 27
4 4  8 12 16 20 24 28 32 36
5 5 10 15 20 25 30 35 40 45
6 6 12 18 24 30 36 42 48 54
7 7 14 21 28 35 42 49 56 63
8 8 16 24 32 40 48 56 64 72
9 9 18 27 36 45 54 63 72 81
> 
\end{Soutput}
\end{Schunk}

이를 활용하여 구구단을 만드는 프로그램을 작성해봅니다. 

\begin{Schunk}
\begin{Soutput}
> x <- 1:9
> names(x) <- x
> y <- 2:9
> names(y) <- paste(y, "*", sep="")
> outer(y, x, "*")
   1  2  3  4  5  6  7  8  9
2* 2  4  6  8 10 12 14 16 18
3* 3  6  9 12 15 18 21 24 27
4* 4  8 12 16 20 24 28 32 36
5* 5 10 15 20 25 30 35 40 45
6* 6 12 18 24 30 36 42 48 54
7* 7 14 21 28 35 42 49 56 63
8* 8 16 24 32 40 48 56 64 72
9* 9 18 27 36 45 54 63 72 81
> 
\end{Soutput}
\end{Schunk}

\paragraph{고유값과 고유벡터:}  M 행렬의 고유값과 고유벡터는 아래와 같은 방법으로 구할 수 있습니다. 

\begin{Schunk}
\begin{Soutput}
> eM <- eigen(M)
> names(eM)
[1] "values"  "vectors"
> eM$values
[1]  5.3722813 -0.3722813
> eM$vectors
           [,1]       [,2]
[1,] -0.5657675 -0.9093767
[2,] -0.8245648  0.4159736
> 
\end{Soutput}
\end{Schunk}

\paragraph{특이값 분해}

행렬 A의 Singular value decomposition (특이값 분해)는 아래와 같은 수학적 의미를 가집니다. 

\begin{equation}
A = U D(Q) V^T
\end{equation}
%
여기에서 $ U^T U = V^T V = VV^T = I $ 이며 $Q$는 특이값 벡터입니다. 

\begin{Schunk}
\begin{Soutput}
> svdM <- svd(M)
> names(svdM)
[1] "d" "u" "v"
> svdM$d
[1] 5.4649857 0.3659662
> svdM$u
           [,1]       [,2]
[1,] -0.5760484 -0.8174156
[2,] -0.8174156  0.5760484
> svdM$v
           [,1]       [,2]
[1,] -0.4045536  0.9145143
[2,] -0.9145143 -0.4045536
> $
\end{Soutput}
\end{Schunk}


\paragraph{일반 수학함수들}

\paragraph{삼각함수들}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}
\paragraph{집합과 관련된 함수들}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}
\paragraph{기타 유용한 함수들}
% \item \texttt{which.max()}와 \texttt{which.min()}을 사용하는 방법 
\texttt{combn()} 함수를 이용하여 모든 조합을 찾기



\section{확률분포에 대해서}

\subsection{밀도/누적 확률분포}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{퍼센타일 값 찾기}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\subsection{표준 난수생성 함수}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\subsection{비표준 난수생성 알고리즘}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}


\paragraph{Multinomial random variables}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{Correlated binary random variables}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}





\section{미분과 적분}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}


\section{Numerical Techniques}

Numerical techniques 에 대한 한국어가 무엇인지요?

\paragraph{Newton-Raphson} 알고리즘을 구현하는 방법 -- optimization 에 관련된 일종의 설명도 추가해주면 좋을 것 같음 
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{Laplace Approximation} 알고리즘을 구현하는 방법 -- 적분하는 방법에 많이 쓰임 (특히, 베이지안 컴퓨테이션) 
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}



\subsection{Metropolis-Hastings} 알고리즘을 구현하는 프레임 워크 - 이것은 그냥 사용가능하게 바로 소스코드 붙여주기 (베이지안 컴퓨테이션에 많이 쓰임)
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\subsection{Importance Sampling}

\subsection{Accept-Rejection Sampling}

\subsection{EM algorithm}

\subsection{Bootstrap} 
방법 -- 요건 아주 좋은 패키지가 있음 
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\end{document}
