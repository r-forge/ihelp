%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{수학/확률/행렬/수치해석과 관련하여}

\section{수학연산에 도움이 되는 함수들}

\paragraph{행렬값 구하기: }  아마도 행렬과 연관하여 자주 쓰이는 연산은 행렬값을 구하는 것일 것입니다. 
위에서 언급한 M 이라는 행렬값은 $1\times 4 - 3\times 2 = -2$ 일 것입니다. 
R은 이것의 계산을 det()이라는 함수를 이용합니다. 

\begin{Schunk}
\begin{Soutput}
> M <- matrix(c(1,2,3,4), ncol=2)
> val <- det(M)
> M
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> val
[1] -2
> 1*4-3*2
[1] -2
\end{Soutput}
\end{Schunk}


\paragraph{역행렬 찾기:} 역행렬은 \texttt{solve()}라는 함수를 통해 얻을 수 있는데, 수학적인 의미가 $M M^{-1} = I$ 입니다.

\begin{Schunk}
\begin{Soutput}
> solve(M)
     [,1] [,2]
[1,]   -2  1.5
[2,]    1 -0.5
>
\end{Soutput}
\end{Schunk}


\paragraph{연립방정식의 해찾기:} 역행렬을 이용하는 예는 아마도 선형방정식의 해를 구하는 것입니다. 
아래와 같은 선형방정식을 살펴봅니다. 
\begin{eqnarray}
3x + 4y - 2z & = & 5 \\
-4x + 3y - z & = & 22 \\
x + y + z & = & 6
\end{eqnarray}

이는 수학적으로 아래와 같이 쓸 수 있습니다. 

\begin{equation}
	\begin{bmatrix}
		3 & 4 & -2 \\
		-4 & 3 & -1 \\
		1 & 1 & 1 
	\end{bmatrix}
\begin{bmatrix}
	x \\
	y \\
	z 
\end{bmatrix}
= 
\begin{bmatrix}
	5 \\
	-1 \\
	6 
\end{bmatrix}
\end{equation}

이렇게 선형방정식이 $AX=b$라는 형식으로 표현 할 수 있다면 \texttt{solve(M)}의 결과는 \texttt{x}의 해를 의미합니다.
이 선형방정식을 손으로 풀면 $x=1$, $y=2$, $z=3$ 이라는 값이 나오게 됩니다. 
이를 R로 하기위해서는 다음과 같이 할 수 있습니다. 

\begin{Schunk}
\begin{Soutput}
> A <- matrix(c(3,-4,1,4,3,1,-2,-1,1), ncol=3)
> b <- c(5,-1,6)
> solve(A,b)
[1] 1 2 3
> 
\end{Soutput}
\end{Schunk}

\paragraph{텐서 프로닥트}  tensor product (혹은 Kronecker product)란 아래와 같이 행렬의 연산을 수행합니다. 
이를 수행하기 위한 R 함수는 아래와 같습니다. 

\begin{Schunk}
\begin{Soutput}
> A1 <- matrix(c(1,2,3,4), ncol=2)
> A2 <- matrix(1:9, ncol=3)
> kronecker(A1, A2)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    4    7    3   12   21
[2,]    2    5    8    6   15   24
[3,]    3    6    9    9   18   27
[4,]    2    8   14    4   16   28
[5,]    4   10   16    8   20   32
[6,]    6   12   18   12   24   36
> 	
\end{Soutput}
\end{Schunk}

\paragraph{외적과 내적}  그런데, 크로넥커 프로닥트는 본래 벡터의 외적을 이용하여 계산합니다. 
외적의 연산에 대한 이해는 아래를 살펴보시길 바랍니다.
\begin{Schunk}
\begin{Soutput}
> x <- 1:9
> names(x) <- x
> x %o% x
  1  2  3  4  5  6  7  8  9
1 1  2  3  4  5  6  7  8  9
2 2  4  6  8 10 12 14 16 18
3 3  6  9 12 15 18 21 24 27
4 4  8 12 16 20 24 28 32 36
5 5 10 15 20 25 30 35 40 45
6 6 12 18 24 30 36 42 48 54
7 7 14 21 28 35 42 49 56 63
8 8 16 24 32 40 48 56 64 72
9 9 18 27 36 45 54 63 72 81
> 
\end{Soutput}
\end{Schunk}

이를 활용하여 구구단을 만드는 프로그램을 작성해봅니다. 

\begin{Schunk}
\begin{Soutput}
> x <- 1:9
> names(x) <- x
> y <- 2:9
> names(y) <- paste(y, "*", sep="")
> outer(y, x, "*")
   1  2  3  4  5  6  7  8  9
2* 2  4  6  8 10 12 14 16 18
3* 3  6  9 12 15 18 21 24 27
4* 4  8 12 16 20 24 28 32 36
5* 5 10 15 20 25 30 35 40 45
6* 6 12 18 24 30 36 42 48 54
7* 7 14 21 28 35 42 49 56 63
8* 8 16 24 32 40 48 56 64 72
9* 9 18 27 36 45 54 63 72 81
> 
\end{Soutput}
\end{Schunk}

\paragraph{고유값과 고유벡터:}  M 행렬의 고유값과 고유벡터는 아래와 같은 방법으로 구할 수 있습니다. 

\begin{Schunk}
\begin{Soutput}
> eM <- eigen(M)
> names(eM)
[1] "values"  "vectors"
> eM$values
[1]  5.3722813 -0.3722813
> eM$vectors
           [,1]       [,2]
[1,] -0.5657675 -0.9093767
[2,] -0.8245648  0.4159736
> 
\end{Soutput}
\end{Schunk}

\paragraph{특이값 분해}

행렬 A의 Singular value decomposition (특이값 분해)는 아래와 같은 수학적 의미를 가집니다. 

\begin{equation}
A = U D(Q) V^T
\end{equation}
%
여기에서 $ U^T U = V^T V = VV^T = I $ 이며 $Q$는 특이값 벡터입니다. 

\begin{Schunk}
\begin{Soutput}
> svdM <- svd(M)
> names(svdM)
[1] "d" "u" "v"
> svdM$d
[1] 5.4649857 0.3659662
> svdM$u
           [,1]       [,2]
[1,] -0.5760484 -0.8174156
[2,] -0.8174156  0.5760484
> svdM$v
           [,1]       [,2]
[1,] -0.4045536  0.9145143
[2,] -0.9145143 -0.4045536
> $
\end{Soutput}
\end{Schunk}


\paragraph{일반 수학함수들}

\paragraph{삼각함수들}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}
\paragraph{집합과 관련된 함수들}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}
\paragraph{기타 유용한 함수들}
% \item \texttt{which.max()}와 \texttt{which.min()}을 사용하는 방법 
\texttt{combn()} 함수를 이용하여 모든 조합을 찾기

\section{확률의 사용}

\subsection{밀도/누적 확률분포}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{퍼센타일 값 찾기}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\subsection{표준 난수생성 함수}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\subsection{비표준 난수생성 알고리즘}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}
\paragraph{Multinomial random variables}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{Correlated binary random variables}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{수치해석}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\subsection{미분}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\subsection{적분}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}
\paragraph{Laplace Approximation} 알고리즘을 구현하는 방법 -- 적분하는 방법에 많이 쓰임 (특히, 베이지안 컴퓨테이션) 
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\subsection{최적화 문제}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}
\paragraph{Newton-Raphson} 알고리즘을 구현하는 방법 -- optimization 에 관련된 일종의 설명도 추가해주면 좋을 것 같음 
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}



\section{시뮬레이션}
\subsection{Metropolis-Hastings} 알고리즘을 구현하는 프레임 워크 - 이것은 그냥 사용가능하게 바로 소스코드 붙여주기 (베이지안 컴퓨테이션에 많이 쓰임)
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\subsection{Bootstrap} 
방법 -- 요건 아주 좋은 패키지가 있음 
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{탐색적 데이터 분석}

여기에서 말하는 탐색적 분석이란 분석 초기에 단순히 데이터의 특징을 보는데 사용됩니다. 
또한, 이 과정은 데이터 클리닝과도 연관이 있습니다. 

\section{기술통계량 요약}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{평균과 분산과 같은 기초요약 함수들}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{그룹별 평균산출}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{5분위수 구하기}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{퀀타일}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{표준화와 스케일링}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\paragraph{신뢰구간}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{분할표와 카이제곱 검정}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{z-검정}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{t-검정}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}




\chapter{통계모형의 선택 및 적용}

각 섹션은 다음과 같은 방법으로 이루어져야 합니다. 
\begin{itemize}
\item 아래의 모형이 어느 경우에 사용되어야 하는가?
\item 모형을 사용하는데 있어서 요구되는 가정들은 무엇인가?
\item 모형의 계수에 대한 추정치는 어떻게 구하는가?
\item 모형의 진단
\item 추정치들에 대한 해석
\item 사용법들 
\item 모형에 대한 한계점
\end{itemize}

\section{분산분석 (Analysis of Variance-Covariance)}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{상관분석 (Correlation Analysis) }
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{회귀분석 (Regression Analysis) }
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{주성분분석 (Principle Component Analysis)}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{판별분석 (Discriminant Analysis) }
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{군집분석 (Cluster Analysis) }
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{시계열분석 (Time-Series Analysis) }
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{일반선형모델 (GLM)}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{의사결정 나무(Decision Tree)}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{Longitudinal data analysis}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{생존분석 (Survivial analysis)}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{Mixture and latent class analysis}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{신경망 분석}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{기계학습 (Machine Learning)}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}

\section{메타 분석 (Meta Analysis)}
\begin{Schunk}
\begin{Soutput}
output
\end{Soutput}
\end{Schunk}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{패키지 관리}
\begin{enumerate}
\item 	이와 반대로 현재 연결된 라이브러리를 떼어낼 수도 있습니다. 

	\begin{Schunk}
	\begin{Soutput}
	> detach(package:pkg_name)	
	\end{Soutput}
	\end{Schunk}

	% 웹에 > detach(package:pkg_name) 과 5. 패키지를 설치 (분류: 사용자 환경)이 한 줄 띄어져야 함.

	\item 패키지를 설치 (분류: 사용자 환경)  
	
	\textsf{(답변)} 설치되는 패키지의 \textbf{설치위치}와 \textbf{의존성}에 대해서 반드시 알아야 합니다. 
	
	\begin{Schunk}
	\begin{Soutput}
	> install.packages("패키지명", dependencies=TRUE, )
	\end{Soutput}
	\end{Schunk}
% 을 쓰지 못하는 사례도 허다하다. package를 설치할 때 메뉴에서 [패키지 -> 패키지 설치하기]를 선택하고 난 뒤
% [mirror]를 선택한 뒤 패키지 리스트에서 하나씩 어디선가 본 패키지 이름을 어렵게 어렵게 찾아 더블클릭하는 절차를 따르는 것이다.

	\item 설치된 패키지의 목록을 확인하는 방법을 알고 싶습니다.
\end{enumerate}

