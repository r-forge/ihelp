%  File tutorial-dev/Parts/part1-ch02.tex
%  Part of the iHELP project at http://ihelp.r-forge.r-project.org
%
%  Copyright (C) 2013- The iHELP Working Group 
%                                in the Korean R Translation Team
%
%  This program is free software; you can redistribute it and/or modify
%  it under the terms of the GNU General Public License as published by
%  the Free Software Foundation; either version 2 of the License, or
%  (at your option) any later version.
%
%  This program is distributed in the hope that it will be useful,
%  but WITHOUT ANY WARRANTY; without even the implied warranty of
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%  GNU General Public License for more details.
%
%  A copy of the GNU General Public License is available at
%  http://www.r-project.org/Licenses/
%

이번 챕터에서는 문자열 데이터와 시간과 관련된 데이터의 조작에 대해서 조금 더 알아보기로 할 것입니다.
문자열 데이터의 가장 대표적인 예로는 이름 또는 주소와 같이 정형화 된 형식으로 입력되지 않는 경우에 해당하며, 
시간과 관련된 데이터는 생년월일, 입원일 또는 퇴원일과 같이 일반적인 문자열 데이터보다는 다소 정형화 된 형식을 가지고 있습니다.
R에서는 이러한 문자열과 날짜를 처리하는데 있어 유용한 기능들을 제공하고 있습니다.

이전 챕터에서 다루었던 dart8.xls 데이터를 계속 활용하도록 합니다. 
본 데이터는 \href{http://korea.gnu.org/gnustats/dataset/dart8.xls}{여기 다운로드 링크}를 눌러 다운받을 수 있습니다.

\section{문자열 다루기}

\begin{comment}
	rm(list=ls())
	library(XLConnect)
	wb <- loadWorkbook("../dataset/dart8.xls")
	tmp <- readWorksheet(wb, sheet=getSheets(wb))
	mydata <- do.call(rbind, tmp)
	names(mydata)[1] <- c("년도별분기")
	mydata$여행사 <- do.call(rbind, strsplit(rownames(mydata), ".", fixed=TRUE))[,1]
	mydata$여행사 <- factor(mydata$여행사, levels=unique(mydata$여행사))
	mydata$번호 <- do.call(rbind, strsplit(rownames(mydata), ".", fixed=TRUE))[,2]
	rownames(mydata) <- NULL
	yrQ <- as.data.frame(do.call(rbind, strsplit(as.character(mydata$년도별분기), ".", fixed=TRUE)))
	names(yrQ) <- c("년도", "분기")
	mydata <- data.frame(mydata, yrQ)
	mydata <- mydata[,-1]
	mydata$분기 <- factor(mydata$분기, levels=c("03", "06", "09", "12"), labels=c("1분기", "2분기", "3분기", "4분기"))
	mydata$여행사 <- factor(mydata$여행사)
	mydatax <- na.exclude(mydata)

	다트8 <- subset(mydata, subset=(년도 %in% c("2008", "2009", "2010") & 분기 %in% c("1분기", "3분기")))
	다트8.1 <- 다트8[order(다트8$년도),]
	다트8.1$first <- !duplicated(다트8.1$년도)
	다트8.1$last <- !duplicated(다트8.1$년도, fromLast=TRUE)

	다트8.2 <- 다트8.1[c(FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE, FALSE, FALSE)]
	다트8.3 <- 다트8.2[order(다트8.2$여행사, 다트8.2$년도), ]
	다트8.3$first <- !duplicated(다트8.3$여행사)
	다트8.3$last <- !duplicated(다트8.3$여행사, fromLast=TRUE)
	다트8.4 <- subset(다트8.3, subset=(first == TRUE | last == TRUE))
	다트8.5 <- 다트8.4[,-c(4:5)]
	다트8.6 <- reshape(다트8.5, timevar="년도", idvar="여행사", direction="wide")
	다트8.6$차이 <- with(다트8.6, 매출액.2010 - 매출액.2008)
	reshape(다트8.6,  v.names=c("매출액"), varying=c("매출액.2008", "매출액.2010"), direction="long", timevar=c("년도"), times=c("2008", "2010"), ids=row.names(다트8.6))
\end{comment}

이전 챕터에서 다루었던 `다트8.5'이라는 데이터를 가지고 문자열 조작에 대한 예를 들어보도록 하겠습니다.
이를 위해서 `다트8.5' 데이터를 `다트8.7'라는 객체로 아래와 같이 저장합니다.
 
\begin{Schunk}
% 다트8.7 <- 다트8.5
\begin{Soutput}
> 다트8.7 <- 다트8.5
> 다트8.7
         매출액       여행사 년도
30  57624282255     하나투어 2008
40  66245202818     하나투어 2010
77  19926326125   레드캡투어 2008
87  28589391364   레드캡투어 2010
104 26530405258     모두투어 2008
114 36466418562     모두투어 2010
149 16463319852         세중 2008
159 20282845926         세중 2010
168  5790815204   참좋은레져 2008
178 14717211161   참좋은레져 2010
191 12954724212 롯데관광개발 2008
201 12561340891 롯데관광개발 2010
232  4803096281     자유투어 2008
242 10455493093     자유투어 2010
275  1012965573   비티앤아이 2008
285  4986588998   비티앤아이 2010
> 
\end{Soutput}
\end{Schunk}

이 데이터에서는 매출액은 수치형 변수임을 알고 있고, 여행사는 문자열 변수이고, 년도는 수치형이면서도 요인형 변수입니다.
그리고, first 와 last 라는 변수은 논리형 변수입니다.
만약, 아래와 같이 년도라는 데이터가 없다면 분석자는 여행사 데이터가 중복이 된 것인지 아닌지를 판단하기가 불확실하기 때문에 데이터처리에 곤란함을 느낄 것입니다.
 
\begin{Schunk}
\begin{Soutput}
> 다트8.7 <- 다트8.7[c(TRUE, TRUE, FALSE)] 
> 다트8.7
         매출액       여행사
30  57624282255     하나투어
40  66245202818     하나투어
77  19926326125   레드캡투어
87  28589391364   레드캡투어
104 26530405258     모두투어
114 36466418562     모두투어
149 16463319852         세중
159 20282845926         세중
168  5790815204   참좋은레져
178 14717211161   참좋은레져
191 12954724212 롯데관광개발
201 12561340891 롯데관광개발
232  4803096281     자유투어
242 10455493093     자유투어
275  1012965573   비티앤아이
285  4986588998   비티앤아이
> 
\end{Soutput}
\end{Schunk}

따라서, 매출액의 값이 다를지라도 여행사 변수에 대해서 분석자는 추후에 데이터에 대한 중복확인, 다른 자료의 유입, 혹은 다른 시점으로부터의 입력인가에 대한 확인하고자 임시적으로 현재 `여행사'변수의 값이 중복되었다면 .1 이라는 값을 붙여 두고 싶을 수 있습니다.
(독자는 추후에 R에서 중복된 값들은 보통 동일한 값의 뒤에 .1 이 붙는다는 것을 보게 될 것입니다.  
그리고, 이미 이전 챕터에서 행이름이 .1, .2, .3, ... 과 같이 생성된다는 것을 보았습니다.
아래에서 `여행사2'라는 변수를 살펴보시길 바랍니다.

\begin{Schunk}
\begin{Soutput}
> 다트8.7$여행사2 <- ifelse(duplicated(다트8.7$여행사), paste(다트8.7$여행사, 1, sep="."),paste(다트8.7$여행사, "", sep=""))
> 다트8.7
         매출액       여행사        여행사2
30  57624282255     하나투어       하나투어
40  66245202818     하나투어     하나투어.1
77  19926326125   레드캡투어     레드캡투어
87  28589391364   레드캡투어   레드캡투어.1
104 26530405258     모두투어       모두투어
114 36466418562     모두투어     모두투어.1
149 16463319852         세중           세중
159 20282845926         세중         세중.1
168  5790815204   참좋은레져     참좋은레져
178 14717211161   참좋은레져   참좋은레져.1
191 12954724212 롯데관광개발   롯데관광개발
201 12561340891 롯데관광개발 롯데관광개발.1
232  4803096281     자유투어       자유투어
242 10455493093     자유투어     자유투어.1
275  1012965573   비티앤아이     비티앤아이
285  4986588998   비티앤아이   비티앤아이.1
> 
\end{Soutput}
\end{Schunk}

여기에서 사용된 함수 duplicated()는 중복을 확인하는데 사용되었습니다 (이전 챕터에서 설명했습니다).
함수 paste()의 기능은 주어진 인자들을 문자열로 묶는 것이며, 이 때 주어진 모든 인자들은 문자열로 강제변환이 됨을 알아두면 좋습니다.
즉, 아래와 같이 숫자 1을 입력할지라도 paste()함수 내부에서 이를 문자열로 처리하여 결과를 돌려주게 됩니다. 

\begin{Schunk}
\begin{Soutput}
> paste(다트8.7$여행사, 1, sep=".")
 [1] "하나투어.1"     "하나투어.1"     "레드캡투어.1"   "레드캡투어.1"  
 [5] "모두투어.1"     "모두투어.1"     "세중.1"         "세중.1"        
 [9] "참좋은레져.1"   "참좋은레져.1"   "롯데관광개발.1" "롯데관광개발.1"
[13] "자유투어.1"     "자유투어.1"     "비티앤아이.1"   "비티앤아이.1"  
\end{Soutput}
\end{Schunk}
%$ 

함수 paste()에서 사용되는 지정된 인자 sep은 사용된 인자들이 어떤 구분기호를 이용하여 결합할 것인지를 알려줍니다. 
위에서와 같이 어떤 독자는 . 를 구분기호로서 사용하고 싶을 수도 있고, 어떤 독자는 - 를 선호할 수 있습니다. 

\begin{Schunk}
\begin{Soutput}
> paste(다트8.7$여행사, 1, sep="-")
 [1] "하나투어-1"     "하나투어-1"     "레드캡투어-1"   "레드캡투어-1"  
 [5] "모두투어-1"     "모두투어-1"     "세중-1"         "세중-1"        
 [9] "참좋은레져-1"   "참좋은레져-1"   "롯데관광개발-1" "롯데관광개발-1"
[13] "자유투어-1"     "자유투어-1"     "비티앤아이-1"   "비티앤아이-1"  
\end{Soutput}
\end{Schunk}
%$ 

어떤 독자는 아무런 공백없이 연결하고자 할 수도 있습니다. 

\begin{Schunk}
\begin{Soutput}
> paste(다트8.7$여행사, 1, sep="")
 [1] "하나투어1"     "하나투어1"     "레드캡투어1"   "레드캡투어1"  
 [5] "모두투어1"     "모두투어1"     "세중1"         "세중1"        
 [9] "참좋은레져1"   "참좋은레져1"   "롯데관광개발1" "롯데관광개발1"
[13] "자유투어1"     "자유투어1"     "비티앤아이1"   "비티앤아이1"  
> 
\end{Soutput}
\end{Schunk}
%$ 

이렇게 문자열을 결합하는 기능을 가진 함수 paste()를 이용하여 아래와 같이 변수명을 생성할때 유용하게 쓰일 수도 있습니다. 

\begin{Schunk}
\begin{Soutput}
> paste("V", 1:3, sep="")
[1] "V1" "V2" "V3"
> 
\end{Soutput}
\end{Schunk}

또 다른 유용한 경우는 아래와 같이 문자와 숫자의 조합을 형성하기 쉽습니다. 
(여기에서 사용된 함수 outer()는 수학/확률 이라는 챕터에서 구구단을 만드는 예제에서 설명되어 있습니다).

\begin{Schunk}
\begin{Soutput}
> outer(LETTERS[1:3], 1:3, paste, sep="-")
     [,1]  [,2]  [,3] 
[1,] "A-1" "A-2" "A-3"
[2,] "B-1" "B-2" "B-3"
[3,] "C-1" "C-2" "C-3"
\end{Soutput}
\end{Schunk}

\begin{comment}
\begin{Schunk}
\begin{Soutput}
> lower.tri(outer(LETTERS[1:3], 1:3, paste, sep="-"))
      [,1]  [,2]  [,3]
[1,] FALSE FALSE FALSE
[2,]  TRUE FALSE FALSE
[3,]  TRUE  TRUE FALSE

> upper.tri(outer(LETTERS[1:3], 1:3, paste, sep="-"))
      [,1]  [,2]  [,3]
[1,] FALSE  TRUE  TRUE
[2,] FALSE FALSE  TRUE
[3,] FALSE FALSE FALSE
> 
\end{Soutput}
\end{Schunk}	
\end{comment}

이제 좀 더 일반적으로 문자열을 다루는 방법에 대해서 알아보도록 하겠습니다.
먼저, 아래와 같이 현재 R 세션에 로드되어 있는 기본 패키지들을 확인하도록 합니다.

\begin{Schunk}
\begin{Soutput}
> str.ex <- getOption("defaultPackages")
> str.ex
[1] "datasets"  "utils"     "grDevices" "graphics"  "stats"     "methods"  
>
\end{Soutput}
\end{Schunk}

만약, str.ex 이라는 문자열벡터를 이루는 각 개별 구성요소들에 대한 문자열의 길이를 알고 싶다면 아래와 같이 함수 nchar()를 사용하세요.

\begin{Schunk}
\begin{Soutput} 
> nchar(str.ex)
[1] 8 5 9 8 5 7
> 
\end{Soutput}
\end{Schunk}

갑자기 어떤 독자가 현재 문자열은 영어로 되어 있어서 잘 되는것이 아닌가하고 질문을 합니다. 
그래서, 이전의 `다트8.5' 데이터에서 `여행사'변수의 값을 이용하여 한글도 잘 되는가를 확인해 봅니다.

\begin{Schunk}
\begin{Soutput} 
> 다트8.7 <- 다트8.5
> str.ex1 <- unique(다트8.7$여행사)
> str.ex1
[1] 하나투어     레드캡투어   모두투어     세중         참좋은레져  
[6] 롯데관광개발 자유투어     비티앤아이  
8 Levels: 하나투어 레드캡투어 모두투어 세중 참좋은레져 ... 비티앤아이
>
> str.ex1 <- as.character(unique(다트8.7$여행사))
> str.ex1
[1] "하나투어"     "레드캡투어"   "모두투어"     "세중"         "참좋은레져"  
[6] "롯데관광개발" "자유투어"     "비티앤아이"  
> nchar(str.ex1)
[1] 4 5 4 2 5 6 4 5
>
\end{Soutput}
\end{Schunk}

한글에서도 문자열의 길이를 알려주는 함수가 잘 작동함을 알게 되었으므로, 이제는 문자열의 어떤 위치로부터 어떤 위치까지 뽑아 낼 수 있는 기능에 대해서 알아봅니다.

먼저 위에서 사용했던 문자열 str.ex 를 불러오고, 이 문자열을 구성하는 각 요소들의 첫번째 위치부터 세번째까지의 문자들만 골라 내고 싶다면 아래와 같이 함수 substr()을 이용합니다.

\begin{Schunk}
\begin{Soutput} 
> str.ex
[1] "datasets"  "utils"     "grDevices" "graphics"  "stats"     "methods"  
> substr(str.ex, 1, 3)
[1] "dat" "uti" "grD" "gra" "sta" "met"
\end{Soutput}
\end{Schunk}

이제 함수 nchar()를 함께 사용하여 각 구성요소의 첫번째 문자부터 맨 마지막 문자까지 뽑아냅니다. 
즉, 원래의 문자열과 동일한 값을 얻어야 할 것입니다. 

\begin{Schunk}
\begin{Soutput} 
> substr(str.ex, 1, nchar(str.ex))
[1] "datasets"  "utils"     "grDevices" "graphics"  "stats"     "methods"  
\end{Soutput}
\end{Schunk}

어떤 독자는 문자열의 일부분을 추출하기 보다는 어떤 특정 구분자에 의해서 문자열 자체를 쪼개기를 희망할 수있습니다. 
이를 위해서 아래와 같이 현재 세션에 놓인 모든 탐색경로를 이용합니다. 

\begin{Schunk}
\begin{Soutput} 
> str.ex2 <- search()
> str.ex2
 [1] ".GlobalEnv"        "package:XLConnect" "package:rJava"    
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"     
\end{Soutput}
\end{Schunk}

이 탐색경로를 잘 보면 str.ex2의 대다수의 구성요소들이 package 라는 이름 뒤에 콜론 (:)이 놓여지고 그 뒤에 패키지명이 놓인다는 것을 알 수 있습니다.
여기에서 하고자 하는 것은 str.ex2을 이루는 각 구성요소를 ``:''라는 구분자를 이용하여 분리하는 것입니다.
이 경우에는 아래와 같은 함수 strsplit()을 사용할 수 있습니다. 

\begin{Schunk}
\begin{Soutput} 
> strsplit(str.ex2, ":")
[[1]]
[1] ".GlobalEnv"

[[2]]
[1] "package"   "XLConnect"

[[3]]
[1] "package" "rJava"  

[[4]]
[1] "package" "stats"  

[[5]]
[1] "package"  "graphics"

[[6]]
[1] "package"   "grDevices"

[[7]]
[1] "package" "utils"  

[[8]]
[1] "package"  "datasets"

[[9]]
[1] "package" "methods"

[[10]]
[1] "Autoloads"

[[11]]
[1] "package" "base"   
\end{Soutput}
\end{Schunk}

그런데, strsplit()함수의 결과물은 리스트 형태임을 알 수 있으므로, 보기 편하게 아래와 같이 do.call()함수를 이용해봅니다. 

\begin{Schunk}
\begin{Soutput} 
> do.call(rbind, strsplit(search(), ":", fixed=FALSE))
      [,1]         [,2]        
 [1,] ".GlobalEnv" ".GlobalEnv"
 [2,] "package"    "XLConnect" 
 [3,] "package"    "rJava"     
 [4,] "package"    "stats"     
 [5,] "package"    "graphics"  
 [6,] "package"    "grDevices" 
 [7,] "package"    "utils"     
 [8,] "package"    "datasets"  
 [9,] "package"    "methods"   
[10,] "Autoloads"  "Autoloads" 
[11,] "package"    "base"      
> 
\end{Soutput}
\end{Schunk}

여기까지 우리는 문자열의 부분추출, 결합, 그리고 분리에 대해서 보았습니다.
어떤 독자는 치환은 어떻게 할 수 있는지에 대해서 궁금해 할 것입니다.
% 치환은 탐색과 대체라는 두가지 요소로 이루어져 있습니다.
위에서 사용한 문자열 str.ex2 에서 package 라는 문자를 한국어로 ``패키지''로 바꾸고 싶다면 아래와 같이 함수 gsub() 를 이용할 수 있습니다. 

\begin{Schunk}
\begin{Soutput} 
> str.ex2
 [1] ".GlobalEnv"        "package:XLConnect" "package:rJava"    
 [4] "package:stats"     "package:graphics"  "package:grDevices"
 [7] "package:utils"     "package:datasets"  "package:methods"  
[10] "Autoloads"         "package:base"     
> gsub("package", "패키지", str.ex2)
 [1] ".GlobalEnv"       "패키지:XLConnect" "패키지:rJava"     "패키지:stats"    
 [5] "패키지:graphics"  "패키지:grDevices" "패키지:utils"     "패키지:datasets" 
 [9] "패키지:methods"   "Autoloads"        "패키지:base"     
> 
\end{Soutput}
\end{Schunk}

그런데 이러한 치환과정은 먼저 주어진 문자열을 탐색하는 것으로부터 이루어집니다.
따라서, 독자가 R을 이용하여 어떤 문자열을 탐색하고 싶다면 아래와 같은 grep()함수를 사용해 볼 수 있습니다. 
먼저 letters 라는 예약어는 알파벳 a부터 z까지의 레터들을 미리 저장해두고 있습니다. 

\begin{Schunk}
\begin{Soutput} 
> letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"
\end{Soutput}
\end{Schunk}

여기에서 a 라는 문자가 어디에 위치하는지, 또는 e 라는 문잔는 어디에 위치하는지알고 싶다면 함수 grep()의 사용은 유용합니다.
\begin{Schunk}
\begin{Soutput} 
> grep("a", letters)
[1] 1
> grep("e", letters)
[1] 5
\end{Soutput}
\end{Schunk}
이렇게 얻어진 위치정보를 이용하여 아래와 같이 e 라는 문자를 찾을 수 있습니다. 

\begin{Schunk}
\begin{Soutput} 
> letters[grep("e", letters)]
[1] "e"
\end{Soutput}
\end{Schunk}

또한 grepl()이라는 함수가 있는데 이는 논리값으로 그 결과를 돌려줍니다. 
grep뒤에 l은 logical을 의미합니다.

\begin{Schunk}
\begin{Soutput} 
> grepl("e", letters)
 [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
[25] FALSE FALSE
\end{Soutput}
\end{Schunk}


함수 grep은 찾고자 하는 문자를 탐색하여 검색어를 포함하는 모든 문자열의 위치를 알려줍니다.
이를 이해하기 위해서 아래의 예제를 보길 바랍니다.

\begin{Schunk}
\begin{Soutput} 
> txt <- c("R", "is", "free", "software", "and", "your", "friend")
> txt
[1] "R"        "is"       "free"     "software" "and"      "your"     "friend"  
\end{Soutput}
\end{Schunk}

이러한 문자열 벡터에서 o 라는 글자를 포함하는 문자열은 아래와 같이 얻을 수 있습니다. 

\begin{Schunk}
\begin{Soutput} 
> grep("o", txt)
[1] 4 6
> grepl("o", txt)
[1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE
> txt[grep("o", txt)]
[1] "software" "your"    
> 
\end{Soutput}
\end{Schunk}

이제 한글은 어떻게 작동하는지 확인해보도록 합니다. 

\begin{Schunk}
\begin{Soutput} 
> txt.ko <- c("김지윤", "강사", "남녀", "연애", "정말?", "ㅋㅋ", "그랬어?", "맞 아", "오빠", "아잉")
> txt.ko
 [1] "김지윤"  "강사"    "남녀"    "연애"    "정말?"   "ㅋㅋ"    "그랬어?"
 [8] "맞아"    "오빠"    "아잉"   
> 
\end{Soutput}
\end{Schunk}

여기에서 ``아''라는 글자가 들어간 문자열을 찾고 싶을때는 아래와 같이 할 수 있습니다. 

\begin{Schunk}
\begin{Soutput} 
> grep("아", txt.ko)
[1]  8 10
\end{Soutput}
\end{Schunk}

같은 방법으로  ``김'' 또는 ``애'' 라는 글자가 들어간 문자열도 찾을 수 있습니다. 

\begin{Schunk}
\begin{Soutput} 
> grep("[김애]", txt.ko)
[1] 1 4
\end{Soutput}
\end{Schunk}

그런데, 아래와 같이 특수문자를 사용할 때는 주의를 해야합니다. 

\begin{Schunk}
\begin{Soutput} 
> grep("^?", txt.ko)
 [1]  1  2  3  4  5  6  7  8  9 10
> grep("^", txt.ko)
 [1]  1  2  3  4  5  6  7  8  9 10
> grep("*", txt.ko)
 [1]  1  2  3  4  5  6  7  8  9 10
> 
\end{Soutput}
\end{Schunk}

주어진 특수문자를 올바르게 찾기 위해서는 꼭 대괄호 안에 위치시켜주어야 합니다. 

\begin{Schunk}
\begin{Soutput} 
> grep("[?]", txt.ko)
[1] 5 7
\end{Soutput}
\end{Schunk}

그런데, 갑자기 독자가 지금 사용한 문자열을 하나의 문자열로 만들고 싶어합니다.
이런 경우 역시 paste()함수를 활용할 수 있습니다.

\begin{Schunk}
\begin{Soutput} 
> txt
[1] "R"        "is"       "free"     "software" "and"      "your"     "friend"  
> paste(txt, collapse=" ")
[1] "R is free software and your friend"
\end{Soutput}
\end{Schunk}

이전에 사용했던 sep 인자는 문자열 벡터의 구성요소 내에서 작용하는 것이고, collapse는 구성요소간에 작용하는 것임을 알고 계시면 도움이 됩니다.  

\begin{Schunk}
\begin{Soutput} 
> paste(txt, collapse="-")
[1] "R-is-free-software-and-your-friend"
\end{Soutput}
\end{Schunk}

한글 문자열 역시 잘 됨을 확인할 수 있습니다. 

\begin{Schunk}
\begin{Soutput} 
> paste(txt.ko, collapse="-")
[1] "김지윤-강사-남녀-연애-정말?-ㅋㅋ-그랬어?-맞아-오빠-아잉"
> paste(txt.ko, collapse=" ")
[1] "김지윤 강사 남녀 연애 정말? ㅋㅋ 그랬어? 맞아 오빠 아잉"
> 
\end{Soutput}
\end{Schunk}


문자열 섹션을 마치기 전에 아래와 같은 사항을 알아두시면 도움이 될 것 같아 남겨둡니다. 

문자열을 출력할 때는 주로 print()와 cat()을 이용합니다. 
이 두함수의 차이는 이스케이프 시퀀스가 적용이 되는가 안되는가의 차이입니다.
이스케이프 시퀀스라는 것은 문자열을 사람이 잘 읽을 수있도록 도와주는 일종의 특수기호이며, 이는 컴퓨터만이 이해하도록 하고 출력시에는 보여주지 않도록 처리됩니다. 
cat()이라는 문자는 이러한 이스케이스 시퀀스를 아래와 같이 처리해서 보여주지만, print()함수는 그러한 과정없이 그대로 보여줍니다. 

\begin{Schunk}
\begin{Soutput} 
> cat("Hi \nHello \n")
Hi 
Hello 
> print("Hi \nHello \n")
[1] "Hi \nHello \n"
\end{Soutput}
\end{Schunk}

만약, 문자의 대소문자를 변경하고 싶다면 tolower()와 toupper()함수를 이용해보세요.

\begin{Schunk}
\begin{Soutput} 
> txt1 <- paste(txt, collapse=" ")
> txt1
[1] "R is free software and your friend"
> txt1.1 <- toupper(txt1)
> txt1.1
[1] "R IS FREE SOFTWARE AND YOUR FRIEND"
> txt1.2 <- tolower(txt1.1)
> txt1.2
[1] "r is free software and your friend"
> 
\end{Soutput}
\end{Schunk}

R에서는 Perl에서 제공하는 regular expression을 사용합니다. 
(이 부분은 따로 제공해주는게 좋을 것 같음).
     


\section{날짜와 시간을 다루기}

이 부분은 내일 작성하겠습니다.

\begin{comment}
> ct <- Sys.time()
> cd <- Sys.Date()
> str(ct)
 POSIXct[1:1], format: "2013-05-17 18:16:57"
> str(cd)
 Date[1:1], format: "2013-05-17"
> is.character(ct)
[1] FALSE
> is.character(cd)
[1] FALSE
> 

> as.Date("2013-05-17")
[1] "2013-05-17"
> as.Date("2013년05월17일")
Error in charToDate(x) : 
  character string is not in a standard unambiguous format
> as.Date("05/17/13")
Error in charToDate(x) : 
  character string is not in a standard unambiguous format
> 

> as.Date("2013년05월17일", format="%Y/m/%d")
[1] NA
> as.Date("2013년05월17일", format="%Y/%m/%d")
[1] NA
> as.Date("2013년05월17일", format="%Y년%m월%d")
[1] "2013-05-17"
> as.Date("2013/05/17", format="%Y/%m/%d")
[1] "2013-05-17"
> as.Date("05월17일2013년", format="%m/%d/%Y")
[1] NA
> 

> as.Date("05월17일2013년", format="%m월%d일%Y")
[1] "2013-05-17"
> as.Date("05월2013년17일", format="%m월%Y년%d")
[1] "2013-05-17"
> 
% 5 http://rhdxmr.tistory.com/45

International Organization for Standardization  _ISO 8601.
     
     ## locale-specific version of the date
     format(Sys.Date(), "%a %b %d")
     
     ## read in date info in format 'ddmmmyyyy'
     ## This will give NA(s) in some locales; setting the C locale
     ## as in the commented lines will overcome this on most systems.
     ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
     x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")
     z <- as.Date(x, "%d%b%Y")
     ## Sys.setlocale("LC_TIME", lct)
     z
     
     ## read in date/time info in format 'm/d/y'
     dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")
     as.Date(dates, "%m/%d/%y")
     
    
     ## date given as number of days since 1900-01-01 (a date in 1989)
     as.Date(32768, origin="1900-01-01")
     ## Excel is said to use 1900-01-01 as day 1 (Windows default) or
     ## 1904-01-01 as day 0 (Mac default), but this is complicated by Excel
     ## treating 1900 as a leap year.
     ## So for dates (post-1901) from Windows Excel
     as.Date(35981, origin="1899-12-30") # 1998-07-05
     ## and Mac Excel
     as.Date(34519, origin="1904-01-01") # 1998-07-05
     ## (these values come from http://support.microsoft.com/kb/214330)
     
     ## Experiment shows that Matlab's origin is 719529 days before ours,
     ## so Matlab day 734373 can be imported as
     as.Date(734373, origin = "1970-01-01") - 719529
     ## (value from http://www.mathworks.com/help/techdoc/matlab_prog/bspgcx2-1.html)
     
    
     ## Timezone effect
     z <- ISOdate(2010, 04, 13, c(0,12)) # midnight and midday UTC
     as.Date(z) # in UTC
     ## these timezone names are common
     as.Date(z, tz ="NZ")
     as.Date(z, tz ="HST") # Hawaii
     
     
 ## locale-specific version of date()
     format(Sys.time(), "%a %b %d %X %Y %Z")
     
     ## time to sub-second accuracy (if supported by the OS)
     format(Sys.time(), "%H:%M:%OS3")
     
     ## read in date info in format 'ddmmmyyyy'
     ## This will give NA(s) in some locales; setting the C locale
     ## as in the commented lines will overcome this on most systems.
     ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
     x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")
     z <- strptime(x, "%d%b%Y")
     ## Sys.setlocale("LC_TIME", lct)
     z
     
     ## read in date/time info in format 'm/d/y h:m:s'
     dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")
     times <- c("23:03:20", "22:29:56", "01:03:30", "18:21:03", "16:56:26")
     x <- paste(dates, times)
     strptime(x, "%m/%d/%y %H:%M:%S")


     ## time with fractional seconds
     z <- strptime("20/2/06 11:16:16.683", "%d/%m/%y %H:%M:%OS")
     z # prints without fractional seconds
     op <- options(digits.secs=3)
     z
     options(op)
     
     ## timezones are not portable, but 'EST5EDT' comes pretty close.
     (x <- strptime(c("2006-01-08 10:07:52", "2006-08-07 19:33:02"),
                    "%Y-%m-%d %H:%M:%S", tz="EST5EDT"))
     attr(x, "tzone")
     
     ## An RFC 822 header (Eastern Canada, during DST)
     strptime("Tue, 23 Mar 2010 14:36:38 -0400",  "%a, %d %b %Y %H:%M:%S %z")
     
> ?strftime
> d
에러:개체 'd'이 없습니다
>   x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")
>      z <- strptime(x, "%d%b%Y")
> x
[1] "1jan1960"  "2jan1960"  "31mar1960" "30jul1960"
> z
[1] NA NA NA NA
>      z <- strptime(x, "%d일%b월%Y")
> z
[1] NA NA NA NA
>      z <- strptime(x, "%d일%b월%Y년")
> z
[1] NA NA NA NA
> as.Date(x, "%d일%b월%Y년")
[1] NA NA NA NA
> as.Date(x, "%d%b%Y")
[1] NA NA NA NA
> ?strptime
> as.Date("05월17일2013년", format="%m월%d일%Y")
[1] "2013-05-17"
> as.Date("05월17일2013년", format="%m/%d/%Y")
[1] NA
>      format(Sys.Date(), "%a %b %d")
[1] "금  5월 17"
> as.Date(x, formate="%d%b%Y")
다음에 오류charToDate(x) : 문자열이 표준서식을 따르지 않습니다 
> x
[1] "1jan1960"  "2jan1960"  "31mar1960" "30jul1960"
> str(x)
 chr [1:4] "1jan1960" "2jan1960" "31mar1960" "30jul1960"
> as.Date(x)
다음에 오류charToDate(x) : 문자열이 표준서식을 따르지 않습니다 
> as.Date(x, format="%d%b%U)
+ ")
[1] NA NA NA NA
> as.Date(x, format="%d%b%Y")
[1] NA NA NA NA
> as.Date(x, format="%d%b%Y")
[1] NA NA NA NA
> Sys.getlocale("LC_ALL")
[1] "LC_CTYPE=ko_KR.UTF-8;LC_NUMERIC=C;LC_TIME=ko_KR.UTF-8;LC_COLLATE=ko_KR.UTF-8;LC_MONETARY=ko_KR.UTF-8;LC_MESSAGES=ko_KR.UTF-8;LC_PAPER=C;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=ko_KR.UTF-8;LC_IDENTIFICATION=C"
> Sys.setlocale("LC_ALL", "C")
[1] "LC_CTYPE=C;LC_NUMERIC=C;LC_TIME=C;LC_COLLATE=C;LC_MONETARY=C;LC_MESSAGES=ko_KR.UTF-8;LC_PAPER=C;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=ko_KR.UTF-8;LC_IDENTIFICATION=C"
> as.Date(x, format="%d%b%Y")
[1] "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"
> 

> "2013-05-17"
[1] "2013-05-17"
> seq(from="2013-05-17", to="2013-05-29")
Error in from:to : NA/NaN argument
In addition: Warning messages:
1: In seq.default(from = "2013-05-17", to = "2013-05-29") :
  NAs introduced by coercion
2: In seq.default(from = "2013-05-17", to = "2013-05-29") :
  NAs introduced by coercion
> seq(from=as.Date("2013-05-17"), to=as.Date("2013-05-29"))
Error in seq.Date(from = as.Date("2013-05-17"), to = as.Date("2013-05-29")) : 
  exactly two of 'to', 'by' and 'length.out' / 'along.with' must be specified
> seq(from=as.Date("2013-05-17"), to=as.Date("2013-05-29"), by=1)
 [1] "2013-05-17" "2013-05-18" "2013-05-19" "2013-05-20" "2013-05-21"
 [6] "2013-05-22" "2013-05-23" "2013-05-24" "2013-05-25" "2013-05-26"
[11] "2013-05-27" "2013-05-28" "2013-05-29"
> 
> seq(from=as.Date("2013-05-17"), to=as.Date("2016-05-29"), by="year")
[1] "2013-05-17" "2014-05-17" "2015-05-17" "2016-05-17"
> seq(from=as.Date("2013-05-17"), to=as.Date("2016-05-29"), by="month")
 [1] "2013-05-17" "2013-06-17" "2013-07-17" "2013-08-17" "2013-09-17"
 [6] "2013-10-17" "2013-11-17" "2013-12-17" "2014-01-17" "2014-02-17"
[11] "2014-03-17" "2014-04-17" "2014-05-17" "2014-06-17" "2014-07-17"
[16] "2014-08-17" "2014-09-17" "2014-10-17" "2014-11-17" "2014-12-17"
[21] "2015-01-17" "2015-02-17" "2015-03-17" "2015-04-17" "2015-05-17"
[26] "2015-06-17" "2015-07-17" "2015-08-17" "2015-09-17" "2015-10-17"
[31] "2015-11-17" "2015-12-17" "2016-01-17" "2016-02-17" "2016-03-17"
[36] "2016-04-17" "2016-05-17"

> ISOdate(2015, 2, 3)
[1] "2015-02-03 12:00:00 GMT"
> as.Date(ISOdate(2015, 2, 3))
[1] "2015-02-03"
> 
> ct <- as.POSIXlt("2015-02-03")
> ct$mday
[1] 3
> as.POSIXlt
function (x, tz = "", ...) 
UseMethod("as.POSIXlt")
<bytecode: 0x8ddac28>
<environment: namespace:base>
> attributes(ct)
$names
[1] "sec"   "min"   "hour"  "mday"  "mon"   "year"  "wday"  "yday"  "isdst"

$class
[1] "POSIXlt" "POSIXt" 

> 



날짜와 시간을 다루는데는 크게 두가지로 나눌 수 있습니다.
하나는 2013년 05월 16일과 같이 시간정보 없이 날짜만을 다루는 Date 클래스, 그리고 다른 하나는 2013년 05월 16일 오후 06시 28분 33초 와 같이 날짜와 시간을 동시에 다루는 POSIXlt와 POSIXct 라는 클래스들입니다.
POSIXlt와 POSIXct 모두 시간을 초단위까지 다루지만, POSIXlt는 1970년 1월 1일 00시 00분 00초를 기준으로 현재의 날짜와 시간을 초단위로 기억해 두는 반면 POSIXct는 `sec', `min', `hour', `mday', `mon', `year', 'wday' `yday', `isdst'라는 아홉개의 구성요소를 가진 리스트로 되어 있습니다. 
여기에서 `mday'는 한 달중에 몇번째 날짜인지를 나타내고, `year'는 1990년 이래로 몇 번째 해인가에 대한 정보이며, `wday'는 1주일중 몇 번째 날짜인지 아려줍니다. 
그리고 `yday'는 1년중 몇번째 날인지에 대한 정보가 있으며, `isdst'는 일광시간절약제에 대한 정보를 담고 있습니다.
날짜와 시간에 대해서는 Ripley, B. D. 와 Hornik, K. (2001)가 작성한  \href{http://www.r-project.org/doc/Rnews/Rnews_2001-2.pdf}{Date-time classes} 이라는 내용을 읽어보시길 바랍니다. 
% ?POSIXct 의 예제 살펴보면 좋음 


% 베리굿 노트: http://www.pitt.edu/~njc23/
% http://cm.bell-labs.com/cm/ms/departments/sia/Sbook/
% http://developer.r-project.org/methodDefinition.html
% http://www.biostat.jhsph.edu/~rpeng/teaching.html
% http://onertipaday.blogspot.ca/
% http://web.udl.es/Biomath/Bioestadistica/R/Manuals/r_in_a_nutshell.pdf
% http://web.udl.es/Biomath/Bioestadistica/R/Manuals/

% \item \texttt{do.call()} 함수를 사용하는 법에 대해서..
% http://cran.r-project.org/web/packages/rockchalk/vignettes/Rchaeology.pdf
% http://www.stat.berkeley.edu/classes/s133/all2011.pdf  (다운로드 해두었음 Desktop/tmpRsrc/all2011.pdf)
% http://www.stat.berkeley.edu/classes/s133/resources.html 

\end{comment}
